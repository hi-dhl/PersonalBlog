<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Android 10 源码分析：APK 的安装流程 - 程序员DHL</title><meta description="APK 安装到手机的全过程"><meta property="og:type" content="blog"><meta property="og:title" content="Android 10 源码分析：APK 的安装流程"><meta property="og:url" content="https://www.hi-dhl.com/2020/06/07/android10/package-manager/02-APK-install/"><meta property="og:site_name" content="程序员DHL"><meta property="og:description" content="APK 安装到手机的全过程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.51git.cn/2020-05-04-android-APK-banner-670x335-1.jpg"><meta property="article:published_time" content="2020-06-06T16:24:42.605Z"><meta property="article:modified_time" content="2020-11-11T02:47:42.346Z"><meta property="article:author" content="程序员DHL"><meta property="article:tag" content="源码"><meta property="article:tag" content="Android10"><meta property="article:tag" content="APK生成"><meta property="article:tag" content="APK打包"><meta property="article:tag" content="APK安装"><meta property="article:tag" content="包管理系统"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://cdn.51git.cn/2020-05-04-android-APK-banner-670x335-1.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hi-dhl.com/2020/06/07/android10/package-manager/02-APK-install/"},"headline":"程序员DHL","image":["http://cdn.51git.cn/2020-05-04-android-APK-banner-670x335-1.jpg"],"datePublished":"2020-06-06T16:24:42.605Z","dateModified":"2020-11-11T02:47:42.346Z","author":{"@type":"Person","name":"程序员DHL"},"description":"APK 安装到手机的全过程"}</script><link rel="canonical" href="https://www.hi-dhl.com/2020/06/07/android10/package-manager/02-APK-install/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/logo.png" alt="程序员DHL" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="程序员DHL" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/categories/Jetpack">Jetpack</a><a class="navbar-item" href="/categories/Kotlin/">Kotlin</a><a class="navbar-item" href="/categories/Android10/">系统源码</a><a class="navbar-item" href="/categories/translated/">译文</a><a class="navbar-item" href="https://offer.hi-dhl.com">算法</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hi-dhl"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="http://cdn.51git.cn/2020-05-04-android-APK-banner-670x335-1.jpg" alt="Android 10 源码分析：APK 的安装流程"></span></div><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile"></h1><h1 class="title is-3 is-size-4-mobile">Android 10 源码分析：APK 的安装流程</h1><div class="article-meta size-small level is-mobile"><div class="level-left"><span class="mr-2"><i class="fa fa-calendar"></i></span><time class="level-item" dateTime="2020-06-06T16:24:42.605Z" title="2020-06-06T16:24:42.605Z">2020-06-07</time><span class="mr-2"> <i class="fa fa-folder"></i></span><span class="level-item"><a class="link-muted" href="/categories/Android10/">Android10</a></span><span class="mr-2"> <i class="fa fa-tag"></i></span><span class="level-item"><a class="link-muted" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span> , </span><a class="link-muted" href="/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">Android10-包管理系统</a></span></div></div><div class="level-left article-meta size-small is-mobile"></div><div><p style="height:15px"></p><ul class="page-blockquote"><li>如果评论区没有及时回复，欢迎来公众号：ByteCode 咨询</li><li>公众号：ByteCode。致力于分享最新技术原创文章，涉及 Kotlin、Jetpack、算法、译文、系统源码相关的文章</li><li></li></ul><p style="height:15px"></p></div><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<ul>
<li>这是 Android 10 源码分析系列的第 2 篇</li>
<li>分支：android-10.0.0_r14</li>
<li>全文阅读大概 10 分钟</li>
</ul>
</blockquote>
<p>上一篇文章介绍了 <a href="https://juejin.im/post/5e4366c3f265da57397e1189">0xA01 Android 10 源码分析：APK 是如何生成的</a>，这篇文章接着介绍如何安装 APK，需要说一下 Android 10 及更高版本中, 安装器  PackageInstaller 源码位置有所变动<br/></p>
<h3 id="PackageInstaller-源码所在位置"><a href="#PackageInstaller-源码所在位置" class="headerlink" title="PackageInstaller 源码所在位置"></a>PackageInstaller 源码所在位置</h3><p>PackageInstaller 是系统内置的应用程序，用于安装和卸载应用<br/></p>
<p>在 Android 9 及更低版本中，软件包安装和权限控制功能包含在  PackageInstaller 软件包 (//packages/apps/PackageInstaller) 中。在 Android 10 及更高版本中，权限控制功能位于单独的软件包 PermissionController (//packages/apps/PermissionController)，这两个软件包在 Android 10 中的位置如下图所示，更多信息点击这里前往 <a href="https://source.android.google.cn/devices/tech/config?hl=zh-cn">Android 权限</a></p>
<p><img src="http://cdn.51git.cn/2020-02-29-package-install.png" alt="package-instal"></p>
<p><strong>Android 9 及更低版本中 ：</strong></p>
<p>软件包安装和权限控制功能源码路径：packages/apps/PackageInstaller</p>
<p><strong>Android 10 及更高版本：</strong></p>
<ul>
<li>权限控制功能 PermissionController 源码路径：packages/apps/PermissionController/</li>
<li>安装器 PackageInstaller 源码路径：frameworks/base/packages/PackageInstaller/</li>
</ul>
<h3 id="在-Android-系统不同的目录存放不同类型的应用"><a href="#在-Android-系统不同的目录存放不同类型的应用" class="headerlink" title="在 Android 系统不同的目录存放不同类型的应用"></a>在 Android 系统不同的目录存放不同类型的应用</h3><ul>
<li>/system/framwork：保存的是资源型的应用程序，它们用来打包资源文件</li>
<li>/system/app：保存系统自带的应用程序</li>
<li>/data/app：保存用户安装的应用程序</li>
<li>/data/data：应用数据目录</li>
<li>/data/app-private：保存受DRM保护的私有应用程序</li>
<li>/vendor/app：保存设备厂商提供的应用程序</li>
</ul>
<h3 id="查看-PackageInstaller-源码方式"><a href="#查看-PackageInstaller-源码方式" class="headerlink" title="查看 PackageInstaller 源码方式"></a>查看 PackageInstaller 源码方式</h3><ul>
<li><a href="https://github.com/hi-dhl/AOSP-PackageInstaller/tree/android-10.0.0_r14">AOSP-PackageInstaller</a>: 包含了安装器 PackageInstaller(7.1.2、8.1.0、9.0.0、10.0.0) 的源码，可以切换分之查看，跟随 Android 版本更新，你永远可以看到最新的源代码</li>
</ul>
<p><img src="http://cdn.51git.cn/2020-02-29-source.png" alt="source"></p>
<ul>
<li><a href="http://aospxref.com/">aospxref</a>：这是一个在线查看 Android 源码网站，服务器在阿里云访问速度很快，文末有关这个网站的介绍</li>
<li><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-10.0.0_r14/packages/PackageInstaller/">googlesource-PackageInstaller</a>：这是安装器 PackageInstaller 在 googlesource 上的地址</li>
</ul>
<h2 id="1-APK-的安装方式"><a href="#1-APK-的安装方式" class="headerlink" title="1. APK 的安装方式"></a>1. APK 的安装方式</h2><p>安装 APK 主要分为以下三种场景</p>
<ul>
<li>安装系统应用：系统启动后调用 PackageManagerService.main() 初始化注册解析安装工作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static PackageManagerService main(Context context, Installer installer,</span><br><span class="line">        boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">    &#x2F;&#x2F; Self-check for initial settings.</span><br><span class="line">    PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line"></span><br><span class="line">    PackageManagerService m &#x3D; new PackageManagerService(context, installer,</span><br><span class="line">            factoryTest, onlyCore);</span><br><span class="line">    m.enableSystemUserPackages();</span><br><span class="line">    ServiceManager.addService(&quot;package&quot;, m);</span><br><span class="line">    final PackageManagerNative pmn &#x3D; m.new PackageManagerNative();</span><br><span class="line">    ServiceManager.addService(&quot;package_native&quot;, pmn);</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 adb 安装：通过 pm 参数，调用 PM 的 runInstall 方法，进入 PackageManagerService 安装安装工作</li>
<li>通过系统安装器 PackageInstaller 进行安装：先调用 InstallStart 进行权限检查之后启动 PackageInstallActivity，调用 PackageInstallActivity 的 startInstall 方法，点击 OK 按钮后进入 PackageManagerService 完成拷贝解析安装工作</li>
</ul>
<p>所有安装方式大致相同，最终就是回到 PackageManagerService 中，安装一个 APK 的大致流程如下：</p>
<p><img src="http://cdn.51git.cn/2020-02-29-15829642823114.jpg" alt=""></p>
<ul>
<li>拷贝到 APK 文件到指定目录</li>
<li>解压缩 APK，拷贝文件，创建应用的数据目录</li>
<li>解析 APK 的 AndroidManifest.xml 文件</li>
<li>向 Launcher 应用申请添加创建快捷方式</li>
</ul>
<p>本文主要来分析通过安装器 PackageInstaller 安装 APK，这是用户最常用的一种方式</p>
<h2 id="2-PackageInstaller-的入口"><a href="#2-PackageInstaller-的入口" class="headerlink" title="2. PackageInstaller 的入口"></a>2. PackageInstaller 的入口</h2><p>下面代码一定不会很陌生，这就是我们常用的安装 APK 的代码（PS: 关于静默安装我会后续分享在逆向开发相关的文章）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intent intent &#x3D; new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* 自Android N开始，是通过FileProvider共享相关文件，但是Android Q对公</span><br><span class="line">* 有目录 File API进行了限制，只能通过Uri来操作</span><br><span class="line">*&#x2F;</span><br><span class="line">if(Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.Q)&#123;</span><br><span class="line">    &#x2F;&#x2F; filePath是通过ContentResolver得到的</span><br><span class="line">    intent.setDataAndType(Uri.parse(filePath) ,&quot;application&#x2F;vnd.android.package-archive&quot;);</span><br><span class="line">    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">&#125;else if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.N) &#123;</span><br><span class="line">    intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    Uri contentUri &#x3D; FileProvider.getUriForFile(mContext, &quot;com.dhl.file.fileProvider&quot;, file);</span><br><span class="line">    intent.setDataAndType(contentUri, &quot;application&#x2F;vnd.android.package-archive&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    intent.setDataAndType(Uri.fromFile(file), &quot;application&#x2F;vnd.android.package-archive&quot;);</span><br><span class="line">&#125;</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 需要在AndroidManifest添加权限</span><br><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>通过 intent.setDataAndType 方法指定 Intent 的数据类型为 application/vnd.android.package-archive，隐式匹配的 Activity 为 InstallStart：<br><strong>frameworks/base/packages/PackageInstaller/AndroidManifest.xml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name&#x3D;&quot;.InstallStart&quot;</span><br><span class="line">        android:theme&#x3D;&quot;@android:style&#x2F;Theme.Translucent.NoTitleBar&quot;</span><br><span class="line">        android:exported&#x3D;&quot;true&quot;</span><br><span class="line">        android:excludeFromRecents&#x3D;&quot;true&quot;&gt;</span><br><span class="line">    &lt;intent-filter android:priority&#x3D;&quot;1&quot;&gt;</span><br><span class="line">        &lt;action android:name&#x3D;&quot;android.intent.action.VIEW&quot; &#x2F;&gt;</span><br><span class="line">        &lt;action android:name&#x3D;&quot;android.intent.action.INSTALL_PACKAGE&quot; &#x2F;&gt;</span><br><span class="line">        &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">        &lt;data android:scheme&#x3D;&quot;content&quot; &#x2F;&gt;</span><br><span class="line">        &lt;data android:mimeType&#x3D;&quot;application&#x2F;vnd.android.package-archive&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;intent-filter&gt;</span><br><span class="line">    &lt;intent-filter android:priority&#x3D;&quot;1&quot;&gt;</span><br><span class="line">        &lt;action android:name&#x3D;&quot;android.intent.action.INSTALL_PACKAGE&quot; &#x2F;&gt;</span><br><span class="line">        &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">        &lt;data android:scheme&#x3D;&quot;package&quot; &#x2F;&gt;</span><br><span class="line">        &lt;data android:scheme&#x3D;&quot;content&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;intent-filter&gt;</span><br><span class="line">    &lt;intent-filter android:priority&#x3D;&quot;1&quot;&gt;</span><br><span class="line">        &lt;action android:name&#x3D;&quot;android.content.pm.action.CONFIRM_INSTALL&quot; &#x2F;&gt;</span><br><span class="line">        &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;intent-filter&gt;</span><br><span class="line">&lt;&#x2F;activity&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>本文分析的是 10.0 的源码，在 8.0、9.0、10.0 等等版本中隐式匹配的 Activity 是 InstallStart，7.0 隐式匹配的 Activity 是 PackageInstallerActivity</li>
<li>安装器 PackageInstaller 的入口 Activity 是 InstallStart，定义了两个 scheme：content 和 package</li>
</ul>
<h2 id="3-APK-的安装流程"><a href="#3-APK-的安装流程" class="headerlink" title="3. APK 的安装流程"></a>3. APK 的安装流程</h2><p>通过上面方式找到了入口 Activity，下面我们来查看一下 APK 是如何安装的</p>
<h3 id="3-1-InstallStart"><a href="#3-1-InstallStart" class="headerlink" title="3.1 InstallStart"></a>3.1 InstallStart</h3><p>主要工作：</p>
<ol>
<li>判断是否勾选“未知来源”选项，若未勾选跳转到设置安装未知来源界面</li>
<li>对于大于等于 Android 8.0 版本，会先检查是否申请安装权限，若没有则中断安装</li>
<li>判断 Uri 的 Scheme 协议，若是 content 则调用 InstallStaging, 若是 package 则调用 PackageInstallerActivity</li>
</ol>
<p>当我们调用上面安装代码来安装 APK 时。会跳转到 InstallStart, 并调用它的 onCreate 方法：<br><strong>frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallStart.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    final boolean isSessionInstall &#x3D;</span><br><span class="line">            PackageInstaller.ACTION_CONFIRM_INSTALL.equals(intent.getAction());</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    final ApplicationInfo sourceInfo &#x3D; getSourceInfo(callingPackage);</span><br><span class="line">    final int originatingUid &#x3D; getOriginatingUid(sourceInfo);</span><br><span class="line">    boolean isTrustedSource &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 判断是否勾选“未知来源”选项</span><br><span class="line">    if (sourceInfo !&#x3D; null</span><br><span class="line">            &amp;&amp; (sourceInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) !&#x3D; 0) &#123;</span><br><span class="line">        isTrustedSource &#x3D; intent.getBooleanExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, false);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isTrustedSource &amp;&amp; originatingUid !&#x3D; PackageInstaller.SessionParams.UID_UNKNOWN) &#123;</span><br><span class="line">        final int targetSdkVersion &#x3D; getMaxTargetSdkVersionForUid(this, originatingUid);</span><br><span class="line">        &#x2F;&#x2F; 如果targetSdkVerison小于0中止安装</span><br><span class="line">        if (targetSdkVersion &lt; 0) &#123;</span><br><span class="line">            Log.w(LOG_TAG, &quot;Cannot get target sdk version for uid &quot; + originatingUid);</span><br><span class="line">            mAbortInstall &#x3D; true;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果targetSdkVersion大于等于26（8.0）, 且获取不到REQUEST_INSTALL_PACKAGES权限中止安装</span><br><span class="line">        &#125; else if (targetSdkVersion &gt;&#x3D; Build.VERSION_CODES.O &amp;&amp; !declaresAppOpPermission(</span><br><span class="line">                originatingUid, Manifest.permission.REQUEST_INSTALL_PACKAGES)) &#123;</span><br><span class="line">            Log.e(LOG_TAG, &quot;Requesting uid &quot; + originatingUid + &quot; needs to declare permission &quot;</span><br><span class="line">                    + Manifest.permission.REQUEST_INSTALL_PACKAGES);</span><br><span class="line">            mAbortInstall &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果设置了ACTION_CONFIRM_PERMISSIONS，则调用PackageInstallerActivity。</span><br><span class="line">    if (isSessionInstall) &#123;</span><br><span class="line">        nextActivity.setClass(this, PackageInstallerActivity.class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Uri packageUri &#x3D; intent.getData();</span><br><span class="line">        &#x2F;&#x2F; 判断Uri的Scheme协议是否是content</span><br><span class="line">        if (packageUri !&#x3D; null &amp;&amp; packageUri.getScheme().equals(</span><br><span class="line">                ContentResolver.SCHEME_CONTENT)) &#123;</span><br><span class="line">            &#x2F;&#x2F; [IMPORTANT] This path is deprecated, but should still work.</span><br><span class="line">            &#x2F;&#x2F; 这个路径已经被起用了，但是仍然可以工作</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 调用InstallStaging来拷贝file&#x2F;content，防止被修改</span><br><span class="line">            nextActivity.setClass(this, InstallStaging.class);</span><br><span class="line">        &#125; else if (packageUri !&#x3D; null &amp;&amp; packageUri.getScheme().equals(</span><br><span class="line">                PackageInstallerActivity.SCHEME_PACKAGE)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果Uri中包含package，则调用PackageInstallerActivity</span><br><span class="line">            nextActivity.setClass(this, PackageInstallerActivity.class);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Uri不合法</span><br><span class="line">            Intent result &#x3D; new Intent();</span><br><span class="line">            result.putExtra(Intent.EXTRA_INSTALL_RESULT,</span><br><span class="line">                    PackageManager.INSTALL_FAILED_INVALID_URI);</span><br><span class="line">            setResult(RESULT_FIRST_USER, result);</span><br><span class="line">            nextActivity &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nextActivity !&#x3D; null) &#123;</span><br><span class="line">        startActivity(nextActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 Uri 的 Scheme 协议，若是 content 则调用 InstallStaging，查看 InstallStaging 的 onResume方法：<br><strong>frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallStaging.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onResume() &#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    if (mStagingTask &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (mStagedFile &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建临时文件 mStagedFile 用来存储数据</span><br><span class="line">            try &#123;</span><br><span class="line">                mStagedFile &#x3D; TemporaryFileManager.getStagedFile(this);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                showError();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 启动 StagingAsyncTask，并传入了content协议的Uri</span><br><span class="line">        mStagingTask &#x3D; new StagingAsyncTask();</span><br><span class="line">        mStagingTask.execute(getIntent().getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建临时文件 mStagedFile 用来存储数据</li>
<li>启动 StagingAsyncTask，并传入了 content 协议的 Uri</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final class StagingAsyncTask extends AsyncTask&lt;Uri, Void, Boolean&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Boolean doInBackground(Uri... params) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Uri packageUri &#x3D; params[0];</span><br><span class="line">        try (InputStream in &#x3D; getContentResolver().openInputStream(packageUri)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 将packageUri（content协议的Uri）的内容写入到mStagedFile中</span><br><span class="line">            try (OutputStream out &#x3D; new FileOutputStream(mStagedFile)) &#123;</span><br><span class="line">                byte[] buffer &#x3D; new byte[1024 * 1024];</span><br><span class="line">                int bytesRead;</span><br><span class="line">                while ((bytesRead &#x3D; in.read(buffer)) &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Be nice and respond to a cancellation</span><br><span class="line">                    if (isCancelled()) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    out.write(buffer, 0, bytesRead);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException | SecurityException | IllegalStateException e) &#123;</span><br><span class="line">            Log.w(LOG_TAG, &quot;Error staging apk from content URI&quot;, e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onPostExecute(Boolean success) &#123;</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果写入成功，调用DeleteStagedFileOnResult</span><br><span class="line">            Intent installIntent &#x3D; new Intent(getIntent());</span><br><span class="line">            installIntent.setClass(InstallStaging.this, DeleteStagedFileOnResult.class);</span><br><span class="line">            installIntent.setData(Uri.fromFile(mStagedFile));</span><br><span class="line">            ...</span><br><span class="line">            startActivity(installIntent);</span><br><span class="line">            InstallStaging.this.finish();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            showError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>doInBackground 方法中将 packageUri（content 协议的 Uri）的内容写入到 mStagedFile 中</li>
<li>如果写入成功，调用 DeleteStagedFileOnResult 的 OnCreate 方法：</li>
</ol>
<p><strong>frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/DeleteStagedFileOnResult.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    if (savedInstanceState &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 启动PackageInstallerActivity</span><br><span class="line">        Intent installIntent &#x3D; new Intent(getIntent());</span><br><span class="line">        installIntent.setClass(this, PackageInstallerActivity.class);</span><br><span class="line">        installIntent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);</span><br><span class="line">        startActivityForResult(installIntent, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过分析 InstallStaging 主要起了中转作用，将 content 协议的 Uri 转换为 File 协议，最后跳转到 PackageInstallerActivity</p>
<h3 id="3-2-PackageInstallerActivity"><a href="#3-2-PackageInstallerActivity" class="headerlink" title="3.2 PackageInstallerActivity"></a>3.2 PackageInstallerActivity</h3><p>主要工作：</p>
<ol>
<li>显示安装界面</li>
<li>初始化安装需要用的各种对象，比如 PackageManager、IPackageManager、AppOpsManager、UserManager、PackageInstaller 等等</li>
<li>根据传递过来的 Scheme 协议做不同的处理</li>
<li>检查是否允许、初始化安装</li>
<li>在准备安装的之前，检查应用列表判断该应用是否已安装，若已安装则提示该应用已安装，由用户决定是否替换</li>
<li>在安装界面，提取出 APK 中权限信息并展示出来</li>
<li>点击 OK 按钮确认安装后，会调用 startInstall 开始安装工作</li>
</ol>
<p>PackageInstallerActivity 才是应用安装器 PackageInstaller 真正的入口 Activity，查看它的 onCreate 方法：<br><strong>frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onCreate(Bundle icicle) &#123;</span><br><span class="line">    getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);</span><br><span class="line">    super.onCreate(null);</span><br><span class="line">    &#x2F;&#x2F; 初始化安装需要用到的对象</span><br><span class="line">    mPm &#x3D; getPackageManager();</span><br><span class="line">    mIpm &#x3D; AppGlobals.getPackageManager();</span><br><span class="line">    mAppOpsManager &#x3D; (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line">    mInstaller &#x3D; mPm.getPackageInstaller();</span><br><span class="line">    mUserManager &#x3D; (UserManager) getSystemService(Context.USER_SERVICE);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据Uri的Scheme做不同的处理</span><br><span class="line">    boolean wasSetUp &#x3D; processPackageUri(packageUri);</span><br><span class="line">    if (!wasSetUp) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 显示安装界面</span><br><span class="line">    bindUi();</span><br><span class="line">    &#x2F;&#x2F; 检查是否允许安装包，如果允许则启动安装。如果不允许显示适当的对话框</span><br><span class="line">    checkIfAllowedAndInitiateInstall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了对象的初始化，解析 Uri 的 Scheme，初始化界面，安装包检查等等工作，接着查看一下 processPackageUri 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean processPackageUri(final Uri packageUri) &#123;</span><br><span class="line">    mPackageURI &#x3D; packageUri;</span><br><span class="line">    final String scheme &#x3D; packageUri.getScheme();</span><br><span class="line">    &#x2F;&#x2F; 根据这个Scheme协议分别对package协议和file协议进行处理</span><br><span class="line">    switch (scheme) &#123;</span><br><span class="line">        case SCHEME_PACKAGE: &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 通过PackageManager对象获取指定包名的包信息</span><br><span class="line">                mPkgInfo &#x3D; mPm.getPackageInfo(packageUri.getSchemeSpecificPart(),</span><br><span class="line">                        PackageManager.GET_PERMISSIONS</span><br><span class="line">                                | PackageManager.MATCH_UNINSTALLED_PACKAGES);</span><br><span class="line">            &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPkgInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Requested package &quot; + packageUri.getScheme()</span><br><span class="line">                        + &quot; not available. Discontinuing installation&quot;);</span><br><span class="line">                showDialogInner(DLG_PACKAGE_ERROR);</span><br><span class="line">                setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            mAppSnippet &#x3D; new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo),</span><br><span class="line">                    mPm.getApplicationIcon(mPkgInfo.applicationInfo));</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        case ContentResolver.SCHEME_FILE: &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据packageUri创建一个新的File</span><br><span class="line">            File sourceFile &#x3D; new File(packageUri.getPath());</span><br><span class="line">            &#x2F;&#x2F; 解析APK得到APK的信息，PackageParser.Package存储了APK的所有信息</span><br><span class="line">            PackageParser.Package parsed &#x3D; PackageUtil.getPackageInfo(this, sourceFile);</span><br><span class="line"></span><br><span class="line">            if (parsed &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;);</span><br><span class="line">                showDialogInner(DLG_PACKAGE_ERROR);</span><br><span class="line">                setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 根据PackageParser.Package得到的APK信息，生成PackageInfo</span><br><span class="line">            mPkgInfo &#x3D; PackageParser.generatePackageInfo(parsed, null,</span><br><span class="line">                    PackageManager.GET_PERMISSIONS, 0, 0, null,</span><br><span class="line">                    new PackageUserState());</span><br><span class="line">            mAppSnippet &#x3D; PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile);</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        default: &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unexpected URI scheme &quot; + packageUri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要对 Scheme 协议分别对 package 协议和 file 协议进行处理</p>
<p><strong>SCHEME_PACKAGE：</strong></p>
<ul>
<li>在 package 协议中调用了 PackageManager.getPackageInfo 方法生成 PackageInfo，PackageInfo 是跨进程传递的包数据（activities、receivers、services、providers、permissions等等）包含 APK 的所有信息</li>
</ul>
<p><strong>SCHEME_FILE：</strong></p>
<ul>
<li>在 file 协议的处理中调用了 PackageUtil.getPackageInfo 方法，方法内部调用了 PackageParser.parsePackage() 把 APK 文件的 manifest 和签名信息都解析完成并保存在了 Package，Package 包含了该 APK 的所有信息</li>
<li>调用 PackageParser.generatePackageInfo 生成 PackageInfo</li>
</ul>
<p>接着往下走，都解析完成之后，回到 onCreate 方法，继续调用 checkIfAllowedAndInitiateInstall 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void checkIfAllowedAndInitiateInstall() &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先检查安装应用程序的用户限制，如果有限制并弹出弹出提示Dialog或者跳转到设置界面</span><br><span class="line">    final int installAppsRestrictionSource &#x3D; mUserManager.getUserRestrictionSource(</span><br><span class="line">            UserManager.DISALLOW_INSTALL_APPS, Process.myUserHandle());</span><br><span class="line">    if ((installAppsRestrictionSource &amp; UserManager.RESTRICTION_SOURCE_SYSTEM) !&#x3D; 0) &#123;</span><br><span class="line">        showDialogInner(DLG_INSTALL_APPS_RESTRICTED_FOR_USER);</span><br><span class="line">        return;</span><br><span class="line">    &#125; else if (installAppsRestrictionSource !&#x3D; UserManager.RESTRICTION_NOT_SET) &#123;</span><br><span class="line">        startActivity(new Intent(Settings.ACTION_SHOW_ADMIN_SUPPORT_DETAILS));</span><br><span class="line">        finish();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断如果允许安装未知来源或者根据Intent判断得出该APK不是未知来源</span><br><span class="line">    if (mAllowUnknownSources || !isInstallRequestFromUnknownSource(getIntent())) &#123;</span><br><span class="line">        initiateInstall();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查未知安装源限制,如果有限制弹出Dialog,显示相应的信息</span><br><span class="line">        final int unknownSourcesRestrictionSource &#x3D; mUserManager.getUserRestrictionSource(</span><br><span class="line">                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, Process.myUserHandle());</span><br><span class="line">        final int unknownSourcesGlobalRestrictionSource &#x3D; mUserManager.getUserRestrictionSource(</span><br><span class="line">                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, Process.myUserHandle());</span><br><span class="line">        final int systemRestriction &#x3D; UserManager.RESTRICTION_SOURCE_SYSTEM</span><br><span class="line">                &amp; (unknownSourcesRestrictionSource | unknownSourcesGlobalRestrictionSource);</span><br><span class="line">        if (systemRestriction !&#x3D; 0) &#123;</span><br><span class="line">            showDialogInner(DLG_UNKNOWN_SOURCES_RESTRICTED_FOR_USER);</span><br><span class="line">        &#125; else if (unknownSourcesRestrictionSource !&#x3D; UserManager.RESTRICTION_NOT_SET) &#123;</span><br><span class="line">            startAdminSupportDetailsActivity(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES);</span><br><span class="line">        &#125; else if (unknownSourcesGlobalRestrictionSource !&#x3D; UserManager.RESTRICTION_NOT_SET) &#123;</span><br><span class="line">            startAdminSupportDetailsActivity(</span><br><span class="line">                    UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理未知来源的APK</span><br><span class="line">            handleUnknownSources();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要检查安装应用程序的用户限制，当 APK 文件不对或者安装有限制则调用 showDialogInner 方法，弹出 dialog 提示用户，显示相应的错误信息，来看一下都有那些错误信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Dialog identifiers used in showDialog</span><br><span class="line">private static final int DLG_BASE &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; package信息错误</span><br><span class="line">private static final int DLG_PACKAGE_ERROR &#x3D; DLG_BASE + 2;</span><br><span class="line">&#x2F;&#x2F; 存储空间不够</span><br><span class="line">private static final int DLG_OUT_OF_SPACE &#x3D; DLG_BASE + 3;</span><br><span class="line">&#x2F;&#x2F; 安装错误</span><br><span class="line">private static final int DLG_INSTALL_ERROR &#x3D; DLG_BASE + 4;</span><br><span class="line">&#x2F;&#x2F; 用户限制的未知来源</span><br><span class="line">private static final int DLG_UNKNOWN_SOURCES_RESTRICTED_FOR_USER &#x3D; DLG_BASE + 5;</span><br><span class="line">private static final int DLG_ANONYMOUS_SOURCE &#x3D; DLG_BASE + 6;</span><br><span class="line">&#x2F;&#x2F; 在wear上不支持</span><br><span class="line">private static final int DLG_NOT_SUPPORTED_ON_WEAR &#x3D; DLG_BASE + 7;</span><br><span class="line">private static final int DLG_EXTERNAL_SOURCE_BLOCKED &#x3D; DLG_BASE + 8;</span><br><span class="line">&#x2F;&#x2F; 安装限制用户使用的应用程序</span><br><span class="line">private static final int DLG_INSTALL_APPS_RESTRICTED_FOR_USER &#x3D; DLG_BASE + 9;</span><br></pre></td></tr></table></figure>

<p>如果用户允许安装未知来源，会调用 initiateInstall 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void initiateInstall() &#123;</span><br><span class="line">    String pkgName &#x3D; mPkgInfo.packageName;</span><br><span class="line">    &#x2F;&#x2F; 检查设备上是否存在相同包名的APK</span><br><span class="line">    String[] oldName &#x3D; mPm.canonicalToCurrentPackageNames(new String[] &#123; pkgName &#125;);</span><br><span class="line">    if (oldName !&#x3D; null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] !&#x3D; null) &#123;</span><br><span class="line">        pkgName &#x3D; oldName[0];</span><br><span class="line">        mPkgInfo.packageName &#x3D; pkgName;</span><br><span class="line">        mPkgInfo.applicationInfo.packageName &#x3D; pkgName;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 检查package是否已安装, 如果已经安装则显示对话框提示用户是否替换。</span><br><span class="line">    try &#123;</span><br><span class="line">        mAppInfo &#x3D; mPm.getApplicationInfo(pkgName,</span><br><span class="line">                PackageManager.MATCH_UNINSTALLED_PACKAGES);</span><br><span class="line">        if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mAppInfo &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">        mAppInfo &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 初始化确认安装界面</span><br><span class="line">    startInstallConfirm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据包名获取应用程序的信息，调用 startInstallConfirm 方法初始化安装确认界面后，当用户点击确认按钮之后发生了什么，接着查看确认按钮点击事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void bindUi() &#123;</span><br><span class="line">   ...</span><br><span class="line">    &#x2F;&#x2F; 点击确认按钮，安装APK</span><br><span class="line">    mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install),</span><br><span class="line">            (ignored, ignored2) -&gt; &#123;</span><br><span class="line">                if (mOk.isEnabled()) &#123;</span><br><span class="line">                    if (mSessionId !&#x3D; -1) &#123;</span><br><span class="line">                        mInstaller.setPermissionsResult(mSessionId, true);</span><br><span class="line">                        finish();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; 启动Activity来完成应用的安装</span><br><span class="line">                        startInstall();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, null);</span><br><span class="line">   &#x2F;&#x2F; 点击取消按钮，取消此次安装</span><br><span class="line">    mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel),</span><br><span class="line">            (ignored, ignored2) -&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F; Cancel and finish</span><br><span class="line">                setResult(RESULT_CANCELED);</span><br><span class="line">                if (mSessionId !&#x3D; -1) &#123;</span><br><span class="line">                    mInstaller.setPermissionsResult(mSessionId, false);</span><br><span class="line">                &#125;</span><br><span class="line">                finish();</span><br><span class="line">            &#125;, null);</span><br><span class="line">    setupAlert();</span><br><span class="line">    mOk &#x3D; mAlert.getButton(DialogInterface.BUTTON_POSITIVE);</span><br><span class="line">    mOk.setEnabled(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当用户点击确认按钮调用了 startInstall 方法，启动子 Activity 完成 APK 的安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startInstall() &#123;</span><br><span class="line">    &#x2F;&#x2F; 启动子Activity来完成应用的安</span><br><span class="line">    Intent newIntent &#x3D; new Intent();</span><br><span class="line">    newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,</span><br><span class="line">            mPkgInfo.applicationInfo);</span><br><span class="line">    newIntent.setData(mPackageURI);</span><br><span class="line">    newIntent.setClass(this, InstallInstalling.class);</span><br><span class="line">    ...</span><br><span class="line">    if(localLOGV) Log.i(TAG, &quot;downloaded app uri&#x3D;&quot;+mPackageURI);</span><br><span class="line">    startActivity(newIntent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startInstall 方法用来跳转到 InstallInstalling，并关闭掉当前的 PackageInstallerActivity</p>
<h3 id="3-3-InstallInstalling"><a href="#3-3-InstallInstalling" class="headerlink" title="3.3 InstallInstalling"></a>3.3 InstallInstalling</h3><p>主要工作：</p>
<ol>
<li>向包管理器发送包的信息，然后等待包管理器处理结果</li>
<li>注册一个观察者 InstallEventReceiver，并接受安装成功和失败的回调</li>
<li>在方法 onResume 中创建同步栈，打开安装 session，设置安装进度条</li>
</ol>
<p>InstallInstalling 首先向包管理器发送包的信息，然后等待包管理器处理结果，并在方法 InstallSuccess 和方法 InstallFailed 进行成功和失败的处理，查看 InstallInstalling 的 onCreate 方法：<br><strong>frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallInstalling.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断安装的应用是否已经存在</span><br><span class="line">    if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getPackageManager().installExistingPackage(appInfo.packageName);</span><br><span class="line">            launchSuccess();</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final File sourceFile &#x3D; new File(mPackageURI.getPath());</span><br><span class="line">        PackageUtil.AppSnippet as &#x3D; PackageUtil.getAppSnippet(this, appInfo, sourceFile);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        if (savedInstanceState !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果savedInstanceState 不为空，获取已经存在mSessionId 和mInstallId 重新注册</span><br><span class="line">            mSessionId &#x3D; savedInstanceState.getInt(SESSION_ID);</span><br><span class="line">            mInstallId &#x3D; savedInstanceState.getInt(INSTALL_ID);</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 根据mInstallId向InstallEventReceiver注册一个观察者，launchFinishBasedOnResult会接收到安装事件的回调</span><br><span class="line">                InstallEventReceiver.addObserver(this, mInstallId,</span><br><span class="line">                        this::launchFinishBasedOnResult);</span><br><span class="line">            &#125; catch (EventResultPersister.OutOfIdsException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果为空创建SessionParams，代表安装会话的参数</span><br><span class="line">            &#x2F;&#x2F; 解析APK, 并将解析的参数赋值给SessionParams</span><br><span class="line">            PackageInstaller.SessionParams params &#x3D; new PackageInstaller.SessionParams(</span><br><span class="line">                    PackageInstaller.SessionParams.MODE_FULL_INSTALL);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 注册InstallEventReceiver，并在launchFinishBasedOnResult会接收到安装事件的回调</span><br><span class="line">                mInstallId &#x3D; InstallEventReceiver</span><br><span class="line">                        .addObserver(this, EventResultPersister.GENERATE_NEW_ID,</span><br><span class="line">                                this::launchFinishBasedOnResult);</span><br><span class="line">            &#125; catch (EventResultPersister.OutOfIdsException e) &#123;</span><br><span class="line">                launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; createSession 内部通过IPackageInstaller与PackageInstallerService进行进程间通信，</span><br><span class="line">                &#x2F;&#x2F; 最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId</span><br><span class="line">                mSessionId &#x3D; getPackageManager().getPackageInstaller().createSession(params);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最终都会注册一个观察者 InstallEventReceiver，并在 launchFinishBasedOnResult 会接收到安装事件的回调，其中 InstallEventReceiver 继承自 BroadcastReceiver，用于接收安装事件并回调给 EventResultPersister</li>
<li>createSession 内部通过 IPackageInstaller 与 PackageInstallerService 进行进程间通信，最终调用的是 PackageInstallerService的createSession 方法来创建并返回 mSessionId</li>
<li>接下来在 onResume 方法创建 InstallingAsyncTask 用来执行 APK 的安装，接着查看 onResume 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onResume() &#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    if (mInstallingTask &#x3D;&#x3D; null) &#123;</span><br><span class="line">        PackageInstaller installer &#x3D; getPackageManager().getPackageInstaller();</span><br><span class="line">        &#x2F;&#x2F; 根据mSessionId 获取SessionInfo, 代表安装会话的详细信息</span><br><span class="line">        PackageInstaller.SessionInfo sessionInfo &#x3D; installer.getSessionInfo(mSessionId);</span><br><span class="line">        if (sessionInfo !&#x3D; null &amp;&amp; !sessionInfo.isActive()) &#123;</span><br><span class="line">            mInstallingTask &#x3D; new InstallingAsyncTask();</span><br><span class="line">            mInstallingTask.execute();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 安装完成后会收到广播</span><br><span class="line">            mCancelButton.setEnabled(false);</span><br><span class="line">            setFinishOnTouchOutside(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到 SessionInfo 创建并创建 InstallingAsyncTask，InstallingAsyncTask 的 doInBackground 方法设置安装进度条，并将 APK 信息写入 PackageInstaller.Session，写入完成之后，在 InstallingAsyncTask 的 onPostExecute 进行成功与失败的处理，接着查看 onPostExecute 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onPostExecute(PackageInstaller.Session session) &#123;</span><br><span class="line">    if (session !&#x3D; null) &#123;</span><br><span class="line">        Intent broadcastIntent &#x3D; new Intent(BROADCAST_ACTION);</span><br><span class="line">        broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">        broadcastIntent.setPackage(getPackageName());</span><br><span class="line">        broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId);</span><br><span class="line"></span><br><span class="line">        PendingIntent pendingIntent &#x3D; PendingIntent.getBroadcast(</span><br><span class="line">                InstallInstalling.this,</span><br><span class="line">                mInstallId,</span><br><span class="line">                broadcastIntent,</span><br><span class="line">                PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line"></span><br><span class="line">        session.commit(pendingIntent.getIntentSender());</span><br><span class="line">        mCancelButton.setEnabled(false);</span><br><span class="line">        setFinishOnTouchOutside(false);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        getPackageManager().getPackageInstaller().abandonSession(mSessionId);</span><br><span class="line"></span><br><span class="line">        if (!isCancelled()) &#123;</span><br><span class="line">            launchFailure(PackageManager.INSTALL_FAILED_INVALID_APK, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了 broadcastIntent，并通过 PackageInstaller.Session 的 commit 方法发送出去，通过 broadcastIntent 构造方法指定的 Intent 的 Action 为 BROADCAST_ACTION，而 BROADCAST_ACTION 是一个常量值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final String BROADCAST_ACTION &#x3D;</span><br><span class="line">           &quot;com.android.packageinstaller.ACTION_INSTALL_COMMIT&quot;;</span><br></pre></td></tr></table></figure>

<p>回到 InstallInstalling.OnCreate 方法，在 OnCreate 方法注册 InstallEventReceiver，而 InstallEventReceiver 继承自 BroadcastReceiver，而使用 BroadcastReceiver 需要在 AndroidManifest.xml注册，接着查看 AndroidManifest.xml：<br><strong>/frameworks/base/packages/PackageInstaller/AndroidManifest.xml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;receiver android:name&#x3D;&quot;.InstallEventReceiver&quot;</span><br><span class="line">        android:permission&#x3D;&quot;android.permission.INSTALL_PACKAGES&quot;</span><br><span class="line">        android:exported&#x3D;&quot;true&quot;&gt;</span><br><span class="line">    &lt;intent-filter android:priority&#x3D;&quot;1&quot;&gt;</span><br><span class="line">        &lt;action android:name&#x3D;&quot;com.android.packageinstaller.ACTION_INSTALL_COMMIT&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;intent-filter&gt;</span><br><span class="line">&lt;&#x2F;receiver&gt;</span><br></pre></td></tr></table></figure>

<p>安装结束之后，会在观察者 InstallEventReceiver 注册的回调方法 launchFinishBasedOnResult 处理安装事件的结果，接着查看 launchFinishBasedOnResult</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void launchFinishBasedOnResult(int statusCode, int legacyStatus, String statusMessage) &#123;</span><br><span class="line">    if (statusCode &#x3D;&#x3D; PackageInstaller.STATUS_SUCCESS) &#123;</span><br><span class="line">        launchSuccess();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        launchFailure(legacyStatus, statusMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void launchSuccess() &#123;</span><br><span class="line">    Intent successIntent &#x3D; new Intent(getIntent());</span><br><span class="line">    successIntent.setClass(this, InstallSuccess.class);</span><br><span class="line">    successIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">    startActivity(successIntent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void launchFailure(int legacyStatus, String statusMessage) &#123;</span><br><span class="line">    Intent failureIntent &#x3D; new Intent(getIntent());</span><br><span class="line">    failureIntent.setClass(this, InstallFailed.class);</span><br><span class="line">    failureIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">    failureIntent.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, legacyStatus);</span><br><span class="line">    failureIntent.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, statusMessage);</span><br><span class="line">    startActivity(failureIntent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装成功和失败，都会启动一个新的 Activity（InstallSuccess、InstallFailed）将结果展示给用户，然后 finish 掉 InstallInstalling<br/></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>总结一下 PackageInstaller 安装APK的过程：</p>
<ol>
<li>根据根据 Uri 的 Scheme 找到入口 InstallStart</li>
<li>InstallStart 根据 Uri 的 Scheme 协议不同做不同的处理</li>
<li>都会调用 PackageInstallerActivity, 然后分别对package协议和 file 协议的 Uri 进行处理</li>
<li>PackageInstallerActivity 检查未知安装源限制,如果安装源限制弹出提示 Dialog</li>
<li>点击 OK 按钮确认安装后，会调用 startInstall 开始安装工作</li>
<li>如果用户允许安装，然后跳转到 InstallInstalling，进行 APK 的安装工作</li>
<li>在 InstallInstalling 中，向包管理器发送包的信息，然后注册一个观察者 InstallEventReceiver，并接受安装成功和失败的回调</li>
</ol>
<h2 id="5-关于-packages-xml"><a href="#5-关于-packages-xml" class="headerlink" title="5. 关于 packages.xml"></a>5. 关于 packages.xml</h2><p>在 Andorid 系统目录 “/data/system” 下保存很多系统文件，主要介绍 packages.xml 文件<br/></p>
<ul>
<li>packages.xml：记录了系统中所有安装的应用信息，包括基本信息、签名和权限、APK 文件的路径、native 库的存储路径</li>
</ul>
<p>系统启动的时候会通过 PackageManagerServcie 读取这个文件加载系统中所有安装的应用，这个文件在开发中也是非常有帮助的，不同厂商会对  Android 源码有不同的修改，如果我们需要分析系统 App 的源码，就通过这个 packages.xml 找到目标 APK，dump 出来分析源码<br/></p>
<p>以下是 packages.xml 文件部分内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;utf-8&#39; standalone&#x3D;&#39;yes&#39; ?&gt;</span><br><span class="line">&lt;packages&gt;</span><br><span class="line">    &lt;version sdkVersion&#x3D;&quot;27&quot; databaseVersion&#x3D;&quot;3&quot; fingerprint&#x3D;&quot;Meizu&#x2F;meizu_M1822_CN&#x2F;M1822:8.1.0&#x2F;OPM1.171019.026&#x2F;1539943691:user&#x2F;release-keys&quot; &#x2F;&gt;</span><br><span class="line">    &lt;version volumeUuid&#x3D;&quot;primary_physical&quot; sdkVersion&#x3D;&quot;27&quot; databaseVersion&#x3D;&quot;27&quot; fingerprint&#x3D;&quot;Meizu&#x2F;meizu_M1822_CN&#x2F;M1822:8.1.0&#x2F;OPM1.171019.026&#x2F;1539943691:user&#x2F;release-keys&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meizu_version meizu_fingerprint&#x3D;&quot;8.1.0-1541573178_stable&quot; &#x2F;&gt;</span><br><span class="line">    &lt;permission-trees &#x2F;&gt;</span><br><span class="line">    &lt;permissions&gt;</span><br><span class="line">        &lt;item name&#x3D;&quot;com.meizu.voiceassistant.push.permission.MESSAGE&quot; package&#x3D;&quot;com.meizu.voiceassistant&quot; protection&#x3D;&quot;2&quot; &#x2F;&gt;</span><br><span class="line">        &lt;item name&#x3D;&quot;com.meizu.safe.alphame.permission.DATA&quot; package&#x3D;&quot;com.meizu.safe&quot; protection&#x3D;&quot;18&quot; &#x2F;&gt;</span><br><span class="line">        &lt;item name&#x3D;&quot;android.permission.REAL_GET_TASKS&quot; package&#x3D;&quot;android&quot; protection&#x3D;&quot;18&quot; &#x2F;&gt;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        &lt;item name&#x3D;&quot;android.permission.MODIFY_PHONE_STATE&quot; granted&#x3D;&quot;true&quot; flags&#x3D;&quot;0&quot; &#x2F;&gt;</span><br><span class="line">        &lt;item name&#x3D;&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot; granted&#x3D;&quot;true&quot; flags&#x3D;&quot;0&quot; &#x2F;&gt;</span><br><span class="line">        &lt;item name&#x3D;&quot;android.permission.WAKE_LOCK&quot; granted&#x3D;&quot;true&quot; flags&#x3D;&quot;0&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;perms&gt;</span><br><span class="line">        &lt;proper-signing-keyset identifier&#x3D;&quot;1&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;package&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;package name&#x3D;&quot;com.android.providers.telephony&quot; codePath&#x3D;&quot;&#x2F;system&#x2F;priv-app&#x2F;TelephonyProvider&quot; nativeLibraryPath&#x3D;&quot;&#x2F;system&#x2F;priv-app&#x2F;TelephonyProvider&#x2F;lib&quot; primaryCpuAbi&#x3D;&quot;arm64-v8a&quot; publicFlags&#x3D;&quot;1007402501&quot; privateFlags&#x3D;&quot;8&quot; ft&#x3D;&quot;11e8dc5d800&quot; it&#x3D;&quot;11e8dc5d800&quot; ut&#x3D;&quot;11e8dc5d800&quot; version&#x3D;&quot;27&quot; sharedUserId&#x3D;&quot;1001&quot; isOrphaned&#x3D;&quot;true&quot; forceFull&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;sigs count&#x3D;&quot;1&quot;&gt;</span><br><span class="line">            &lt;cert index&#x3D;&quot;0&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;sigs&gt;</span><br><span class="line">        &lt;perms&gt;</span><br><span class="line">            &lt;item name&#x3D;&quot;android.permission.SEND_RECEIVE_STK_INTENT&quot; granted&#x3D;&quot;true&quot; flags&#x3D;&quot;0&quot; &#x2F;&gt;</span><br><span class="line">            &lt;item name&#x3D;&quot;android.permission.BIND_INCALL_SERVICE&quot; granted&#x3D;&quot;true&quot; flags&#x3D;&quot;0&quot; &#x2F;&gt;</span><br><span class="line">            </span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            &lt;item name&#x3D;&quot;android.permission.UPDATE_APP_OPS_STATS&quot; granted&#x3D;&quot;true&quot; flags&#x3D;&quot;0&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;perms&gt;</span><br><span class="line">        &lt;proper-signing-keyset identifier&#x3D;&quot;1&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;package&gt;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-package-表示包信息"><a href="#5-1-package-表示包信息" class="headerlink" title="5.1. package 表示包信息"></a>5.1. package 表示包信息</h5><ul>
<li>name 表示应用的包名</li>
<li>codePath 表示的是 APK 文件的路径</li>
<li>nativeLibraryPath 表示应用的 native 库的存储路径</li>
<li>it 表示应用安装的时间</li>
<li>ut 表示应用最后一次修改的时间</li>
<li>version 表示应用的版本号</li>
<li>userId 表示所属于的 id</li>
</ul>
<h5 id="5-2-sign-表示应用的签名"><a href="#5-2-sign-表示应用的签名" class="headerlink" title="5.2. sign 表示应用的签名"></a>5.2. sign 表示应用的签名</h5><ul>
<li>count 表示标签中包含有多少个证书</li>
<li>cert 表示具体的证书的值</li>
</ul>
<h5 id="5-3-perms-表示应用声明使用的权限，每一个子标签代表一项权限"><a href="#5-3-perms-表示应用声明使用的权限，每一个子标签代表一项权限" class="headerlink" title="5.3. perms 表示应用声明使用的权限，每一个子标签代表一项权限"></a>5.3. perms 表示应用声明使用的权限，每一个子标签代表一项权限</h5><h2 id="6-安利一个在线查看-Android-源码网站"><a href="#6-安利一个在线查看-Android-源码网站" class="headerlink" title="6. 安利一个在线查看 Android 源码网站"></a>6. 安利一个在线查看 Android 源码网站</h2><p><a href="http://aospxref.com/">aospxref</a> 是 <a href="https://zhuanlan.zhihu.com/weishu">weishu</a> 大神搭建一个在线查看在线查看 Android源码网站, 访问速度非常快<br/></p>
<p>在这之前我常用的在线查看 Android 源码的网站 <a href="http://androidxref.com/">androidxref</a>，访问速度不仅慢，而且更新也不及时，现在 Android 10 发布了，这个网站到现在提供的最新的代码还是 Andorid 9 <br/></p>
<p><a href="http://aospxref.com/">aospxref</a> 提供了与 <a href="http://androidxref.com/">androidxref</a> 完全一样的源码浏览和交叉索引功能；除此之外，它还有一些别的优点：</p>
<ul>
<li>跟随 Android 版本更新，你永远可以看到最新的源代码。</li>
<li>服务器在阿里云，国内访问速度贼快。</li>
<li>opengrok 版本较高，查阅代码时会有自动提示。</li>
<li>对页面做过部分优化，使用更便捷；比如可以在任意界面跳转到首页。<br/></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/1199502">Android包管理总结</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/90782268">安利一个看 Android 源代码的网站</a></li>
<li><a href="https://source.android.google.cn/devices/tech/config?hl=zh-cn">Android 权限</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTg2MjA2OA==&mid=2649842440&idx=1&sn=a24633e9e82a74c6d33440ecddba1849&chksm=83bf6a53b4c8e345195a212b6e66abbc862ed40aa087730d24233d81e2cf9b22cdf81a7a14da&scene=21#wechat_redirect">Android包管理机制（一）PackageInstaller的初始化</a></li>
</ul>
</div><div><p style="height:15px"></p><ul class="page-copyright"><li><strong>本文作者：</strong>hi-dhl</li><li><strong>本文标题：</strong>Android 10 源码分析：APK 的安装流程</li><li><strong>本文链接：</strong><a href="" title="{page.title}">https://hi-dhl.com/2020/06/07/android10/package-manager/02-APK-install/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hi-dhl.com" title="{page.title}">hi-dhl</a></li></ul><p style="height:15px"></p></div><!--!--><h1 class="title is-4 is-size-4-mobile"></h1></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/06/07/android10/resource-manager/03-APK-resource/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android 10 源码分析：APK 加载流程之资源加载</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/07/android10/package-manager/01-APK-generate/"><span class="level-item">Android 10 源码分析：APK 是如何生成的</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content template"><p align="center"><img src="http://cdn.51git.cn/2020-10-07-bytecode.png"></p><p>致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，在技术的道路上一起前进</p><h3 class="title is-4">Android10 源码分析</h3><p>正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Android10-Source-Analysis">Android10-Source-Analysis</a>。</p><h3 class="title is-4">算法题库的归纳和总结</h3><p>由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序。</p><ul><li>数据结构： 数组、栈、队列、字符串、链表、树……</li><li>算法： 查找算法、搜索算法、位运算、排序、数学、……</li></ul><p>每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：<a href="https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin">Leetcode-Solutions-with-Java-And-Kotlin</a>。</p><h3 class="title is-4">精选国外的技术文章</h3><p>目前正在整理和翻译一系列精选国外的技术文章，不仅仅是翻译，很多优秀的英文技术文章提供了很好思路和方法，每篇文章都会有<strong>译者思考</strong>部分，对原文的更加深入的解读，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Technical-Article-Translation">Technical-Article-Translation</a>。</p><p></p></div></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: undefined,
            appId: 'zfvr24HFhzQ5vtHkr4NQ1fmW-gzGzoHsz',
            appKey: 'RChgr9mR005hgu4yiQ4WQU3O',
            placeholder: '说点什么',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" style="max-height: 500px;overflow: auto;"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#前言"><span>前言</span></a><ul class="menu-list"><li><a class="is-flex" href="#PackageInstaller-源码所在位置"><span>PackageInstaller 源码所在位置</span></a></li><li><a class="is-flex" href="#在-Android-系统不同的目录存放不同类型的应用"><span>在 Android 系统不同的目录存放不同类型的应用</span></a></li><li><a class="is-flex" href="#查看-PackageInstaller-源码方式"><span>查看 PackageInstaller 源码方式</span></a></li></ul></li><li><a class="is-flex" href="#1-APK-的安装方式"><span>1. APK 的安装方式</span></a></li><li><a class="is-flex" href="#2-PackageInstaller-的入口"><span>2. PackageInstaller 的入口</span></a></li><li><a class="is-flex" href="#3-APK-的安装流程"><span>3. APK 的安装流程</span></a><ul class="menu-list"><li><a class="is-flex" href="#3-1-InstallStart"><span>3.1 InstallStart</span></a></li><li><a class="is-flex" href="#3-2-PackageInstallerActivity"><span>3.2 PackageInstallerActivity</span></a></li><li><a class="is-flex" href="#3-3-InstallInstalling"><span>3.3 InstallInstalling</span></a></li></ul></li><li><a class="is-flex" href="#4-总结"><span>4. 总结</span></a></li><li><a class="is-flex" href="#5-关于-packages-xml"><span>5. 关于 packages.xml</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" href="#5-3-perms-表示应用声明使用的权限，每一个子标签代表一项权限"><span>5.3. perms 表示应用声明使用的权限，每一个子标签代表一项权限</span></a></li></ul></ul></li><li><a class="is-flex" href="#6-安利一个在线查看-Android-源码网站"><span>6. 安利一个在线查看 Android 源码网站</span></a></li><li><a class="is-flex" href="#参考"><span>参考</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2022-09-20T01:03:36.410Z">2022-09-20</time></p><p class="title is-6"><a class="link-muted" href="/2022/09/20/kotlin/27-kotlin-twitter/">Twitter 上有趣的代码</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-07-28T01:37:04.044Z">2022-07-28</time></p><p class="title is-6"><a class="link-muted" href="/2022/07/28/performance/01-reflect/">谁动了我的内存，揭秘 OOM 崩溃下降 90% 的秘密</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-07-24T17:26:33.064Z">2022-07-25</time></p><p class="title is-6"><a class="link-muted" href="/2022/07/25/kotlin/26-reflect-performance/">反射技巧让你的性能提升 N 倍</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-07-10T06:20:44.679Z">2022-07-10</time></p><p class="title is-6"><a class="link-muted" href="/2022/07/10/kotlin/25-genericsclear/">90%人不懂的泛型局限性，泛型擦除，星投影</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-06-23T01:18:18.600Z">2022-06-23</time></p><p class="title is-6"><a class="link-muted" href="/2022/06/23/kotlin/24-generics/">90%的人都不懂的泛型，泛型的缺陷和应用场景</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android-12/"><span class="level-start"><span class="level-item">Android 12</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android-AndroidStudio/"><span class="level-start"><span class="level-item">Android,AndroidStudio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android10/"><span class="level-start"><span class="level-item">Android10</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AndroidStudio/"><span class="level-start"><span class="level-item">AndroidStudio</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Jetpack/"><span class="level-start"><span class="level-item">Jetpack</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9D%82%E8%B0%88/"><span class="level-start"><span class="level-item">杂谈</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95%E5%8A%A8%E7%94%BB/"><span class="level-start"><span class="level-item">算法动画</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/translated/"><span class="level-start"><span class="level-item">译文</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%91%E6%96%87-AndroidStudio/"><span class="level-start"><span class="level-item">译文,AndroidStudio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%91%E6%96%87-Kotlin/"><span class="level-start"><span class="level-item">译文,Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android-12/"><span class="tag">Android 12</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-包管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-窗口管理系统</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-资源管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AndroidStudio/"><span class="tag">AndroidStudio</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android%E6%BA%90%E7%A0%81/"><span class="tag">Android源码</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compose/"><span class="tag">Compose</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fragment/"><span class="tag">Fragment</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Jetpack/"><span class="tag">Jetpack</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Koin/"><span class="tag">Koin</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag is-grey-lightest">32</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OOM/"><span class="tag">OOM</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Protobuf/"><span class="tag">Protobuf</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kotlin/"><span class="tag">kotlin</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E7%94%BB/"><span class="tag">动画</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B3%BB%E7%BB%9F/"><span class="tag">系统</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%91%E6%96%87/"><span class="tag">译文</span><span class="tag is-grey-lightest">11</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level-item"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/logo.png" alt="程序员DHL" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="程序员DHL" height="28"></a><p class="size-small"><span>&copy; 2022 程序员DHL</span>  <a href="http://beian.miit.gov.cn/" target="_blank">京ICP备18050211号-2</a>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.hi-dhl.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://s9.cnzz.com/z_stat.php?id=1278919895&amp;web_id=1278919895" async></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/imaegoo/universe.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>