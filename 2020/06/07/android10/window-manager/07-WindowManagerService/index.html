<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Android 10 源码分析：Window 的类型 以及 三维视图层级分析 - dhl</title><meta description="Window 视图层级顺序是如何确定，深入了解Window、PhoneWindow、WindowManager 之间的关系"><meta property="og:type" content="blog"><meta property="og:title" content="Android 10 源码分析：Window 的类型 以及 三维视图层级分析"><meta property="og:url" content="https://www.hi-dhl.com/2020/06/07/android10/window-manager/07-WindowManagerService/"><meta property="og:site_name" content="dhl"><meta property="og:description" content="Window 视图层级顺序是如何确定，深入了解Window、PhoneWindow、WindowManager 之间的关系"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.51git.cn/2020-06-03-Window视图层级.png"><meta property="article:published_time" content="2020-06-06T16:45:50.638Z"><meta property="article:modified_time" content="2020-11-11T02:48:17.460Z"><meta property="article:author" content="dhl"><meta property="article:tag" content="源码"><meta property="article:tag" content="Android10"><meta property="article:tag" content="Dialog"><meta property="article:tag" content="Window"><meta property="article:tag" content="WindowManager"><meta property="article:tag" content="Android视图管理"><meta property="article:tag" content="窗口管理系统"><meta property="article:tag" content="PhoneWindow"><meta property="article:tag" content="WindowManagerService"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://cdn.51git.cn/2020-06-03-Window视图层级.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hi-dhl.com/2020/06/07/android10/window-manager/07-WindowManagerService/"},"headline":"dhl","image":["http://cdn.51git.cn/2020-06-03-Window视图层级.png"],"datePublished":"2020-06-06T16:45:50.638Z","dateModified":"2020-11-11T02:48:17.460Z","author":{"@type":"Person","name":"dhl"},"description":"Window 视图层级顺序是如何确定，深入了解Window、PhoneWindow、WindowManager 之间的关系"}</script><link rel="canonical" href="https://www.hi-dhl.com/2020/06/07/android10/window-manager/07-WindowManagerService/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/logo.png" alt="dhl" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="dhl" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/categories/Jetpack">Jetpack</a><a class="navbar-item" href="/categories/Kotlin/">Kotlin</a><a class="navbar-item" href="/categories/Android10/">系统源码</a><a class="navbar-item" href="/categories/translated/">译文</a><a class="navbar-item" href="https://offer.hi-dhl.com">算法</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hi-dhl"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="http://cdn.51git.cn/2020-06-03-Window视图层级.png" alt="Android 10 源码分析：Window 的类型 以及 三维视图层级分析"></span></div><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile"></h1><h1 class="title is-3 is-size-4-mobile">Android 10 源码分析：Window 的类型 以及 三维视图层级分析</h1><div class="article-meta size-small level is-mobile"><div class="level-left"><span class="mr-2"><i class="fa fa-calendar"></i></span><time class="level-item" dateTime="2020-06-06T16:45:50.638Z" title="2020-06-06T16:45:50.638Z">2020-06-07</time><span class="mr-2"> <i class="fa fa-folder"></i></span><span class="level-item"><a class="link-muted" href="/categories/Android10/">Android10</a></span><span class="mr-2"> <i class="fa fa-tag"></i></span><span class="level-item"><a class="link-muted" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span> , </span><a class="link-muted" href="/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">Android10-窗口管理系统</a></span></div></div><div class="level-left article-meta size-small is-mobile"></div><div><p style="height:15px"></p><ul class="page-blockquote"><li>如果评论区没有及时回复，欢迎来公众号：ByteCode 咨询</li><li>公众号：ByteCode。致力于分享最新技术原创文章，涉及 Kotlin、Jetpack、算法、译文、系统源码相关的文章</li><li></li></ul><p style="height:15px"></p></div><div class="content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<ul>
<li>这是 Android 10 源码分析系列的第 7 篇</li>
<li>分支：android-10.0.0_r14</li>
<li>全文阅读大概 10 分钟</li>
</ul>
</blockquote>
<p>在之前的文章 <a href="https://juejin.im/post/5ead0b865188256d545fd2f8">0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构</a> 介绍了  Activity、Window、PhoneWindow、WindowManager 之间的关系，以及 Activity 和 Dialog 的视图绑定过程，而这篇文章主要两个目的：</p>
<ol>
<li>对上一篇文章 <a href="https://juejin.im/post/5ead0b865188256d545fd2f8">0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构</a> 做深入的了解</li>
<li>为后面的篇文章「如何在 Andorid 系统里添加自定义 View」等等做好铺垫</li>
</ol>
<p><strong>通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案</strong></p>
<ul>
<li>Window 都有那些常用的参数?</li>
<li>Window 都那些类型？每个类型的意思？以及作用？</li>
<li>Window 那些过时的 API 以及处理方案？</li>
<li>Window 视图层级顺序是如何确定的？</li>
<li>Window 都那些 flag？每个 flag 的意思？以及作用？</li>
<li>Window 的软键盘模式？每个模式的意思？以及如何使用？</li>
<li>Kotlin 小技巧？</li>
</ul>
<p>在开始分析之前，我们先来看一张图，熟悉一下几个基本概念，这些概念伴将随着整篇文章</p>
<p><img src="http://cdn.51git.cn/2020-06-03-640.gif" alt="Window 视图层级顺序"></p>
<ul>
<li>我们在手机上看到的界面是二维的，但是实际上是一个三维，如上图所示</li>
<li>Window：是一个抽象类，它作为一个顶级视图添加到 WindowManager 中，View 是依附于 Window 而存在的，对 View 进行管理</li>
<li>WindowManager：它是一个接口，继承自接口 ViewManager，对 Window 进行管理</li>
<li>PhoneWindow：Window 唯一实现类，添加到 WindowManager 的根容器中</li>
<li>WindowManagerService：WindowManager 是 Window 的容器，管理着 Window，对 Window 进行添加和删除，最终具体的工作都是由 WindowManagerService 来处理的，WindowManager 和 WindowManagerService 通过 Binder 来进行跨进程通信，WindowManagerService 才是 Window 的最终管理者</li>
</ul>
<p>这篇文章重要知识点是 <strong>Window 视图层级顺序是如何确定的</strong>，其他内容都是一些概念的东西，可以选择性的阅读，了解完基本概念之后，进入这篇文章的核心内容，我们先来了解一下 Window 都有那些常用的参数</p>
<h2 id="Window-都有那些常用的参数"><a href="#Window-都有那些常用的参数" class="headerlink" title="Window 都有那些常用的参数"></a>Window 都有那些常用的参数</h2><p>Window 的参数都被定义在 WindowManager 的静态内部类 LayoutParams 中<br><strong>frameworks/base/core/java/android/view/WindowManager#LayoutParams.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123;</span><br><span class="line">    &#x2F;&#x2F; window 左上角的 x 坐标</span><br><span class="line">    public int x;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; window 左上角的 y 坐标</span><br><span class="line">    public int y;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Window 的类型</span><br><span class="line">    public int type;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Window 的 flag 用于控制 Window 的显示</span><br><span class="line">    public int flags;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; window 软键盘输入区域的显示模式</span><br><span class="line">    public int softInputMode;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; window 的透明度，取值为0-1</span><br><span class="line">    public float alpha &#x3D; 1.0f;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; window 在屏幕中的位置</span><br><span class="line">    public int gravity;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; window 的像素点格式，值定义在 PixelFormat 中</span><br><span class="line">    public int format;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们我们主要来介绍一下 Window 的类型、Window 视图层级顺序、Window 的 flag、和 window 软键盘模式</p>
<h3 id="Window-都那些类型以及作用"><a href="#Window-都那些类型以及作用" class="headerlink" title="Window 都那些类型以及作用"></a>Window 都那些类型以及作用</h3><p>Window 的类型大概可以分为三类： 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window）， Window 的类型通过 type 值来表示，每个大类型又包含多个小类型，它们都定义在 WindowManager 的静态内部类 LayoutParams<br><strong>frameworks/base/core/java/android/view/WindowManager#LayoutParams.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123;</span><br><span class="line">    public int type;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 应用程序 Window 的开始值</span><br><span class="line">    public static final int FIRST_APPLICATION_WINDOW &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 应用程序 Window 的结束值</span><br><span class="line">    public static final int LAST_APPLICATION_WINDOW &#x3D; 99;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 子 Window 类型的开始值</span><br><span class="line">    public static final int FIRST_SUB_WINDOW &#x3D; 1000;</span><br><span class="line">    &#x2F;&#x2F; 子 Window 类型的结束值</span><br><span class="line">    public static final int LAST_SUB_WINDOW &#x3D; 1999;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 系统 Window 类型的开始值</span><br><span class="line">    public static final int FIRST_SYSTEM_WINDOW     &#x3D; 2000;   </span><br><span class="line">    &#x2F;&#x2F; 系统 Window 类型的结束值</span><br><span class="line">    public static final int LAST_SYSTEM_WINDOW      &#x3D; 2999;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FIRST_APPLICATION_WINDOW</td>
<td>1</td>
<td>应用程序 Window 的开始值</td>
</tr>
<tr>
<td>LAST_APPLICATION_WINDOW</td>
<td>99</td>
<td>应用程序 Window 的结束值</td>
</tr>
<tr>
<td>FIRST_SUB_WINDOW</td>
<td>1000</td>
<td>子 Window 的开始值</td>
</tr>
<tr>
<td>LAST_SUB_WINDOW</td>
<td>1999</td>
<td>子 Window 的结束值</td>
</tr>
<tr>
<td>FIRST_SYSTEM_WINDOW</td>
<td>2000</td>
<td>系统 Window 的开始值</td>
</tr>
<tr>
<td>LAST_SYSTEM_WINDOW</td>
<td>2999</td>
<td>系统 Window 的结束值</td>
</tr>
</tbody></table>
<p><strong>小技巧：如果是层级在 2000（FIRST_SYSTEM_WINDOW）以下的是不需要申请弹窗权限的</strong></p>
<p>应用程序 Window（Application Window）：它的区间范围 [1,99]，例如 Activity<br><strong>frameworks/base/core/java/android/view/WindowManager#LayoutParams.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 应用程序 Window 的开始值</span><br><span class="line">public static final int FIRST_APPLICATION_WINDOW &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应用程序 Window 的基础值</span><br><span class="line">public static final int TYPE_BASE_APPLICATION   &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 普通的应用程序</span><br><span class="line">public static final int TYPE_APPLICATION        &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特殊的应用程序窗口，当程序可以显示 Window 之前使用这个 Window 来显示一些东西</span><br><span class="line">public static final int TYPE_APPLICATION_STARTING &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TYPE_APPLICATION 的变体，在应用程序显示之前，WindowManager 会等待这个 Window 绘制完毕</span><br><span class="line">public static final int TYPE_DRAWN_APPLICATION &#x3D; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应用程序 Window 的结束值</span><br><span class="line">public static final int LAST_APPLICATION_WINDOW &#x3D; 99;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><div style="width: 180pt">类型</div></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FIRST_APPLICATION_WINDOW</td>
<td>应用程序 Window 的开始值</td>
</tr>
<tr>
<td>TYPE_BASE_APPLICATION</td>
<td>应用程序 Window 的基础值</td>
</tr>
<tr>
<td>TYPE_APPLICATION</td>
<td>普通的应用程序</td>
</tr>
<tr>
<td>TYPE_APPLICATION_STARTING</td>
<td>特殊的应用程序窗口，当程序可以显示 Window 之前使用这个<br/> Window 来显示一些东西</td>
</tr>
<tr>
<td>TYPE_DRAWN_APPLICATION</td>
<td>TYPE_APPLICATION 的变体 在应用程序显示之前，<br/>WindowManager 会等待这个 Window 绘制完毕</td>
</tr>
<tr>
<td>LAST_APPLICATION_WINDOW</td>
<td>应用程序 Window 的结束值</td>
</tr>
</tbody></table>
<p>子 Window（Sub Windwow）：它的区间范围 [1000,1999]，这些 Window 按照 Z-order 顺序依附于父 Window 上（关于 Z-order 后文有介绍），并且他们的坐标空间相对于父 Window 的，例如：PopupWindow<br><strong>frameworks/base/core/java/android/view/WindowManager#LayoutParams.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子 Window 类型的开始值</span><br><span class="line">public static final int FIRST_SUB_WINDOW &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应用程序 Window 顶部的面板。这些 Window 出现在其附加 Window 的顶部。</span><br><span class="line">public static final int TYPE_APPLICATION_PANEL &#x3D; FIRST_SUB_WINDOW;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于显示媒体(如视频)的 Window。这些 Window 出现在其附加 Window 的后面。</span><br><span class="line">public static final int TYPE_APPLICATION_MEDIA &#x3D; FIRST_SUB_WINDOW + 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应用程序 Window 顶部的子面板。这些 Window 出现在其附加 Window 和任何Window的顶部</span><br><span class="line">public static final int TYPE_APPLICATION_SUB_PANEL &#x3D; FIRST_SUB_WINDOW + 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当前Window的布局和顶级Window布局相同时，不能作为子代的容器</span><br><span class="line">public static final int TYPE_APPLICATION_ATTACHED_DIALOG &#x3D; FIRST_SUB_WINDOW + 3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用显示媒体 Window 覆盖顶部的 Window， 这是系统隐藏的 API</span><br><span class="line">public static final int TYPE_APPLICATION_MEDIA_OVERLAY  &#x3D; FIRST_SUB_WINDOW + 4;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子面板在应用程序Window的顶部，这些Window显示在其附加Window的顶部， 这是系统隐藏的 API</span><br><span class="line">public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL &#x3D; FIRST_SUB_WINDOW + 5;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子 Window 类型的结束值</span><br><span class="line">public static final int LAST_SUB_WINDOW &#x3D; 1999;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><div style="width: 240pt">类型 </div></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FIRST_SUB_WINDOW</td>
<td>子 Window 的开始值</td>
</tr>
<tr>
<td>TYPE_APPLICATION_PANEL</td>
<td>应用程序 Window 顶部的面板，这些 Window 出现在其附加 Window 的顶部</td>
</tr>
<tr>
<td>TYPE_APPLICATION_MEDIA</td>
<td>用于显示媒体(如视频)的 Window，这些 Window 出现在其附加 Window 的后面</td>
</tr>
<tr>
<td>TYPE_APPLICATION_SUB_PANEL</td>
<td>应用程序 Window 顶部的子面板，这些 Window 出现在其附加 Window 和任何Window的顶部</td>
</tr>
<tr>
<td>TYPE_APPLICATION_ATTACHED_DIALOG</td>
<td>当前Window的布局和顶级Window布局相同时，不能作为子代的容器</td>
</tr>
<tr>
<td>TYPE_APPLICATION_MEDIA_OVERLAY</td>
<td>用显示媒体 Window 覆盖顶部的 Window， 这是系统隐藏的 API</td>
</tr>
<tr>
<td>TYPE_APPLICATION_ABOVE_SUB_PANEL</td>
<td>子面板在应用程序Window的顶部，这些Window显示在其附加Window的顶部， 这是系统隐藏的 API</td>
</tr>
<tr>
<td>LAST_SUB_WINDOW</td>
<td>子 Window 的结束值</td>
</tr>
</tbody></table>
<p>系统 Window（System Window）: 它区间范围 [2000,2999]，例如：Toast，输入法窗口，系统音量条窗口，系统错误窗口<br><strong>frameworks/base/core/java/android/view/WindowManager#LayoutParams.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 系统Window类型的开始值</span><br><span class="line">public static final int FIRST_SYSTEM_WINDOW     &#x3D; 2000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 系统状态栏，只能有一个状态栏，它被放置在屏幕的顶部，所有其他窗口都向下移动</span><br><span class="line">public static final int TYPE_STATUS_BAR         &#x3D; FIRST_SYSTEM_WINDOW;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 系统搜索窗口，只能有一个搜索栏，它被放置在屏幕的顶部</span><br><span class="line">public static final int TYPE_SEARCH_BAR         &#x3D; FIRST_SYSTEM_WINDOW+1;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">&#x2F;&#x2F; API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</span><br><span class="line">public static final int TYPE_PHONE              &#x3D; FIRST_SYSTEM_WINDOW+2;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">&#x2F;&#x2F; API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</span><br><span class="line">public static final int TYPE_SYSTEM_ALERT       &#x3D; FIRST_SYSTEM_WINDOW+3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 已经从系统中被移除，可以使用 TYPE_KEYGUARD_DIALOG 代替</span><br><span class="line">public static final int TYPE_KEYGUARD           &#x3D; FIRST_SYSTEM_WINDOW+4;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">&#x2F;&#x2F; API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</span><br><span class="line">public static final int TYPE_TOAST              &#x3D; FIRST_SYSTEM_WINDOW+5;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">&#x2F;&#x2F; API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</span><br><span class="line">public static final int TYPE_SYSTEM_OVERLAY     &#x3D; FIRST_SYSTEM_WINDOW+6;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">&#x2F;&#x2F; API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</span><br><span class="line">public static final int TYPE_PRIORITY_PHONE     &#x3D; FIRST_SYSTEM_WINDOW+7;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 系统对话框窗口</span><br><span class="line">public static final int TYPE_SYSTEM_DIALOG      &#x3D; FIRST_SYSTEM_WINDOW+8;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 锁屏时显示的对话框</span><br><span class="line">public static final int TYPE_KEYGUARD_DIALOG    &#x3D; FIRST_SYSTEM_WINDOW+9;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">&#x2F;&#x2F; API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</span><br><span class="line">public static final int TYPE_SYSTEM_ERROR       &#x3D; FIRST_SYSTEM_WINDOW+10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输入法窗口，位于普通 UI 之上，应用程序可重新布局以免被此窗口覆盖</span><br><span class="line">public static final int TYPE_INPUT_METHOD       &#x3D; FIRST_SYSTEM_WINDOW+11;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输入法对话框，显示于当前输入法窗口之上</span><br><span class="line">public static final int TYPE_INPUT_METHOD_DIALOG&#x3D; FIRST_SYSTEM_WINDOW+12;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 墙纸</span><br><span class="line">public static final int TYPE_WALLPAPER          &#x3D; FIRST_SYSTEM_WINDOW+13;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 状态栏的滑动面板</span><br><span class="line">public static final int TYPE_STATUS_BAR_PANEL   &#x3D; FIRST_SYSTEM_WINDOW+14;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应用程序叠加窗口显示在所有窗口之上</span><br><span class="line">public static final int TYPE_APPLICATION_OVERLAY &#x3D; FIRST_SYSTEM_WINDOW + 38;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 系统Window类型的结束值</span><br><span class="line">public static final int LAST_SYSTEM_WINDOW      &#x3D; 2999;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><div style="width: 180pt">类型 </div></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FIRST_SYSTEM_WINDOW</td>
<td>系统 Window 类型的开始值</td>
</tr>
<tr>
<td>TYPE_STATUS_BAR</td>
<td>系统状态栏，只能有一个状态栏，它被放置在屏幕的顶部，所有其他窗口都向下移动</td>
</tr>
<tr>
<td>TYPE_SEARCH_BAR</td>
<td>系统搜索窗口，只能有一个搜索栏，它被放置在屏幕的顶部</td>
</tr>
<tr>
<td>TYPE_PHONE</td>
<td>API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</td>
</tr>
<tr>
<td>TYPE_SYSTEM_ALERT</td>
<td>API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</td>
</tr>
<tr>
<td>TYPE_KEYGUARD</td>
<td>已经从系统中被移除，可以使用 TYPE_KEYGUARD_DIALOG 代替</td>
</tr>
<tr>
<td>TYPE_TOAST</td>
<td>API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</td>
</tr>
<tr>
<td>TYPE_SYSTEM_OVERLAY</td>
<td>API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</td>
</tr>
<tr>
<td>TYPE_PRIORITY_PHONE</td>
<td>API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</td>
</tr>
<tr>
<td>TYPE_SYSTEM_ERROR</td>
<td>API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替</td>
</tr>
<tr>
<td>TYPE_APPLICATION_OVERLAY</td>
<td>应用程序叠加窗口显示在所有窗口之上</td>
</tr>
<tr>
<td>TYPE_SYSTEM_DIALOG</td>
<td>系统对话框窗口</td>
</tr>
<tr>
<td>TYPE_KEYGUARD_DIALOG</td>
<td>锁屏时显示的对话框</td>
</tr>
<tr>
<td>TYPE_INPUT_METHOD</td>
<td>输入法窗口，位于普通 UI 之上，应用程序可重新布局以免被此窗口覆盖</td>
</tr>
<tr>
<td>TYPE_INPUT_METHOD_DIALOG</td>
<td>输入法对话框，显示于当前输入法窗口之上</td>
</tr>
<tr>
<td>TYPE_WALLPAPER</td>
<td>墙纸</td>
</tr>
<tr>
<td>TYPE_STATUS_BAR_PANEL</td>
<td>状态栏的滑动面板</td>
</tr>
<tr>
<td>LAST_SYSTEM_WINDOW</td>
<td>系统 Window 类型的结束值</td>
</tr>
</tbody></table>
<p><strong>需要注意的是：</strong></p>
<ol>
<li><p><code>TYPE_PHONE、TYPE_SYSTEM_ALERT、TYPE_TOAST、TYPE_SYSTEM_OVERLAY、TYPE_PRIORITY_PHONE、TYPE_SYSTEM_ERROR</code> 这些 type 在 API 26 中均已经过时，使用 <code>TYPE_APPLICATION_OVERLAY</code> 代替，<strong>需要申请 Manifest.permission.SYSTEM_ALERT_WINDOW 权限</strong></p>
</li>
<li><p><code>TYPE_KEYGUARD</code> 已经被从系统中移除，可以使用 <code>TYPE_KEYGUARD_DIALOG</code> 来代替</p>
</li>
</ol>
<h3 id="Window-视图层级顺序"><a href="#Window-视图层级顺序" class="headerlink" title="Window 视图层级顺序"></a>Window 视图层级顺序</h3><p>我们在手机上看的是二维的，但是实际上是三维的显示，如下图所示</p>
<p><img src="http://cdn.51git.cn/2020-06-03-640.gif" alt="640"></p>
<p>在文章开头介绍了参数类型包含了 Window 的 x 轴坐标、Window 的 y 轴坐标， 既然是一个三维坐标系，那么 z 轴坐标在哪里？ 接下来就是我们要分析的非常重要的一个类 WindowManagerService，当添加 Window 的时候已经确定好了 Window 的层级，显示的时候才会根据当前的层级确定 Window 应该在哪一层显示</p>
<p>WindowManager 是 Window 的容器，管理着 Window，对 Window 进行添加和删除，具体的工作都是由 WMS 来处理的，WindowManager 和 WMS 通过 Binder 来进行跨进程通信，WMS 才是 Window 的最终管理者，我先来看一下 WMS 的 addWindow 方法<br><strong>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int addWindow(Session session, IWindow client, int seq,</span><br><span class="line">        LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame,</span><br><span class="line">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span><br><span class="line">        DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</span><br><span class="line">        InsetsState outInsetsState) &#123;</span><br><span class="line">        </span><br><span class="line">            final WindowState win &#x3D; new WindowState(this, session, client, token, parentWindow,</span><br><span class="line">            appOp[0], seq, attrs, viewVisibility, session.mUid,</span><br><span class="line">            session.mCanAddInternalSystemWindow);</span><br><span class="line">            ......</span><br><span class="line">            </span><br><span class="line">            win.mToken.addWindow(win);</span><br><span class="line">            ......</span><br><span class="line">            </span><br><span class="line">            win.getParent().assignChildLayers();</span><br><span class="line">            ......</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>WindowState 计算当前 Window 层级</li>
<li>win.mToken.addWindow 这个方法将当前的 win 放入 WindowList 中，WindowList 是一个 ArrayList</li>
<li>displayContent.assignWindowLayers 方法 计算 z-order 值, z-order 值越大越靠前，就越靠近用户</li>
</ul>
<p>Window 视图层级顺序 用 Z-order 来表示，Z-order 对应着 WindowManager.LayoutParams 的 type 值，Z-order 可以理解为 Android 视图的层级概念，值越大越靠前，就越靠近用户。</p>
<p>WindowState 就是 windowManager 中的窗口，一个 WindowState 表示一个 window</p>
<p>那么 Z-order 的值的计算逻辑在 WindowState 类中，WindowState 构造的时候初始化当前的 mBaseLayer 和 mSubLayer，这两个参数应该是决定 z-order 的两个因素<br><strong>frameworks/base/services/core/java/com/android/server/wm/WindowState.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final int TYPE_LAYER_MULTIPLIER &#x3D; 10000;</span><br><span class="line">static final int TYPE_LAYER_OFFSET &#x3D; 1000;</span><br><span class="line">    </span><br><span class="line">WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,</span><br><span class="line">        WindowState parentWindow, int appOp, int seq, WindowManager.LayoutParams a,</span><br><span class="line">        int viewVisibility, int ownerId, boolean ownerCanAddInternalSystemWindow,</span><br><span class="line">        PowerManagerWrapper powerManagerWrapper) &#123;</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F; 判断该是否在子 Window 的类型范围内[1000,1999]</span><br><span class="line">        if (mAttrs.type &gt;&#x3D; FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;&#x3D; LAST_SUB_WINDOW) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 调用 getWindowLayerLw 方法返回值在[1,33]之间，根据不同类型的 Window 在屏幕上进行排序</span><br><span class="line">            mBaseLayer &#x3D; mPolicy.getWindowLayerLw(parentWindow)</span><br><span class="line">                    * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; mSubLayer 子窗口的顺序</span><br><span class="line">            &#x2F;&#x2F; 调用 getSubWindowLayerFromTypeLw 方法返回值在[-2.3]之间 ，返回子 Window 相对于父 Window 的位置</span><br><span class="line">            mSubLayer &#x3D; mPolicy.getSubWindowLayerFromTypeLw(a.type);</span><br><span class="line">            ......</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           </span><br><span class="line">            mBaseLayer &#x3D; mPolicy.getWindowLayerLw(this)</span><br><span class="line">                    * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">            mSubLayer &#x3D; 0;</span><br><span class="line">            ......</span><br><span class="line">            </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mBaseLayer 是基础序，对应的区间范围 [1,33]</li>
<li>mSubLayer 相同分组下的子 Window 的序，对应的区间范围 [-2.3]</li>
<li>判断该是否在子 Window 的类型范围内[1000,1999]</li>
<li>如果是子 Window，调用 getWindowLayerLw 方法，计算 mBaseLayer 的值，返回一个用来对 Window 进行排序的任意整数，调用 getSubWindowLayerFromTypeLw 方法，计算 mSubLayer 的值，返回子 Window 相对于父 Window 的位置</li>
<li>如果不是子 Window，调用 getWindowLayerLw 方法，计算 mBaseLayer 的值，返回一个用来对 Window 进行排序的任意整数，mSubLayer 值为 0</li>
</ul>
<h4 id="计算-mBaseLayer-的值"><a href="#计算-mBaseLayer-的值" class="headerlink" title="计算 mBaseLayer 的值"></a>计算 mBaseLayer 的值</h4><p>调用 WindowManagerPolicy 的 getWindowLayerLw 方法，计算 mBaseLayer 的值<br><strong>frameworks/base/services/core/java/com/android/server/policy/WindowManagerPolicy.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int APPLICATION_LAYER &#x3D; 2;</span><br><span class="line">int APPLICATION_MEDIA_SUBLAYER &#x3D; -2;</span><br><span class="line">int APPLICATION_MEDIA_OVERLAY_SUBLAYER &#x3D; -1;</span><br><span class="line">int APPLICATION_PANEL_SUBLAYER &#x3D; 1;</span><br><span class="line">int APPLICATION_SUB_PANEL_SUBLAYER &#x3D; 2;</span><br><span class="line">int APPLICATION_ABOVE_SUB_PANEL_SUBLAYER &#x3D; 3;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line">* 根据不同类型的 Window 在屏幕上进行排序</span><br><span class="line">* 返回一个用来对窗口进行排序的任意整数，数字越小，表示的值越小</span><br><span class="line">*&#x2F;   </span><br><span class="line">default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断是否在应用程序 Window 类型的取值范围内 [1,99]</span><br><span class="line">    if (type &gt;&#x3D; FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;&#x3D; LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">        return APPLICATION_LAYER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case TYPE_WALLPAPER: &#x2F;&#x2F; 壁纸，通过 window manager 删除它</span><br><span class="line">            return  1;</span><br><span class="line">        case TYPE_PHONE: &#x2F;&#x2F; 电话</span><br><span class="line">            return  3;</span><br><span class="line">        case TYPE_SEARCH_BAR: &#x2F;&#x2F; 搜索栏</span><br><span class="line">            return  6;</span><br><span class="line">        case TYPE_SYSTEM_DIALOG: &#x2F;&#x2F; 系统的 dialog</span><br><span class="line">            return  7;</span><br><span class="line">        case TYPE_TOAST: &#x2F;&#x2F; 系统 toast</span><br><span class="line">            return  8;</span><br><span class="line">        case TYPE_INPUT_METHOD: &#x2F;&#x2F; 输入法</span><br><span class="line">            return  15;</span><br><span class="line">        case TYPE_STATUS_BAR: &#x2F;&#x2F; 状态栏</span><br><span class="line">            return  17;</span><br><span class="line">        case TYPE_KEYGUARD_DIALOG: &#x2F;&#x2F;锁屏</span><br><span class="line">            return  20;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        case TYPE_POINTER:</span><br><span class="line">            &#x2F;&#x2F; the (mouse) pointer layer</span><br><span class="line">            return  33;</span><br><span class="line">        default:</span><br><span class="line">            return APPLICATION_LAYER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据不同类型的 Window 在屏幕上进行排序，返回一个用来对 Window 进行排序的任意整数，数字越小，表示的值越小，通过以下公式来计算它的基础序 ，基础序越大，Z-order 值越大越靠前，就越靠近用户，我们以 <strong>Activity</strong> 为例：</p>
<p>Activity 属于应用层 Window，它的取值范围在 [1,99] 内，调用 getWindowLayerLw 方法返回 APPLICATION_LAYER，APPLICATION_LAYER 值为 2，通过下面方法进行计算 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final int TYPE_LAYER_MULTIPLIER &#x3D; 10000;</span><br><span class="line">static final int TYPE_LAYER_OFFSET &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">mBaseLayer &#x3D; mPolicy.getWindowLayerLw(parentWindow)</span><br><span class="line">                * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br></pre></td></tr></table></figure>

<p>那么最终 Activity 的 mBaseLayer 值是 21000</p>
<h4 id="计算-mSubLayer-的值"><a href="#计算-mSubLayer-的值" class="headerlink" title="计算 mSubLayer 的值"></a>计算 mSubLayer 的值</h4><p>调用 getSubWindowLayerFromTypeLw 方法 ，传入  WindowManager.LayoutParams 的实例 a 的 type 值，计算 mSubLayer 的值<br><strong>frameworks/base/services/core/java/com/android/server/policy/WindowManagerPolicy.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int APPLICATION_LAYER &#x3D; 2;</span><br><span class="line">int APPLICATION_MEDIA_SUBLAYER &#x3D; -2;</span><br><span class="line">int APPLICATION_MEDIA_OVERLAY_SUBLAYER &#x3D; -1;</span><br><span class="line">int APPLICATION_PANEL_SUBLAYER &#x3D; 1;</span><br><span class="line">int APPLICATION_SUB_PANEL_SUBLAYER &#x3D; 2;</span><br><span class="line">int APPLICATION_ABOVE_SUB_PANEL_SUBLAYER &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 计算 Window 相对于父 Window 的位置</span><br><span class="line">* 返回 一个整数，正值在前面，表示在父 Window 上面，负值在后面，表示在父 Window 的下面</span><br><span class="line">*&#x2F;</span><br><span class="line">default int getSubWindowLayerFromTypeLw(int type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case TYPE_APPLICATION_PANEL: &#x2F;&#x2F; 1000</span><br><span class="line">        case TYPE_APPLICATION_ATTACHED_DIALOG: &#x2F;&#x2F; 1003</span><br><span class="line">            return APPLICATION_PANEL_SUBLAYER; &#x2F;&#x2F; return 1</span><br><span class="line">        case TYPE_APPLICATION_MEDIA:&#x2F;&#x2F; 1001</span><br><span class="line">            return APPLICATION_MEDIA_SUBLAYER;&#x2F;&#x2F; return -2</span><br><span class="line">        case TYPE_APPLICATION_MEDIA_OVERLAY:</span><br><span class="line">            return APPLICATION_MEDIA_OVERLAY_SUBLAYER; &#x2F;&#x2F; return -1</span><br><span class="line">        case TYPE_APPLICATION_SUB_PANEL:&#x2F;&#x2F; 1002</span><br><span class="line">            return APPLICATION_SUB_PANEL_SUBLAYER;&#x2F;&#x2F; return 2</span><br><span class="line">        case TYPE_APPLICATION_ABOVE_SUB_PANEL:</span><br><span class="line">            return APPLICATION_ABOVE_SUB_PANEL_SUBLAYER;&#x2F;&#x2F; return 3</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算子 Window 相对于父 Window 的位置，返回一个整数，正值表示在父 Window 上面，负值表示在父 Window 的下面</p>
<h3 id="Window-的-flag"><a href="#Window-的-flag" class="headerlink" title="Window 的 flag"></a>Window 的 flag</h3><p>Window 的 flag 用于控制 Window 的显示，它们的值也是定义在 WindowManager 的内部类 LayoutParams 中<br><strong>frameworks/base/core/java/android/view/WindowManager#LayoutParams.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 当 Window 可见时允许锁屏</span><br><span class="line">public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON     &#x3D; 0x00000001;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Window 后面的内容都变暗</span><br><span class="line">public static final int FLAG_DIM_BEHIND        &#x3D; 0x00000002;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">&#x2F;&#x2F; API 已经过时，Window 后面的内容都变模糊</span><br><span class="line">public static final int FLAG_BLUR_BEHIND        &#x3D; 0x00000004;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的</span><br><span class="line">&#x2F;&#x2F; Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL</span><br><span class="line">public static final int FLAG_NOT_FOCUSABLE      &#x3D; 0x00000008;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件</span><br><span class="line">&#x2F;&#x2F; Window 之外的 view 也是可以响应 touch 事件。</span><br><span class="line">public static final int FLAG_NOT_TOUCH_MODAL    &#x3D; 0x00000020;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口。</span><br><span class="line">public static final int FLAG_NOT_TOUCHABLE      &#x3D; 0x00000010;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只要 Window 可见时屏幕就会一直亮着</span><br><span class="line">public static final int FLAG_KEEP_SCREEN_ON     &#x3D; 0x00000080;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 允许 Window 占满整个屏幕</span><br><span class="line">public static final int FLAG_LAYOUT_IN_SCREEN   &#x3D; 0x00000100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 允许 Window 超过屏幕之外</span><br><span class="line">public static final int FLAG_LAYOUT_NO_LIMITS   &#x3D; 0x00000200;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示</span><br><span class="line">public static final int FLAG_FULLSCREEN      &#x3D; 0x00000400;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 表示比FLAG_FULLSCREEN低一级，会显示状态栏</span><br><span class="line">public static final int FLAG_FORCE_NOT_FULLSCREEN   &#x3D; 0x00000800;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件</span><br><span class="line">public static final int FLAG_IGNORE_CHEEK_PRESSES    &#x3D; 0x00008000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件。</span><br><span class="line">public static final int FLAG_WATCH_OUTSIDE_TOUCH &#x3D; 0x00040000;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">&#x2F;&#x2F; 窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替</span><br><span class="line">public static final int FLAG_SHOW_WHEN_LOCKED &#x3D; 0x00080000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制，</span><br><span class="line">&#x2F;&#x2F; 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色。</span><br><span class="line">public static final int FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS &#x3D; 0x80000000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸</span><br><span class="line">public static final int FLAG_SHOW_WALLPAPER &#x3D; 0x00100000;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><div style="width: 170pt"> flag </div></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FLAG_ALLOW_LOCK_WHILE_SCREEN_ON</td>
<td>当 Window 可见时允许锁屏</td>
</tr>
<tr>
<td>FLAG_DIM_BEHIND</td>
<td>Window 后面的内容都变暗</td>
</tr>
<tr>
<td>FLAG_BLUR_BEHIND</td>
<td>API 已经过时，Window 后面的内容都变模糊</td>
</tr>
<tr>
<td>FLAG_NOT_FOCUSABLE</td>
<td>Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的，Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL</td>
</tr>
<tr>
<td>FLAG_NOT_TOUCH_MODAL</td>
<td>设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件，Window 之外的 view 也是可以响应 touch 事件</td>
</tr>
<tr>
<td>FLAG_NOT_TOUCHABLE</td>
<td>设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口</td>
</tr>
<tr>
<td>FLAG_KEEP_SCREEN_ON</td>
<td>只要 Window 可见时屏幕就会一直亮着</td>
</tr>
<tr>
<td>FLAG_LAYOUT_IN_SCREEN</td>
<td>允许 Window 占满整个屏幕</td>
</tr>
<tr>
<td>FLAG_LAYOUT_NO_LIMITS</td>
<td>允许 Window 超过屏幕之外</td>
</tr>
<tr>
<td>FLAG_FULLSCREEN</td>
<td>全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示</td>
</tr>
<tr>
<td>FLAG_FORCE_NOT_FULLSCREEN</td>
<td>表示比FLAG_FULLSCREEN低一级，会显示状态栏</td>
</tr>
<tr>
<td>FLAG_IGNORE_CHEEK_PRESSES</td>
<td>当用户的脸贴近屏幕时（比如打电话），不会去响应此事件</td>
</tr>
<tr>
<td>FLAG_WATCH_OUTSIDE_TOUCH</td>
<td>则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件</td>
</tr>
<tr>
<td>FLAG_SHOW_WHEN_LOCKED</td>
<td>已经过时，窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替</td>
</tr>
<tr>
<td>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</td>
<td>表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制，<br/> 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色</td>
</tr>
<tr>
<td>FLAG_SHOW_WALLPAPER</td>
<td>表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸</td>
</tr>
</tbody></table>
<h3 id="window-软键盘模式"><a href="#window-软键盘模式" class="headerlink" title="window 软键盘模式"></a>window 软键盘模式</h3><p>表示 window 软键盘输入区域的显示模式，常见的情况 Window 的软键盘打开会占据整个屏幕，遮挡了后面的视图，例如看直播的时候底部有个输入框点击的时候，输入框随着键盘一起上来，而有的时候，希望键盘覆盖在所有的 View 之上，界面保持不动等等</p>
<p>软键盘模式(SoftInputMode) 值，与 AndroidManifest 中 Activity 的属性 android:windowSoftInputMode 是对应的，因此可以在 AndroidManifest 文件中为 Activity 设置android:windowSoftInputMode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;activity android:windowSoftInputMode&#x3D;&quot;adjustNothing&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>也可以在 Java 代码中为 Window 设置 SoftInputMode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING);</span><br></pre></td></tr></table></figure>

<p><strong>SoftInputMode 常用的有以下几个值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不会改变软键盘的状态</span><br><span class="line">public static final int SOFT_INPUT_STATE_UNCHANGED &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当用户进入该窗口时，隐藏软键盘</span><br><span class="line">public static final int SOFT_INPUT_STATE_HIDDEN &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当窗口获取焦点时，隐藏软键盘</span><br><span class="line">public static final int SOFT_INPUT_STATE_ALWAYS_HIDDEN &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当用户进入窗口时，显示软键盘</span><br><span class="line">public static final int SOFT_INPUT_STATE_VISIBLE &#x3D; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当窗口获取焦点时，显示软键盘</span><br><span class="line">public static final int SOFT_INPUT_STATE_ALWAYS_VISIBLE &#x3D; 5;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; window会调整大小以适应软键盘窗口</span><br><span class="line">public static final int SOFT_INPUT_MASK_ADJUST &#x3D; 0xf0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置</span><br><span class="line">public static final int SOFT_INPUT_ADJUST_UNSPECIFIED &#x3D; 0x00;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方</span><br><span class="line">&#x2F;&#x2F; 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用；</span><br><span class="line">&#x2F;&#x2F; 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏。</span><br><span class="line">public static final int SOFT_INPUT_ADJUST_RESIZE &#x3D; 0x10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的,</span><br><span class="line">&#x2F;&#x2F; 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方</span><br><span class="line">&#x2F;&#x2F; 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用</span><br><span class="line">public static final int SOFT_INPUT_ADJUST_PAN &#x3D; 0x20;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将不会调整大小，直接覆盖在window上</span><br><span class="line">public static final int SOFT_INPUT_ADJUST_NOTHING &#x3D; 0x30;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><div style="width: 210pt"> model </div></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>SOFT_INPUT_STATE_UNCHANGED</td>
<td>不会改变软键盘的状态</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_VISIBLE</td>
<td>当用户进入窗口时，显示软键盘</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_HIDDEN</td>
<td>当用户进入该窗口时，隐藏软键盘</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_ALWAYS_HIDDEN</td>
<td>当窗口获取焦点时，隐藏软键盘</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_ALWAYS_VISIBLE</td>
<td>当窗口获取焦点时，显示软键盘</td>
</tr>
<tr>
<td>SOFT_INPUT_MASK_ADJUST</td>
<td>window 会调整大小以适应软键盘窗口</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_UNSPECIFIED</td>
<td>没有指定状态,系统会选择一个合适的状态或依赖于主题的设置</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_RESIZE</td>
<td>1. 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方<br/> 2. 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用<br/> 3. 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_PAN</td>
<td>1. 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的<br/> 2. 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方<br/> 3. 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_NOTHING</td>
<td>将不会调整大小，直接覆盖在window上</td>
</tr>
</tbody></table>
<h2 id="Kotlin-小技巧"><a href="#Kotlin-小技巧" class="headerlink" title="Kotlin 小技巧"></a>Kotlin 小技巧</h2><p>利用 plus (+) 和 plus (-) 对 Map 集合做运算，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    val numbersMap &#x3D; mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; plus (+)</span><br><span class="line">    println(numbersMap + Pair(&quot;four&quot;, 4)) &#x2F;&#x2F; &#123;one&#x3D;1, two&#x3D;2, three&#x3D;3, four&#x3D;4&#125;</span><br><span class="line">    println(numbersMap + Pair(&quot;one&quot;, 10)) &#x2F;&#x2F; &#123;one&#x3D;10, two&#x3D;2, three&#x3D;3&#125;</span><br><span class="line">    println(numbersMap + Pair(&quot;five&quot;, 5) + Pair(&quot;one&quot;, 11)) &#x2F;&#x2F; &#123;one&#x3D;11, two&#x3D;2, three&#x3D;3, five&#x3D;5&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; plus (-)</span><br><span class="line">    println(numbersMap - &quot;one&quot;) &#x2F;&#x2F; &#123;two&#x3D;2, three&#x3D;3&#125;</span><br><span class="line">    println(numbersMap - listOf(&quot;two&quot;, &quot;four&quot;)) &#x2F;&#x2F; &#123;one&#x3D;1, three&#x3D;3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里就结束了，这篇文章主要介绍了 Window 的类型大概可以分为三类： 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window）。 分别介绍了 Window 的类型、Window 视图层级顺序、Window 的 flag、和 window 软键盘模式为后面的内容做铺垫</p>
<p><strong>Window 都有那些常用的参数?</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>window 左上角的 x 坐标</td>
</tr>
<tr>
<td>y</td>
<td>window 左上角的 y 坐标</td>
</tr>
<tr>
<td>type</td>
<td>Window 的类型</td>
</tr>
<tr>
<td>flag</td>
<td>Window 的 flag 用于控制 Window 的显示</td>
</tr>
<tr>
<td>softInputMode</td>
<td>window 软键盘输入区域的显示模式</td>
</tr>
<tr>
<td>alpha</td>
<td>Window 的透明度，取值为0-1</td>
</tr>
<tr>
<td>gravity</td>
<td>Window 在屏幕中的位置</td>
</tr>
<tr>
<td>alpha</td>
<td>Window 的透明度，取值为0-1</td>
</tr>
<tr>
<td>format</td>
<td>Window 的像素点格式，值定义在 PixelFormat 中</td>
</tr>
</tbody></table>
<p><strong>Window 都有那些类型？</strong></p>
<p>应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window），子 Window 依附于父 Window 上，并且他们的坐标空间相对于父 Window 的，每个大类型又包含多个小类型，每个类型在上文的表格中已经列出来了，</p>
<p><strong>Window 那些过时的 API 以及处理方案？</strong></p>
<ol>
<li><p><code>TYPE_PHONE、TYPE_SYSTEM_ALERT、TYPE_TOAST、TYPE_SYSTEM_OVERLAY、TYPE_PRIORITY_PHONE、TYPE_SYSTEM_ERROR</code> 这些 type 在 API 26 中均已经过时，使用 <code>TYPE_APPLICATION_OVERLAY</code> 代替，需要申请 Manifest.permission.SYSTEM_ALERT_WINDOW 权限</p>
</li>
<li><p><code>TYPE_KEYGUARD</code> 已经被从系统中移除，可以使用 <code>TYPE_KEYGUARD_DIALOG</code> 来代替</p>
</li>
</ol>
<p><strong>Window 视图层级顺序是如何确定的？</strong></p>
<p>Window 的参数 x、y，分别表示 Window 左上角的 x 坐标，Window 左上角的 y 坐标，Window 视图层级顺序 用 Z-order 来表示，Z-order 对应着 WindowManager.LayoutParams 的 type 值，Z-order 可以理解为 Android 视图的层级概念，值越大越靠前，就越靠近用户。而 mBaseLayer 和 mSubLayer 决定 z-order 的两个因素</p>
<p><strong>Window 都那些 flag？</strong></p>
<p>Window 的 flag 用于控制 Window 的显示，flag 的参数如下所示：</p>
<table>
<thead>
<tr>
<th><div style="width: 170pt"> flag </div></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FLAG_ALLOW_LOCK_WHILE_SCREEN_ON</td>
<td>当 Window 可见时允许锁屏</td>
</tr>
<tr>
<td>FLAG_DIM_BEHIND</td>
<td>Window 后面的内容都变暗</td>
</tr>
<tr>
<td>FLAG_BLUR_BEHIND</td>
<td>API 已经过时，Window 后面的内容都变模糊</td>
</tr>
<tr>
<td>FLAG_NOT_FOCUSABLE</td>
<td>Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的，Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL</td>
</tr>
<tr>
<td>FLAG_NOT_TOUCH_MODAL</td>
<td>设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件，Window 之外的 view 也是可以响应 touch 事件</td>
</tr>
<tr>
<td>FLAG_NOT_TOUCHABLE</td>
<td>设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口</td>
</tr>
<tr>
<td>FLAG_KEEP_SCREEN_ON</td>
<td>只要 Window 可见时屏幕就会一直亮着</td>
</tr>
<tr>
<td>FLAG_LAYOUT_IN_SCREEN</td>
<td>允许 Window 占满整个屏幕</td>
</tr>
<tr>
<td>FLAG_LAYOUT_NO_LIMITS</td>
<td>允许 Window 超过屏幕之外</td>
</tr>
<tr>
<td>FLAG_FULLSCREEN</td>
<td>全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示</td>
</tr>
<tr>
<td>FLAG_FORCE_NOT_FULLSCREEN</td>
<td>表示比FLAG_FULLSCREEN低一级，会显示状态栏</td>
</tr>
<tr>
<td>FLAG_IGNORE_CHEEK_PRESSES</td>
<td>当用户的脸贴近屏幕时（比如打电话），不会去响应此事件</td>
</tr>
<tr>
<td>FLAG_WATCH_OUTSIDE_TOUCH</td>
<td>则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件</td>
</tr>
<tr>
<td>FLAG_SHOW_WHEN_LOCKED</td>
<td>已经过时，窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替</td>
</tr>
<tr>
<td>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</td>
<td>表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制，<br/> 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色</td>
</tr>
<tr>
<td>FLAG_SHOW_WALLPAPER</td>
<td>表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸</td>
</tr>
</tbody></table>
<p><strong>Window 软键盘模式？</strong></p>
<p>Window 的软键盘模式表示 Window 软键盘输入区域的显示模式</p>
<table>
<thead>
<tr>
<th><div style="width: 210pt"> model </div></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>SOFT_INPUT_STATE_UNCHANGED</td>
<td>不会改变软键盘的状态</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_VISIBLE</td>
<td>当用户进入窗口时，显示软键盘</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_HIDDEN</td>
<td>当用户进入该窗口时，隐藏软键盘</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_ALWAYS_HIDDEN</td>
<td>当窗口获取焦点时，隐藏软键盘</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_ALWAYS_VISIBLE</td>
<td>当窗口获取焦点时，显示软键盘</td>
</tr>
<tr>
<td>SOFT_INPUT_MASK_ADJUST</td>
<td>window 会调整大小以适应软键盘窗口</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_UNSPECIFIED</td>
<td>没有指定状态,系统会选择一个合适的状态或依赖于主题的设置</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_RESIZE</td>
<td>1. 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方<br/> 2. 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用<br/> 3. 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_PAN</td>
<td>1. 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的<br/> 2. 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方<br/> 3. 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_NOTHING</td>
<td>将不会调整大小，直接覆盖在window上</td>
</tr>
</tbody></table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html?hl=en#summary">https://developer.android.google.cn/…/WindowManager.LayoutParams</a></li>
<li><a href="https://www.jianshu.com/p/3528255475a2">https://www.jianshu.com/p/3528255475a2</a></li>
</ul>
</div><div><p style="height:15px"></p><ul class="page-copyright"><li><strong>本文作者：</strong>hi-dhl</li><li><strong>本文标题：</strong>Android 10 源码分析：Window 的类型 以及 三维视图层级分析</li><li><strong>本文链接：</strong><a href="" title="{page.title}">https://hi-dhl.com/2020/06/07/android10/window-manager/07-WindowManagerService/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hi-dhl.com" title="{page.title}">hi-dhl</a></li></ul><p style="height:15px"></p></div><!--!--><h1 class="title is-4 is-size-4-mobile"></h1></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/06/10/translate/01-fragment/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「译」Google 最新发布了 Fragment 的新特性 Fragment 间传递数据的新方式 以及源码分析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/07/android10/window-manager/06-Window-WindowManager/"><span class="level-item">Android 10 源码分析：WindowManager 视图绑定以及体系结构</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content template"><p align="center"><img src="http://cdn.51git.cn/2020-10-07-bytecode.png"></p><p>致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，在技术的道路上一起前进</p><h3 class="title is-4">Android10 源码分析</h3><p>正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Android10-Source-Analysis">Android10-Source-Analysis</a>。</p><h3 class="title is-4">算法题库的归纳和总结</h3><p>由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序。</p><ul><li>数据结构： 数组、栈、队列、字符串、链表、树……</li><li>算法： 查找算法、搜索算法、位运算、排序、数学、……</li></ul><p>每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：<a href="https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin">Leetcode-Solutions-with-Java-And-Kotlin</a>。</p><h3 class="title is-4">精选国外的技术文章</h3><p>目前正在整理和翻译一系列精选国外的技术文章，不仅仅是翻译，很多优秀的英文技术文章提供了很好思路和方法，每篇文章都会有<strong>译者思考</strong>部分，对原文的更加深入的解读，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Technical-Article-Translation">Technical-Article-Translation</a>。</p><p></p></div></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: undefined,
            appId: 'zfvr24HFhzQ5vtHkr4NQ1fmW-gzGzoHsz',
            appKey: 'RChgr9mR005hgu4yiQ4WQU3O',
            placeholder: '说点什么',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" style="max-height: 500px;overflow: auto;"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#引言"><span>引言</span></a></li><li><a class="is-flex" href="#Window-都有那些常用的参数"><span>Window 都有那些常用的参数</span></a><ul class="menu-list"><li><a class="is-flex" href="#Window-都那些类型以及作用"><span>Window 都那些类型以及作用</span></a></li><li><a class="is-flex" href="#Window-视图层级顺序"><span>Window 视图层级顺序</span></a><ul class="menu-list"><li><a class="is-flex" href="#计算-mBaseLayer-的值"><span>计算 mBaseLayer 的值</span></a></li><li><a class="is-flex" href="#计算-mSubLayer-的值"><span>计算 mSubLayer 的值</span></a></li></ul></li><li><a class="is-flex" href="#Window-的-flag"><span>Window 的 flag</span></a></li><li><a class="is-flex" href="#window-软键盘模式"><span>window 软键盘模式</span></a></li></ul></li><li><a class="is-flex" href="#Kotlin-小技巧"><span>Kotlin 小技巧</span></a></li><li><a class="is-flex" href="#总结"><span>总结</span></a></li><li><a class="is-flex" href="#参考文献"><span>参考文献</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2021-11-14T05:53:33.793Z">2021-11-14</time></p><p class="title is-6"><a class="link-muted" href="/2021/11/14/kotlin/14-valueclass/">Kotlin 宣布一个重磅特性 value class</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-11-01T01:54:19.586Z">2021-11-01</time></p><p class="title is-6"><a class="link-muted" href="/2021/11/01/kotlin/13-Kotlin-LiveData/">Google 宣布废弃 LiveData.observe 方法</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-10-14T01:02:29.585Z">2021-10-14</time></p><p class="title is-6"><a class="link-muted" href="/2021/10/14/algorithm/04-loop-queue/">独家 | 跟源码学数据结构 | 循环队列</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-09-27T00:48:32.866Z">2021-09-27</time></p><p class="title is-6"><a class="link-muted" href="/2021/09/27/algorithm/03-arraydeque2/">图解 ArrayDeque 比 LinkedList 快</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-09-24T01:14:31.412Z">2021-09-24</time></p><p class="title is-6"><a class="link-muted" href="/2021/09/24/algorithm/02-arraydeque/">为什么不推荐 ArrayDeque 代替 Stack</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android-12/"><span class="level-start"><span class="level-item">Android 12</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android-AndroidStudio/"><span class="level-start"><span class="level-item">Android,AndroidStudio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android10/"><span class="level-start"><span class="level-item">Android10</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AndroidStudio/"><span class="level-start"><span class="level-item">AndroidStudio</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Jetpack/"><span class="level-start"><span class="level-item">Jetpack</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9D%82%E8%B0%88/"><span class="level-start"><span class="level-item">杂谈</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95%E5%8A%A8%E7%94%BB/"><span class="level-start"><span class="level-item">算法动画</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/translated/"><span class="level-start"><span class="level-item">译文</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%91%E6%96%87-AndroidStudio/"><span class="level-start"><span class="level-item">译文,AndroidStudio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%91%E6%96%87-Kotlin/"><span class="level-start"><span class="level-item">译文,Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android-12/"><span class="tag">Android 12</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-包管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-窗口管理系统</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-资源管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AndroidStudio/"><span class="tag">AndroidStudio</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android%E6%BA%90%E7%A0%81/"><span class="tag">Android源码</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compose/"><span class="tag">Compose</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fragment/"><span class="tag">Fragment</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Jetpack/"><span class="tag">Jetpack</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Koin/"><span class="tag">Koin</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Protobuf/"><span class="tag">Protobuf</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kotlin/"><span class="tag">kotlin</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E7%94%BB/"><span class="tag">动画</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%91%E6%96%87/"><span class="tag">译文</span><span class="tag is-grey-lightest">9</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level-item"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/logo.png" alt="dhl" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="dhl" height="28"></a><p class="size-small"><span>&copy; 2021 dhl</span>  <a href="http://www.beian.miit.gov.cn/" target="_blank">京ICP备18050211号-2</a>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.hi-dhl.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://s9.cnzz.com/z_stat.php?id=1278919895&amp;web_id=1278919895" async></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/imaegoo/universe.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>