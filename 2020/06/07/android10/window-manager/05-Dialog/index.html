<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>0xA05 Android 10 源码分析：Dialog加载绘制流程以及在Kotlin、DataBinding中的使用 - 奔跑吧前中后浪</title><meta description="Dialog 的绘制流程 以及 Dialog 的视图怎么与 Window 做关联了"><meta property="og:type" content="blog"><meta property="og:title" content="0xA05 Android 10 源码分析：Dialog加载绘制流程以及在Kotlin、DataBinding中的使用"><meta property="og:url" content="https://hi-dhl.com/2020/06/07/android10/window-manager/05-Dialog/"><meta property="og:site_name" content="奔跑吧前中后浪"><meta property="og:description" content="Dialog 的绘制流程 以及 Dialog 的视图怎么与 Window 做关联了"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.51git.cn/2020-04-12-DataBindingDialog1.png"><meta property="article:published_time" content="2020-06-06T16:38:15.320Z"><meta property="article:modified_time" content="2020-06-06T17:24:36.991Z"><meta property="article:author" content="Hi Dhl"><meta property="article:tag" content="源码"><meta property="article:tag" content="Android10"><meta property="article:tag" content="Dialog"><meta property="article:tag" content="Window"><meta property="article:tag" content="WindowManager"><meta property="article:tag" content="Android视图管理"><meta property="article:tag" content="窗口管理系统"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://cdn.51git.cn/2020-04-12-DataBindingDialog1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hi-dhl.com/2020/06/07/android10/window-manager/05-Dialog/"},"headline":"奔跑吧前中后浪","image":["http://cdn.51git.cn/2020-04-12-DataBindingDialog1.png"],"datePublished":"2020-06-06T16:38:15.320Z","dateModified":"2020-06-06T17:24:36.991Z","author":{"@type":"Person","name":"Hi Dhl"},"description":"Dialog 的绘制流程 以及 Dialog 的视图怎么与 Window 做关联了"}</script><link rel="canonical" href="https://hi-dhl.com/2020/06/07/android10/window-manager/05-Dialog/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/logo.png" alt="奔跑吧前中后浪" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="奔跑吧前中后浪" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/LeetCode/">LeetCode</a><a class="navbar-item" href="http://site.51git.cn/">国内外书签</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hi-dhl"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="http://cdn.51git.cn/2020-04-12-DataBindingDialog1.png" alt="0xA05 Android 10 源码分析：Dialog加载绘制流程以及在Kotlin、DataBinding中的使用"></span></div><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile"></h1><h1 class="title is-3 is-size-4-mobile">0xA05 Android 10 源码分析：Dialog加载绘制流程以及在Kotlin、DataBinding中的使用</h1><div class="article-meta size-small level is-mobile"><div class="level-left"><span class="mr-2"><i class="fa fa-calendar"></i></span><time class="level-item" dateTime="2020-06-06T16:38:15.320Z" title="2020-06-06T16:38:15.320Z">2020-06-07</time><span class="mr-2"> <i class="fa fa-folder"></i></span><span class="level-item"><a class="link-muted" href="/categories/Android10/">Android10</a></span><span class="mr-2"> <i class="fa fa-tag"></i></span><span class="level-item"><a class="link-muted" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span> , </span><a class="link-muted" href="/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">Android10-窗口管理系统</a></span></div></div><div class="level-left article-meta size-small is-mobile"></div><h1 class="title is-3 is-size-4-mobile"></h1><div class="content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<ul>
<li>这是 Android 10 源码分析系列的第 5 篇</li>
<li>分支：android-10.0.0_r14</li>
<li>全文阅读大概 10 分钟</li>
</ul>
</blockquote>
<p><strong>通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案</strong></p>
<ul>
<li>Dialog的的创建流程？</li>
<li>Dialog的视图怎么与Window做关联了？</li>
<li>自定义CustomDialog的view的是如何绑定的?</li>
<li>如何使用Kotlin具名可选参数构造类，实现构建者模式？</li>
<li>相比于Java的构建者模式，通过具名可选参数构造类具有以下优点?</li>
<li>如何在Dialog中使用DataBinding？</li>
</ul>
<p>阅读本文之前，如果之前没有看过 <strong>Apk加载流程之资源加载一</strong> 和 <strong>Apk加载流程之资源加载二</strong> 点击下方链接前去查看，这几篇文章都是互相关联的</p>
<ul>
<li><a href="https://juejin.im/post/5e6c8c14f265da574b792a1a">0xA03 Android 10 源码分析：Apk加载流程之资源加载（一）</a></li>
<li><a href="https://juejin.im/post/5e7f0f2c51882573c4676bc7">0xA04 Android 10 源码分析：Apk加载流程之资源加载（二）</a></li>
</ul>
<p><strong>本文主要来主要围绕以下几个方面来分析:</strong></p>
<ul>
<li>Dialog加载绘制流程</li>
<li>如何使用Kotlin具名可选参数构造类，实现构建者模式</li>
<li>如何在Dialog中使用DataBinding</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>在开始分析Dialog的源码之前，需要了解一下Dialog加载绘制流程，涉及到的数据结构与职能</p>
<p><strong>在包 android.app 下：</strong></p>
<ul>
<li>Dialog：Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑<ul>
<li>AlertDialog：继承自Dialog，是具体的Dialog的操作实现类</li>
<li>AlertDialog.Builder：是AlertDialog的内部类，主要用于构造AlertDialog</li>
</ul>
</li>
<li>AlertController：是AlertDialog的控制类<ul>
<li>AlertController.AlertParams：是AlertController的内部类，负责AlertDialog的初始化参数</li>
</ul>
</li>
</ul>
<p>了解完相关的数据结构与职能，接下来回顾一下Dialog的创建流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AlertDialog.Builder builder &#x3D; new AlertDialog.Builder(this);</span><br><span class="line">builder.setIcon(R.mipmap.ic_launcher);</span><br><span class="line">builder.setMessage(&quot;Message部分&quot;);</span><br><span class="line">builder.setTitle(&quot;Title部分&quot;);</span><br><span class="line">builder.setView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">builder.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">        alertDialog.dismiss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">        alertDialog.dismiss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alertDialog &#x3D; builder.create();</span><br><span class="line">alertDialog.show();</span><br></pre></td></tr></table></figure>

<p>上面代码都不会很陌生，主要使用了设计模式当中-构建者模式，</p>
<ol>
<li>构建AlertDialog.Builder对象</li>
<li>builder.setXXX 系列方法完成Dialog的初始化</li>
<li>调用builder.create()方法创建AlertDialog</li>
<li>调用AlertDialog的show()完成View的绘制并显示AlertDialog</li>
</ol>
<p>主要通过上面四步完成Dialog的创建和显示，接下来根据源码来分析每个方法的具体实现，以及Dialog的视图怎么与Window做关联</p>
<h3 id="1-构建AlertDialog-Builder对象"><a href="#1-构建AlertDialog-Builder对象" class="headerlink" title="1 构建AlertDialog.Builder对象"></a>1 构建AlertDialog.Builder对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AlertDialog.Builder builder &#x3D; new AlertDialog.Builder(this);</span><br></pre></td></tr></table></figure>

<p>AlertDialog.Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法<br><strong>frameworks/base/core/java/android/app/AlertDialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; AlertController.AlertParams类型的成员变量</span><br><span class="line">private final AlertController.AlertParams P;</span><br><span class="line">public Builder(Context context) &#123;</span><br><span class="line">    this(context, resolveDialogTheme(context, Resources.ID_NULL));</span><br><span class="line">&#125;</span><br><span class="line">public Builder(Context context, int themeResId) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造ContextThemeWrapper，ContextThemeWrapper 是 Context的子类，主要用来处理和主题相关的</span><br><span class="line">    &#x2F;&#x2F; 初始化成为变量 P</span><br><span class="line">    P &#x3D; new AlertController.AlertParams(new ContextThemeWrapper(</span><br><span class="line">            context, resolveDialogTheme(context, themeResId)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ContextThemeWrapper 继承自ContextWrapper，Application、Service继承自ContextWrapper，Activity继承自ContextThemeWrapper</li>
</ul>
<p><img src="http://cdn.51git.cn/2020-04-06-context3.png" alt="context3"></p>
<ul>
<li>P是AlertDialog.Builder中的AlertController.AlertParams类型的成员变量</li>
<li>AlertParams中包含了与AlertDialog视图中对应的成员变量，调用builder.setXXX系列方法之后，我们传递的参数就保存在P中了</li>
</ul>
<h3 id="1-1-AlertParams封装了初始化参数"><a href="#1-1-AlertParams封装了初始化参数" class="headerlink" title="1.1 AlertParams封装了初始化参数"></a>1.1 AlertParams封装了初始化参数</h3><p>AlertController.AlertParams 是AlertController的内部类，负责AlertDialog的初始化参数<br><strong>frameworks/base/core/java/com/android/internal/app/AlertController.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AlertParams(Context context) &#123;</span><br><span class="line">mContext &#x3D; context;</span><br><span class="line">&#x2F;&#x2F; mCancelable 用来控制点击外部是否可取消，默认可以取消</span><br><span class="line">mCancelable &#x3D; true;</span><br><span class="line">&#x2F;&#x2F; LayoutInflater 主要来解析layout.xml文件</span><br><span class="line">mInflater &#x3D; (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量，LayoutInflater 主要来解析layout.xml文件，关于LayoutInflater可以参考之前的文章<a href="https://juejin.im/post/5e7f0f2c51882573c4676bc7">0xA04 Android 10 源码分析：Apk加载流程之资源加载（二）</a></li>
<li>初始化完成AlertParams之后，就完成了AlertDialog.Builder的构建</li>
</ul>
<h3 id="2-调用AlertDialog-Builder的setXXX系列方法"><a href="#2-调用AlertDialog-Builder的setXXX系列方法" class="headerlink" title="2 调用AlertDialog.Builder的setXXX系列方法"></a>2 调用AlertDialog.Builder的setXXX系列方法</h3><p>AlertDialog.Builder初始化完成之后，调用它的builder.setXXX 系列方法完成Dialog的初始化<br><strong>frameworks/base/core/java/android/app/AlertDialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ... 省略了很多builder.setXXX方法</span><br><span class="line">public Builder setTitle(@StringRes int titleId) &#123;</span><br><span class="line">    P.mTitle &#x3D; P.mContext.getText(titleId);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">public Builder setMessage(@StringRes int messageId) &#123;</span><br><span class="line">    P.mMessage &#x3D; P.mContext.getText(messageId);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">public Builder setPositiveButton(@StringRes int textId, final OnClickListener listener) &#123;</span><br><span class="line">    P.mPositiveButtonText &#x3D; P.mContext.getText(textId);</span><br><span class="line">    P.mPositiveButtonListener &#x3D; listener;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123;</span><br><span class="line">    P.mPositiveButtonText &#x3D; text;</span><br><span class="line">    P.mPositiveButtonListener &#x3D; listener;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ... 省略了很多builder.setXXX方法</span><br></pre></td></tr></table></figure>

<p>上面所有setXXX方法都是给Builder的成员变量P赋值，并且他们的返回值都是Builder类型，因此可以通过消息琏的方式调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">builder.setTitle().setMessage().setPositiveButton()...</span><br></pre></td></tr></table></figure>

<p>PS: 在Kotlin应该尽量避免使用构建者模式，使用Kotlin中的具名可选参数，实现构建者模式，代码更加简洁，为了不影响阅读的流畅性，将这部分内容放到了文末<strong>扩展阅读</strong>部分</p>
<h3 id="3-builder-create方法"><a href="#3-builder-create方法" class="headerlink" title="3 builder.create方法"></a>3 builder.create方法</h3><p>builder.setXXX 系列方法之后调用builder.create方法完成AlertDialog构建，接下来看一下create方法<br><strong>frameworks/base/core/java/android/app/AlertDialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AlertDialog create() &#123;</span><br><span class="line">    &#x2F;&#x2F; P.mContext 是ContextWrappedTheme 的实例</span><br><span class="line">    final AlertDialog dialog &#x3D; new AlertDialog(P.mContext, 0, false);</span><br><span class="line">    &#x2F;&#x2F; Dialog的参数其实保存在P这个类里面</span><br><span class="line">    &#x2F;&#x2F; mAler是AlertController的实例，通过这个方法把P中的变量传给AlertController.AlertParams</span><br><span class="line">    P.apply(dialog.mAlert);</span><br><span class="line">    &#x2F;&#x2F; 用来控制点击外部是否可取消,mCancelable 默认为true</span><br><span class="line">    dialog.setCancelable(P.mCancelable);</span><br><span class="line">    &#x2F;&#x2F; 如果可以取消设置回调监听</span><br><span class="line">    if (P.mCancelable) &#123;</span><br><span class="line">        dialog.setCanceledOnTouchOutside(true);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置一系列监听</span><br><span class="line">    dialog.setOnCancelListener(P.mOnCancelListener);</span><br><span class="line">    dialog.setOnDismissListener(P.mOnDismissListener);</span><br><span class="line">    if (P.mOnKeyListener !&#x3D; null) &#123;</span><br><span class="line">        dialog.setOnKeyListener(P.mOnKeyListener);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回 AlertDialog 对象</span><br><span class="line">    return dialog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据P.mContex 构建了一个AlertDialog</li>
<li>mAler是AlertController的实例，调用apply方法把P中的变量传给AlertController.AlertParams</li>
<li>设置是否可以点击外部取消，默认可以取消，同时设置回调监听</li>
<li>最后返回AlertDialog对象</li>
</ul>
<h4 id="3-1-如何构建AlertDialog"><a href="#3-1-如何构建AlertDialog" class="headerlink" title="3.1 如何构建AlertDialog"></a>3.1 如何构建AlertDialog</h4><p>我们来分析一下AlertDialog是如何构建的，来看一下它的造方法具体实现<br><strong>frameworks/base/core/java/android/app/AlertDialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123;</span><br><span class="line">    super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0,</span><br><span class="line">            createContextThemeWrapper);</span><br><span class="line"></span><br><span class="line">    mWindow.alwaysReadCloseOnTouchAttr();</span><br><span class="line">    &#x2F;&#x2F; getContext() 返回的是ContextWrapperTheme</span><br><span class="line">    &#x2F;&#x2F; getWindow() 返回的是 PhoneWindow</span><br><span class="line">    &#x2F;&#x2F; mAlert 是AlertController的实例</span><br><span class="line">    mAlert &#x3D; AlertController.create(getContext(), this, getWindow());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PhoneWindows是什么时候创建的？AlertDialog继承自Dialog，首先调用了super的构造方法，来看一下Dialog的构造方法<br><strong>frameworks/base/core/java/android/app/Dialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取WindowManager对象</span><br><span class="line">    mWindowManager &#x3D; (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    &#x2F;&#x2F; 构建PhoneWindow</span><br><span class="line">    final Window w &#x3D; new PhoneWindow(mContext);</span><br><span class="line">    &#x2F;&#x2F; mWindow 是PhoneWindow实例</span><br><span class="line">    mWindow &#x3D; w;</span><br><span class="line">    w.setCallback(this);</span><br><span class="line">    w.setOnWindowDismissedCallback(this);</span><br><span class="line">    w.setOnWindowSwipeDismissedCallback(() -&gt; &#123;</span><br><span class="line">        if (mCancelable) &#123;</span><br><span class="line">            cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    w.setWindowManager(mWindowManager, null, null);</span><br><span class="line">    w.setGravity(Gravity.CENTER);</span><br><span class="line">    &#x2F;&#x2F; 继承 Handler</span><br><span class="line">    mListenersHandler &#x3D; new ListenersHandler(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取WindowManager对象，构建了PhoneWindow，到这里我们知道了PhoneWindow是在Dialog构造方法创建的</li>
<li>初始化了Dialog的成员变量mWindow，mWindow 是PhoneWindow的实例</li>
<li>初始化了Dialog的成员变量mListenersHandler，mListenersHandler继承Handler</li>
</ul>
<p>我们回到AlertDialog构造方法，在AlertDialog构造方法内，调用了 AlertController.create方法，来看一下这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final AlertController create(Context context, DialogInterface di, Window window) &#123;</span><br><span class="line">    final TypedArray a &#x3D; context.obtainStyledAttributes(</span><br><span class="line">            null, R.styleable.AlertDialog, R.attr.alertDialogStyle,</span><br><span class="line">            R.style.Theme_DeviceDefault_Settings);</span><br><span class="line">    int controllerType &#x3D; a.getInt(R.styleable.AlertDialog_controllerType, 0);</span><br><span class="line">    a.recycle();</span><br><span class="line">    &#x2F;&#x2F; 根据controllerType 使用不同的AlertController</span><br><span class="line">    switch (controllerType) &#123;</span><br><span class="line">        case MICRO:</span><br><span class="line">            &#x2F;&#x2F; MicroAlertController 是matrix风格 继承自AlertController</span><br><span class="line">            return new MicroAlertController(context, di, window);</span><br><span class="line">        default:</span><br><span class="line">            return new AlertController(context, di, window);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据controllerType 返回不同的AlertController，到这里分析完了AlertDialog是如何构建的</p>
<h3 id="4-调用Dialog的show方法显示Dialog"><a href="#4-调用Dialog的show方法显示Dialog" class="headerlink" title="4 调用Dialog的show方法显示Dialog"></a>4 调用Dialog的show方法显示Dialog</h3><p>调用AlertDialog.Builder的create方法之后返回了AlertDialog的实例，最后调用了AlertDialog的show方法显示dialog，但是AlertDialog是继承自Dialog的，实际上调用的是Dialog的show方法<br><strong>frameworks/base/core/java/android/app/Dialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void show() &#123;</span><br><span class="line">    &#x2F;&#x2F; mShowing变量用于表示当前dialog是否正在显示</span><br><span class="line">    if (mShowing) &#123;</span><br><span class="line">        if (mDecor !&#x3D; null) &#123;</span><br><span class="line">            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mCanceled &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; mCreated这个变量控制dispatchOnCreate方法只被执行一次</span><br><span class="line">    if (!mCreated) &#123;</span><br><span class="line">        dispatchOnCreate(null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Fill the DecorView in on any configuration changes that</span><br><span class="line">        &#x2F;&#x2F; may have occured while it was removed from the WindowManager.</span><br><span class="line">        final Configuration config &#x3D; mContext.getResources().getConfiguration();</span><br><span class="line">        mWindow.getDecorView().dispatchConfigurationChanged(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于设置ActionBar</span><br><span class="line">    onStart();</span><br><span class="line">    &#x2F;&#x2F; 获取DecorView</span><br><span class="line">    mDecor &#x3D; mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">    if (mActionBar &#x3D;&#x3D; null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">        final ApplicationInfo info &#x3D; mContext.getApplicationInfo();</span><br><span class="line">        mWindow.setDefaultIcon(info.icon);</span><br><span class="line">        mWindow.setDefaultLogo(info.logo);</span><br><span class="line">        mActionBar &#x3D; new WindowDecorActionBar(this);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取布局参数</span><br><span class="line">    WindowManager.LayoutParams l &#x3D; mWindow.getAttributes();</span><br><span class="line">    boolean restoreSoftInputMode &#x3D; false;</span><br><span class="line">    if ((l.softInputMode</span><br><span class="line">            &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        l.softInputMode |&#x3D;</span><br><span class="line">                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">        restoreSoftInputMode &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将DecorView和布局参数添加到WindowManager中，完成view的绘制</span><br><span class="line">    mWindowManager.addView(mDecor, l);</span><br><span class="line">    if (restoreSoftInputMode) &#123;</span><br><span class="line">        l.softInputMode &amp;&#x3D;</span><br><span class="line">                ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mShowing &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F; 向Handler发送一个Dialog的消息，从而显示AlertDialog</span><br><span class="line">    sendShowMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断dialog是否已经显示，如果显示了直接返回</li>
<li>判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法</li>
<li>获取布局参数添加到WindowManager，调用addView方法完成view的绘制</li>
<li>向Handler发送一个Dialog的消息，从而显示AlertDialog</li>
</ul>
<h4 id="4-1-dispatchOnCreate"><a href="#4-1-dispatchOnCreate" class="headerlink" title="4.1 dispatchOnCreate"></a>4.1 dispatchOnCreate</h4><p>在上面代码中，根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法<br><strong>frameworks/base/core/java/android/app/Dialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dispatchOnCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    if (!mCreated) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用 onCreate 方法</span><br><span class="line">        onCreate(savedInstanceState);</span><br><span class="line">        mCreated &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dispatchOnCreate方法中主要调用Dialog的onCreate方法, Dialog的onCreate方法是个空方法，由于我们创建的是AlertDialog对象，AlertDialog继承于Dialog，所以调用的是AlertDialog的onCreate方法<br><strong>frameworks/base/core/java/android/app/AlertDialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    mAlert.installContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这方法里面调用了AlertController的installContent方法，来看一下具体的实现逻辑<br><strong>frameworks/base/core/java/com/android/internal/app/AlertController.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void installContent() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取相应的Dialog布局文件</span><br><span class="line">    int contentView &#x3D; selectContentView();</span><br><span class="line">    &#x2F;&#x2F; 调用setContentView方法解析布局文件</span><br><span class="line">    mWindow.setContentView(contentView);</span><br><span class="line">    &#x2F;&#x2F; 初始化布局文件中的组件</span><br><span class="line">    setupView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用selectContentView方法获取布局文件，来看一下具体的实现</li>
<li><em>frameworks/base/core/java/com/android/internal/app/AlertController.java*</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int selectContentView() &#123;</span><br><span class="line">    if (mButtonPanelSideLayout &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return mAlertDialogLayout;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mButtonPanelLayoutHint &#x3D;&#x3D; AlertDialog.LAYOUT_HINT_SIDE) &#123;</span><br><span class="line">        return mButtonPanelSideLayout;</span><br><span class="line">    &#125;</span><br><span class="line">    return mAlertDialogLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的布局是mAlertDialogLayout，布局文件是在AlertController的构造方法初始化的<br><strong>frameworks/base/core/java/com/android/internal/app/AlertController.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mAlertDialogLayout &#x3D; a.getResourceId(</span><br><span class="line">                R.styleable.AlertDialog_layout, R.layout.alert_dialog);</span><br></pre></td></tr></table></figure>

<ul>
<li>调用Window.setContentView方法解析布局文件，Activity的setContentView最后也是调用了Window.setContentView这个方法，具体的解析流程，可以参考之前的文章Activity布局加载流程 <a href="https://juejin.im/post/5e6c8c14f265da574b792a1a">0xA03 Android 10 源码分析：Apk加载流程之资源加载</a></li>
<li>调用setupView方法初始化布局文件中的组件, 到这里dispatchOnCreate方法分析结束</li>
</ul>
<h4 id="4-2-调用mWindowManager-addView完成View的绘制"><a href="#4-2-调用mWindowManager-addView完成View的绘制" class="headerlink" title="4.2 调用mWindowManager.addView完成View的绘制"></a>4.2 调用mWindowManager.addView完成View的绘制</h4><p>回到我们的Dialog的show方法，在执行了dispatchOnCreate方法之后，又调用了onStart方法，这个方法主要用于设置ActionBar，然后初始化WindowManager.LayoutParams对象，最后调用mWindowManager.addView()方法完成界面的绘制，绘制完成之后调用sendShowMessage方法<br><strong>frameworks/base/core/java/android/app/Dialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void sendShowMessage() &#123;</span><br><span class="line">    if (mShowMessage !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Obtain a new message so this dialog can be re-used</span><br><span class="line">        Message.obtain(mShowMessage).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向Handler发送一个Dialog的消息，从而显示AlertDialog，该消息最终会在ListenersHandler中的handleMessage方法中被执行，ListenersHandler是Dialog的内部类，继承Handler<br><strong>frameworks/base/core/java/android/app/Dialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case DISMISS:</span><br><span class="line">            ((OnDismissListener) msg.obj).onDismiss(mDialog.get());</span><br><span class="line">            break;</span><br><span class="line">        case CANCEL:</span><br><span class="line">            ((OnCancelListener) msg.obj).onCancel(mDialog.get());</span><br><span class="line">            break;</span><br><span class="line">        case SHOW:</span><br><span class="line">            ((OnShowListener) msg.obj).onShow(mDialog.get());</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果msg.what = SHOW，会执行OnShowListener.onShow方法，msg.what的值和OnShowListener调用setOnShowListener方法赋值的<br><strong>frameworks/base/core/java/android/app/Dialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setOnShowListener(@Nullable OnShowListener listener) &#123;</span><br><span class="line">    if (listener !&#x3D; null) &#123;</span><br><span class="line">        mShowMessage &#x3D; mListenersHandler.obtainMessage(SHOW, listener);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mShowMessage &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mListenersHandler构造了Message对象，当我们在Dialog中发送showMessage的时候，被mListenersHandler所接收</p>
<h4 id="4-3-自定义Dialog的view的是如何绑定的"><a href="#4-3-自定义Dialog的view的是如何绑定的" class="headerlink" title="4.3 自定义Dialog的view的是如何绑定的"></a>4.3 自定义Dialog的view的是如何绑定的</h4><p>在上文分析中根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法，在dispatchOnCreate方法中主要调用Dialog的onCreate方法，由于创建的是AlertDialog对象，AlertDialog继承于Dialog，所以实际调用的是AlertDialog的onCreate方法，来完成布局文件的解析，和布局文件中控件的初始化<br/></p>
<p>同理我们自定义CustomDialog继承自Dialog，所以调用的是自定义CustomDialog的onCreate方法，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomDialog extends Dialog &#123;</span><br><span class="line">    Context mContext;</span><br><span class="line">    &#x2F;&#x2F; ... 省略构造方法</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        LayoutInflater inflater &#x3D; (LayoutInflater) mContext</span><br><span class="line">                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        View view &#x3D; inflater.inflate(R.layout.custom_dialog, null);</span><br><span class="line">        setContentView(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onCreate方法中调用了 Dialog的setContentView 方法, 来分析setContentView方法<br><strong>frameworks/base/core/java/android/app/Dialog.java</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setContentView(@NonNull View view) &#123;</span><br><span class="line">    mWindow.setContentView(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mWindow是PhoneWindow的实例，最后调用的是PhoneWindow的setContentView解析布局文件，Activity的setContentView最后也是调用了PhoneWindow的setContentView方法，具体的解析流程，可以参考之前的文章Activity布局加载流程 <a href="https://juejin.im/post/5e6c8c14f265da574b792a1a">0xA03 Android 10 源码分析：Apk加载流程之资源加载</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑<br/></p>
<p><strong>Dialog的的创建流程？</strong></p>
<ol>
<li>构建AlertDialog.Builder对象</li>
<li>builder.setXXX 系列方法完成Dialog的初始化</li>
<li>调用builder.create()方法创建AlertDialog</li>
<li>调用AlertDialog的show()初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，最终将Dialog显示出来</li>
</ol>
<p><strong>Dialog的视图怎么与Window做关联了？</strong></p>
<ul>
<li>在Dialog的构造方法中初始化了Window对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 获取WindowManager对象</span><br><span class="line">    mWindowManager &#x3D; (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    &#x2F;&#x2F; 构建PhoneWindow</span><br><span class="line">    final Window w &#x3D; new PhoneWindow(mContext);</span><br><span class="line">    &#x2F;&#x2F; mWindow 是PhoneWindow实例</span><br><span class="line">    mWindow &#x3D; w;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用Dialog的show方法，完成view的绘制和Dialog的显示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void show() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取DecorView</span><br><span class="line">    mDecor &#x3D; mWindow.getDecorView();</span><br><span class="line">    &#x2F;&#x2F; 获取布局参数</span><br><span class="line">    WindowManager.LayoutParams l &#x3D; mWindow.getAttributes();</span><br><span class="line">    &#x2F;&#x2F; 将DecorView和布局参数添加到WindowManager中</span><br><span class="line">    mWindowManager.addView(mDecor, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会通过WindowManager将DecorView添加到Window之中，用WIndow对象实现界面的加载与显示逻辑</p>
<p><strong>自定义CustomDialog的view的是如何绑定的?</strong></p>
<ul>
<li>调用Dialog的show方法，在该方法内部会根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法，在dispatchOnCreate方法中主要调用Dialog的onCreate方法</li>
<li>自定义CustomDialog继承自Dialog，所以调用的是自定义CustomDialog的onCreate方法，在CustomDialog的onCreate方法中调用setContentView方法，最后调用的是PhoneWindow的setContentView解析布局文件，解析流程参考<a href="https://juejin.im/post/5e6c8c14f265da574b792a1a">0xA03 Android 10 源码分析：Apk加载流程之资源加载</a></li>
</ul>
<p><strong>如何使用Kotlin具名可选参数构造类，实现构建者模式？</strong></p>
<p>这部分内容参考<strong>扩展阅读</strong>部分</p>
<p><strong>相比于Java的构建者模式，通过具名可选参数构造类具有以下优点?</strong></p>
<ul>
<li>代码非常的简洁</li>
<li>每个参数名都可以显示的，声明对象时无须按照顺序书写，非常的灵活</li>
<li>构造函数中每个参数都是val声明的，在多线程并发业务场景中更加的安全</li>
<li>Kotlin的require方法，让我们在参数约束上更加的友好</li>
</ul>
<p><strong>如何在Dialog中使用DataBinding？</strong></p>
<p>这部分内容参考<strong>扩展阅读</strong>部分</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="1-Kotlin实现构建者模式"><a href="#1-Kotlin实现构建者模式" class="headerlink" title="1. Kotlin实现构建者模式"></a>1. Kotlin实现构建者模式</h3><p>刚才在上文中提到了，在Kotlin中应该尽量避免使用构建者模式，使用Kotlin的具名可选参数构造类，实现构建者模式，代码更加简洁<br/></p>
<blockquote>
<p>在 “Effective Java” 书中介绍构建者模式时，是这样子描述它的：本质上builder模式模拟了具名的可算参数，就像Ada和Python中的一样</p>
</blockquote>
<p>关于Java用构建者模式实现自定义dialog，可以参考这边文章 <a href="http://codethataint.com/blog/builder-pattern/">Builder Pattern in Java</a>，代码显得很长……..幸运的是，Kotlin是一门拥有具名可选参数的变成语言，Kotlin中的函数和构造器都支持这一特性，接下里我们使用具名可选参数构造类，实现构建者模式，点击<a href="https://github.com/hi-dhl/JDataBinding">JDataBinding</a>前往查看，核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AppDialog(</span><br><span class="line">    context: Context,</span><br><span class="line">    val title: String? &#x3D; null,</span><br><span class="line">    val message: String? &#x3D; null,</span><br><span class="line">    val yes: AppDialog.() -&gt; Unit</span><br><span class="line">) : DataBindingDialog(context, R.style.AppDialog) &#123;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        requireNotNull(message) &#123; &quot;message must be not null&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE)</span><br><span class="line"></span><br><span class="line">        setContentView(root)</span><br><span class="line">        display.text &#x3D; message</span><br><span class="line">        btnNo.setOnClickListener &#123; dismiss() &#125;</span><br><span class="line">        btnYes.setOnClickListener &#123; yes() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式也更加的简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppDialog(</span><br><span class="line">        context &#x3D; this@MainActivity,</span><br><span class="line">        message &#x3D; msg,</span><br><span class="line">        yes &#x3D; &#123;</span><br><span class="line">            &#x2F;&#x2F; do something</span><br><span class="line">        &#125;).show()</span><br></pre></td></tr></table></figure>

<p><strong>相比于Java的构建者模式，通过具名可选参数构造类具有以下优点:</strong></p>
<ul>
<li>代码非常的简洁</li>
<li>每个参数名都可以显示的，声明对象时无须按照顺序书写，非常的灵活</li>
<li>构造函数中每个参数都是val声明的，在多线程并发业务场景中更加的安全</li>
<li>Kotlin的require方法，让我们在参数约束上更加的友好</li>
</ul>
<h3 id="2-如何在Dialog中使用DataBinding"><a href="#2-如何在Dialog中使用DataBinding" class="headerlink" title="2. 如何在Dialog中使用DataBinding"></a>2. 如何在Dialog中使用DataBinding</h3><p>DataBinding是什么？查看<a href="https://developer.android.com/topic/libraries/data-binding">Google官网</a>，会有更详细的介绍<br/></p>
<blockquote>
<p>DataBinding 是 Google 在 Jetpack 中推出的一款数据绑定的支持库，利用该库可以实现在页面组件中直接绑定应用程序的数据源</p>
</blockquote>
<p>在使用Kotlin的具名可选参数构造类实现Dailog构建者模式的基础上，用DataBinding进行二次封装，加上DataBinding数据绑定的特性，使Dialog变得更加简洁、易用<br/></p>
<p><strong>Step1: 定义一个基类DataBindingDialog</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class DataBindingDialog(@NonNull context: Context, @StyleRes themeResId: Int) :</span><br><span class="line">    Dialog(context, themeResId) &#123;</span><br><span class="line"></span><br><span class="line">    protected inline fun &lt;reified T : ViewDataBinding&gt; binding(@LayoutRes resId: Int): Lazy&lt;T&gt; &#x3D;</span><br><span class="line">        lazy &#123;</span><br><span class="line">            requireNotNull(</span><br><span class="line">                DataBindingUtil.bind&lt;T&gt;(LayoutInflater.from(context).inflate(resId, null))</span><br><span class="line">            ) &#123; &quot;cannot find the matched view to layout.&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step2:  改造AppDialog</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AppDialog(</span><br><span class="line">    context: Context,</span><br><span class="line">    val title: String? &#x3D; null,</span><br><span class="line">    val message: String? &#x3D; null,</span><br><span class="line">    val yes: AppDialog.() -&gt; Unit</span><br><span class="line">) : DataBindingDialog(context, R.style.AppDialog) &#123;</span><br><span class="line">    private val mBinding: DialogAppBinding by binding(R.layout.dialog_app)</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        requireNotNull(message) &#123; &quot;message must be not null&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE)</span><br><span class="line"></span><br><span class="line">        mBinding.apply &#123;</span><br><span class="line">            setContentView(root)</span><br><span class="line">            display.text &#x3D; message</span><br><span class="line">            btnNo.setOnClickListener &#123; dismiss() &#125;</span><br><span class="line">            btnYes.setOnClickListener &#123; yes() &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理DataBinding在Activity、Fragment、Adapter中的使用也是一样的，利用Kotlin的inline、reified、DSL等等语法，可以设计出更加简洁并利于维护的代码<br/></p>
<p>关于基于DataBinding封装的DataBindingActivity、DataBindingFragment、DataBindingDialog基础库相关代码，后续也会陆续完善基础库，点击<a href="https://github.com/hi-dhl/JDataBinding">JDataBinding</a>前往查看，欢迎start<br/></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack  源码相关的文章，如果你同我一样喜欢研究 Android 源码，可以关注我，如果你喜欢这篇文章欢迎 star，一起来学习，期待与你一起成长</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序</p>
<ul>
<li>数据结构： 数组、栈、队列、字符串、链表、树……</li>
<li>算法： 查找算法、搜索算法、位运算、排序、数学、……</li>
</ul>
<p>每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：<a href="https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin">Leetcode-Solutions-with-Java-And-Kotlin</a>，一起来学习，期待与你一起成长</p>
<h3 id="Android-10-源码系列"><a href="#Android-10-源码系列" class="headerlink" title="Android 10 源码系列"></a>Android 10 源码系列</h3><p>正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Android10-Source-Analysis">Android10-Source-Analysis</a>，文章都会同步到这个仓库</p>
</div><h1 class="title is-4 is-size-4-mobile"></h1><h1 class="title is-4 is-size-4-mobile"></h1><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><h1 class="title is-4 is-size-4-mobile"></h1></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/06/07/android10/window-manager/06-Window-WindowManager/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/07/android10/resource-manager/04-APK-resource2/"><span class="level-item">0xA04 Android 10 源码分析：Apk加载流程之资源加载（二）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: undefined,
            appId: 'zfvr24HFhzQ5vtHkr4NQ1fmW-gzGzoHsz',
            appKey: 'RChgr9mR005hgu4yiQ4WQU3O',
            placeholder: '说点什么',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" style="max-height: 500px;overflow: auto;"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#引言"><span>引言</span></a></li><li><a class="is-flex" href="#源码分析"><span>源码分析</span></a><ul class="menu-list"><li><a class="is-flex" href="#1-构建AlertDialog-Builder对象"><span>1 构建AlertDialog.Builder对象</span></a></li><li><a class="is-flex" href="#1-1-AlertParams封装了初始化参数"><span>1.1 AlertParams封装了初始化参数</span></a></li><li><a class="is-flex" href="#2-调用AlertDialog-Builder的setXXX系列方法"><span>2 调用AlertDialog.Builder的setXXX系列方法</span></a></li><li><a class="is-flex" href="#3-builder-create方法"><span>3 builder.create方法</span></a><ul class="menu-list"><li><a class="is-flex" href="#3-1-如何构建AlertDialog"><span>3.1 如何构建AlertDialog</span></a></li></ul></li><li><a class="is-flex" href="#4-调用Dialog的show方法显示Dialog"><span>4 调用Dialog的show方法显示Dialog</span></a><ul class="menu-list"><li><a class="is-flex" href="#4-1-dispatchOnCreate"><span>4.1 dispatchOnCreate</span></a></li><li><a class="is-flex" href="#4-2-调用mWindowManager-addView完成View的绘制"><span>4.2 调用mWindowManager.addView完成View的绘制</span></a></li><li><a class="is-flex" href="#4-3-自定义Dialog的view的是如何绑定的"><span>4.3 自定义Dialog的view的是如何绑定的</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#总结"><span>总结</span></a></li><li><a class="is-flex" href="#扩展阅读"><span>扩展阅读</span></a><ul class="menu-list"><li><a class="is-flex" href="#1-Kotlin实现构建者模式"><span>1. Kotlin实现构建者模式</span></a></li><li><a class="is-flex" href="#2-如何在Dialog中使用DataBinding"><span>2. 如何在Dialog中使用DataBinding</span></a></li></ul></li><li><a class="is-flex" href="#结语"><span>结语</span></a><ul class="menu-list"><li><a class="is-flex" href="#算法"><span>算法</span></a></li><li><a class="is-flex" href="#Android-10-源码系列"><span>Android 10 源码系列</span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-06T16:45:50.638Z">2020-06-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/07/android10/window-manager/07-WindowManagerService/">0xA07 Android 10 源码分析：Window 的类型 以及 三维视图层级分析</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-06T16:43:56.280Z">2020-06-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/07/android10/window-manager/06-Window-WindowManager/">0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-06T16:38:15.320Z">2020-06-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/07/android10/window-manager/05-Dialog/">0xA05 Android 10 源码分析：Dialog加载绘制流程以及在Kotlin、DataBinding中的使用</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-06T16:34:23.363Z">2020-06-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/07/android10/resource-manager/04-APK-resource2/">0xA04 Android 10 源码分析：Apk加载流程之资源加载（二）</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-06T16:26:40.660Z">2020-06-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/07/android10/resource-manager/03-APK-resource/">0xA03 Android 10 源码分析：APK 加载流程之资源加载</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android10/"><span class="level-start"><span class="level-item">Android10</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AndroidStudio/"><span class="level-start"><span class="level-item">AndroidStudio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%80%86%E5%90%91/"><span class="level-start"><span class="level-item">逆向</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-包管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-窗口管理系统</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-资源管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AndroidStudio/"><span class="tag">AndroidStudio</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android%E6%BA%90%E7%A0%81/"><span class="tag">Android源码</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DeviceMonitor/"><span class="tag">DeviceMonitor</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apktool/"><span class="tag">apktool</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/smali-android-studio/"><span class="tag">smali-android-studio</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/smalidea/"><span class="tag">smalidea</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><span class="tag">二分查找</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%91%E6%8C%87offer/"><span class="tag">剑指offer</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E7%BB%84/"><span class="tag">数组</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">6</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level-item"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/logo.png" alt="奔跑吧前中后浪" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="奔跑吧前中后浪" height="28"></a><p class="size-small"><span>&copy; 2020 Hi Dhl</span>  <a href="http://www.beian.miit.gov.cn/" target="_blank">京ICP备18050211号-2</a>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://hi-dhl.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://s9.cnzz.com/z_stat.php?id=1278919895&amp;web_id=1278919895" async></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/imaegoo/universe.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>