<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>为数不多的人知道的 Kotlin 技巧以及 原理解析（一） - dhl</title><meta description="结合着 Kotlin 的高级函数的特性可以让代码可读性更强，更加简洁，但是简洁的背后是有代价的，使用不当对性能可能会有损耗，这块往往很容易被我们忽略，这就需要我们去研究 kotlin 语法糖背后的魔法"><meta property="og:type" content="blog"><meta property="og:title" content="为数不多的人知道的 Kotlin 技巧以及 原理解析（一）"><meta property="og:url" content="https://www.hi-dhl.com/2020/08/22/kotlin/01-kotlin/"><meta property="og:site_name" content="dhl"><meta property="og:description" content="结合着 Kotlin 的高级函数的特性可以让代码可读性更强，更加简洁，但是简洁的背后是有代价的，使用不当对性能可能会有损耗，这块往往很容易被我们忽略，这就需要我们去研究 kotlin 语法糖背后的魔法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.51git.cn/2020-10-22-kotlin-tip1.png"><meta property="article:published_time" content="2020-08-22T11:04:21.284Z"><meta property="article:modified_time" content="2020-10-21T16:49:15.502Z"><meta property="article:author" content="dhl"><meta property="article:tag" content="Android10"><meta property="article:tag" content="AndroidStudio"><meta property="article:tag" content="buildSrc"><meta property="article:tag" content="kotlin"><meta property="article:tag" content="run"><meta property="article:tag" content="with"><meta property="article:tag" content="let"><meta property="article:tag" content="also"><meta property="article:tag" content="apply"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://cdn.51git.cn/2020-10-22-kotlin-tip1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hi-dhl.com/2020/08/22/kotlin/01-kotlin/"},"headline":"dhl","image":["http://cdn.51git.cn/2020-10-22-kotlin-tip1.png"],"datePublished":"2020-08-22T11:04:21.284Z","dateModified":"2020-10-21T16:49:15.502Z","author":{"@type":"Person","name":"dhl"},"description":"结合着 Kotlin 的高级函数的特性可以让代码可读性更强，更加简洁，但是简洁的背后是有代价的，使用不当对性能可能会有损耗，这块往往很容易被我们忽略，这就需要我们去研究 kotlin 语法糖背后的魔法"}</script><link rel="canonical" href="https://www.hi-dhl.com/2020/08/22/kotlin/01-kotlin/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/logo.png" alt="dhl" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="dhl" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/categories/Jetpack">Jetpack</a><a class="navbar-item" href="/categories/Kotlin/">Kotlin</a><a class="navbar-item" href="/categories/Android10/">系统源码</a><a class="navbar-item" href="/categories/translated/">译文</a><a class="navbar-item" href="https://offer.hi-dhl.com">算法</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hi-dhl"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="http://cdn.51git.cn/2020-10-22-kotlin-tip1.png" alt="为数不多的人知道的 Kotlin 技巧以及 原理解析（一）"></span></div><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile"></h1><h1 class="title is-3 is-size-4-mobile">为数不多的人知道的 Kotlin 技巧以及 原理解析（一）</h1><div class="article-meta size-small level is-mobile"><div class="level-left"><span class="mr-2"><i class="fa fa-calendar"></i></span><time class="level-item" dateTime="2020-08-22T11:04:21.284Z" title="2020-08-22T11:04:21.284Z">2020-08-22</time><span class="mr-2"> <i class="fa fa-folder"></i></span><span class="level-item"><a class="link-muted" href="/categories/Kotlin/">Kotlin</a></span><span class="mr-2"> <i class="fa fa-tag"></i></span><span class="level-item"><a class="link-muted" href="/tags/Kotlin/">Kotlin</a></span></div></div><div class="level-left article-meta size-small is-mobile"></div><div><p style="height:15px"></p><ul class="page-blockquote"><li>如果评论区没有及时回复，欢迎来公众号：ByteCode 咨询</li><li>公众号：ByteCode。致力于分享最新技术原创文章，涉及 Kotlin、Jetpack、算法、译文、系统源码相关的文章</li><li></li></ul><p style="height:15px"></p></div><div class="content"><p>Google 引入 Kotlin 的目的就是为了让 Android 开发更加方便，自从官宣 Kotlin 成为了 Android 开发的首选语言之后，已经有越来越多的人开始使用 Kotlin。</p>
<p>结合着 Kotlin 的高级函数的特性可以让代码可读性更强，更加简洁，但是简洁的背后是有代价的，使用不当对性能可能会有损耗，这块往往很容易被我们忽略，这就需要我们去研究 kotlin 语法糖背后的魔法，当我们在开发的时候，选择合适的语法糖，尽量避免这些错误，关于 Kotlin 性能损失那些事，可以看一下我另外两篇文章。</p>
<ul>
<li><a href="https://juejin.im/post/5ebc1eb8e51d454dcf45744e?utm_source=gold_browser_extension">[译][2.4K Start] 放弃 Dagger 拥抱 Koin</a></li>
<li><a href="https://juejin.im/post/5ec0f3afe51d454db11f8a94#heading-7">[译][5k+] Kotlin 的性能优化那些事</a></li>
</ul>
<p>这两篇文章都分析了 Kotlin 使用不当对性能的影响，不仅如此 Kotlin 当中还有很多让人傻傻分不清楚的语法糖例如 run, with, let, also, apply 等等，这篇文章将介绍一种简单的方法来区分它们以及如何选择使用。</p>
<p><strong>通过这篇文章你将学习到以下内容，文中会给出相应的答案</strong></p>
<ul>
<li>如何使用 plus 操作符对集合进行操作？</li>
<li>当获取 Map 值为空时，如何设置默认值？</li>
<li>require 或者 check 函数做什么用的？</li>
<li>如何区分 run, with, let, also and apply 以及如何使用？</li>
<li>如何巧妙的使用 in 和 when 关键字？</li>
<li>Kotlin 的单例有那种三种写法?</li>
<li>为什么 by lazy 声明的变量只能用 val？</li>
</ul>
<h2 id="plus-操作符"><a href="#plus-操作符" class="headerlink" title="plus 操作符"></a>plus 操作符</h2><p>在 Java 中算术运算符只能用于基本数据类型，+ 运算符可以与 String 值一起使用，但是不能在集合中使用，在 Kotlin 中可以应用在任何类型，我们来看一个例子，利用 plus (+) 和 minus (-) 对 Map 集合做运算，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    val numbersMap &#x3D; mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; plus (+)</span><br><span class="line">    println(numbersMap + Pair(&quot;four&quot;, 4)) &#x2F;&#x2F; &#123;one&#x3D;1, two&#x3D;2, three&#x3D;3, four&#x3D;4&#125;</span><br><span class="line">    println(numbersMap + Pair(&quot;one&quot;, 10)) &#x2F;&#x2F; &#123;one&#x3D;10, two&#x3D;2, three&#x3D;3&#125;</span><br><span class="line">    println(numbersMap + Pair(&quot;five&quot;, 5) + Pair(&quot;one&quot;, 11)) &#x2F;&#x2F; &#123;one&#x3D;11, two&#x3D;2, three&#x3D;3, five&#x3D;5&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; minus (-)</span><br><span class="line">    println(numbersMap - &quot;one&quot;) &#x2F;&#x2F; &#123;two&#x3D;2, three&#x3D;3&#125;</span><br><span class="line">    println(numbersMap - listOf(&quot;two&quot;, &quot;four&quot;)) &#x2F;&#x2F; &#123;one&#x3D;1, three&#x3D;3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里用到了运算符重载，Kotlin 在 Maps.kt 文件里面，定义了一系列用关键字 operator 声明的 Map 的扩展函数。</p>
<p>用 operator 关键字声明 plus 函数，可以直接使用 + 号来做运算，使用 operator 修饰符声明 minus 函数，可以直接使用 - 号来做运算，其实我们也可以在自定义类里面实现 plus (+) 和 minus (-) 做运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">data class Salary(var base: Int &#x3D; 100)&#123;</span><br><span class="line">    override fun toString(): String &#x3D; base.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operator fun Salary.plus(other: Salary): Salary &#x3D; Salary(base + other.base)</span><br><span class="line">operator fun Salary.minus(other: Salary): Salary &#x3D; Salary(base - other.base)</span><br><span class="line"></span><br><span class="line">val s1 &#x3D; Salary(10)</span><br><span class="line">val s2 &#x3D; Salary(20)</span><br><span class="line">println(s1 + s2) &#x2F;&#x2F; 30</span><br><span class="line">println(s1 - s2) &#x2F;&#x2F; -10</span><br></pre></td></tr></table></figure>

<h2 id="Map-集合的默认值"><a href="#Map-集合的默认值" class="headerlink" title="Map 集合的默认值"></a>Map 集合的默认值</h2><p>在 Map 集合中，可以使用 withDefault 设置一个默认值，当键不在 Map 集合中，通过 getValue 返回默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val map &#x3D; mapOf(</span><br><span class="line">        &quot;java&quot; to 1,</span><br><span class="line">        &quot;kotlin&quot; to 2,</span><br><span class="line">        &quot;python&quot; to 3</span><br><span class="line">).withDefault &#123; &quot;?&quot; &#125;</span><br><span class="line"></span><br><span class="line">println(map.getValue(&quot;java&quot;)) &#x2F;&#x2F; 1</span><br><span class="line">println(map.getValue(&quot;kotlin&quot;)) &#x2F;&#x2F; 2</span><br><span class="line">println(map.getValue(&quot;c++&quot;)) &#x2F;&#x2F; ?</span><br></pre></td></tr></table></figure>

<p>源码实现也非常简单，当返回值为 null 时，返回设置的默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal inline fun &lt;K, V&gt; Map&lt;K, V&gt;.getOrElseNullable(key: K, defaultValue: () -&gt; V): V &#123;</span><br><span class="line">    val value &#x3D; get(key)</span><br><span class="line">    if (value &#x3D;&#x3D; null &amp;&amp; !containsKey(key)) &#123;</span><br><span class="line">        return defaultValue()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">        return value as V</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种写法和 plus 操作符在一起用，有一个 bug ，看一下下面这个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val newMap &#x3D; map + mapOf(&quot;python&quot; to 3)</span><br><span class="line">println(newMap.getValue(&quot;c++&quot;)) &#x2F;&#x2F; 调用 getValue 时抛出异常，异常信息：Key c++ is missing in the map.</span><br></pre></td></tr></table></figure>

<p>这段代码的意思就是，通过 plus(+) 操作符合并两个 map，返回一个新的 map, 但是忽略了默认值，所以看到上面的错误信息，我们在开发的时候需要注意这点。</p>
<h2 id="使用-require-或者-check-函数作为条件检查"><a href="#使用-require-或者-check-函数作为条件检查" class="headerlink" title="使用 require 或者 check 函数作为条件检查"></a>使用 require 或者 check 函数作为条件检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 传统的做法</span><br><span class="line">val age &#x3D; -1;</span><br><span class="line">if (age &lt;&#x3D; 0) &#123;</span><br><span class="line">    throw IllegalArgumentException(&quot;age must  not be negative&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 require 去检查</span><br><span class="line">require(age &gt; 0) &#123; &quot;age must be negative&quot; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 checkNotNull 检查</span><br><span class="line">val name: String? &#x3D; null</span><br><span class="line">checkNotNull(name)&#123;</span><br><span class="line">    &quot;name must not be null&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们如何在项目中使用呢，具体的用法可以查看我 GitHub 上的项目 <a href="https://github.com/hi-dhl/JDataBinding/blob/master/jdatabinding/src/main/java/com/hi/dhl/jdatabinding/DataBindingDialog.kt">DataBindingDialog.kt</a> 当中的用法。</p>
<h2 id="如何区分和使用-run-with-let-also-apply"><a href="#如何区分和使用-run-with-let-also-apply" class="headerlink" title="如何区分和使用 run, with, let, also, apply"></a>如何区分和使用 run, with, let, also, apply</h2><p>感谢大神 Elye 的这篇文章提供的思路 <a href="https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84">Mastering Kotlin standard functions</a>。</p>
<p>run, with, let, also, apply 都是作用域函数，这些作用域函数如何使用，以及如何区分呢，我们将从以下三个方面来区分它们。</p>
<ul>
<li>是否是扩展函数。</li>
<li>作用域函数的参数（this、it）。</li>
<li>作用域函数的返回值（调用本身、其他类型即最后一行）。</li>
</ul>
<h3 id="是否是扩展函数"><a href="#是否是扩展函数" class="headerlink" title="是否是扩展函数"></a>是否是扩展函数</h3><p>首先我们来看一下 with 和 T.run，这两个函数非常的相似，他们的区别在于 with 是个普通函数，T.run 是个扩展函数，来看一下下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val name: String? &#x3D; null</span><br><span class="line">with(name)&#123;</span><br><span class="line">val subName &#x3D; name!!.substring(1,2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用之前可以检查它的可空性</span><br><span class="line">name?.run &#123; val subName &#x3D; name.substring(1,2) &#125;?:throw IllegalArgumentException(&quot;name must not be null&quot;)</span><br></pre></td></tr></table></figure>

<p>在这个例子当中，name?.run 会更好一些，因为在使用之前可以检查它的可空性。</p>
<h3 id="作用域函数的参数（this、it）"><a href="#作用域函数的参数（this、it）" class="headerlink" title="作用域函数的参数（this、it）"></a>作用域函数的参数（this、it）</h3><p>我们在来看一下 T.run 和 T.let，它们都是扩展函数，但是他们的参数不一样，T.run 的参数是 this, T.let 的参数是 it。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val name: String? &#x3D; &quot;hi-dhl.com&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 参数是 this，可以省略不写</span><br><span class="line">name?.run &#123;</span><br><span class="line">println(&quot;The length  is $&#123;this.length&#125;  this 是可以省略的 $&#123;length&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 参数 it</span><br><span class="line">name?.let &#123;</span><br><span class="line">println(&quot;The length  is  $&#123;it.length&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义参数名字</span><br><span class="line">name?.let &#123; str -&gt;</span><br><span class="line">println(&quot;The length  is  $&#123;str.length&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中看似 T.run 会更好，因为 this 可以省略，调用更加的简洁，但是 T.let 允许我们自定义参数名字，使可读性更强，如果倾向可读性可以选择 T.let。</p>
<h3 id="作用域函数的返回值（调用本身、其他类型）"><a href="#作用域函数的返回值（调用本身、其他类型）" class="headerlink" title="作用域函数的返回值（调用本身、其他类型）"></a>作用域函数的返回值（调用本身、其他类型）</h3><p>接下里我们来看一下 T.let 和 T.also 它们接受的参数都是 it, 但是它们的返回值是不同的，T.let 返回最后一行，T.also 返回调用本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var name &#x3D; &quot;hi-dhl&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回调用本身</span><br><span class="line">name &#x3D; name.also &#123;</span><br><span class="line">val result &#x3D; 1 * 1</span><br><span class="line">&quot;juejin&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;name &#x3D; $&#123;name&#125;&quot;) &#x2F;&#x2F; name &#x3D; hi-dhl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回的最后一行</span><br><span class="line">name &#x3D; name.let &#123;</span><br><span class="line">val result &#x3D; 1 * 1</span><br><span class="line">&quot;hi-dhl.com&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;name &#x3D; $&#123;name&#125;&quot;) &#x2F;&#x2F; name &#x3D; hi-dhl.com</span><br></pre></td></tr></table></figure>

<p>从上面的例子来看 T.also 似乎没有什么意义，细想一下其实是非常有意义的，在使用之前可以进行自我操作，结合其他的函数，功能会更强大。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun makeDir(path: String) &#x3D; path.let&#123; File(it) &#125;.also&#123; it.mkdirs() &#125;</span><br></pre></td></tr></table></figure>

<p>当然 T.also 还可以做其他事情，比如利用 T.also 在使用之前可以进行自我操作特点，可以实现一行代码交换两个变量，在后面会有详细介绍</p>
<h3 id="T-apply-函数"><a href="#T-apply-函数" class="headerlink" title="T.apply 函数"></a>T.apply 函数</h3><p>通过上面三个方面，大致了解函数的行为，接下来看一下 T.apply 函数，T.apply 函数是一个扩展函数，返回值是它本身，并且接受的参数是 this。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 普通方法</span><br><span class="line">fun createInstance(args: Bundle) : MyFragment &#123;</span><br><span class="line">val fragment &#x3D; MyFragment()</span><br><span class="line">fragment.arguments &#x3D; args</span><br><span class="line">return fragment</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 改进方法</span><br><span class="line">fun createInstance(args: Bundle) </span><br><span class="line">          &#x3D; MyFragment().apply &#123; arguments &#x3D; args &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">&#x2F;&#x2F; 普通方法</span><br><span class="line">fun createIntent(intentData: String, intentAction: String): Intent &#123;</span><br><span class="line">val intent &#x3D; Intent()</span><br><span class="line">intent.action &#x3D; intentAction</span><br><span class="line">intent.data&#x3D;Uri.parse(intentData)</span><br><span class="line">return intent</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 改进方法，链式调用</span><br><span class="line">fun createIntent(intentData: String, intentAction: String) &#x3D;</span><br><span class="line">    Intent().apply &#123; action &#x3D; intentAction &#125;</span><br><span class="line">            .apply &#123; data &#x3D; Uri.parse(intentData) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p>以表格的形式汇总，更方便去理解</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>是否是扩展函数</th>
<th>函数参数(this、it)</th>
<th>返回值(调用本身、最后一行)</th>
</tr>
</thead>
<tbody><tr>
<td>with</td>
<td>不是</td>
<td>this</td>
<td>最后一行</td>
</tr>
<tr>
<td>T.run</td>
<td>是</td>
<td>this</td>
<td>最后一行</td>
</tr>
<tr>
<td>T.let</td>
<td>是</td>
<td>it</td>
<td>最后一行</td>
</tr>
<tr>
<td>T.also</td>
<td>是</td>
<td>it</td>
<td>调用本身</td>
</tr>
<tr>
<td>T.apply</td>
<td>是</td>
<td>this</td>
<td>调用本身</td>
</tr>
</tbody></table>
<h3 id="使用-T-also-函数交换两个变量"><a href="#使用-T-also-函数交换两个变量" class="headerlink" title="使用 T.also 函数交换两个变量"></a>使用 T.also 函数交换两个变量</h3><p>接下来演示的是使用 T.also 函数，实现一行代码交换两个变量？我们先来回顾一下 Java 的做法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">int b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Java - 中间变量</span><br><span class="line">int temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">System.out.println(&quot;a &#x3D; &quot;+a +&quot; b &#x3D; &quot;+b); &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Java - 加减运算</span><br><span class="line">a &#x3D; a + b;</span><br><span class="line">b &#x3D; a - b;</span><br><span class="line">a &#x3D; a - b;</span><br><span class="line">System.out.println(&quot;a &#x3D; &quot; + a + &quot; b &#x3D; &quot; + b); &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; Java - 位运算</span><br><span class="line">a &#x3D; a ^ b;</span><br><span class="line">b &#x3D; a ^ b;</span><br><span class="line">a &#x3D; a ^ b;</span><br><span class="line">System.out.println(&quot;a &#x3D; &quot; + a + &quot; b &#x3D; &quot; + b); &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Kotlin</span><br><span class="line">a &#x3D; b.also &#123; b &#x3D; a &#125;</span><br><span class="line">println(&quot;a &#x3D; $&#123;a&#125; b &#x3D; $&#123;b&#125;&quot;) &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1</span><br></pre></td></tr></table></figure>

<p>来一起分析 T.also 是如何做到的，其实这里用到了 T.also 函数的两个特点。</p>
<ul>
<li>调用 T.also 函数返回的是调用者本身。</li>
<li>在使用之前可以进行自我操作。</li>
</ul>
<p>也就是说 b.also { b = a } 会先将 a 的值 (1) 赋值给 b，此时 b 的值为 1，然后将 b 原始的值（2）赋值给 a，此时 a 的值为 2，实现交换两个变量的目的。</p>
<h2 id="in-和-when-关键字"><a href="#in-和-when-关键字" class="headerlink" title="in 和 when 关键字"></a>in 和 when 关键字</h2><p>使用 in 和 when 关键字结合正则表达式，验证用户的输入，这是一个很酷的技巧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用扩展函数重写 contains 操作符</span><br><span class="line">operator fun Regex.contains(text: CharSequence) : Boolean &#123;</span><br><span class="line">  return this.containsMatchIn(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结合着 in 和 when 一起使用</span><br><span class="line">when (input) &#123;</span><br><span class="line">  in Regex(&quot;[0–9]&quot;) -&gt; println(&quot;contains a number&quot;)</span><br><span class="line">  in Regex(&quot;[a-zA-Z]&quot;) -&gt; println(&quot;contains a letter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>in 关键字其实是 contains 操作符的简写，它不是一个接口，也不是一个类型，仅仅是一个操作符，也就是说任意一个类只要重写了 contains 操作符，都可以使用 in 关键字，如果我们想要在自定义类型中检查一个值是否在列表中，只需要重写 contains() 方法即可，Collections 集合也重写了 contains 操作符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val input &#x3D; &quot;kotlin&quot;</span><br><span class="line"></span><br><span class="line">when (input) &#123;</span><br><span class="line">    in listOf(&quot;java&quot;, &quot;kotlin&quot;) -&gt; println(&quot;found $&#123;input&#125;&quot;)</span><br><span class="line">    in setOf(&quot;python&quot;, &quot;c++&quot;) -&gt; println(&quot;found $&#123;input&#125;&quot;)</span><br><span class="line">    else -&gt; println(&quot; not found $&#123;input&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kotlin-的单例三种写法"><a href="#Kotlin-的单例三种写法" class="headerlink" title="Kotlin 的单例三种写法"></a>Kotlin 的单例三种写法</h2><p>我汇总了一下目前 Kotlin 单例总共有三种写法：</p>
<ul>
<li>使用 Object 实现单例。</li>
<li>使用 by lazy 实现单例。</li>
<li>可接受参数的单例（来自大神 Christophe Beyls）。</li>
</ul>
<h3 id="使用-Object-实现单例"><a href="#使用-Object-实现单例" class="headerlink" title="使用 Object 实现单例"></a>使用 Object 实现单例</h3><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object WorkSingleton</span><br></pre></td></tr></table></figure>

<p>Kotlin 当中 Object 关键字就是一个单例，比 Java 的一坨代码看起来舒服了很多，来看一下编译后的 Java 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class WorkSingleton &#123;</span><br><span class="line">   public static final WorkSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      WorkSingleton var0 &#x3D; new WorkSingleton();</span><br><span class="line">      INSTANCE &#x3D; var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 static 代码块实现的单例，优点：饿汉式且是线程安全的，缺点：类加载时就初始化，浪费内存。</p>
<h3 id="使用-by-lazy-实现单例"><a href="#使用-by-lazy-实现单例" class="headerlink" title="使用 by lazy 实现单例"></a>使用 by lazy 实现单例</h3><p>利用伴生对象 和 by lazy 也可以实现单例，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class WorkSingleton private constructor() &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 方式一</span><br><span class="line">        val INSTANCE1 by lazy(mode &#x3D; LazyThreadSafetyMode.SYNCHRONIZED) &#123; WorkSingleton() &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 方式二 默认就是 LazyThreadSafetyMode.SYNCHRONIZED，可以省略不写，如下所示</span><br><span class="line">        val INSTANCE2 by lazy &#123; WorkSingleton() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lazy 的延迟模式有三种：</p>
<ul>
<li><p>上面代码所示 mode = LazyThreadSafetyMode.SYNCHRONIZED，lazy 默认的模式，可以省掉，这个模式的意思是：如果有多个线程访问，只有一条线程可以去初始化 lazy 对象。</p>
</li>
<li><p>当 mode = LazyThreadSafetyMode.PUBLICATION 表达的意思是：对于还没有被初始化的 lazy 对象，可以被不同的线程调用，如果 lazy 对象初始化完成，其他的线程使用的是初始化完成的值。</p>
</li>
<li><p>mode = LazyThreadSafetyMode.NONE 表达的意思是：只能在单线程下使用，不能在多线程下使用，不会有锁的限制，也就是说它不会有任何线程安全的保证以及相关的开销。</p>
</li>
</ul>
<p>通过上面三种模式，这就可以理解为什么 by lazy 声明的变量只能用 val，因为初始化完成之后它的值是不会变的。</p>
<h3 id="可接受参数的单例"><a href="#可接受参数的单例" class="headerlink" title="可接受参数的单例"></a>可接受参数的单例</h3><p>但是有的时候，希望在单例实例化的时候传递参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Singleton.getInstance(context).doSome()</span><br></pre></td></tr></table></figure>

<p>上面这两种形式都不能满足，来看看大神 Christophe Beyls 在这篇文章给出的方法 <a href="https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e">Kotlin singletons with argument</a> 代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class WorkSingleton private constructor(context: Context) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        &#x2F;&#x2F; Init using context argument</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object : SingletonHolder&lt;WorkSingleton, Context&gt;(::WorkSingleton)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">open class SingletonHolder&lt;out T : Any, in A&gt;(creator: (A) -&gt; T) &#123;</span><br><span class="line">    private var creator: ((A) -&gt; T)? &#x3D; creator</span><br><span class="line">    @Volatile</span><br><span class="line">    private var instance: T? &#x3D; null</span><br><span class="line"></span><br><span class="line">    fun getInstance(arg: A): T &#123;</span><br><span class="line">        val i &#x3D; instance</span><br><span class="line">        if (i !&#x3D; null) &#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return synchronized(this) &#123;</span><br><span class="line">            val i2 &#x3D; instance</span><br><span class="line">            if (i2 !&#x3D; null) &#123;</span><br><span class="line">                i2</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                val created &#x3D; creator!!(arg)</span><br><span class="line">                instance &#x3D; created</span><br><span class="line">                creator &#x3D; null</span><br><span class="line">                created</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有没有感觉这和 Java 中双重校验锁的机制很像，在 SingletonHolder 类中如果已经初始化了直接返回，如果没有初始化进入 synchronized 代码块创建对象，利用了 Kotlin 伴生对象提供的非常强大功能，它能够像其他任何对象一样从基类继承，从而实现了与静态继承相当的功能。 所以我们将 SingletonHolder 作为单例类伴随对象的基类，以便在单例类上重用并公开 getInstance（）函数。</p>
<p>参数传递给 SingletonHolder 构造函数的 creator，creator 是一个 lambda 表达式，将 WorkSingleton 传递给 SingletonHolder 类构造函数。</p>
<p>并且不限制传入参数的类型，凡是需要传递参数的单例模式，只需将单例类的伴随对象继承于 SingletonHolder，然后传入当前的单例类和参数类型即可，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FileSingleton private constructor(path: String) &#123;</span><br><span class="line"></span><br><span class="line">    companion object : SingletonHolder&lt;FileSingleton, String&gt;(::FileSingleton)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里就结束了，Kotlin 的强大不止于此，后面还会分享更多的技巧，在 Kotlin 的道路上还有很多实用的技巧等着我们一起来探索。</p>
<p>例如利用 Kotlin 的 inline、reified、DSL 等等语法, 结合着 DataBinding、LiveData 等等可以设计出更加简洁并利于维护的代码，更多技巧可以查看我 GitHub 上的项目 <a href="https://github.com/hi-dhl/JDataBinding">JDataBinding</a>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84">Mastering Kotlin standard functions: run, with, let, also and apply</a></li>
<li><a href="https://proandroiddev.com/kotlin-fun-with-in-8a425704b635">Kotlin: fun with “in”</a></li>
</ul>
</div><div><p style="height:15px"></p><ul class="page-copyright"><li><strong>本文作者：</strong>hi-dhl</li><li><strong>本文标题：</strong>为数不多的人知道的 Kotlin 技巧以及 原理解析（一）</li><li><strong>本文链接：</strong><a href="" title="{page.title}">https://hi-dhl.com/2020/08/22/kotlin/01-kotlin/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hi-dhl.com" title="{page.title}">hi-dhl</a></li></ul><p style="height:15px"></p></div><!--!--><h1 class="title is-4 is-size-4-mobile"></h1></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/08/22/kotlin/02-kotlin/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">为数不多的人知道的 Kotlin 技巧以及 原理解析（二）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/08/22/AndroidStudio/03-androidstudio-2/"><span class="level-item">图解多平台 AndroidStudio 技巧(二)</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content template"><p align="center"><img src="http://cdn.51git.cn/2020-10-07-bytecode.png"></p><p>致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，在技术的道路上一起前进</p><h3 class="title is-4">Android10 源码分析</h3><p>正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Android10-Source-Analysis">Android10-Source-Analysis</a>。</p><h3 class="title is-4">算法题库的归纳和总结</h3><p>由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序。</p><ul><li>数据结构： 数组、栈、队列、字符串、链表、树……</li><li>算法： 查找算法、搜索算法、位运算、排序、数学、……</li></ul><p>每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：<a href="https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin">Leetcode-Solutions-with-Java-And-Kotlin</a>。</p><h3 class="title is-4">精选国外的技术文章</h3><p>目前正在整理和翻译一系列精选国外的技术文章，不仅仅是翻译，很多优秀的英文技术文章提供了很好思路和方法，每篇文章都会有<strong>译者思考</strong>部分，对原文的更加深入的解读，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Technical-Article-Translation">Technical-Article-Translation</a>。</p><p></p></div></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: undefined,
            appId: 'zfvr24HFhzQ5vtHkr4NQ1fmW-gzGzoHsz',
            appKey: 'RChgr9mR005hgu4yiQ4WQU3O',
            placeholder: '说点什么',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" style="max-height: 500px;overflow: auto;"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#plus-操作符"><span>plus 操作符</span></a></li><li><a class="is-flex" href="#Map-集合的默认值"><span>Map 集合的默认值</span></a></li><li><a class="is-flex" href="#使用-require-或者-check-函数作为条件检查"><span>使用 require 或者 check 函数作为条件检查</span></a></li><li><a class="is-flex" href="#如何区分和使用-run-with-let-also-apply"><span>如何区分和使用 run, with, let, also, apply</span></a><ul class="menu-list"><li><a class="is-flex" href="#是否是扩展函数"><span>是否是扩展函数</span></a></li><li><a class="is-flex" href="#作用域函数的参数（this、it）"><span>作用域函数的参数（this、it）</span></a></li><li><a class="is-flex" href="#作用域函数的返回值（调用本身、其他类型）"><span>作用域函数的返回值（调用本身、其他类型）</span></a></li><li><a class="is-flex" href="#T-apply-函数"><span>T.apply 函数</span></a></li><li><a class="is-flex" href="#汇总"><span>汇总</span></a></li><li><a class="is-flex" href="#使用-T-also-函数交换两个变量"><span>使用 T.also 函数交换两个变量</span></a></li></ul></li><li><a class="is-flex" href="#in-和-when-关键字"><span>in 和 when 关键字</span></a></li><li><a class="is-flex" href="#Kotlin-的单例三种写法"><span>Kotlin 的单例三种写法</span></a><ul class="menu-list"><li><a class="is-flex" href="#使用-Object-实现单例"><span>使用 Object 实现单例</span></a></li><li><a class="is-flex" href="#使用-by-lazy-实现单例"><span>使用 by lazy 实现单例</span></a></li><li><a class="is-flex" href="#可接受参数的单例"><span>可接受参数的单例</span></a></li></ul></li><li><a class="is-flex" href="#总结"><span>总结</span></a></li><li><a class="is-flex" href="#参考链接"><span>参考链接</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2022-05-20T05:51:55.907Z">2022-05-20</time></p><p class="title is-6"><a class="link-muted" href="/2022/05/20/kotlin/22-iterable-Sequence/">迭代器 Iterable 这么慢吗？而它让性能提升 N 倍</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-05-12T06:37:26.221Z">2022-05-12</time></p><p class="title is-6"><a class="link-muted" href="/2022/05/12/kotlin/21-reflect/">揭秘反射真的很耗时吗，射10万次用时多久</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-05-12T06:35:05.575Z">2022-05-12</time></p><p class="title is-6"><a class="link-muted" href="/2022/05/12/kotlin/20-Context-Receivers/">揭秘 Kotlin 1.6.20 重磅功能 Context Receivers</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-04-25T14:08:39.158Z">2022-04-25</time></p><p class="title is-6"><a class="link-muted" href="/2022/04/25/Note/10-vpn/">科学上网 | 十年前，他打开了通往自由世界的大门</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-04-25T14:04:25.435Z">2022-04-25</time></p><p class="title is-6"><a class="link-muted" href="/2022/04/25/Note/09-longquan/">程序员 PK 刘畊宏，我用代码实现龙拳了</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android-12/"><span class="level-start"><span class="level-item">Android 12</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android-AndroidStudio/"><span class="level-start"><span class="level-item">Android,AndroidStudio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android10/"><span class="level-start"><span class="level-item">Android10</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AndroidStudio/"><span class="level-start"><span class="level-item">AndroidStudio</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Jetpack/"><span class="level-start"><span class="level-item">Jetpack</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9D%82%E8%B0%88/"><span class="level-start"><span class="level-item">杂谈</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95%E5%8A%A8%E7%94%BB/"><span class="level-start"><span class="level-item">算法动画</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/translated/"><span class="level-start"><span class="level-item">译文</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%91%E6%96%87-AndroidStudio/"><span class="level-start"><span class="level-item">译文,AndroidStudio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%91%E6%96%87-Kotlin/"><span class="level-start"><span class="level-item">译文,Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android-12/"><span class="tag">Android 12</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-包管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-窗口管理系统</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-资源管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AndroidStudio/"><span class="tag">AndroidStudio</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android%E6%BA%90%E7%A0%81/"><span class="tag">Android源码</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compose/"><span class="tag">Compose</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fragment/"><span class="tag">Fragment</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Jetpack/"><span class="tag">Jetpack</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Koin/"><span class="tag">Koin</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag is-grey-lightest">26</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Protobuf/"><span class="tag">Protobuf</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kotlin/"><span class="tag">kotlin</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E7%94%BB/"><span class="tag">动画</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B3%BB%E7%BB%9F/"><span class="tag">系统</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%91%E6%96%87/"><span class="tag">译文</span><span class="tag is-grey-lightest">11</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level-item"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/logo.png" alt="dhl" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="dhl" height="28"></a><p class="size-small"><span>&copy; 2022 dhl</span>  <a href="http://beian.miit.gov.cn/" target="_blank">京ICP备18050211号-2</a>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.hi-dhl.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://s9.cnzz.com/z_stat.php?id=1278919895&amp;web_id=1278919895" async></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/imaegoo/universe.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>