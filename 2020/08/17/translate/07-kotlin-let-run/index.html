<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>「译」你中招了吗？ Kotlin 一个隐藏的坑 - dhl</title><meta description="Kotlin 的这些坑你遇到过吗"><meta property="og:type" content="blog"><meta property="og:title" content="「译」你中招了吗？ Kotlin 一个隐藏的坑"><meta property="og:url" content="https://hi-dhl.com/2020/08/17/translate/07-kotlin-let-run/"><meta property="og:site_name" content="dhl"><meta property="og:description" content="Kotlin 的这些坑你遇到过吗"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.51git.cn/2020-08-04-15964757436916.jpg"><meta property="article:published_time" content="2020-08-16T16:58:28.722Z"><meta property="article:modified_time" content="2020-11-11T17:01:54.345Z"><meta property="article:author" content="dhl"><meta property="article:tag" content="Java"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Fragment"><meta property="article:tag" content="Dagger"><meta property="article:tag" content="Koin"><meta property="article:tag" content="FragmentContainerView"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Coil"><meta property="article:tag" content="Glide"><meta property="article:tag" content="Picasso"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://cdn.51git.cn/2020-08-04-15964757436916.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hi-dhl.com/2020/08/17/translate/07-kotlin-let-run/"},"headline":"dhl","image":["http://cdn.51git.cn/2020-08-04-15964757436916.jpg"],"datePublished":"2020-08-16T16:58:28.722Z","dateModified":"2020-11-11T17:01:54.345Z","author":{"@type":"Person","name":"dhl"},"description":"Kotlin 的这些坑你遇到过吗"}</script><link rel="canonical" href="https://hi-dhl.com/2020/08/17/translate/07-kotlin-let-run/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/logo.png" alt="dhl" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="dhl" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/categories/Jetpack">Jetpack</a><a class="navbar-item" href="/categories/Kotlin/">Kotlin</a><a class="navbar-item" href="/categories/Android10/">系统源码</a><a class="navbar-item" href="/categories/translated/">译文</a><a class="navbar-item" href="https://offer.hi-dhl.com">算法</a><a class="navbar-item" href="https://site.51git.cn/">国内外书签</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hi-dhl"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="http://cdn.51git.cn/2020-08-04-15964757436916.jpg" alt="「译」你中招了吗？ Kotlin 一个隐藏的坑"></span></div><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile"></h1><h1 class="title is-3 is-size-4-mobile">「译」你中招了吗？ Kotlin 一个隐藏的坑</h1><div class="article-meta size-small level is-mobile"><div class="level-left"><span class="mr-2"><i class="fa fa-calendar"></i></span><time class="level-item" dateTime="2020-08-16T16:58:28.722Z" title="2020-08-16T16:58:28.722Z">2020-08-17</time><span class="mr-2"> <i class="fa fa-folder"></i></span><span class="level-item"><a class="link-muted" href="/categories/translated/">译文</a></span><span class="mr-2"> <i class="fa fa-tag"></i></span><span class="level-item"><a class="link-muted" href="/tags/Kotlin/">Kotlin</a><span> , </span><a class="link-muted" href="/tags/%E8%AF%91%E6%96%87/">译文</a></span></div></div><div class="level-left article-meta size-small is-mobile"></div><div><p style="height:15px"></p><ul class="page-blockquote"><li>如果评论区没有及时回复，欢迎来公众号：ByteCode 咨询</li><li>公众号：ByteCode。致力于分享最新技术原创文章，涉及 Kotlin、Jetpack、算法、译文、系统源码相关的文章</li><li></li></ul><p style="height:15px"></p></div><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<ul>
<li>原标题:  A decompiled story of Kotlin let and run</li>
<li>原地址: <a href="https://dev.to/vlazdra/a-decompiled-story-of-kotlin-let-and-run-4k83">https://dev.to/vlazdra/a-decompiled……</a></li>
<li>原作者：Vladimir Zdravkovic</li>
<li>译者：hi-dhl</li>
<li>本文已收录于仓库 <a href="https://github.com/hi-dhl/Technical-Article-Translation">Technical-Article-Translation</a></li>
</ul>
</blockquote>
<p>之前我发表过几篇关于 Kotlin 性能损耗和 Kotlin 技巧方面的文章，如果没有了解过，可以点击下方链接前去查看，可以避免在实际开发中遇到重复的问题。</p>
<ul>
<li><a href="https://juejin.im/post/5ebc1eb8e51d454dcf45744e?utm_source=gold_browser_extension">[译][2.4K Start] 放弃 Dagger 拥抱 Koin</a></li>
<li><a href="https://juejin.im/post/5ec0f3afe51d454db11f8a94#heading-7">[译][5k+] Kotlin 的性能优化那些事</a></li>
<li><a href="https://juejin.im/post/5edfd7c9e51d45789a7f206d">为数不多的人知道的 Kotlin 技巧以及 原理解析(一)</a></li>
<li><a href="https://juejin.im/post/6847902224467623950">为数不多的人知道的 Kotlin 技巧以及 原理解析(二)</a></li>
</ul>
<p>这篇文章主要来分析 Kotlin 另外一个隐藏的问题，文章将会分为 <strong>译文</strong> 和 <strong>译者思考</strong> 两部分，本文不仅仅是翻译，在 <strong>译者思考</strong> 部分会对译文进行总结以及更加深入的思考和分析，也可以跳过译文直接看 <strong>译者思考</strong> 部分。</p>
<p><strong>通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案</strong></p>
<ul>
<li>使用 <code>T.let</code> 会遇到什么问题？</li>
<li>为什么会造成这个问题？</li>
<li>如何解决这个问题？</li>
<li>为什么使用 <code>T.apply</code> 可以解决这个问题？</li>
<li><code>T.apply</code> 和 <code>T.let</code> 有什么区别？</li>
<li>如何区分 run, with, let, also, apply？</li>
<li>Kotlin 如何交换两个变量？</li>
</ul>
<p>这篇文章涉及很多重要的知识点，请耐心读下去，应该可以从中学到很多技巧。</p>
<h2 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h2><p>前段时间，我花了不少时间，为了弄清楚一个简单的 Kotlin 代码块 <code>let</code> 和 <code>run</code>，为什么不想做我想让它做的事，经过无数次重写我的代码之后，我认为这一定是我自己的错误，最后为了搞清楚 Kotlin 语法糖背后发生了什么，最后我决定花点时间深入研究生成的代码。</p>
<p><code>let</code> 和 <code>run</code> 是 Kotlin 标准库当中的内联函数，我认为它们的工作的方式与经典的 <code>if ... else ...</code> 语句类似，所以我一直在项目中这么使用它们，直到我在一个项目中为了实现某个功能的时候，遇到了一个隐藏的问题，让我们看看问题是什么。</p>
<p><img src="http://cdn.51git.cn/2020-08-04-159629675122671.jpg" alt=""></p>
<p>这是一个很简单的 Kotlin 代码，它有两个可空的变量，其中一个已经有值，如果我调用 <code>doSomeAwesomePrinting()</code> 方法，你认为控制台会输出什么？</p>
<p>你可能会和我一样认为什么都不会输出，可是… 错了，最后会输出 “awesome output 1”。</p>
<p>为什么会这样？我们来看一下反编译后的代码，发生了什么。</p>
<p><img src="http://cdn.51git.cn/2020-08-04-159634085308213.jpg" alt=""></p>
<p>正如你所见，当第二个变量 awesomeVar2 为空时，Kotlin 自动生成的变量 <code>var10000</code> 也为空，所以程序不会执行 return 语句，函数执行到最后会输出 ”awesome output 1“。</p>
<p>让我们来看看另外一个例子，在这个例子中，我们对上面 Kotlin 代码做一些更改，在第二个变量上添加 elvis 操作符，代码如下所示。</p>
<p><img src="http://cdn.51git.cn/2020-08-04-159629754266153.jpg" alt=""></p>
<p>如果再次调用 <code>doSomeAwesomePrinting()</code> 方法则会输出 “awesome output 3”，这次的修改已完成了想要做的事情，与经典的 <code>if ... else ...</code> 语句类似，我们来看一下反编译后的代码。</p>
<p><img src="http://cdn.51git.cn/2020-08-04-159634121091672.jpg" alt=""></p>
<p>正如你所见，反编译后的代码其实就是 <code>if ... else ...</code> 语句，当第二个变量为空时则输出 “awesome output 3”， 现在来分析一下如何解决文章开头提出来的问题。</p>
<p><strong>解决方案</strong></p>
<p>感谢 Danny 的建议，其实可以用 Kotlin 另外的一个内联函数 apply 来解决这个问题。</p>
<p><img src="http://cdn.51git.cn/2020-08-04-15962985306741.jpg" alt=""></p>
<p>接下来按照 Danny 的建议，使用 Kotlin 另外一个内联函数 apply，看看会发生什么。</p>
<p><img src="http://cdn.51git.cn/2020-08-04-159629868566451.jpg" alt=""></p>
<p>和我们所期望的一样，当第二个变量为空时，控制台什么都不会输出，你可以试一下，接下来我们来分析一下反编译后的代码。</p>
<p><img src="http://cdn.51git.cn/2020-08-04-159629876789301.jpg" alt=""></p>
<p>正如你所看到的，Kotlin 自动生成的变量 var1 不为空，当第二个变量 awesomeVar2 为空时，直接 return 了。</p>
<p>最后我们对上面 Kotlin 代码，在 apply 的基础上，做一点一点修改，在第二个变量上添加 elvis 操作符如下所示。</p>
<p><img src="http://cdn.51git.cn/2020-08-04-159629901151061.jpg" alt=""></p>
<p>运行代码之后，当第二个变量为空时，控制台将会输出 “awesome output 3” ，为了能够理解这里发生了什么，我们来看一下反编译后的代码。</p>
<p><img src="http://cdn.51git.cn/2020-08-04-159629927356662.jpg" alt=""></p>
<p>生成的代码比之前多了很多，但是不影响我们正常分析，和我们预期的一样，控制台将输出 “awesome output 3”</p>
<h2 id="译者思考"><a href="#译者思考" class="headerlink" title="译者思考"></a>译者思考</h2><p>接下来是译者思考部分，按照之前的风格，我们先对译文进行总结，然后在进行分析。</p>
<h3 id="总结和分析"><a href="#总结和分析" class="headerlink" title="总结和分析"></a>总结和分析</h3><p><strong>使用 T.let 会遇到了什么问题？</strong></p>
<p>Kotlin 标准库当中的内联函数 T.let 和 T.run 等等，它们的工作的方式与 <code>if ... else ...</code> 语句类似，从反编译后的代码可知其实就是 <code>if ... else ...</code> 语句，所以我们可能会认为运行下面的代码和 <code>if ... else ...</code> 语句一样不会有任何输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ExampleClass &#123;</span><br><span class="line">    var awesomeVar1: String? &#x3D; &quot;some awesome string value&quot;</span><br><span class="line">    var awesomeVar2: String? &#x3D; null</span><br><span class="line"></span><br><span class="line">    fun doSomeAwesomePrinting() &#123;</span><br><span class="line">        awesomeVar1?.let &#123;</span><br><span class="line">            awesomeVar2?.let &#123;</span><br><span class="line">                println(&quot;awesome output 2&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ?: run &#123;</span><br><span class="line">            println(&quot;awesome output 1&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是结果却出人意料，当第二个变量为空时，居然输出 “awesome output 1”，大家可以反编译上面的代码看一下，会更加清楚其内部逻辑。</p>
<p><strong>为什么会造成这个问题？</strong></p>
<p>我们来看一下 Kotlin 内联函数 T.let 的源码实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return block(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的 T.let 接受的参数是 it, 它返回最后一行，接下来我们将源代码拆解一下，可能会更清楚发生了什么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun doSomeAwesomePrinting() &#123;</span><br><span class="line">    awesomeVar1?.let &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将 awesomeVar2?.let&#123;...&#125;  的结果作为 awesomeVar1?.let&#123;...&#125; 的返回值</span><br><span class="line">        &#x2F;&#x2F; 所以当 awesomeVar2 为空时，awesomeVar2?.let&#123;...&#125; 的结果为空</span><br><span class="line">        &#x2F;&#x2F; 函数最后会输出 &quot;awesome output 1&quot;</span><br><span class="line">        awesomeVar2?.let &#123; println(&quot;awesome output 2&quot;) &#125;</span><br><span class="line"></span><br><span class="line">    &#125; ?: run &#123;</span><br><span class="line">        println(&quot;awesome output 1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将 <code>awesomeVar2?.let{...}</code> 的结果作为 <code>awesomeVar1?.let{...}</code> 的返回值</li>
<li>当 <code>awesomeVar2</code> 为空时，<code>awesomeVar2?.let{...}</code> 的结果为空</li>
<li>函数最后会输出 “awesome output 1”</li>
</ul>
<p><strong>如何解决这个问题？</strong></p>
<p>解决方案也很简单使用另外一个 Kotlin 内联函数 T.apply，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ExampleClass &#123;</span><br><span class="line">    var awesomeVar1: String? &#x3D; &quot;some awesome string value&quot;</span><br><span class="line">    var awesomeVar2: String? &#x3D; null</span><br><span class="line"></span><br><span class="line">    fun doSomeAwesomePrinting() &#123;</span><br><span class="line">        awesomeVar1?.apply &#123;</span><br><span class="line">            awesomeVar2?.apply &#123;</span><br><span class="line">                println(&quot;awesome output 2&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ?: run &#123;</span><br><span class="line">            println(&quot;awesome output 1&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Kotlin 另外一个内联函数 T.apply 之后，结果和我们所预期的一样，这里什么都不会输出，那么为什么使用 T.apply 可以解决这个问题？T.apply 和 T.let 有什么区别呢？</p>
<p><strong>为什么使用 T.apply 可以解决这个问题？</strong></p>
<p>我们来看一下 Kotlin 内联函数 T.apply 的源码实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T.apply 函数是一个扩展函数，返回值是它本身，并且接受的参数是 this，接下来我们将源代码拆解进行分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun doSomeAwesomePrinting() &#123;</span><br><span class="line">    awesomeVar1?.apply &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; awesomeVar1?.apply&#123;...&#125; 的返回值是它本身，awesomeVar1 不为空</span><br><span class="line">        &#x2F;&#x2F; 所以当 awesomeVar2 为空时，什么都不会输出</span><br><span class="line">        awesomeVar2?.apply &#123; println(&quot;awesome output 2&quot;) &#125; &#x2F;&#x2F; awesomeVar2?.apply&#123;...&#125; 返回值是 awesomeVar2</span><br><span class="line"></span><br><span class="line">    &#125; ?: run &#123;</span><br><span class="line">        println(&quot;awesome output 1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据 T.apply 函数特性，<code>awesomeVar1?.apply{...}</code> 的返回值是它本身，变量 <code>awesomeVar1</code>不为空</li>
<li>当 <code>awesomeVar2</code> 为空时，并不会影响到 <code>awesomeVar1?.apply{...}</code> 的结果，所这里什么都不会输出</li>
</ul>
<p><strong>T.apply 和 T.let 有什么区别？</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>是否是扩展函数</th>
<th>函数参数(this、it)</th>
<th>返回值(调用本身、最后一行)</th>
</tr>
</thead>
<tbody><tr>
<td>T.let</td>
<td>是</td>
<td>it</td>
<td>最后一行</td>
</tr>
<tr>
<td>T.apply</td>
<td>是</td>
<td>this</td>
<td>调用本身</td>
</tr>
</tbody></table>
<p>除了 T.apply 和 T.let 之外，Kotlin 还有很多其他内联函数例如 T.run 、T.also、with 等等，虽然操作符不多，但是想要分清楚这些操作符确实有些困难，所以我将会介绍一种简单的方法来区分它们以及如何使用。</p>
<h3 id="如何区分-run-with-let-also-apply"><a href="#如何区分-run-with-let-also-apply" class="headerlink" title="如何区分 run, with, let, also, apply"></a>如何区分 run, with, let, also, apply</h3><p>感谢大神 Elye 的这篇文章提供的思路 <a href="https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84">Mastering Kotlin standard functions</a>。</p>
<p>关于如何区分 run, with, let, also, apply 我在之前的文章  <a href="https://juejin.im/post/5edfd7c9e51d45789a7f206d">为数不多的人知道的 Kotlin 技巧以及 原理解析</a> 中有介绍，这里我们在回顾一下。</p>
<p>run, with, let, also, apply 是 Kotlin 的内联函数，也是作用域函数，这些作用域函数如何使用，以及如何区分呢，我们将从以下三个维度来区分它们。</p>
<ul>
<li>是否是扩展函数。</li>
<li>作用域函数的参数（this、it）。</li>
<li>作用域函数的返回值（调用本身、其他类型即最后一行）。</li>
</ul>
<h3 id="是否是扩展函数"><a href="#是否是扩展函数" class="headerlink" title="是否是扩展函数"></a>是否是扩展函数</h3><p>首先我们来看一下 with 和 T.run，这两个函数非常的相似，他们的区别在于 with 是个普通函数，T.run 是个扩展函数，来看一下下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val name: String? &#x3D; null</span><br><span class="line">with(name)&#123;</span><br><span class="line">    val subName &#x3D; name!!.substring(1,2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用之前可以检查它的可空性</span><br><span class="line">name?.run &#123; val subName &#x3D; name.substring(1,2) &#125;?:throw IllegalArgumentException(&quot;name must not be null&quot;)</span><br></pre></td></tr></table></figure>

<p>在这个例子当中，name?.run 会更好一些，因为在使用之前可以检查它的可空性。</p>
<h3 id="作用域函数的参数（this、it）"><a href="#作用域函数的参数（this、it）" class="headerlink" title="作用域函数的参数（this、it）"></a>作用域函数的参数（this、it）</h3><p>我们在来看一下 T.run 和 T.let，它们都是扩展函数，但是他们的参数不一样，T.run 的参数是 this, T.let 的参数是 it。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val name: String? &#x3D; &quot;hi-dhl.com&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 参数是 this，可以省略不写</span><br><span class="line">name?.run &#123;</span><br><span class="line">    println(&quot;The length  is $&#123;this.length&#125;  this 是可以省略的 $&#123;length&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 参数 it</span><br><span class="line">name?.let &#123;</span><br><span class="line">    println(&quot;The length  is  $&#123;it.length&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义参数名字</span><br><span class="line">name?.let &#123; str -&gt;</span><br><span class="line">    println(&quot;The length  is  $&#123;str.length&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中似乎 T.run 会更好，因为 this 可以省略，调用更加的简洁，但是 T.let 允许我们自定义参数名字，使可读性更强，如果倾向可读性可以选择 T.let。</p>
<h3 id="作用域函数的返回值（调用本身、其他类型即最后一行）"><a href="#作用域函数的返回值（调用本身、其他类型即最后一行）" class="headerlink" title="作用域函数的返回值（调用本身、其他类型即最后一行）"></a>作用域函数的返回值（调用本身、其他类型即最后一行）</h3><p>接下里我们来看一下 T.let 和 T.also 它们接受的参数都是 it, 但是它们的返回值是不同的，T.let 返回的是最后一行，T.also 返回调用者本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;hi-dhl&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回调用本身</span><br><span class="line">name &#x3D; name.also &#123;</span><br><span class="line">    val result &#x3D; 1 * 1</span><br><span class="line">    &quot;juejin&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;name &#x3D; $&#123;name&#125;&quot;) &#x2F;&#x2F; name &#x3D; hi-dhl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回的最后一行</span><br><span class="line">name &#x3D; name.let &#123;</span><br><span class="line">    val result &#x3D; 1 * 1</span><br><span class="line">    &quot;hi-dhl.com&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;name &#x3D; $&#123;name&#125;&quot;) &#x2F;&#x2F; name &#x3D; hi-dhl.com</span><br></pre></td></tr></table></figure>

<p>从上面的例子来看 T.also 似乎没有什么意义，细想一下其实是非常有意义的，在使用之前可以进行自我操作，结合其他的函数，功能会更强大。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun makeDir(path: String) &#x3D; path.let&#123; File(it) &#125;.also&#123; it.mkdirs() &#125;</span><br></pre></td></tr></table></figure>

<p>当然 T.also 还可以做其他事情，比如利用 T.also 在使用之前可以进行自我操作特点，可以实现一行代码交换两个变量，在后面会有详细介绍</p>
<h3 id="T-apply-函数"><a href="#T-apply-函数" class="headerlink" title="T.apply 函数"></a>T.apply 函数</h3><p>通过上面的分析，大致了解了函数的行为，接下来看一下 T.apply 函数，T.apply 函数是一个扩展函数，返回值是它本身，并且接受的参数是 this。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 普通方法</span><br><span class="line">fun createInstance(args: Bundle) : MyFragment &#123;</span><br><span class="line">    val fragment &#x3D; MyFragment()</span><br><span class="line">    fragment.arguments &#x3D; args</span><br><span class="line">    return fragment</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 改进方法</span><br><span class="line">fun createInstance(args: Bundle) </span><br><span class="line">          &#x3D; MyFragment().apply &#123; arguments &#x3D; args &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">&#x2F;&#x2F; 普通方法</span><br><span class="line">fun createIntent(intentData: String, intentAction: String): Intent &#123;</span><br><span class="line">    val intent &#x3D; Intent()</span><br><span class="line">    intent.action &#x3D; intentAction</span><br><span class="line">    intent.data&#x3D;Uri.parse(intentData)</span><br><span class="line">    return intent</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 改进方法，链式调用</span><br><span class="line">fun createIntent(intentData: String, intentAction: String) &#x3D;</span><br><span class="line">    Intent().apply &#123; action &#x3D; intentAction &#125;</span><br><span class="line">            .apply &#123; data &#x3D; Uri.parse(intentData) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-T-also-函数交换两个变量"><a href="#使用-T-also-函数交换两个变量" class="headerlink" title="使用 T.also 函数交换两个变量"></a>使用 T.also 函数交换两个变量</h3><p>接下来演示的是使用 T.also 函数，实现一行代码交换两个变量？我们先来回顾一下 Java 的做法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">int b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Java - 中间变量</span><br><span class="line">int temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">System.out.println(&quot;a &#x3D; &quot;+a +&quot; b &#x3D; &quot;+b); &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Java - 加减运算</span><br><span class="line">a &#x3D; a + b;</span><br><span class="line">b &#x3D; a - b;</span><br><span class="line">a &#x3D; a - b;</span><br><span class="line">System.out.println(&quot;a &#x3D; &quot; + a + &quot; b &#x3D; &quot; + b); &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; Java - 位运算</span><br><span class="line">a &#x3D; a ^ b;</span><br><span class="line">b &#x3D; a ^ b;</span><br><span class="line">a &#x3D; a ^ b;</span><br><span class="line">System.out.println(&quot;a &#x3D; &quot; + a + &quot; b &#x3D; &quot; + b); &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Kotlin</span><br><span class="line">a &#x3D; b.also &#123; b &#x3D; a &#125;</span><br><span class="line">println(&quot;a &#x3D; $&#123;a&#125; b &#x3D; $&#123;b&#125;&quot;) &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1</span><br></pre></td></tr></table></figure>

<p>一起来分析 T.also 是如何做到的，其实这里用到了 T.also 函数的两个特点。</p>
<ul>
<li>调用 T.also 函数返回的是调用者本身。</li>
<li>在使用之前可以进行自我操作。</li>
</ul>
<p>也就是说 b.also { b = a } 会先将 a 的值 (1) 赋值给 b，此时 b 的值为 1，然后将 b 原始的值（2）赋值给 a，此时 a 的值为 2，实现交换两个变量的目的。</p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p>为了更方便的理解和记忆，接下来我以表格的形式将上面的内容进行汇总，具体还需要有结合实际项目去使用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>是否是扩展函数</th>
<th>函数参数(this、it)</th>
<th>返回值(调用本身、最后一行)</th>
</tr>
</thead>
<tbody><tr>
<td>with</td>
<td>不是</td>
<td>this</td>
<td>最后一行</td>
</tr>
<tr>
<td>T.run</td>
<td>是</td>
<td>this</td>
<td>最后一行</td>
</tr>
<tr>
<td>T.let</td>
<td>是</td>
<td>it</td>
<td>最后一行</td>
</tr>
<tr>
<td>T.also</td>
<td>是</td>
<td>it</td>
<td>调用本身</td>
</tr>
<tr>
<td>T.apply</td>
<td>是</td>
<td>this</td>
<td>调用本身</td>
</tr>
</tbody></table>
<p>全文到这里就结束了，大家可以在项目中灵活的去运用，可以让代码的可读性更高，如果你在 Kotlin 中遇到了那些坑，欢迎在评论区分享，更多优秀的英文技术文章，点击这里 <a href="https://github.com/hi-dhl/Technical-Article-Translation">精选译文</a></p>
<p>更多关于 Kotlin 的内联函数 run, with, let, also, apply 在实际项目中的使用，可以看我另外一个项目 PokemonGo ，基于 Jetpack + MVVM + Repository + Data Mapper + Kotlin Flow + Kotlin 技巧的实战项目，可以点击下面链接前去查看。</p>
<p><a href="https://github.com/hi-dhl/PokemonGo">PokemonGo 仓库地址：https://github.com/hi-dhl/PokemonGo</a></p>
<p><img src="http://cdn.51git.cn/2020-07-23-Pokemon12.png" alt="PokemonGo"></p>
<h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><ul>
<li><a href="https://juejin.im/post/5eb58da05188256d6d6bb248">[译][Google工程师] 刚刚发布了 Fragment 的新特性 “Fragment 间传递数据的新方式” 以及源码分析</a> </li>
<li><a href="https://juejin.im/post/5ecb16f1f265da76fb0c3967">[译][Google工程师] 详解 FragmentFactory 如何优雅使用 Koin 以及部分源码分析</a></li>
<li><a href="https://juejin.im/post/5ebc1eb8e51d454dcf45744e?utm_source=gold_browser_extension">[译][2.4K Start] 放弃 Dagger 拥抱 Koin</a></li>
<li><a href="https://juejin.im/post/5ec0f3afe51d454db11f8a94#heading-7">[译][5k+] Kotlin 的性能优化那些事</a></li>
<li><a href="https://juejin.im/post/5ecc10626fb9a047e25d5aac">[译] 解密 RxJava 的异常处理机制</a></li>
<li><a href="https://juejin.im/post/5edd1f5ae51d45789e0d9a22">[译][1.4K+ Star] Kotlin 新秀 Coil VS Glide and Picasso</a></li>
<li><a href="https://github.com/hi-dhl/Technical-Article-Translation">更多……</a></li>
</ul>
</div><div><p style="height:15px"></p><ul class="page-copyright"><li><strong>本文作者：</strong>hi-dhl</li><li><strong>本文标题：</strong>「译」你中招了吗？ Kotlin 一个隐藏的坑</li><li><strong>本文链接：</strong><a href="" title="{page.title}">https://hi-dhl.com/2020/08/17/translate/07-kotlin-let-run/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hi-dhl.com" title="{page.title}">hi-dhl</a></li></ul><p style="height:15px"></p></div><!--!--><h1 class="title is-4 is-size-4-mobile"></h1></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/08/17/translate/06-coil-vs-glide-vs-picasso/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「译」Kotlin 新秀 Coil、Glide 和 Picasso 大比拼</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/08/17/translate/05-rxJava-error/"><span class="level-item">「译」解密 RxJava 的异常处理机制</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content template"><p align="center"><img src="http://cdn.51git.cn/2020-10-07-bytecode.png"></p><p>致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，在技术的道路上一起前进</p><h3 class="title is-4">Android10 源码分析</h3><p>正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Android10-Source-Analysis">Android10-Source-Analysis</a>。</p><h3 class="title is-4">算法题库的归纳和总结</h3><p>由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序。</p><ul><li>数据结构： 数组、栈、队列、字符串、链表、树……</li><li>算法： 查找算法、搜索算法、位运算、排序、数学、……</li></ul><p>每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：<a href="https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin">Leetcode-Solutions-with-Java-And-Kotlin</a>。</p><h3 class="title is-4">精选国外的技术文章</h3><p>目前正在整理和翻译一系列精选国外的技术文章，不仅仅是翻译，很多优秀的英文技术文章提供了很好思路和方法，每篇文章都会有<strong>译者思考</strong>部分，对原文的更加深入的解读，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Technical-Article-Translation">Technical-Article-Translation</a>。</p><p></p></div></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: undefined,
            appId: 'zfvr24HFhzQ5vtHkr4NQ1fmW-gzGzoHsz',
            appKey: 'RChgr9mR005hgu4yiQ4WQU3O',
            placeholder: '说点什么',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" style="max-height: 500px;overflow: auto;"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#前言"><span>前言</span></a></li><li><a class="is-flex" href="#译文"><span>译文</span></a></li><li><a class="is-flex" href="#译者思考"><span>译者思考</span></a><ul class="menu-list"><li><a class="is-flex" href="#总结和分析"><span>总结和分析</span></a></li><li><a class="is-flex" href="#如何区分-run-with-let-also-apply"><span>如何区分 run, with, let, also, apply</span></a></li><li><a class="is-flex" href="#是否是扩展函数"><span>是否是扩展函数</span></a></li><li><a class="is-flex" href="#作用域函数的参数（this、it）"><span>作用域函数的参数（this、it）</span></a></li><li><a class="is-flex" href="#作用域函数的返回值（调用本身、其他类型即最后一行）"><span>作用域函数的返回值（调用本身、其他类型即最后一行）</span></a></li><li><a class="is-flex" href="#T-apply-函数"><span>T.apply 函数</span></a></li><li><a class="is-flex" href="#使用-T-also-函数交换两个变量"><span>使用 T.also 函数交换两个变量</span></a></li><li><a class="is-flex" href="#汇总"><span>汇总</span></a></li></ul></li><li><a class="is-flex" href="#推荐文章"><span>推荐文章</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2021-06-12T11:16:02.855Z">2021-06-12</time></p><p class="title is-6"><a class="link-muted" href="/2021/06/12/Note/leetcode-0-200/">LeetCode 从 0 到 200 学到了什么</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-05-23T11:38:11.187Z">2021-05-23</time></p><p class="title is-6"><a class="link-muted" href="/2021/05/23/android/07-Android-resource/">Android 常用资源汇总</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-05-09T07:41:11.309Z">2021-05-09</time></p><p class="title is-6"><a class="link-muted" href="/2021/05/09/jetpack/13-compose/">开篇，初识 Compose，永久激活 IntelliJ IDEA</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-04-17T10:46:33.038Z">2021-04-17</time></p><p class="title is-6"><a class="link-muted" href="/2021/04/17/android/06-andrid12-change/">Android 12 行为变更，对应用产生的影响</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-01-26T02:56:06.126Z">2021-01-26</time></p><p class="title is-6"><a class="link-muted" href="/2021/01/26/AndroidStudio/04-androidstuido-3/">图解多平台 AndroidStudio 技巧(三)</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android-12/"><span class="level-start"><span class="level-item">Android 12</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android-AndroidStudio/"><span class="level-start"><span class="level-item">Android,AndroidStudio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android10/"><span class="level-start"><span class="level-item">Android10</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AndroidStudio/"><span class="level-start"><span class="level-item">AndroidStudio</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Jetpack/"><span class="level-start"><span class="level-item">Jetpack</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/translated/"><span class="level-start"><span class="level-item">译文</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%91%E6%96%87-AndroidStudio/"><span class="level-start"><span class="level-item">译文,AndroidStudio</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%91%E6%96%87-Kotlin/"><span class="level-start"><span class="level-item">译文,Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android-12/"><span class="tag">Android 12</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-包管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-窗口管理系统</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-资源管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AndroidStudio/"><span class="tag">AndroidStudio</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android%E6%BA%90%E7%A0%81/"><span class="tag">Android源码</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compose/"><span class="tag">Compose</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fragment/"><span class="tag">Fragment</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Jetpack/"><span class="tag">Jetpack</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Koin/"><span class="tag">Koin</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Protobuf/"><span class="tag">Protobuf</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kotlin/"><span class="tag">kotlin</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%91%E6%96%87/"><span class="tag">译文</span><span class="tag is-grey-lightest">9</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level-item"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/logo.png" alt="dhl" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="dhl" height="28"></a><p class="size-small"><span>&copy; 2021 dhl</span>  <a href="http://www.beian.miit.gov.cn/" target="_blank">京ICP备18050211号-2</a>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://hi-dhl.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://s9.cnzz.com/z_stat.php?id=1278919895&amp;web_id=1278919895" async></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/imaegoo/universe.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>