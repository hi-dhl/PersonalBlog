<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>「译」放弃 Dagger 拥抱 Koin - dhl</title><meta description="本文主要介绍 Dagger 和 Koin 优势和劣势，应该选择 Dagger 还是 Koin，为什么 Koin 可以做到无代码生成、无反射。"><meta property="og:type" content="blog"><meta property="og:title" content="「译」放弃 Dagger 拥抱 Koin"><meta property="og:url" content="https://hi-dhl.com/2020/08/04/translate/03-dagger-koin/"><meta property="og:site_name" content="dhl"><meta property="og:description" content="本文主要介绍 Dagger 和 Koin 优势和劣势，应该选择 Dagger 还是 Koin，为什么 Koin 可以做到无代码生成、无反射。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.51git.cn/2020-05-14-15893872014931.jpg"><meta property="article:published_time" content="2020-08-03T17:35:47.566Z"><meta property="article:modified_time" content="2020-08-16T17:10:09.816Z"><meta property="article:author" content="dhl"><meta property="article:tag" content="Fragment"><meta property="article:tag" content="Dagger"><meta property="article:tag" content="Koin"><meta property="article:tag" content="FragmentContainerView"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://cdn.51git.cn/2020-05-14-15893872014931.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hi-dhl.com/2020/08/04/translate/03-dagger-koin/"},"headline":"dhl","image":["http://cdn.51git.cn/2020-05-14-15893872014931.jpg"],"datePublished":"2020-08-03T17:35:47.566Z","dateModified":"2020-08-16T17:10:09.816Z","author":{"@type":"Person","name":"dhl"},"description":"本文主要介绍 Dagger 和 Koin 优势和劣势，应该选择 Dagger 还是 Koin，为什么 Koin 可以做到无代码生成、无反射。"}</script><link rel="canonical" href="https://hi-dhl.com/2020/08/04/translate/03-dagger-koin/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/logo.png" alt="dhl" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="dhl" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/categories/Jetpack">Jetpack</a><a class="navbar-item" href="/categories/Kotlin/">Kotlin</a><a class="navbar-item" href="/categories/Android10/">源码</a><a class="navbar-item" href="/categories/translated/">译文</a><a class="navbar-item" href="https://leetcode.hi-dhl.com">LeetCode</a><a class="navbar-item" href="https://offer.hi-dhl.com">算法</a><a class="navbar-item" href="https://site.51git.cn/">国内外书签</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hi-dhl"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="http://cdn.51git.cn/2020-05-14-15893872014931.jpg" alt="「译」放弃 Dagger 拥抱 Koin"></span></div><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile"></h1><h1 class="title is-3 is-size-4-mobile">「译」放弃 Dagger 拥抱 Koin</h1><div class="article-meta size-small level is-mobile"><div class="level-left"><span class="mr-2"><i class="fa fa-calendar"></i></span><time class="level-item" dateTime="2020-08-03T17:35:47.566Z" title="2020-08-03T17:35:47.566Z">2020-08-04</time><span class="mr-2"> <i class="fa fa-folder"></i></span><span class="level-item"><a class="link-muted" href="/categories/%E7%B2%BE%E9%80%89%E8%AF%91%E6%96%87/">精选译文</a></span><span class="mr-2"> <i class="fa fa-tag"></i></span><span class="level-item"><a class="link-muted" href="/tags/%E8%AF%91%E6%96%87/">译文</a><span> , </span><a class="link-muted" href="/tags/Koin/">Koin</a></span></div></div><div class="level-left article-meta size-small is-mobile"></div><div><p style="height:15px"></p><ul class="page-blockquote"><li>本文首发于公众号：ByteCode</li><li>致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Kotlin、Jetpack 源码相关的文章</li><li>如果评论区没有及时回复，欢迎来公众号：ByteCode 咨询</li></ul><p style="height:15px"></p></div><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<ul>
<li>原标题:  Koin vs Dagger, Say hello to Koin</li>
<li>原文地址: <a href="https://blog.usejournal.com/android-koin-with-mvvm-and-retrofit-e040e4e15f9d">https://blog.usejournal.com/android-koin…</a></li>
<li>原文作者：Farshid ABZ</li>
</ul>
</blockquote>
<p>作者这篇文章到目前为止已经收到了 2.4k+ 的赞，冲上了 Medium 热门，非常好的一篇文章，我也使用 Koin + kotlin + databinding 结合着 inline、reified 强大的特性封装了基础库，包含了 DataBindingActivity、DataBindingFragment、DataBindingDialog、DataBindingListAdapter 等等, 正在陆续添加新的组件。</p>
<ul>
<li><a href="https://juejin.im/post/5e9c434a51882573663f6cc6">文章：https://juejin.im/post/5e9c434a51882573663f6cc6</a></li>
<li><a href="https://juejin.im/post/5e9c434a51882573663f6cc6">GitHub：https://github.com/hi-dhl/JDataBinding</a></li>
</ul>
<p><strong>通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案</strong></p>
<ul>
<li>Dagger 和 Koin 优势劣势对比？应该选择 Dagger 还是 Koin？</li>
<li>koin 语法特性？</li>
<li>Koin 为什么可以做到无代码生成、无反射？</li>
<li>Inline 修饰符做什么用的？如何正确使用？带来的性能损失？<ul>
<li>只是用 Inline 修饰符，为什么编译器会给我们一个警告？ </li>
<li>为什么编译器建议 inline 修饰符需要和 lambda 表达式一起使用呢？</li>
<li>什么时候应该使用 inline 修饰符？</li>
</ul>
</li>
<li>Reified 修饰符做什么用？如何使用？</li>
<li>Koin 带来性能损失的那些事？</li>
<li>Kotlin 用 5 行代码实现快排算法？</li>
</ul>
<p>这篇文章涉及很多重要的知识点，请耐心读下去，我相信应该会给大家带来很多不一样的东西。</p>
<h2 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h2><p>当我正在反复学习 Dagger 的时候，我遇见了 Koin，Koin 不仅节省了我的时间，还提高了效率，将我从复杂 Dagger 给释放出来了。</p>
<p>这篇文章将会告诉你什么是 Koin，与 Dagger 对比有那些优势，以及如何使用 Koin。</p>
<h3 id="是什么-Koin"><a href="#是什么-Koin" class="headerlink" title="是什么 Koin"></a>是什么 Koin</h3><p>Koin 是为 Kotlin 开发者提供的一个实用型轻量级依赖注入框架，采用纯 Kotlin 语言编写而成，仅使用功能解析，无代理、无代码生成、无反射。</p>
<h3 id="Dagger-vs-Koin"><a href="#Dagger-vs-Koin" class="headerlink" title="Dagger vs Koin"></a>Dagger vs Koin</h3><p>为了正确比较这两种方式，我们用 Dagger 和 Koin 去实现了一个项目，项目的架构都是 MVVM，其中用到了 retrofit 和 LiveData，包含了 1 个Activity、4 个 fragments、5 个 view models、1 个 repository 和 1 个 web service 接口, 这应该是一个小型项目的基础架构了</p>
<p>先来看一下 DI 包下的结构，左边是 Dagger，右边是 Koin</p>
<p><img src="http://cdn.51git.cn/2020-05-14-15892088691787.jpg" alt=""></p>
<p>如你所见配置 Dagger 需要很多文件 而 Koin 只需要 2 个文件，例如 用 Dagger 注入 1 个 view models 就需要 3 个文件（真的需要用这么多文件吗？）</p>
<h4 id="比较-Dagger-和-Koin-代码行数"><a href="#比较-Dagger-和-Koin-代码行数" class="headerlink" title="比较 Dagger 和 Koin 代码行数"></a>比较 Dagger 和 Koin 代码行数</h4><p>我使用 <a href="https://plugins.jetbrains.com/plugin/4509-statistic">Statistic</a> 工具来统计的，反复对比了项目编译前和编译后，Dagger 和 Koin 生成的代码行数，结果是非常吃惊的</p>
<p><img src="http://cdn.51git.cn/2020-05-14-15892101014856.jpg" alt=""></p>
<p>正如你看到的 Dagger 生成的代码行比 Koin 多两倍</p>
<h4 id="Dagger-和-Koin-编译时间怎么样呢"><a href="#Dagger-和-Koin-编译时间怎么样呢" class="headerlink" title="Dagger 和 Koin 编译时间怎么样呢"></a>Dagger 和 Koin 编译时间怎么样呢</h4><p>每次编译之前我都会先 clean 然后才会 rebuild，我得到下面这个结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Koin:</span><br><span class="line">BUILD SUCCESSFUL in 17s</span><br><span class="line">88 actionable tasks: 83 executed, 5 up-to-date</span><br><span class="line"></span><br><span class="line">Dagger:</span><br><span class="line">BUILD SUCCESSFUL in 18s</span><br><span class="line">88 actionable tasks: 83 executed, 5 up-to-date</span><br></pre></td></tr></table></figure>

<p>我认为这个结果证明了，如果是在一个更大、更真实的项目中，这个代价是非常昂贵。</p>
<h4 id="Dagger-和-Koin-使用上怎么样呢"><a href="#Dagger-和-Koin-使用上怎么样呢" class="headerlink" title="Dagger 和 Koin 使用上怎么样呢"></a>Dagger 和 Koin 使用上怎么样呢</h4><p>如果你想在 MVVM 和 Android Support lib 中使用 Dagger 你必须这么做。</p>
<p>首先在 module gradle 中 添加 Dagger 依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kapt &quot;com.google.dagger:dagger-compiler:$dagger_version&quot;</span><br><span class="line">kapt &quot;com.google.dagger:dagger-android-processor:$dagger_version&quot;</span><br><span class="line">implementation &quot;com.google.dagger:dagger:$dagger_version&quot;</span><br></pre></td></tr></table></figure>

<p>然后创建完 modules 和 components 文件之后， 需要在 Application 中 初始化 Dagger（或者其他方式初始化 Dagger）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class MyApplication : Application(), HasActivityInjector &#123; </span><br><span class="line">    @Inject</span><br><span class="line">    lateinit var dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Activity&gt;</span><br><span class="line">    </span><br><span class="line">    override fun activityInjector() &#x3D; dispatchingAndroidInjector</span><br><span class="line">    </span><br><span class="line">    fun initDagger() &#123;</span><br><span class="line">       DaggerAppComponent</span><br><span class="line">          .builder()</span><br><span class="line">          .application(this)</span><br><span class="line">          .build()</span><br><span class="line">          .inject(this)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的 Activity 继承 BaseActivity，我们需要实现 HasSupportFragmentInjector 和 inject DispatchingAndroidInjector。</p>
<p>对于 view models，我们需要在 BaseFragment 中注入 ViewModelFactory，并实现 Injectable。</p>
<p>但这并不是全部。还有更多的事情要做。</p>
<p>对于每一个 ViewModel、Fragment 和 Activity 我们需要告诉 DI 如何注入它们，正如你所见我们有 ActivityModule、FragmentModule、和  ViewModelModule。</p>
<p>我们来看一下下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Module</span><br><span class="line">abstract class ActivityModule &#123;</span><br><span class="line">    @ContributesAndroidInjector(modules &#x3D; [FragmentModule::class])</span><br><span class="line">    abstract fun contributeMainActivity(): MainActivity</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;Add your other activities here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fragments 如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Module</span><br><span class="line">abstract class FragmentModule &#123;</span><br><span class="line">    @ContributesAndroidInjector</span><br><span class="line">    abstract fun contributeLoginFragment(): LoginFragment</span><br><span class="line"></span><br><span class="line">    @ContributesAndroidInjector</span><br><span class="line">    abstract fun contributeRegisterFragment(): RegisterFragment</span><br><span class="line"></span><br><span class="line">    @ContributesAndroidInjector</span><br><span class="line">    abstract fun contributeStartPageFragment(): StartPageFragment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewModels 如下所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Module</span><br><span class="line">abstract class ViewModelModule &#123;</span><br><span class="line"></span><br><span class="line">    @Binds</span><br><span class="line">    abstract fun bindViewModelFactory(factory: ViewModelFactory): ViewModelProvider.Factory</span><br><span class="line"></span><br><span class="line">    @Binds</span><br><span class="line">    @IntoMap</span><br><span class="line">    @ViewModelKey(loginViewModel::class)</span><br><span class="line">    abstract fun bindLoginFragmentViewModel(loginViewModel: loginViewModel): ViewModel</span><br><span class="line"></span><br><span class="line">    @Binds</span><br><span class="line">    @IntoMap</span><br><span class="line">    @ViewModelKey(StartPageViewModel::class)</span><br><span class="line">    abstract fun bindStartPageViewModel(startPageViewModel:  StartPageViewModel): ViewModel</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以你必须在 DI modules 中添加这些 Fragments、Activities 和 ViewModels。</p>
<p><strong>那么在 Koin 中如何做</strong></p>
<p>你需要在 module gradle 中添加 Koin 依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &quot;org.koin:koin-android-viewmodel:$koin_version&quot;</span><br></pre></td></tr></table></figure>

<p>然后我们需要创建 module 文件，稍后我告诉你怎么做，实际上我们并不需要像 Dagger 那么多文件。</p>
<p><strong>Dagger 还有其他问题</strong></p>
<p>学习 Dagger 成本是很高的，如果有人加入你的项目或者团队，他/她不得不花很多时间学习 Dagger，我使用 Dagger 两年了，到现在还不是很了解，每次我开始学习 Andorid 新技术的时候，我不得不去搜索和学习如何用 Dagger 实现新技术。</p>
<p><strong>来看一下 Koin 代码</strong></p>
<p>首先我们需要添加 Koin 依赖，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &quot;org.koin:koin-android-viewmodel:$koin_version&quot;</span><br></pre></td></tr></table></figure>

<p>我们使用的是 koin-android-viewmodel 库，因为我们希望在 MVVM 中使用它，当然还有其他的依赖库。</p>
<p>添加完依赖之后，我们来实现第一个 module 文件，像 Dagger 一样，可以在一个单独的文件中实现每个模块，但是由于代码简单，我决定在一个文件中实现所有模块，你也可以把它们分开。</p>
<p>首先我们需要了解一下 koin 语法特性</p>
<ul>
<li>get()： 解析 Koin 模块中的实例，调用 get() 函数解析所请求组件需要的实例，这个 get() 函数通常用于构造函数中，注入构造函数值</li>
<li>factory：声明这是一个工厂组件，每次请求都为您提供一个新实例</li>
<li>single：采用单例设计模式</li>
<li>name：用于命名定义，当您希望具有不同类型的同一个类的多个实例时，需要使用它</li>
</ul>
<p>我们没有创建具有多个注释和多个组件的许多文件，而是为 DI 注入每个类的时候，提供一个简单、可读的文件。</p>
<p><strong>了解完 koin 语法特性之后，我们来解释下面代码什么意思</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private val retrofit: Retrofit &#x3D; createNetworkClient()</span><br></pre></td></tr></table></figure>

<p>createNetworkClient 方法创建 Retrofit 实例，设置 baseUrl，添加  ConverterFactory 和 Interceptor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private val generalApi: GeneralApi &#x3D;  retrofit.create(GeneralApi::class.java)</span><br><span class="line">private val authApi: AuthApi &#x3D; retrofit.create(AuthApi::class.java)</span><br></pre></td></tr></table></figure>

<p>AuthApi 和 GeneralApi 是 retrofit 接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val viewModelModule &#x3D; module &#123;</span><br><span class="line">    viewModel &#123; LoginFragmentViewModel(get()) &#125;</span><br><span class="line">    viewModel &#123; StartPageViewModel() &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 module 文件中声明为 viewModel， Koin 将会向 ViewModelFactory 提供 viewModel，将其绑定到当前组件。</p>
<p>正如你所见，在 LoginFragmentViewModel 构造函数中有调用了 get() 方法，get() 会解析一个 LoginFragmentViewModel 需要的参数，然后传递给 LoginFragmentViewModel，这个参数就是 AuthRepo。</p>
<p>最后在 Application onCreate 方法中添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startKoin(this, listOf(repositoryModule, networkModule, viewModelModule))</span><br></pre></td></tr></table></figure>

<p>这里只是调用 startKoin 方法，传入一个上下文和一个希望用来初始化 Koin 的模块列表。</p>
<p>现在使用 ViewModel 比使用纯 ViewModel 更容易，在 Fragment 和 Activity 视图中添加下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private val startPageViewModel: StartPageViewModel by viewModel()</span><br></pre></td></tr></table></figure>

<p>通过这段代码，koin 为您创建了一个 StartPageViewModel 对象，现在你可以在 Fragment 和 Activity 中使用 view model</p>
<h2 id="译者思考"><a href="#译者思考" class="headerlink" title="译者思考"></a>译者思考</h2><p>作者总共从以下 4 个方面对比了 Dagger 和 Kotlin：</p>
<ul>
<li>文件数量：基于 mvvm 架构，分别使用了 Dagger 和 koltin 作为依赖注入框架，初始化 Dagger 时至少需要 9 个文件，而 koltin 只需要 2 个文件，Dagger 文件数量远超过 koltin</li>
<li>代码行数：作者使用了 Statistic 工具，反复对比了项目编译前和编译后，Dagger 和 Koin 生成的代码行数，如下图所示</li>
</ul>
<p><img src="http://cdn.51git.cn/2020-05-14-15892938609364.jpg" alt=""></p>
<ul>
<li>反复的对比了 Dagger 和 Koin 编译时间，结果如下所示 koin 比 Dagger 快</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Koin:</span><br><span class="line">BUILD SUCCESSFUL in 17s</span><br><span class="line">88 actionable tasks: 83 executed, 5 up-to-date</span><br><span class="line"></span><br><span class="line">Dagger:</span><br><span class="line">BUILD SUCCESSFUL in 18s</span><br><span class="line">88 actionable tasks: 83 executed, 5 up-to-date</span><br></pre></td></tr></table></figure>

<ul>
<li>学习成本巨大，如果使用了 Dagger 朋友，应该和作者的感觉是一样的，Dagger 学习的成本是非常高的，如果项目中引入了 Dagger 意味着团队每个人都要学习 Dagger，无疑这个成本是巨大的，而且使用起来非常的复杂</li>
</ul>
<p><strong>注意：作者在 Application 中调用 startKoin 方法初始化 Koin 的模块列表，是 Koin 1X 的方式，Koin 团队在 2x 的时候做了很多改动（下面会介绍），初始化 Koin 的模块列有所改动，代码如下所示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startKoin &#123;</span><br><span class="line">    &#x2F;&#x2F; Use Koin Android Logger</span><br><span class="line">    androidLogger()</span><br><span class="line">    &#x2F;&#x2F; declare Android context</span><br><span class="line">    androidContext(this@MainApplication)</span><br><span class="line">    &#x2F;&#x2F; declare modules to use</span><br><span class="line">    modules(module1, module2 ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Koin-为什么可以做到无代码生成、无反射"><a href="#Koin-为什么可以做到无代码生成、无反射" class="headerlink" title="Koin 为什么可以做到无代码生成、无反射"></a>Koin 为什么可以做到无代码生成、无反射</h3><p>Koin 作为一个轻量级依赖注入框架，为什么可以做到无代码生成、无反射？因为 kotlin 强大的语法糖（例如 Inline、Reified 等等）和函数式编程，我们先来看一段代码。<br><strong>koin-projects/koin-core/src/main/kotlin/org/koin/dsl/Module.kt</strong></p>
<p><strong>案例一</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  typealias 是用来为已经存在的类型重新定义名字的</span><br><span class="line">typealias ModuleDeclaration &#x3D; Module.() -&gt; Unit</span><br><span class="line"></span><br><span class="line">fun module(createdAtStart: Boolean &#x3D; false, override: Boolean &#x3D; false, moduleDeclaration: ModuleDeclaration): Module &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 Module</span><br><span class="line">    val module &#x3D; Module(createdAtStart, override)</span><br><span class="line">    &#x2F;&#x2F; 执行匿扩展函数</span><br><span class="line">    moduleDeclaration(module)</span><br><span class="line">    return module</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如何使用</span><br><span class="line">val mModule: Module &#x3D; module &#123;</span><br><span class="line">   single &#123; ... &#125;</span><br><span class="line">   factory &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Module 是一个 lambda 表达式，才可以在 “{}” 里面自由定义 single 和 factory，会等到你需要的时候才会执行。</p>
<p><strong>案例二</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun &lt;reified T : ViewModel&gt; Module.viewModel(</span><br><span class="line">    qualifier: Qualifier? &#x3D; null,</span><br><span class="line">    override: Boolean &#x3D; false,</span><br><span class="line">    noinline definition: Definition&lt;T&gt;</span><br><span class="line">): BeanDefinition&lt;T&gt; &#123;</span><br><span class="line">    val beanDefinition &#x3D; factory(qualifier, override, definition)</span><br><span class="line">    beanDefinition.setIsViewModel()</span><br><span class="line">    return beanDefinition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联函数支持具体化的类型参数，使用 reified 修饰符来限定类型参数，以在函数内部访问它了，由于函数是内联的，不需要反射，通过上面两个案例，说明了为什么 Koin 可以做到无代码生成、无反射。建议大家都去看看 Koin 的源码，能够从中学到很多技巧，后面我会花好几篇文章分析 Koin 源码。</p>
<h3 id="Inline-修饰符带来的性能损失"><a href="#Inline-修饰符带来的性能损失" class="headerlink" title="Inline 修饰符带来的性能损失"></a>Inline 修饰符带来的性能损失</h3><p>Inline (<a href="https://www.kotlincn.net/docs/reference/inline-functions.html">内联函数</a>) 的作用：提升运行效率，调用被 inline 修饰符的函数，会把里面的代码放到我调用的地方。</p>
<p>如果阅读过 Koin 源码的朋友，应该会发现 inline 都是和 lambda 表达式和 reified 修饰符配套在一起使用的，如果只使用 inline 修饰符标记函数会怎么样？</p>
<p>只使用 inline 修饰符会有性能问题，在这篇文章 <a href="https://blog.kotlin-academy.com/effective-kotlin-consider-inline-modifier-for-higher-order-functions-758afcaffc11">Consider inline modifier for higher-order functions</a> 也分析了只使用 inline 修饰符为什么会带来性能问题，并且 Android Studio 也会给一个大大大的警告。</p>
<p><img src="http://cdn.51git.cn/2020-05-14-15892979748233.jpg" alt=""></p>
<p>编译器建议我们在含有 lambda 表达式作为形参的函数中使用内联，既然 Inline 修饰符可以提升运行效率，为什么编译器会给我们一个警告？ 为什么编译器建议 inline 修饰符需要和 lambda 表达式一起使用呢？</p>
<p><strong>1. 既然 Inline 修饰符可以提升运行效率，为什么编译器会给我们一个警告？</strong></p>
<p>刚才我们说过调用被 inline 修饰符的函数，会把里面的代码放到我调用的地方，来看一下下面这段代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun twoPrintTwo() &#123;</span><br><span class="line">    print(2)</span><br><span class="line">    print(2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline fun twoTwoPrintTwo() &#123;</span><br><span class="line">    twoPrintTwo()</span><br><span class="line">    twoPrintTwo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline fun twoTwoTwoPrintTwo() &#123;</span><br><span class="line">    twoTwoPrintTwo()</span><br><span class="line">    twoTwoPrintTwo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun twoTwoTwoTwoPrintTwo() &#123;</span><br><span class="line">    twoTwoTwoPrintTwo()</span><br><span class="line">    twoTwoTwoPrintTwo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完最后一个方法 twoTwoTwoTwoPrintTwo，反编译出来的结果是非常令人吃惊的，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final void twoTwoTwoTwoPrintTwo() &#123;</span><br><span class="line">   byte var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print(var1);</span><br><span class="line">   var1 &#x3D; 2;</span><br><span class="line">   System.out.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这显示了使用 Inline 修饰符的主要问题，当我们过度使用它们时，代码会快速增长。这就是为什么 IntelliJ 在我们使用它的时候会给出警告。</p>
<p><strong>2. 为什么编译器建议 inline 修饰符需要和 lambda 表达式一起使用呢？</strong></p>
<p>因为 JVM 是不支持 lambda 表达式的，非内联函数中的 Lambda 表达式会被编译为匿名类，这对性能开销是非常巨大的，而且它们的创建和使用都较慢，当我们使用 inline 修饰符时，我们根本不需要创建任何其他类，来看一下下面代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    var a &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 带 inline 的 Lambda 表达式</span><br><span class="line">    repeat(100_000_000) &#123;</span><br><span class="line">        a +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    var b &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 不带 inline 的 Lambda 表达式</span><br><span class="line">    noinlineRepeat(100_000_000) &#123;</span><br><span class="line">        b +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Java 代码</span><br><span class="line">public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">   int a &#x3D; 0;</span><br><span class="line">   &#x2F;&#x2F; 带 inline 的 Lambda 表达式, 会把里面的代码放到我调用的地方</span><br><span class="line">   int times$iv &#x3D; 100000000;</span><br><span class="line">   int var3 &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   for(int var4 &#x3D; times$iv; var3 &lt; var4; ++var3) &#123;</span><br><span class="line">      ++a;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 不带 inline 的 Lambda 表达式，会被编译为匿名类</span><br><span class="line">   final IntRef b &#x3D; new IntRef();</span><br><span class="line">   b.element &#x3D; 0;</span><br><span class="line">   noinlineRepeat(100000000, (Function1)(new Function1() &#123;</span><br><span class="line">      public Object invoke(Object var1) &#123;</span><br><span class="line">         ++b.element;</span><br><span class="line">         return Unit.INSTANCE;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那么我们应该在什么时候使用 inline 修饰符呢？</strong></p>
<p>使用 inline 修饰符时最常见的场景就是把函数作为另一个函数的参数时(高阶函数)，例如 filter、map、joinToString 或者一些独立的函数 repeat。</p>
<p>如果没有函数类型作为参数，也没有 reified 实化类型参数时，不应该使用 inline 修饰符了。</p>
<p>从分析 Koin 源码，inline 应该 lambda 表达式或者 reified 修饰符配合在一起使用的，另外 Android Studio 越来越智能了，如果在不正确的地方使用，会有一个大大大的警告。</p>
<h3 id="Reified-修饰符，具体化的类型参数"><a href="#Reified-修饰符，具体化的类型参数" class="headerlink" title="Reified 修饰符，具体化的类型参数"></a>Reified 修饰符，具体化的类型参数</h3><p>reified （<a href="https://www.kotlincn.net/docs/reference/inline-functions.html">具体化的类型参数</a>）：使用 reified 修饰符来限定类型参数，结合着 inline 修饰符具体化的类型参数，可以直接在函数内部访问它。</p>
<p>我想分享两个使用 Reified 修饰符很常见的例子 <a href="https://typealias.com/guides/getting-real-with-reified-type-parameters/">reified-type-parameters</a>，使用 Java 是不可能实现的。</p>
<p><strong>案例一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; Gson.fromJson(json: String) &#x3D; </span><br><span class="line">        fromJson(json, T::class.java) </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">val user: User &#x3D; Gson().fromJson(json)</span><br><span class="line">val user &#x3D; Gson().fromJson&lt;User&gt;(json)</span><br></pre></td></tr></table></figure>

<p><strong>案例二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline fun &lt;reified T: Activity&gt; Context.startActivity(vararg params: Pair&lt;String, Any?&gt;) &#x3D;</span><br><span class="line">        AnkoInternals.internalStartActivity(this, T::class.java, params)</span><br></pre></td></tr></table></figure>

<h3 id="Koin-带来性能损失的那些事"><a href="#Koin-带来性能损失的那些事" class="headerlink" title="Koin 带来性能损失的那些事"></a>Koin 带来性能损失的那些事</h3><p>思考了很久需不需要写这部分内容，因为在 Koin 2x 的版本的时候已经修复了，这是官方的链接 <a href="https://medium.com/koin-developers/news-from-the-trenches-whats-next-for-koin-994791d572d5">News from the trenches — What’s next for Koin?</a>，后来想想还是写写吧，作为自己的一个学习笔记。</p>
<p>这个源于有个人开了一个 Issue(<a href="https://github.com/InsertKoinIO/koin/issues/281">Bad performance in some Android devices</a>) 现在已经被关闭了，他指出了当 Dependency 数量越来越多的时候，Koin 效能会越来越差，而且还做了一个对比如下图所示：</p>
<p><img src="http://cdn.51git.cn/2020-05-14-15893022611028.jpg" alt=""></p>
<p>如果使用过 Koin 1x 的朋友应该会感觉到，引入 Koin 1x 冷启动时间边长了，而且在有大量依赖的时候，查找的时间会有点长，后来 Koin 团队也发现确实存在这个问题，到底是怎么回事呢？</p>
<p>他们在 BeanRegistry 类中维护了一个列表，用来存储了 BeanDefinition，然后使用 Kotlin 的 filter 函数找出对应的 BeanDefinition，所以找出一个 Definition 时间复杂度是 O(n)，如果平均有 M 层 Dependency，那么时间复杂度会变成 O(m*n)。</p>
<p>Koin 团队的解决方案是用了 HashMap，使用空间换取时间，查找一个 Definition 时间复杂度变成了 O(1)，优化之后的结果如下：</p>
<p><img src="http://cdn.51git.cn/2020-05-14-15893026374241.jpg" alt=""></p>
<p>Koin 2x 不仅在性能优化上有很大的提升，也拓展了很多新的特性，例如 FragmentFactory 能够依赖注入到 Fragments 中就像 ViewModels 一样，还有自动拆箱等等，在后面的文章会详细的分析一下。</p>
<h3 id="Kotlin-用-5-行代码实现快排算法"><a href="#Kotlin-用-5-行代码实现快排算法" class="headerlink" title="Kotlin 用 5 行代码实现快排算法"></a>Kotlin 用 5 行代码实现快排算法</h3><p>我想分享一个快速排序算法，这是一个很酷的函数编程的例子 <a href="https://www.freecodecamp.org/news/my-favorite-examples-of-functional-programming-in-kotlin-e69217b39112/">share cool examples</a>，当我看到这段代码的时候惊呆了，居然还可以这么写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun &lt;T : Comparable&lt;T&gt;&gt; List&lt;T&gt;.quickSort(): List&lt;T&gt; &#x3D; </span><br><span class="line">    if(size &lt; 2) this</span><br><span class="line">    else &#123;</span><br><span class="line">        val pivot &#x3D; first()</span><br><span class="line">        val (smaller, greater) &#x3D; drop(1).partition &#123; it &lt;&#x3D; pivot&#125;</span><br><span class="line">        smaller.quickSort() + pivot + greater.quickSort()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 使用 [2,5,1] -&gt; [1,2,5]</span><br><span class="line">listOf(2,5,1).quickSort() &#x2F;&#x2F; [1,2,5]</span><br></pre></td></tr></table></figure>

<h3 id="最后分享一个译者自己撸的导航网站"><a href="#最后分享一个译者自己撸的导航网站" class="headerlink" title="最后分享一个译者自己撸的导航网站"></a>最后分享一个译者自己撸的导航网站</h3><p>译者基于 Python + Material Design 开发的 “<a href="http://site.51git.cn/">为互联网人而设计   国内国外名站导航</a>“ ，收集了国内外热门网址，涵括新闻、体育、生活、娱乐、设计、产品、运营、前端开发、Android开发等等导航网站，如果你有什么好的建议，也可以留言，导航地址 ： <a href="http://site.51git.cn/">http://site.51git.cn/</a> </p>
<p>ps: 网站中的地址如果有原作者不希望展示的，可以留言告诉我，我会立刻删除</p>
<p><strong>国际资讯网址大全</strong><br><img src="http://cdn.51git.cn/2020-05-14-15893890491106.jpg" alt=""></p>
<p><strong>Android 网址大全</strong><br><img src="http://cdn.51git.cn/2020-05-14-15893894983433.jpg" alt=""></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.freecodecamp.org/news/my-favorite-examples-of-functional-programming-in-kotlin-e69217b39112/">My favorite examples of functional programming in Kotlin</a></li>
<li><a href="https://insert-koin.io/">koin 官网:https://insert-koin.io/</a></li>
<li><a href="https://blog.kotlin-academy.com/effective-kotlin-consider-inline-modifier-for-higher-order-functions-758afcaffc11">Effective Kotlin: Consider inline modifier for higher-order functions</a></li>
</ul>
<h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><ul>
<li><a href="https://juejin.im/post/5eb58da05188256d6d6bb248">[译][Google工程师] 刚刚发布了 Fragment 的新特性 “Fragment 间传递数据的新方式” 以及源码分析</a> </li>
<li><a href="https://juejin.im/post/5ecb16f1f265da76fb0c3967">[译][Google工程师] 详解 FragmentFactory 如何优雅使用 Koin 以及部分源码分析</a></li>
<li><a href="https://juejin.im/post/5ebc1eb8e51d454dcf45744e?utm_source=gold_browser_extension">[译][2.4K Start] 放弃 Dagger 拥抱 Koin</a></li>
<li><a href="https://juejin.im/post/5ec0f3afe51d454db11f8a94#heading-7">[译][5k+] Kotlin 的性能优化那些事</a></li>
<li><a href="https://juejin.im/post/5ecc10626fb9a047e25d5aac">[译] 解密 RxJava 的异常处理机制</a></li>
<li><a href="https://juejin.im/post/5edd1f5ae51d45789e0d9a22">[译][1.4K+ Star] Kotlin 新秀 Coil VS Glide and Picasso</a></li>
<li><a href="https://github.com/hi-dhl/Technical-Article-Translation">更多……</a></li>
</ul>
</div><div><p style="height:15px"></p><ul class="page-copyright"><li><strong>本文作者：</strong>hi-dhl</li><li><strong>本文标题：</strong>「译」放弃 Dagger 拥抱 Koin</li><li><strong>本文链接：</strong><a href="" title="{page.title}">https://hi-dhl.com/2020/08/04/translate/03-dagger-koin/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hi-dhl.com" title="{page.title}">hi-dhl</a></li></ul><p style="height:15px"></p></div><!--!--><h1 class="title is-4 is-size-4-mobile"></h1></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/08/05/translate/04-kotlin-performance/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「译」Kotlin 的性能优化那些事</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/31/translate/02-fragment-data/"><span class="level-item">「译」Google 建议使用这些 Fragment 的新特性</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content template"><p align="center"><img src="http://cdn.51git.cn/2020-10-07-bytecode.png"></p><p>致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，在技术的道路上一起前进</p><h3 class="title is-4">Android10 源码分析</h3><p>正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Android10-Source-Analysis">Android10-Source-Analysis</a>。</p><h3 class="title is-4">算法题库的归纳和总结</h3><p>由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序。</p><ul><li>数据结构： 数组、栈、队列、字符串、链表、树……</li><li>算法： 查找算法、搜索算法、位运算、排序、数学、……</li></ul><p>每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：<a href="https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin">Leetcode-Solutions-with-Java-And-Kotlin</a>。</p><h3 class="title is-4">精选国外的技术文章</h3><p>目前正在整理和翻译一系列精选国外的技术文章，不仅仅是翻译，很多优秀的英文技术文章提供了很好思路和方法，每篇文章都会有<strong>译者思考</strong>部分，对原文的更加深入的解读，可以关注我 GitHub 上的 <a href="https://github.com/hi-dhl/Technical-Article-Translation">Technical-Article-Translation</a>。</p><p></p></div></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: undefined,
            appId: 'zfvr24HFhzQ5vtHkr4NQ1fmW-gzGzoHsz',
            appKey: 'RChgr9mR005hgu4yiQ4WQU3O',
            placeholder: '说点什么',
            avatar: 'mm',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" style="max-height: 500px;overflow: auto;"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#前言"><span>前言</span></a></li><li><a class="is-flex" href="#译文"><span>译文</span></a><ul class="menu-list"><li><a class="is-flex" href="#是什么-Koin"><span>是什么 Koin</span></a></li><li><a class="is-flex" href="#Dagger-vs-Koin"><span>Dagger vs Koin</span></a><ul class="menu-list"><li><a class="is-flex" href="#比较-Dagger-和-Koin-代码行数"><span>比较 Dagger 和 Koin 代码行数</span></a></li><li><a class="is-flex" href="#Dagger-和-Koin-编译时间怎么样呢"><span>Dagger 和 Koin 编译时间怎么样呢</span></a></li><li><a class="is-flex" href="#Dagger-和-Koin-使用上怎么样呢"><span>Dagger 和 Koin 使用上怎么样呢</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#译者思考"><span>译者思考</span></a><ul class="menu-list"><li><a class="is-flex" href="#Koin-为什么可以做到无代码生成、无反射"><span>Koin 为什么可以做到无代码生成、无反射</span></a></li><li><a class="is-flex" href="#Inline-修饰符带来的性能损失"><span>Inline 修饰符带来的性能损失</span></a></li><li><a class="is-flex" href="#Reified-修饰符，具体化的类型参数"><span>Reified 修饰符，具体化的类型参数</span></a></li><li><a class="is-flex" href="#Koin-带来性能损失的那些事"><span>Koin 带来性能损失的那些事</span></a></li><li><a class="is-flex" href="#Kotlin-用-5-行代码实现快排算法"><span>Kotlin 用 5 行代码实现快排算法</span></a></li><li><a class="is-flex" href="#最后分享一个译者自己撸的导航网站"><span>最后分享一个译者自己撸的导航网站</span></a></li></ul></li><li><a class="is-flex" href="#参考文献"><span>参考文献</span></a></li><li><a class="is-flex" href="#推荐文章"><span>推荐文章</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-08T08:19:47.188Z">2020-11-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/08/jetpack/12-porot-datastore/">Google | 再见 SharedPreferences 拥抱 Jetpack DataStore(二)</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-08T08:16:13.718Z">2020-11-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/08/translate/08-java-or-kotlin/">「译」Google 官方正解是否应该学习 Kotlin</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-28T14:25:50.792Z">2020-10-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/28/jetpack/05-probuff-AndroidStudio/">Protobuf | 安装 Gradle 插件编译 proto 文件</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-28T14:21:39.485Z">2020-10-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/28/android/05-probuff-mac/">Protobuf | 如何在 MAC 上安装 Protobuf 编译 proto 文件</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-28T14:03:07.989Z">2020-10-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/28/android/04-probuff-ubuntu/">Protobuf | 如何在 ubuntu 上安装 Protobuf 编译 proto 文件</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android10/"><span class="level-start"><span class="level-item">Android10</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AndroidStudio/"><span class="level-start"><span class="level-item">AndroidStudio</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Jetpack/"><span class="level-start"><span class="level-item">Jetpack</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%B2%BE%E9%80%89%E8%AF%91%E6%96%87/"><span class="level-start"><span class="level-item">精选译文</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%B2%BE%E9%80%89%E8%AF%91%E6%96%87-Kotlin/"><span class="level-start"><span class="level-item">精选译文,Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-包管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-窗口管理系统</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android10-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="tag">Android10-资源管理系统</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AndroidStudio/"><span class="tag">AndroidStudio</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android%E6%BA%90%E7%A0%81/"><span class="tag">Android源码</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fragment/"><span class="tag">Fragment</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Jetpack/"><span class="tag">Jetpack</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Koin/"><span class="tag">Koin</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Protobuf/"><span class="tag">Protobuf</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxJava/"><span class="tag">RxJava</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kotlin/"><span class="tag">kotlin</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%91%E6%96%87/"><span class="tag">译文</span><span class="tag is-grey-lightest">8</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level-item"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/logo.png" alt="dhl" height="28"><img class="logo-img-dark" src="/img/logo.png" alt="dhl" height="28"></a><p class="size-small"><span>&copy; 2020 dhl</span>  <a href="http://www.beian.miit.gov.cn/" target="_blank">京ICP备18050211号-2</a>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://hi-dhl.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://s9.cnzz.com/z_stat.php?id=1278919895&amp;web_id=1278919895" async></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/imaegoo/universe.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>