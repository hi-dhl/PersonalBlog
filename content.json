{"pages":[{"title":"","text":"google-site-verification: googlede5fd50279499fe2.html","link":"/googlede5fd50279499fe2.html"},{"title":"LeetCode二分查找：寻找比目标字母大的最小字母","text":"题目来源于 LeetCode 上第 744 号（Find Smallest Letter Greater Than Target）问题：寻找比目标字母大的最小字母。题目难度为 Easy。 英文地址：https://leetcode.com/problems/find-smallest-letter-greater-than-target/ 中文地址：https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/ 题目描述Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target. Letters also wrap around. For example, if the target is target = ‘z’ and letters = [‘a’, ‘b’], the answer is ‘a’. Examples: Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;a&quot; Output: &quot;c&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;c&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;d&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;g&quot; Output: &quot;j&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;j&quot; Output: &quot;c&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;k&quot; Output: &quot;c&quot;Note: 1. letters has a length in range [2, 10000]. 2. letters consists of lowercase letters, and contains at least 2 unique letters. 3. target is a lowercase letter. 二分查找从题意分析从有序列表中找比目标字母大的最小字母得知，这题应该使用二分查找，因为二分查找的时间复杂度 O(logn) 但是这题目有个坑，就是题意给的不准确，笔者也提交几次才通过，总结规律如下： 当 target &lt; letters[0] 时，即 letters[0] 是比目标字母大的最小字母，返回 letters[0] 当 target &gt;= letters[height -1], 即返回 letters[0] Java 实现class Solution { public char nextGreatestLetter(char[] letters, char target) { int low = 0; int height = letters.length - 1; if (target &lt; letters[0] || target &gt;= letters[height]) return letters[0]; while (low &lt;= height) { int mind = (low + height) &gt;&gt;&gt; 1; if (letters[mind] &lt;= target) { low = mind + 1; } else { height = mind - 1; } } return letters[low]; }} Koltin 实现class Solution { fun nextGreatestLetter(letters: CharArray, target: Char): Char { var low = 0 var height = letters.size - 1 if (target &lt; letters[0] || target &gt;= letters[height]) { return letters[0] } while (low &lt;= height) { val mid = (low + height) ushr 1 when { letters[mid] &lt;= target -&gt; low = mid + 1 else -&gt; height = mid - 1 } } return letters[low] }}","link":"/backup/LeetCode/binary-search/03-find-letter.html"},{"title":"LeetCode二分查找：有效的完全平方数","text":"题目来源于 LeetCode 上第 367 号（Valid Perfect Square）问题：有效的完全平方数。题目难度为 Easy。 英文地址：https://leetcode.com/problems/valid-perfect-square/ 中文地址：https://leetcode-cn.com/problems/valid-perfect-square/ 题目描述Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: Input: 16Output: true Example 2: Input: 14Output: false 思路：二分查找什么是完全平方数？维基百科 数学上，平方数，或称完全平方数，是指可以写成某个整数的平方的数，即其平方根为整数的数。例如，9 = 3 × 3，它是一个平方数。 二分法的解题思路大致以下几个步骤： 寻找完全平方数 x 的区间范围：[low, height] 用二分法在区间 [low, height] 内寻找完全平方数 当 low &lt;= height 时：令 mind = (low + height) / 2，square = mind * mind 比较 square 与 x： 如果 square &gt; x，则 height = mind -1。 如果 square &lt; x，则 low = mind + 1。 如果 square == x，即完全平方数为 mind，返回 true。 如果在区间内没有找到，则返回 false。 如何确定 x 的区间范围：[low, height]？ 根据上面的概念 完全平方数 是某个整数的平方的数，也就是说 完全平方数 = n *n，例如，9 = 3 × 3 当 x &gt;= 2 时：它的整数平方根一定小于 x / 2 且大于 0，即 0 &lt; a &lt; x / 2 当 x =1 时：即 1 / 2 的值为0了，所以为了兼顾 1 的特殊情况，需要将边界设为 x / 2 +1 综合以上两种情况 x 的区间范围：[0, x / 2 + 1]，为了提高效率所以使用了位运算符，即 x/2 等价于 x &gt;&gt;&gt; 1 Java实现public class Solution { public boolean isPerfectSquare(int num) { long low = 0; long height = (num &gt;&gt;&gt; 1) + 1; while (low &lt;= height) { long mind = (low + height) &gt;&gt;&gt; 1; long square = mind * mind; if (square == num) { return true; } else if (square &lt; num) { low = mind + 1; } else { height = mind - 1; } } return false; }} Koltin实现class Solution { fun isPerfectSquare(num: Int): Boolean { var low = 0L var height = (num ushr 1).toLong() + 1 var target = num.toLong() while (low &lt;= height) { val mind: Long = (low + height) ushr 1 val square = mind * mind when { square == target -&gt; return true square &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return false }}","link":"/backup/LeetCode/binary-search/01-square.html"},{"title":"LeetCode二分查找：X的平方根","text":"题目来源于 LeetCode 上第 69号（Sqrt(x)）问题：X的平方根。题目难度为 Easy。 英文地址：https://leetcode.com/problems/sqrtx/ 中文地址：https://leetcode-cn.com/problems/sqrtx/ 题目描述Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4Output: 2 Example 2: Input: 8Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 思路：二分查找二分法的解题思路大致以下几个步骤： 寻找平方根 x 的区间范围：[low, height] 用二分法在区间 [low, height] 内寻找平方根 当 low &lt;= height 时：令 mind = (low + height) / 2，square = mind * mind 比较 square 与 x： 如果 square &gt; x，则 height = mind -1。 如果 square &lt; x，则 low = mind + 1。 如果 square == x，即平方根为 mind，返回 mind。 如果在区间内没有找到，则返回 height。 如何确定 x 的区间范围：[low, height]？ 当 x &gt;= 2 时：它的整数平方根一定小于 x / 2 且大于 0，即 0 &lt; a &lt; x / 2，例如 9 的的平方根是 3，16 的平方根是 4，8 的平方根是 2.82842… 取整数部分即是 2，以此类类推可以将区间范围在次缩小 即 0 &lt; a &lt; x / 4 当 x =1 时：即 1 / 4 的值为0了，所以为了兼顾 1 的特殊情况，需要将边界设为 x / 4 +1 综合以上两种情况 x 的区间范围：[0, x / 4 + 1]，为了提高效率所以使用了位运算符，即 x/4 等价于 x &gt;&gt;&gt; 2 Java实现class Solution { public int mySqrt(int x) { long low = 0; long height = (x &gt;&gt;&gt; 2) + 1; long lx = (long) x; while (low &lt;= height) { long mind = (low + height) &gt;&gt;&gt; 1; long square = mind * mind; if (square == lx) { return (int) mind; } else if (square &lt; lx) { low = mind + 1; } else { height = mind - 1; } } return (int)height; }} Kotlin 实现class Solution { fun mySqrt(x: Int): Int { var low = 0L var height = (x ushr 2).toLong() + 1 val target = x.toLong() while (low &lt;= height) { val mind = (low + height) ushr 1 val square: Long = mind * mind when { square == target -&gt; return mind.toInt() square &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return height.toInt() }}","link":"/backup/LeetCode/binary-search/02-x-square.html"},{"title":"LeetCode 数组：2020 力扣杯：拿硬币","text":"题目来源于 2020 力扣杯！Code Your Future 春季全国编程大赛 01：拿硬币。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/na-ying-bi/ 题目描述桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。 示例 1： 输入：[4,2,1]输出：4解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例 2： 输入：[2,3,10]输出：8 限制： 1 &lt;= n &lt;= 41 &lt;= coins[i] &lt;= 10 思路根据题意每次至少可以拿一枚或者两枚力口币，求拿完所有力扣币的最少次数，根据它的限制条件 1 &lt;= coins[i] &lt;= 10 列举可能性找规律 当coins[1]时，第一次拿一枚，至少1次 当coins[2]时，第一次拿两枚，至少1次 当coins[3]时，第一次拿两枚，第二次拿一枚，至少2次 当coins[4]时，第一次拿两枚，第二次拿两枚，至少2次 当coins[5]时，第一次拿两枚，第二次拿两枚，第三次拿一枚，至少3次 当coins[6]时，第一次拿两枚，第二次拿两枚，第三次拿两枚，至少3次 …… 综合以上情况，可以发现当 i 为偶数时，至少次数 = i/2，当 i 为奇数时，至少次数 = i/2 + i%2，代码如下： 复杂度分析： 时间复杂度：O(n)，n 为数组中元素的个数 空间复杂度：O(1)，占用常数大小的空间 Java实现class Solution { public int minCount(int[] coins) { int sum = 0; for (int i = 0; i &lt; coins.length; i++) { sum += coins[i] / 2; if (coins[i] % 2 != 0) { sum += 1; } } return sum; }} Koltin实现class Solution { fun minCount(coins: IntArray): Int { var sum = 0 coins.forEach { value -&gt; sum += value / 2 if (value % 2 != 0) sum += 1 } return sum }}","link":"/backup/LeetCode/2020code/01-na-ying-bi.html"},{"title":"LeetCode 数组：两数之和2 - 输入数组有序","text":"题目来源于 LeetCode 上第 167号（Two Sum II - Input array is sorted）问题：两数之和2 - 输入数组有序。题目难度为 Easy。 英文地址：https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ 中文地址：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ 题目描述Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. 示例： Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 思路一：左右指针法初始化左指针low指向数组起始位置，右指针height指向数组结束位置，时间复杂度o(n) 如果numbers[low] 和 numbers[height]的和sum等于target，返回low+,height+1 如果numbers[low] 和 numbers[height]的和sum小于target，则low++ 如果numbers[low] 和 numbers[height]的和sum大于target，则height– Java实现public class Solution { public int[] twoSum(int[] numbers, int target) { int low = 0; int height = numbers.length - 1; while (low &lt; height) { int sum = numbers[low] + numbers[height]; if (sum == target) { return new int[]{low + 1, height + 1}; } else if (sum &lt; target) { low++; } else { height--; } } return new int[2]; }} Kotlin实现class Solution { fun twoSum(numbers: IntArray, target: Int): IntArray { var height = numbers.size - 1 var low = 0; while (low &lt; height) { val sum = numbers[low] + numbers[height] when { sum == target -&gt; return intArrayOf(low + 1, height + 1) sum &lt; target -&gt; low++ else -&gt; height-- } } return intArrayOf() }} 思路二：二分法查找题目可知找两个数之和 a+b = taget，循环数组每一个元素a, 从剩余的元素里面用二分法查找另外一个元素 b= taget-a 即可，时间复杂度为o(nlogn) 循环每个元素a 从剩余元素用二分法查找元素b = taget-a，返回索引idnex, 如果index ==-1 ，则无结果返回，如果index!=-1，则直接返回a+1,index+1 Java实现public class Solution { public int[] twoSum(int[] numbers, int target) { for (int a = 0; a &lt; numbers.length; a++) { int index = binarySearch(numbers, a + 1, target - numbers[a]); if (index != -1) return new int[]{a + 1, index + 1}; } return new int[2]; } public int binarySearch(int[] numbers, int start, int target) { int low = start; int height = numbers.length - 1; while (low &lt;= height) { int mind = (low + height) &gt;&gt;&gt; 1; if (numbers[mind] == target) return mind; if (numbers[mind] &lt; target) low = mind + 1; if (numbers[mind] &gt; target) height = mind - 1; } return -1; }} kotlin 实现class Solution { fun twoSum(numbers: IntArray, target: Int): IntArray { numbers.forEachIndexed { i, value -&gt; val index = binarySearch(numbers, i + 1, target - value) if (index != -1) { return intArrayOf(i + 1, index + 1) } } return intArrayOf() } fun binarySearch(numbers: IntArray, start: Int, target: Int): Int { var low = start var height = numbers.size - 1 while (low &lt;= height) { val mind = (low + height) ushr 1 when { numbers[mind] == target -&gt; return mind numbers[mind] &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return -1 }}","link":"/backup/LeetCode/arrays/01-two-sum-ii-input-array-is-sorted.html"},{"title":"LeetCode 二叉树：中序遍历","text":"题目来源于 LeetCode 上第 94号（Binary Tree Inorder Traversal）问题：二叉树的中序遍历。题目难度为 Medium。 英文地址: https://leetcode.com/problems/binary-tree-inorder-traversal 中文地址: https://leetcode.com/problems/binary-tree-inorder-traversal 题目描述Given a binary tree, return the inorder traversal of its nodes’ values Example: Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,3,2] 二叉树的中序遍历过程: 左节点 -&gt; 根节点 -&gt; 右节点，如下图所示： 结果为：1 2 3 4 5 6 7 思路一：非递归 循环检测栈是否为空，或者根节点是否为空 循环检测左节点，保存在栈中 弹出栈顶元素，再将当前指针移到其右子节点上，若存在右子节点，在次执行步骤2 复杂度分析： 时间复杂度：O(n)，n 为节点的数量 空间复杂度：O(n)，n 为节点的数量 Java实现class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack(); List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // 循环检测栈是否为空，或者根节点是否为空 while (!stack.isEmpty() || root != null) { // 循环检测左节点，保存在栈中 while (root != null) { stack.push(root); root = root.left; } // 弹出栈顶元素 root = stack.pop(); list.add(root.val); // 再将当前指针移到其右子节点上，若存在右子节点，在次执行步骤2 root = root.right; } return list; }} kotlin 实现class Solution { fun inorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() val stack = Stack&lt;TreeNode&gt;() var current = root while (!stack.isEmpty() || current != null) { while (current != null) { stack.push(current) current = current.left } stack.pop()?.let { item -&gt; list.add(item.`val`) current = item.right } } return list; }} 思路二：递归中序遍历递归思路和前序遍历大概一致，根据递归的两个特点去思考 递归的两个特点： 1. 问题与子问题的递归关系，采用自上而下的思考方式2. 递归的终止条件是当结点为叶子结点时终止（因为叶子节点没有左右结点） 复杂度分析： 时间复杂度：O(n)，n 为节点的数量 空间复杂度：O(n)，n 为节点的数量，最坏情况下需要空间O(n)，平均情况为O(log2^n) java 实现class Solution { List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { if (root == null) return list; inorderTraversal(root.left); list.add(root.val); inorderTraversal(root.right); return list; }} kotlin 尾递归实现class Solution { fun inorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() tailrecInorder(root, list) return list; } tailrec fun tailrecInorder(root: TreeNode?, list: MutableList&lt;Int&gt; = mutableListOf()) { if (root == null) { return } tailrecInorder(root.left, list) list.add(root.`val`) tailrecInorder(root.right, list) }}","link":"/backup/LeetCode/binary-tree/02-binary-tree-inorder.html"},{"title":"LeetCode 二叉树： 前序遍历","text":"题目来源于 LeetCode 上第 144号（Binary Tree Preorder Traversal）问题：二叉树的前序遍历，题目难度为 Medium。 英文地址: https://leetcode.com/problems/binary-tree-preorder-traversal/ 中文地址：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ 题目描述Given a binary tree, return the preorder traversal of its nodes’ values. Example: Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,2,3] 二叉树的前序遍历过程: 根节点 -&gt; 左节点 -&gt; 右节点，如图所示： 结果为: 4 2 1 3 6 5 7 思路一：非递归可以利用栈的特性来解这道题，主要步骤如下： 循环检测栈是否为空，或者根节点是否为空 循环检测左节点，保存到栈中 当左节点遍历结束之后，取出栈顶的右节点，再次执行步骤2 复杂度分析： 时间复杂度：O(n)，n 为节点的数量 空间复杂度：O(n)，n 为节点的数量 Java实现class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack(); List&lt;Integer&gt; list = new LinkedList(); // 循环检测栈是否为空，或者根节点是否为空 while (!stack.isEmpty() || root != null) { // 循环检测左节点，保存到栈中 while (root != null) { stack.push(root); list.add(root.val); root = root.left; } // 取出栈顶的右节点，再次执行步骤2 if (!stack.isEmpty()) { root = stack.pop().right; } } return list; } public List&lt;Integer&gt; preorderTraversal2(TreeNode root) { List&lt;Integer&gt; output = new LinkedList&lt;&gt;(); if (root == null) return output; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); output.add(node.val); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return output; }} Kotlin 实现class Solution { fun preorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() val stack = Stack&lt;TreeNode&gt;() stack.push(root); while (!stack.isEmpty()) { stack.pop()?.let { root -&gt; list.add(root.`val`) if (root.right != null) stack.push(root.right) if (root.left != null) stack.push(root.left) } } return list }} 思路二：递归递归的两个特点： 问题和子问题都会调用函数自身，所以要找寻问题与子问题的递归关系，采用自上而下的思考方式 有个终止条件（临界点）结束当前递归 因此二叉树前序遍历按照上面两步进行分解 1. 问题与子问题的递归关系，采用自上而下的思考方式 按照二叉树的前序遍历过程: 根节点 -&gt; 左节点 -&gt; 右节点 对于根节点4，它的左右节点分别是2、6，继续往下递推 假设根节点是2，它的左右节点是分别1、3，继续往下递推 假设根节点是1，它没有左右节点，此时递推结束了，然后往上回溯，以右节点3作为根节点，以此类推 因此问题与子问题的递归关系：preorder(root) = preorder(root-&gt;left) + preorder(root-&gt;right) 2. 递归的终止条件是当结点为叶子结点时终止（因为叶子节点没有左右子结点） 复杂度分析： 时间复杂度：O(n)，n 为节点的数量 空间复杂度：O(n)，n 为节点的数量，最坏情况下需要空间O(n)，平均情况为O(log2^n) Java实现class Solution { List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { // 叶子节点没有左右子结点 if (root == null) return list; list.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return list; }} Kotlin 尾递归实现class Solution { fun preorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() tailrecPreorder(root, list) return list } tailrec fun tailrecPreorder(root: TreeNode?, list: MutableList&lt;Int&gt;) { if (root == null) { return } list.add(root.`val`) tailrecPreorder(root.left, list) tailrecPreorder(root.right, list) }}","link":"/backup/LeetCode/binary-tree/01-binary-tree-preorder.html"},{"title":"LeetCode 二叉树：后序遍历","text":"题目来源于 LeetCode 上第 145号（Binary Tree Postorder Traversal）问题：二叉树的后序遍历。题目难度为 Medium。 英文地址: https://leetcode.com/problems/binary-tree-postorder-traversal 中文地址: https://leetcode-cn.com/problems/binary-tree-postorder-traversal 题目描述Given a binary tree, return the postorder traversal of its nodes’ values. Example: Input: [1,null,2,3] 1 \\ 2 / 3Output: [3,2,1] 二叉树的后序遍历过程: 左节点 -&gt; 右节点 -&gt; 根节点，如下图所示： 结果为：1 3 2 5 7 6 4 思路一：非递归一般分析问题我们需要采用自上而下的思维，而解决问题有时候采用自下而上的方式，正如上图后续遍历的结果：1 3 2 5 7 6 4，我们采用逆向思维，4是2、6的根节点，而6是5、7的根节点，依次类推逆向输出的过程：根节点 -&gt; 右节点 -&gt; 左节点, 我可以结合栈的特性，以及前序遍历的过程：根节点 -&gt; 左节点 -&gt; 右节点，去思考，大概过程如下： 先将根节点入栈 循环判断判断栈不为空 取出栈顶元素，并添加到list集合（逆序添加） 如果左节点不为空，并将左节点入栈 如果右节点不为空，并将右节点入栈 复杂度分析： 时间复杂度：O(n)，n 为节点的数量 空间复杂度：O(n)，n 为节点的数量 Java实现class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack(); List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); if(root == null) return list; // 先将根节点入栈 stack.push(root); // 循环判断判断栈不为空 while(!stack.isEmpty()){ root = stack.pop(); // 取出栈顶元素，并添加到list集合（逆序添加） list.add(0,root.val); //如果左节点不为空，并将左节点入栈 if(root.left!=null) stack.push(root.left); // 如果右节点不为空，并将右节点入栈 if(root.right!=null) stack.push(root.right); } return list; } } Kotlin实现class Solution { fun postorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() root?.let { val stack = Stack&lt;TreeNode&gt;() stack.push(it) while (!stack.isEmpty()) { val current = stack.pop() list.add(0, current.`val`) if (current.left != null) stack.push(current.left) if (current.right != null) stack.push(current.right) } } return list }} 思路二：递归后序遍历的递归思路和中序遍历、前序遍历大概一致，根据递归的两个特点去思考 递归的两个特点： 1. 问题与子问题的递归关系，采用自上而下的思考方式2. 递归的终止条件是当结点为叶子结点时终止（因为叶子节点没有左右结点） 复杂度分析： 时间复杂度：O(n)，n 为节点的数量 空间复杂度：O(n)，n 为节点的数量，最坏情况下需要空间O(n)，平均情况为O(log2^n) Java实现class Solution { List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) { if (root == null) return list; postorderTraversal(root.left); postorderTraversal(root.right); list.add(root.val); return list; }} Kotlin 尾递归实现class Solution { fun postorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() tailrecPreorder(root, list) return list } tailrec fun tailrecPreorder(root: TreeNode?, list: MutableList&lt;Int&gt;) { if (root == null) { return } tailrecPreorder(root.left, list) tailrecPreorder(root.right, list) list.add(root.`val`) }}","link":"/backup/LeetCode/binary-tree/03-binary-tree-postorder.html"},{"title":"LeetCode 二叉树：计算二叉树的最大深度","text":"题目来源于 LeetCode 上第 104 号（Maximum Depth of Binary Tree）问题：计算二叉树的最大深度。题目难度为 Easy。 英文地址：https://leetcode.com/problems/maximum-depth-of-binary-tree/ 中文地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 题目描述Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\9 20 / \\ 15 7 return its depth = 3. 思路:二叉树的最大深度: 从根节点到叶子节点的最长路径上的节点个数注意：叶子节点即没有左右子节点 任意一个节点的深度是由它左右两个子节点的深度决定的，如果左右两个子节点的深度分别为L1和R1，当前节点的最大深度就是 max(L1,R1)+1，公式如下： maxDepth(root) = Math.max(maxDepth(root.left), maxDepth(root.right)) + 1 复杂度分析： 时间复杂度：O(n)，n 为节点的数量 空间复杂度：O(height)，height 为树的高度，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度 Java实现public int maxDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;} Koltin尾递归实现tailrec fun maxDepth(root: TreeNode?): Int { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1}","link":"/backup/LeetCode/binary-tree/06-maximum-depth-of-binary-tree.html"},{"title":"LeetCode 二叉树：层次遍历","text":"题目来源于 LeetCode 上第 102号（Binary Tree Level Order Traversal）问题：二叉树的层次遍历。题目难度为 Medium。 英文地址: https://leetcode.com/problems/binary-tree-level-order-traversal/中文地址: https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 题目描述Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). Example: Given binary tree [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7return its level order traversal as:[ [3], [9,20], [15,7]] 二叉树的层次遍历过程：逐层遍历 结果为：4 2 6 1 3 5 7 思路一：BFSBFS: 广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法，从根节点开始，沿着树(图)的宽度遍历树(图)的节点，如果所有节点均被访问，则算法中止 二叉树的层次遍历即逐层遍历，由上图所示按照访问的顺序依次输出，得出需要用到队列 新建一个 queue，用来存储访问的每个节点 新建一个 wrapList 集合，保存每层的数据 循环判断队列是否为空，如果队列为空即循环终止 获取每一层的数据的长度，依次遍历，将数据保存到 currLevelList 中 遍历每层数据时，将下一层的节点保存到 queue 中 每层遍历结束，将当前层 currLevelList 数据保存到 wrapList 再次执行3~6，直到 queue 为空即结束循环 注意： 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 remove() poll() 查找 element() peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null 复杂度分析： 时间复杂度：O(n)，n 是二叉树中的节点个数 空间复杂度：O(n)，n 是二叉树中的节点个数，需要一个 list 存储访问的所有节点 Java实现class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { // 存储每层的数据 List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList(); if (root == null) return wrapList; // 存储访问过的每层节点 Queue&lt;TreeNode&gt; queue = new LinkedList(); queue.offer(root); while (!queue.isEmpty()) { int len = queue.size(); // 获取每层的数据的长度 List&lt;Integer&gt; currLevelList = new LinkedList(); // 遍历每次每层的数据 for (int i = 0; i &lt; len; i++) { root = queue.poll(); // 按照每层遍历的顺序，存储每层的节点 currLevelList.add(root.val); // 将下一层的节点入队 if (root.left != null) queue.add(root.left); if (root.right != null) queue.add(root.right); } wrapList.add(currLevelList); } return wrapList; }} Kotlin实现class Solution { fun levelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; { val wrapList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() root?.let { val queue = ArrayDeque&lt;TreeNode&gt;() queue.offer(root) while (queue.isNotEmpty()) { val currLevelList = mutableListOf&lt;Int&gt;() var len = queue.size while (len &gt; 0) { queue.poll()?.let { curNode -&gt; currLevelList.add(curNode.`val`) if (curNode.left != null) queue.offer(curNode.left) if (curNode.right != null) queue.offer(curNode.right) } len-- } wrapList.add(currLevelList) } } return wrapList }} 思路二：DFSDFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 复杂度分析： 时间复杂度：O(n)，n 是二叉树中的节点个数 空间复杂度：O(height)，height 为树的高度，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度 Java 实现class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList(); dfs(wrapList, root, 0); return wrapList; } public void dfs(List&lt;List&lt;Integer&gt;&gt; wrapList, TreeNode root, int level) { if (root == null) return; if (level &gt;= wrapList.size()) { wrapList.add(new LinkedList&lt;Integer&gt;()); } List&lt;Integer&gt; currLevelList = wrapList.get(level); currLevelList.add(root.val); dfs(wrapList, root.left, level + 1); dfs(wrapList, root.right, level + 1); }} Kotlin 尾递归class Solution { fun levelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; { val wrapList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() dfs(wrapList, root, 0) return wrapList } tailrec fun dfs(wrapList: MutableList&lt;MutableList&lt;Int&gt;&gt;, root: TreeNode?, level: Int) { if (root == null) return if (level &gt;= wrapList.size) { wrapList.add(mutableListOf&lt;Int&gt;()) } wrapList[level].add(root.`val`) dfs(wrapList, root.left, level + 1) dfs(wrapList, root.right, level + 1) }}","link":"/backup/LeetCode/binary-tree/04-binary-tree-level-order.html"},{"title":"LeetCode 二叉树：计算二叉树的最小深度","text":"题目来源于 LeetCode 上第 111 号（Minimum Depth of Binary Tree）问题：计算二叉树的最小深度。题目难度为 Easy。 英文地址：https://leetcode.com/problems/minimum-depth-of-binary-tree/ 中文地址：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/ 题目描述Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\9 20 / \\ 15 7 return its minimum depth = 2. 思路:二叉树的最小深度: 从根节点到叶子节点的最短路径上的节点个数注意：叶子节点即没有左右子节点 任意一个节点的深度是由它左右两个子节点的深度决定的，如果左右两个子节点的深度分别为L1和R1，当前节点的最小深度就是 min(L1,R1)+1，公式如下： minDepth(root) = Math.min(minDepth(root.left), minDepth(root.right)) + 1 但是需要注意的是不能只判断左右两个子节点的深度的最小值，因为即使某个节点不是叶子节点，但是它的一个子节点是空节点，那么递归就会返回，从而误判这条路径是最短的，例如： 1 / 2 如果只是判断左右两个子节点的深度的最小值，那么返回结果是1，但是实际上这个二叉树的最小深度是2 复杂度分析： 时间复杂度：O(n)，n 为节点的数量 空间复杂度：O(height)，height 为树的高度，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度 Java实现public int minDepth(TreeNode root) { if (root == null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); if (left == 0 || right == 0) { return left + right + 1; } else { return Math.min(left, right) + 1; }} Koltin尾递归实现tailrec fun minDepth(root: TreeNode?): Int { if (root == null) { return 0; } val left = minDepth(root.left) val right = minDepth(root.right) return if (left == 0 || right == 0) left + right + 1 else Math.min(left, right) + 1}","link":"/backup/LeetCode/binary-tree/07-minimum-depth-of-binary-tree.html"},{"title":"LeetCode 二叉树：从前序与中序遍历序列构造二叉树","text":"题目来源于 LeetCode 上第 105号（Construct Binary Tree from Preorder and Inorder Traversal）问题：从前序与中序遍历序列构造二叉树。题目难度为 Medium。这道题目和 剑指offer： 07 重建二叉树 一样 英文地址：https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 中文地址：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 剑指offer 07 重建二叉树：https://leetcode-cn.com/problems/zhong-jian…… 题目描述Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 3 / \\9 20 / \\ 15 7 思路：如果还不了解前序遍历和中序遍历算法可以点击下方链接前往 前序遍历中序遍历 前序遍历和中序遍历过程如下： 前序遍历：根结点 —&gt; 左节点 —&gt; 右节点 中序遍历：左节点—&gt; 根结点 —&gt; 右节点 根据前序遍历的规则，可知 preorder[0] 一定是整棵二叉树的根节点，如果根节点所在的下标为 index，根据中序遍历的规则，可知中序序列 inorder： 区间 inorder[0, index - 1] 属于根节点的左子树 区间 inorder[index + 1, n - 1] 属于根节点的右子树 根据前序遍历的规则一定是先遍历完左子树，然后才会遍历右子树，所以前序序列 preorder： 区间 preorder[1, index] 在根节点的 preorder[0] 的左边 区间 preorder[index+1, n] 在根节点的 preorder[0] 的右边 所以算法思路如下： 根节点是Preorder数组中的第一个元素，即 preorder[0] 在Inorder数组中查找根的位置 index 在Inorder数组中，根元素左边的元素是左子树，即区间 inorder[0, index - 1] 在Inorder数组中，根元素右边的元素是右子树，即区间 inorder[index + 1, n - 1] 在preorder数组中，区间 preorder[1, index] 在根节点的preorder[0] 的左边 在preorder数组中，preorder[index+1, n] 在根节点的preorder[0] 的右边 在由左子树中的元素组成的子数组上递归调用 在由右子树中的元素组成的子数组上递归地调用 复杂度分析： 时间复杂度：O(n), 遍历每一个节点，重建二叉树 空间复杂度：O(height)，height 为树的高度，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度 Kotlin 尾递归实现class Solution { fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? { return tailrecOrder(preorder, inorder) } tailrec fun tailrecOrder(preorder: IntArray, inorder: IntArray): TreeNode? { if (preorder.size &lt;= 0 || inorder.size &lt;= 0) { return null; } val key = preorder[0] val root = TreeNode(key) if (preorder.size == 1) { return root } val index = getRootIndex(inorder, key) if (index &gt; 0 || index &lt; preorder.size) { // 计算左子树，所以根节点除外，从下标1开始 var pre = Arrays.copyOfRange(preorder, 1, index + 1) var inor = Arrays.copyOfRange(inorder, 0, index) root.left = tailrecOrder(pre, inor) pre = Arrays.copyOfRange(preorder, index + 1, preorder.size) inor = Arrays.copyOfRange(inorder, index + 1, inorder.size) root.right = tailrecOrder(pre, inor) } return root } fun getRootIndex(inorder: IntArray, key: Int): Int { inorder.forEachIndexed { index, item -&gt; if (item == key) { return index } } return -1 }} Java 实现class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length &lt;= 0 || inorder.length &lt;= 0) { return null; } int key = preorder[0]; TreeNode root = new TreeNode(key); if (preorder.length == 1) { return root; } int index = getRootIndex(inorder, key); if (index &gt; 0 || index &lt; preorder.length) { // 计算左子树，所以根节点除外，从下标1开始 int[] pre = Arrays.copyOfRange(preorder, 1, index + 1); int[] inor = Arrays.copyOfRange(inorder, 0, index); root.left = buildTree(pre, inor); pre = Arrays.copyOfRange(preorder, index + 1, preorder.length); inor = Arrays.copyOfRange(inorder, index + 1, inorder.length); root.right = buildTree(pre, inor); } return root; } private final int getRootIndex(int[] inorder, int key) { for (int i = 0; i &lt; preorder.length; i++) { if (preorder[i] == key) { return i; } } return -1; }}","link":"/backup/LeetCode/binary-tree/05-binary-tree-construct.html"},{"title":"LeetCode 二叉树：自下而上分层遍历","text":"题目来源于 LeetCode 上第 107 号（Binary Tree Level Order Traversal II）问题：自下而上分层遍历。题目难度为 Easy。 英文地址：https://leetcode.com/problems/binary-tree-level-order-traversal-ii/ 中文地址：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/ 题目描述Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\9 20 / \\ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3]] 思路一：BFSBFS: 广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法，从根节点开始，沿着树(图)的宽度遍历树(图)的节点，如果所有节点均被访问，则算法中止 二叉树的自下而上分层遍历，和层次遍历相同，只不过在添加数据的时候，逆序添加，具体步骤如下： 新建一个 queue，用来存储访问的每个节点 新建一个 wrapList 集合，保存每层的数据 循环判断队列是否为空，如果队列为空即循环终止 获取每一层的数据的长度，将数据保存到 subList 中 遍历每层数据时，将下一层的节点保存到 queue 中 每层遍历结束，将当前层 subList 数据 逆序添加到 wrapList，如：wrapList.add(0, subList); 再次执行3~6，直到 queue 为空即结束循环 注意： 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 remove() poll() 查找 element() peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null 复杂度分析： 时间复杂度：O(n)，n 是二叉树中的节点个数 空间复杂度：O(n)，n 是二叉树中的节点个数，需要一个 list 存储访问的所有节点 Java实现class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if (root == null) { return wrapList; } queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); List&lt;Integer&gt; subList = new LinkedList(); for (int i = 0; i &lt; size; i++) { TreeNode node = queue.poll(); subList.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } wrapList.add(0, subList); } return wrapList; }} Koltin实现class Solution { fun levelOrderBottom(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; { val wrapList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() root?.let { val queue = ArrayDeque&lt;TreeNode&gt;() queue.offer(root) while (!queue.isEmpty()) { val subList = mutableListOf&lt;Int&gt;() var size = queue.size while (size &gt; 0) { val node = queue.poll() subList.add(node.`val`) if (node.left != null) queue.offer(node.left) if (node.right != null) queue.offer(node.right) size-- } wrapList.add(0, subList) } } return wrapList }} 思路二：DFSDFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 复杂度分析： 时间复杂度：O(n)，n 是二叉树中的节点个数 空间复杂度：O(height)，height 为树的高度，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度 Java实现class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList(); dfs(wrapList, root, 0); return wrapList; } public void dfs(List&lt;List&lt;Integer&gt;&gt; subList, TreeNode root, int level) { if (root == null) { return; } if (level &gt;= subList.size()) { subList.add(0, new LinkedList&lt;Integer&gt;()); } subList.get(subList.size() - 1 - level).add(root.val); dfs(subList, root.left, level + 1); dfs(subList, root.right, level + 1); }} Koltin尾递归实现class Solution { fun levelOrderBottom(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; { val wrapList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() dfs(wrapList, root, 0) return wrapList } tailrec fun dfs(subList: MutableList&lt;MutableList&lt;Int&gt;&gt;, root: TreeNode?, level: Int) { if (root == null) { return } if (level &gt;= subList.size) { subList.add(0, mutableListOf&lt;Int&gt;()) } subList[subList.size - 1 - level].add(root.`val`) dfs(subList, root.left, level + 1) dfs(subList, root.right, level + 1) }}","link":"/backup/LeetCode/binary-tree/09-binary-tree-level-order-traversal.html"},{"title":"LeetCode 二叉树：判断两棵二叉树是否结构相同","text":"题目来源于 LeetCode 上第 100号（same-tree）问题：判断两棵二叉树是否结构相同。题目难度为 Easy。 英文地址：https://leetcode.com/problems/same-tree/ 中文地址：https://leetcode-cn.com/problems/same-tree/ 题目描述Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: Input: 1 1 / \\ 2 2 [1,2], [1,null,2]Output: false 思路一：非递归两棵二叉树结构相同，需要满足以下条件： 二叉树结构相同 二叉树对应节点值相同 根据层次遍历算法，访问每一个节点，检查每个节点是否相同，核心算法如下： if (p == null &amp;&amp; q == null) { continue;}if (p == null || q == null) { return false;}if (p.val != q.val) { return false;} 复杂度分析： 时间复杂度：O(min(m,n))，m 和 n 分别为两颗二叉树中的节点个数，对两个二叉树同时进行深度优先搜索，只要有一颗二叉树的节点为空，即停止循环，因此被访问到的节点数不会超过较小的二叉树的节点数 空间复杂度：O(min(m,n))，m 和 n 分别为两颗二叉树中的节点个数，循环从队列中取数据，当有一颗二叉树的节点为空，即停止循环。 Java实现class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q == null) { return true; } if (p == null || q == null) { return false; } Queue&lt;TreeNode&gt; pWrapQueue = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; qWrapQueue = new LinkedList(); pWrapQueue.offer(p); qWrapQueue.offer(q); while (!pWrapQueue.isEmpty() &amp;&amp; !qWrapQueue.isEmpty()) { TreeNode pNode = pWrapQueue.poll(); TreeNode qNode = qWrapQueue.poll(); if (pNode == null &amp;&amp; qNode == null) { continue; } if (pNode == null || qNode == null) { return false; } if (pNode.val != qNode.val) { return false; } pWrapQueue.offer(pNode.left); qWrapQueue.offer(qNode.left); pWrapQueue.offer(pNode.right); qWrapQueue.offer(qNode.right); } return pWrapQueue.size() == qWrapQueue.size(); }} Koltin实现class Solution { fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean { if (p == null &amp;&amp; q == null) { return true } if (p == null || q == null) { return false } val pWrapQueue = LinkedList&lt;TreeNode&gt;() val qWrapQueue = LinkedList&lt;TreeNode&gt;() pWrapQueue.offer(p) qWrapQueue.offer(q) while (!pWrapQueue.isEmpty() &amp;&amp; !qWrapQueue.isEmpty()) { val pNode = pWrapQueue.poll() val qNode = qWrapQueue.poll() if (pNode == null &amp;&amp; qNode == null) { continue; } if (pNode == null || qNode == null) { return false; } if (pNode.`val` != qNode.`val`) { return false; } pWrapQueue.offer(pNode.left) pWrapQueue.offer(pNode.right) qWrapQueue.offer(qNode.left) qWrapQueue.offer(qNode.right) } return pWrapQueue.size == qWrapQueue.size }} 思路二：递归复杂度分析： 时间复杂度：O(min(m,n))，m 和 n 分别为两颗二叉树中的节点个数，对两个二叉树同时进行深度优先搜索，只要有一颗二叉树的节点为空，即停止循环，因此被访问到的节点数不会超过较小的二叉树的节点数 空间复杂度：O(min(m,n))，m 和 n 分别为两颗二叉树中的节点个数，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度，树的高度不会超过较小的二叉树的最大高度 Java实现 class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q == null) { return true; } if (p == null || q == null) { return false; } if (p.val == q.val) { return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); } return false; }} Koltin实现class Solution { tailrec fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean { if (p == null &amp;&amp; q == null) { return true } if (p == null || q == null) { return false } if (p.`val` == q.`val`) { return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right) } return false }}","link":"/backup/LeetCode/binary-tree/11-same-tree.html"},{"title":"LeetCode 字符串：最长公共前缀","text":"题目来源于 LeetCode 上 第 14 号问题：最长公共前缀。题目难度为 Easy。 英文地址：https://leetcode.com/problems/longest-common-prefix/ 中文地址：https://leetcode-cn.com/problems/longest-common-prefix/ 题目描述编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1： 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2： 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明： 所有输入只包含小写字母 a-z 。 思路一：算法流程如下： 检查当前数组长度是否为 0 ，如果是则返回空字符串 &quot;&quot; 假设第一个字符串为最长公共前缀 从前往后遍历所有字符串的每一列，比较第一个字符串相同列上的字符是否相同 如果相同则继续对下一列进行比较 如果不相同则当前列不再属于公共前缀，返回当前列之前的部分为最长公共前缀 以下图片来自 LeetCode 官方： 复杂度分析： 时间复杂度：0(mn) ，m 是字符串的数量， n 是每个字符串的长度，最坏的情况下，每个字符都比较一遍 空间复杂度：O(1)，使用了一些变量，占常数大小的空间 Kotlin 实现class Solution { fun longestCommonPrefix(strs: Array&lt;String&gt;): String { if (strs.size &lt;= 0) { return &quot;&quot; } val str0 = strs[0] val len = str0.length val count = strs.size for (i in 0 until len) { val c = str0[i] for (j in 1 until count) { if (i == strs[j].length || c != strs[j][i]) { return str0.substring(0, i) } } } return str0 }} Java 实现public class Solution { // 方法一 public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length &lt;= 0) { return &quot;&quot;; } String str0 = strs[0]; int len = str0.length(); int count = strs.length; for (int i = 0; i &lt; len; i++) { char c1 = str0.charAt(i); for (int j = 1; j &lt; count; j++) { if (i == strs[j].length() || c1 != strs[j].charAt(i)) { return str0.substring(0, i); } } } return str0; }} 思路二：算法流程如下： 检查当前数组长度是否为 0 ，如果是则返回空字符串 &quot;&quot; 假设第一个字符串为最长公共前缀 遍历后面字符串和第一个字符串做比较 如果不相同则退出循环，返回之前的字符串为最长公共前缀 复杂度分析： 时间复杂度：0(mn) ，m 是字符串的数量， n 是每个字符串的长度，最坏的情况下，每个字符都比较一遍 空间复杂度：O(1)，使用了一些变量，占常数大小的空间 Java 实现public class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length &lt;= 0) { return &quot;&quot;; } int count = strs.length; String str0 = strs[0]; for (int i = 0; i &lt; count; i++) { int j = 0; for (; j &lt; str0.length() &amp;&amp; j &lt; strs[i].length(); j++) { if (str0.charAt(j) != strs[i].charAt(j)) { break; } } str0 = str0.substring(0, j); } return str0; }}","link":"/backup/LeetCode/character/01-longest-common-prefix.html"},{"title":"LeetCode 二叉树：求二叉树中的节点个数","text":"题目来源于 LeetCode 上第 222 号（ Count Complete Tree Nodes）问题：求二叉树中的节点个数。题目难度为 Medium。 英文地址：https://leetcode.com/problems/count-complete-tree-nodes/ 中文地址：https://leetcode-cn.com/problems/count-complete-tree-nodes/ 题目描述Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input: 1 / \\ 2 3 / \\ /4 5 6Output: 6 思路一：DFS假设每个节点都标记为1，空节点标记为0，将每个节点的和累加起来即可 Java实现class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } return countNodes(root.left) + countNodes(root.right) + 1; }} Koltin实现class Solution { private tailrec fun countNodes(root: TreeNode?): Int { if (root == null) { return 0 } return countNodes(root.left) + countNodes(root.right) + 1 } } 思路二：BFS假设每个节点都标记为1，空节点标记为0，根据前序、中序、后序、层次遍历访问每个节点，遇到不为空的节点+1，层次遍历算法如下，前序、中序、后序遍历原理相同 Java实现class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 0; while (!queue.isEmpty()) { count++; TreeNode node = queue.poll(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } return count; }} Koltin实现class Solution { fun countNodes(root: TreeNode?): Int { var count = 0 root?.let { it -&gt; val queue = LinkedList&lt;TreeNode&gt;() queue.offer(root) while (!queue.isEmpty()) { count++ val node = queue.poll() if (node.left != null) { queue.offer(node.left) } if (node.right != null) { queue.offer(node.right) } } } return count }} 扩展题目1. 求二叉树中第K层结点的个数构建一棵二叉树（不一定是二叉查找树），求出该二叉树中第K层中的结点个数（根结点为第0层） 代码如下 class Solution { public int countLevelNodes(TreeNode root, int k) { if (root == null || k &lt;= 0) { return 0; } if (k == 1) { return 1; } return countLevelNodes(root.left, k - 1) + countLevelNodes(root.right, k - 1); }} 2. 求二叉树第K层的叶子节点个数代码如下： class Solution { public int countLevelNodes(TreeNode root, int k) { if (root == null || k &lt;= 0) { return 0; } if (k == 1) { if (root.left == null &amp;&amp; root.right == null) { return 1; } else { return 0; } } return countLevelNodes(root.left, k - 1) + countLevelNodes(root.right, k - 1); }}","link":"/backup/LeetCode/binary-tree/10-count-complete-tree-nodes.html"},{"title":"剑指 Offer 04：二维数组中的查找","text":"题目来源于 LeetCode 剑指 offer 第 04 号问题：二维数组中的查找。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/ 题目描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000 思路：线性查找由题意得知，每个二维数组都有以下特点： 每一行都按照从左到右递增的顺序排序 每一列都按照从上到下递增的顺序排序 因为都是有序的，所以可以选择将左上角 或者 右上角作为起点，寻找一个和目标数字相等的数，在这里我选择右上角作为起点即 matrix[0][maxColumn] 其中 maxColumn = matrix[0].size - 1 即每一行的最大列数，算法步骤如下 初始化 raw = 0，column = maxColumn 如果 matrix[raw][column] == target，说明存在和目标数字相等的数返回 true 如果 matrix[raw][column] &gt; target, 说明当前元素大于目标值，所以当前元素所在的下面所有元素都大于目标值，因此 column - 1，往左边寻找 如果 matrix[raw][column] &lt; target，说明当前元素小于目标值，所以当前元素所在的左边所有元素都小于目标值，因此 raw + 1，往下面寻找 遍历结束之后，如果没有找到即返回 false 复杂度分析： 时间复杂度：O(n+m)，如果二维数组的有 n 行 m 列，那么在循环过程中行数不会超过 n 行，列数不会超过 m 列，因此在循环结束之后总的次数不会超过 n+m 次 空间复杂度：0(1)，因为没有额外的开销，在内存中一直都是恒定的 Kotlin 实现class Solution { fun findNumberIn2DArray(matrix: Array&lt;IntArray&gt;, target: Int): Boolean { if (matrix == null || matrix.size &lt;= 0 || matrix[0].size &lt;= 0) { return false; } var raw = 0 var column = matrix[0].size - 1; val maxRaw = matrix.size - 1; while (raw &lt;= maxRaw &amp;&amp; column &gt;= 0) { when { matrix[raw][column] == target -&gt; return true matrix[raw][column] &gt; target -&gt; column-- else -&gt; raw++ } } return false }} Java 实现class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length &lt;= 0 || matrix[0].length &lt;= 0) { return false; } int row = 0; int column = matrix[0].length - 1; int maxRow = matrix.length - 1; while (row &lt;= maxRow &amp;&amp; column &gt;= 0) { if (matrix[row][column] == target) { return true; } else if (matrix[row][column] &gt; target) { column--; } else { row++; } } return false; }}","link":"/backup/LeetCode/offer/04-arrays.html"},{"title":"LeetCode 链表：环形链表","text":"题目来源于 LeetCode 上 第 141 号问题：环形链表。题目难度为 Easy。 英文地址：https://leetcode.com/problems/linked-list-cycle/ 中文地址：https://leetcode-cn.com/problems/linked-list-cycle/ 题目描述给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 思路：快慢指针题目分析： 判断链表中是否有环，也就是说如果链表尾节点指向链表的其他任意节点，那么链表就存在一个环。 参数的含义： p ：表示慢指针 q ：表示快指针 算法步骤： 慢指针 p 和 快指针 q 两个指针初始化均指向头结点 循环遍历慢指针 p 和 快指针 q ，每次让慢指针 p 移动一步，快指针 q 移动两步，当一个链表有环时，两个指针会陷入无限循环中，然后变成了追及问题，只要一直移动下去，快指针 q 总会追上慢指针 p 。 如果 p == q 即结束循环 效果如下所示，图片来自 LeetCode 作者 Time-Limit 复杂度分析： 时间复杂度 O(N)：N 为链表节点数量 空间复杂度 O(1)：占用常数大小的空间 Kotlin 实现class Solution { fun hasCycle(head: ListNode?): Boolean { return head?.let { if (head.next == null) return false var p: ListNode? = head var q: ListNode? = head do { if (q == null || q?.next == null) return false p = p?.next; q = q?.next.next; } while (p != q) true } ?: false }} Java 实现public class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.next == null) return false; ListNode p = head; ListNode q = head; do { if (q == null || q.next == null) return false; p = p.next; q = q.next.next; } while (p != q); return true; }}","link":"/backup/LeetCode/linked-list/02-linked-list-cycle.html"},{"title":"剑指 Offer 03：数组中重复的数字","text":"题目来源于 LeetCode 剑指 offer 第 03 号问题：数组中重复的数字。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/ 题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1: 输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 思路一：原地置换法题目指出 在一个长度为 n 的数组 nums 里的所有数字都在 [0,n-1] 的范围内，可遍历数组并通过交换操作使元素的 索引 与 值，通过索引找到对应的值，算法流程如下： 当 nums[i] == i 时，即 值 和 索引，一一对应无需交换 当 nums[nums[i]] == nums[i]，即索引 nums[i] 对应的值 和 nums[i] 相等，找到相同的值，返回此值 nums[i] 上面条件都不满足，即交换索引为 i 和 nums[i] 的元素值，将数字交换到对应索引位置 没有找到返回 -1，即代表数组中无相同值 例如数组 [2,0,1] 交换逻辑如下, 当 i = 0 时： temp = num[i], 即 temp = 2 num[i] = num[temp]，即 num[i] = 1 num[temp] = temp, 即 num[temp] = 2 将 即 值 和 索引 一一对应 复杂性分析 时间复杂度 O(N)，N 为数组的长度 空间复杂度 O(1), 占用额外常用空间大小 Java实现public class Solution { public int findRepeatNumber(int[] nums) { int len = nums.length; for (int i = 0; i &lt; len; i++) { if (nums[i] == i) continue; if (nums[nums[i]] == nums[i]) { return nums[i]; } int temp = nums[i]; nums[i] = nums[temp]; nums[temp] = temp; } return -1; }} Koltin实现class Solution { fun findRepeatNumber(nums: IntArray): Int { for ((index, value) in nums.withIndex()) { if (value == index) continue if (nums[value] == nums[index]) { return nums[index] } val temp = value nums[index] = nums[temp] nums[temp] = temp } return -1 }} 思路二：哈希算法利用 Haset API 的特性，如果添加重复的元素会返回 false 复杂性分析 时间复杂度 O(N)，N 为数组的长度 空间复杂度 O(N), 不重复的每个元素都可能存入集合，最坏的情况下，每个元素都不重复，所以空间复杂度为 O(N) Java 实现public class Solution { public int findRepeatNumber2(int[] nums) { int len = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; len; i++) { if (!set.add(nums[i])) { return nums[i]; } } return -1; }} Koltin 实现class Solution { fun findRepeatNumber(nums: IntArray): Int { val set = HashSet&lt;Int&gt;() for ((index, value) in nums.withIndex()) { if (!set.add(value)) { return value; } } return -1 }}","link":"/backup/LeetCode/offer/03-number.html"},{"title":"LeetCode 字符串：无重复字符的最长子串","text":"题目来源于 LeetCode 上 第 3 号问题：最长公共前缀。题目难度为 Medium。 英文地址：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 中文地址：https://leetcode.com/problems/longest-substring-without-repeating-characters/ 题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1： 输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2： 输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路：滑动窗口什么是滑动窗口？ 在字符串 s 中使用左右指针，左指针 left，右指针 right，初始化 left = right = 0，不断增加 right 扩大窗口大小，满足一定条件的时候，left 向右移动缩小窗口，表示 开始枚举下一个字符作为起始位置。 算法流程如下： 以示例一中的字符串 abcabcbb 为例，从每一个字符开始的，不包含重复字符的最长子串，列举出所有的可能性，其中括号中表示选中的字符以及最长的字符串： 以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb 以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb 以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb 以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb 以 abca(b)cbb 开始的最长字符串为 abca(bc)bb 以 abcab(c)bb 开始的最长字符串为 abcab(cb)b 以 abcabc(b)b 开始的最长字符串为 abcabc(b)b 以 abcabcb(b) 开始的最长字符串为 abcabcb(b) 观察规律，当右指针出现重复字符的时候，更改了左指针的起始位置，继续不断的循环下去，直到所有字符都比较完，满足 滑动窗口 的定义，所以我们可以使用 滑动窗口 来解决这个问题： 检查当前数组长度是否为 0 ，如果是则返回空字符串 &quot;&quot; 左指针 left，右指针 right，初始化 left = right = 0 不断增加 right 扩大窗口大小，直到右侧出现了重复字符为止 移除左指针指向的元素，并将左指针向右移动一格，表示 开始枚举下一个字符作为起始位置 不断重复 3、4 直到所有字符都比较完 如何判断重复字符 可以使用 HashSet 或者 HashMap 来判断是否出现重复字符，HashSet 和 HashMap 采用的时候哈希算法，时间复杂度 0(1)。 复杂度分析： 时间复杂度：0(n) ，n 是字符串的长度，会将整个字符串遍历一次 空间复杂度：O(∣Σ∣)，使用哈希集合来存储出现过的字符，∣Σ∣ 表示字符串中最多可以出现的字符的个数 Java 实现class Solution { /** * 方法一：滑动窗口 hashSet * * @param s * @return */ public int lengthOfLongestSubstring(String s) { if (s == null || s.length() &lt;= 0) { return 0; } int r = 0; int count = 0; int len = s.length(); Set&lt;Character&gt; hashSet = new HashSet&lt;Character&gt;(); for (int i = 0; i &lt; len; i++) { if (i != 0) { hashSet.remove(s.charAt(i - 1)); } while (r &lt; len &amp;&amp; !hashSet.contains(s.charAt(r))) { hashSet.add(s.charAt(r)); r++; } count = Math.max(count, r - i); } return count; } /** * 方法二：滑动窗口 hashMap * * @param s * @return */ public int lengthOfLongestSubstring2(String s) { if (s == null || s.length() &lt;= 0) { return 0; } int left = 0; int count = 0; int len = s.length(); Map&lt;Character, Integer&gt; hashMap = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; len; i++) { if (hashMap.containsKey(s.charAt(i))) { left = Math.max(left, hashMap.get(s.charAt(i)) + 1); } hashMap.put(s.charAt(i), i); count = Math.max(count, i - left + 1); } return count; }} Kotlin 实现class Solution { // 方法一：滑动窗口 hashSet fun lengthOfLongestSubstring(s: String): Int { val len = s.length if (len &lt;= 0) return 0 var r = 0 var count = 0 val hashSet = mutableSetOf&lt;Char&gt;() for (i in 0 until len) { if (i != 0) { hashSet.remove(s[i - 1]) } while (r &lt; len &amp;&amp; !hashSet.contains(s[r])) { hashSet.add(s[r]) r++ } count = Math.max(count, r - i) } return count } // 方法二：滑动窗口 hashMap fun lengthOfLongestSubstring2(s: String): Int { val len = s.length; if (len == 0) { return 0 } var left = 0 var count = 0 val map = mutableMapOf&lt;Char, Int&gt;() for (i in 0 until len) { if (map.containsKey(s[i])) { left = Math.max(left, map.get(s[i])?.let { it + 1 } ?: left) } map.put(s[i], i) count = Math.max(count, i - left + 1) } return count }}","link":"/backup/LeetCode/character/02-longest-substring-without-repeating-characters.html"},{"title":"剑指 offer 06：从尾到头打印链表","text":"题目来源于 LeetCode 剑指 offer 第 06 号问题：从尾到头打印链表。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/ 题目描述输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例: 输入：head = [1,3,2]输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 思路 第一次遍历计算链表的长度，创建相同长度的数组 reverse 第二次遍历将值 逆序 添加进 reverse 中 复杂度分析： 时间复杂度：O(n)，第一次遍历计算链表的长度，第二次遍历添加进数组 空间复杂度：O(n)，需要额外使用一个数组存储 Kotlin 实现class Solution { fun reversePrint(head: ListNode?): IntArray = head?.let { var count = 0 var currentNode = head while (currentNode != null) { count++ currentNode = currentNode.next } val reverse = IntArray(count) { 0 } currentNode = head while (currentNode != null) { reverse[--count] = currentNode.`val` currentNode = currentNode.next } reverse } ?: intArrayOf()} Java 实现class Solution { public int[] reversePrint(ListNode head) { if (head == null) { return new int[]{}; } int count = 0; ListNode currentNode = head; while (currentNode != null) { count++; currentNode = currentNode.next; } int[] reverse = new int[count]; currentNode = head; while (currentNode != null) { reverse[--count] = currentNode.val; currentNode = currentNode.next; } return reverse; }}","link":"/backup/LeetCode/offer/06-list.html"},{"title":"剑指 Offer 05：替换空格","text":"题目来源于 LeetCode 剑指 offer 第 05 号问题：替换空格。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/ 题目描述请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例: 输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制： 0 &lt;= s 的长度 &lt;= 10000 思路声明一个 StringBuffer，遍历字符串，如果遇见空格，添加 %20 到 buffer 中, 否则添加当前字符 复杂度分析： 时间复杂度：O(n)，当一个字符串的长度为 n 时，遍历字符串一遍，时间复杂度为 O(n) 空间复杂度：0(n)，需要创建 StringBuffer 有额外的开销，每次遇见空格，就替换为 %20，最坏的情况下，长度是原来的 3 倍 Kotlin 实现class Solution { fun replaceSpace(s: String): String { val buffer = StringBuffer() var i = 0 val len = s.length while (i &lt; len) { if (s[i] == ' ') { buffer.append(&quot;%20&quot;) } else { buffer.append(s[i]) } i++ } return buffer.toString() }} Java 实现class Solution { public String replaceSpace(String s) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == ' ') { buffer.append(&quot;%20&quot;); } else { buffer.append(s.charAt(i)); } } return buffer.toString(); }}","link":"/backup/LeetCode/offer/05-space.html"},{"title":"剑指 Offer 07：重建二叉树","text":"题目来源于 LeetCode 剑指 offer 第 07 号问题：重建二叉树。题目难度为 Medium。和第 105 号问题 相同 剑指offer 07 重建二叉树：https://leetcode-cn.com/problems/zhong-jian…… 105 号问题-英文地址：https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 105 号问题-中文地址：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\9 20 / \\ 15 7 限制： 0 &lt;= 节点个数 &lt;= 5000 思路：如果还不了解前序遍历和中序遍历算法可以点击下方链接前往 前序遍历中序遍历 前序遍历和中序遍历过程如下： 前序遍历：根结点 —&gt; 左节点 —&gt; 右节点 中序遍历：左节点—&gt; 根结点 —&gt; 右节点 根据前序遍历的规则，可知 preorder[0] 一定是整棵二叉树的根节点，如果根节点所在的下标为 index，根据中序遍历的规则，可知中序序列 inorder： 区间 inorder[0, index - 1] 属于根节点 preorder[0] 左子树 区间 inorder[index + 1, n - 1] 属于根节点 preorder[0] 右子树 根据前序遍历的规则一定是先遍历完左子树，然后才会遍历右子树，所以前序序列 preorder： 区间 preorder[1, index] 属于根节点的 preorder[0] 左子树 区间 preorder[index+1, n -1] 属于根节点的 preorder[0] 右子树 所以算法思路如下： 根节点是Preorder数组中的第一个元素，即 preorder[0] 在Inorder数组中查找根的位置 index 在Inorder数组中，根元素左边的元素是左子树，即区间 inorder[0, index - 1] 在Inorder数组中，根元素右边的元素是右子树，即区间 inorder[index + 1, n - 1] 在preorder数组中，根元素左边的元素是左子树，即区间 preorder[1, index] 在preorder数组中，根元素右边的元素是右子树，即 preorder[index+1, n - 1] 在由左子树中的元素组成的子数组上递归调用 在由右子树中的元素组成的子数组上递归地调用 复杂度分析： 时间复杂度：O(n), 遍历每一个节点，重建二叉树 空间复杂度：O(height)，height 为树的高度，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度 Kotlin 尾递归实现class Solution { fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? { return tailrecOrder(preorder, inorder) } tailrec fun tailrecOrder(preorder: IntArray, inorder: IntArray): TreeNode? { if (preorder.size &lt;= 0 || inorder.size &lt;= 0) { return null; } val key = preorder[0] val root = TreeNode(key) if (preorder.size == 1) { return root } val index = getRootIndex(inorder, key) if (index &gt; 0 || index &lt; preorder.size) { // 计算左子树，所以根节点除外，从下标1开始 // 数组拷贝是左闭右开的区间 var pre = Arrays.copyOfRange(preorder, 1, index + 1) var inor = Arrays.copyOfRange(inorder, 0, index) root.left = tailrecOrder(pre, inor) pre = Arrays.copyOfRange(preorder, index + 1, preorder.size) inor = Arrays.copyOfRange(inorder, index + 1, inorder.size) root.right = tailrecOrder(pre, inor) } return root } fun getRootIndex(inorder: IntArray, key: Int): Int { inorder.forEachIndexed { index, item -&gt; if (item == key) { return index } } return -1 }} Java 实现class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length &lt;= 0 || inorder.length &lt;= 0) { return null; } int key = preorder[0]; TreeNode root = new TreeNode(key); if (preorder.length == 1) { return root; } int index = getRootIndex(inorder, key); if (index &gt; 0 || index &lt; preorder.length) { // 计算左子树，所以根节点除外，从下标1开始 // 数组拷贝是左闭右开的区间 int[] pre = Arrays.copyOfRange(preorder, 1, index + 1); int[] inor = Arrays.copyOfRange(inorder, 0, index); root.left = buildTree(pre, inor); pre = Arrays.copyOfRange(preorder, index + 1, preorder.length); inor = Arrays.copyOfRange(inorder, index + 1, inorder.length); root.right = buildTree(pre, inor); } return root; } private final int getRootIndex(int[] inorder, int key) { for (int i = 0; i &lt; preorder.length; i++) { if (preorder[i] == key) { return i; } } return -1; }}","link":"/backup/LeetCode/offer/07-zhong-jian-er-cha-shu-lcof.html"},{"title":"LeetCode 链表：设计链表","text":"题目来源于 LeetCode 上 第 707 号问题：设计链表。题目难度为 Medium。 英文地址：https://leetcode.com/problems/design-linked-list 中文地址：https://leetcode-cn.com/problems/design-linked-list 题目描述设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性： val 和 next。 val 是当前节点的值， next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回 -1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果 index 小于 0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例： MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3linkedList.get(1); //返回2linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3linkedList.get(1); //返回3 提示： 所有 val 值都在 [1, 1000] 之内。 操作次数将在 [1, 1000] 之内。 请不要使用内置的 LinkedList 库。 链表是一个包含零个或多个元素的数据结构。每个元素都包含一个值和到另一个元素的链接。根据链接数的不同，可以分为单链表，双链表和多重链表。 思路一：单链表 参数的含义： head ：表示的队列的头指针 size ：表示链表的长度，每插入一个元素 +1，删除一个元素 -1 哨兵节点 哨兵节点在树和链表中被广泛用作 伪头、伪尾 等，通常不保存任何数据。 单链表中可以使用 伪头 简化插入和删除，可以避免空指针的处理 在指定位置插入元素 查找指定位置的前驱节点 ListNode pre = head;// 因为有伪头结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点for (int i = 0; i &lt; index; i++) pre = pre.next; 插入元素到前驱节点尾部（伪头不存放任何数据，伪头也是前驱节点）。 ListNode newNode = new ListNode(val);// 插入元素到前驱节点尾部newNode.next = pre.next;pre.next = newNode; 示意图如下，来自 LeetCode 官网 删除指定位置的节点 查找指定位置的前驱节点 ListNode pre = head;// 因为有伪头结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点for (int i = 0; i &lt; index; i++) pre = pre.next; 删除当前节点 pre.next = pre.next.next; 示意图如下，来自 LeetCode 官网 复杂度分析： 时间复杂度： addAtHead： O(1) addAtInder，get，deleteAtIndex: (k)，其中 k 指的是元素的索引。 addAtTail：O(N)，其中 N 指的是链表的元素个数。 空间复杂度 O(1)：所有的操作都是 O(1) Java 实现public class ListNode { public int val; public ListNode next; public ListNode(int x) { val = x; }}public class MyLinkedList1 { ListNode head; int size; /** * 初始化 */ public MyLinkedList1() { size = 0; head = new ListNode(0); } /** * 获取指定位置的元素，找不到返回 -1 */ public int get(int index) { if (index &lt; 0 || index &gt;= size) return -1; ListNode cur = head; // 因为将伪头作为头结点，所以需要 +1 才是当前查找元素所在的结点 for (int i = 0; i &lt; index + 1; i++) cur = cur.next; return cur.val; } /** * 在头部添加元素 */ public void addAtHead(int val) { addAtIndex(0, val); } /** * 在尾部添加元素 */ public void addAtTail(int val) { addAtIndex(size, val); } /** * 在指定位置插入元素 */ public void addAtIndex(int index, int val) { if (index &gt; size) return; if (index &lt; 0) index = 0; ListNode pre = head; // 因为有伪头结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点 for (int i = 0; i &lt; index; i++) pre = pre.next; ListNode newNode = new ListNode(val); // 插入元素到前驱节点尾部 newNode.next = pre.next; pre.next = newNode; size++; } /** * 删除指定位置的元素 */ public void deleteAtIndex(int index) { if (index &lt; 0 || index &gt;= size) return; ListNode pre = head; // 因为有伪头结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点 for (int i = 0; i &lt; index; i++) pre = pre.next; pre.next = pre.next.next; size--; }} Kotlin 实现public class ListNode { public int val; public ListNode next; public ListNode(int x) { val = x; }}class MyLinkedList1() { /** * 初始化 */ var head: ListNode = ListNode(0) var size: Int = 0 /** * 获取指定位置的元素，找不到返回 -1 */ fun get(index: Int): Int { val k = index if (k &lt; 0 || k &gt;= size) return -1 // 因为将伪头作为头结点，所以需要 +1 才是当前查找元素所在的结点 var cur: ListNode? = head for (i in 0 until (k + 1)) cur = cur?.next return cur?.`val` ?: -1 } /** * 在头部添加元素 */ fun addAtHead(`val`: Int) { addAtIndex(0, `val`) } /** * 在尾部添加元素 */ fun addAtTail(`val`: Int) { addAtIndex(size, `val`) } /** * 在指定位置插入元素 */ fun addAtIndex(index: Int, `val`: Int) { var k = index if (k &gt; size) return if (k &lt; 0) k = 0 // 因为有伪头结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点 var pre: ListNode? = head for (i in 0 until k) pre = pre?.next val node = ListNode(`val`) node.next = pre?.next pre?.next = node size++ } /** * 删除指定位置的元素 */ fun deleteAtIndex(index: Int) { var k = index if (k &lt; 0 || k &gt;= size) return // 因为有伪头结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点 var pre: ListNode? = head for (i in 0 until k) pre = pre?.next pre?.next = pre?.next?.next size-- }} 思路二：双向链表双链表比单链表快得多，测试用例花费的时间比单链表快了两倍。但是它更加复杂，它包含了 size，记录链表元素个数，和伪头伪尾 参数的含义： head ：表示的队列的头指针 last ：表示的队列的尾指针 size ：表示链表的长度，每插入一个元素 +1，删除一个元素 -1 哨兵节点 哨兵节点在树和链表中被广泛用作 伪头、伪尾 等，通常不保存任何数据。 双向链表中可以使用 伪头、伪尾 简化插入和删除，可以避免空指针的处理 在指定位置插入元素 找到要插入节点的前驱节点和后继节点 LinkedNode pre;LinkedNode succ;// 因为有伪头、伪尾结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点if (index &lt; size - index) { pre = head; for (int i = 0; i &lt; index; i++) pre = pre.next; succ = pre.next;} else { succ = last; for (int i = 0; i &lt; size - index; i++) succ = succ.pre; pre = succ.pre;} 通过改变前驱结点和后继节点的链接关系插入元素 LinkedNode newNode = new LinkedNode(val);newNode.next = succ;newNode.pre = pre;succ.pre = newNode;pre.next = newNode; 以下示意图，来自 LeetCode 官网 在指定位置删除元素 找到要插入节点的前驱节点和后继节点 LinkedNode pre;LinkedNode succ;// 因为有伪头、伪尾结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点if (index &lt; size - index) { pre = head; for (int i = 0; i &lt; index; i++) pre = pre.next; succ = pre.next.next;} else { succ = last; // 从尾部查找元素，需要 -1 for (int i = 0; i &lt; size - index - 1; i++) succ = succ.pre; pre = succ.pre.pre;} 删除元素 pre.next = succ;succ.pre = pre; 复杂度分析： 时间复杂度： addAtHead，addAtTail： O(1) get，addAtIndex，delete：O(min(k,N−k))，其中 k 指的是元素的索引 空间复杂度 O(1)：所有的操作都是 O(1) Java 实现public class LinkedNode { public int val; public LinkedNode pre; public LinkedNode next; public LinkedNode(int x) { this.val = x; }}class MyLinkedList2 { LinkedNode head; LinkedNode last; int size = 0; /** * 初始化 */ public MyLinkedList2() { size = 0; head = new LinkedNode(0); last = new LinkedNode(0); head.next = last; last.pre = head; } /** * 获取指定位置的元素，找不到返回 -1 */ public int get(int index) { if (index &lt; 0 || index &gt;= size) return -1; LinkedNode cur; if (index + 1 &lt; size - index) { cur = head; // 因为将伪头作为头结点，所以需要 +1 才是当前查找元素所在的结点 for (int i = 0; i &lt; index + 1; i++) cur = cur.next; } else { cur = last; for (int i = 0; i &lt; size - index; i++) cur = cur.pre; } return cur.val; } /** * 在头部添加元素 */ public void addAtHead(int val) { LinkedNode pre = head; LinkedNode succ = head.next; LinkedNode node = new LinkedNode(val); node.next = succ; node.pre = pre; pre.next = node; succ.pre = node; size++; } /** * 在尾部添加元素 */ public void addAtTail(int val) { LinkedNode succ = last; LinkedNode pre = last.pre; LinkedNode node = new LinkedNode(val); node.pre = pre; node.next = succ; succ.pre = node; pre.next = node; size++; } /** * 在指定位置插入元素 */ public void addAtIndex(int index, int val) { if (index &gt; size) return; if (index &lt; 0) index = 0; LinkedNode pre; LinkedNode succ; // 因为有伪头、伪尾结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点 if (index &lt; size - index) { pre = head; for (int i = 0; i &lt; index; i++) pre = pre.next; succ = pre.next; } else { succ = last; for (int i = 0; i &lt; size - index; i++) succ = succ.pre; pre = succ.pre; } LinkedNode newNode = new LinkedNode(val); newNode.next = succ; newNode.pre = pre; succ.pre = newNode; pre.next = newNode; size++; } /** * 删除指定位置的元素 */ public void deleteAtIndex(int index) { if (index &lt; 0 || index &gt;= size) return; LinkedNode pre; LinkedNode succ; // 因为有伪头、伪尾结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点 if (index &lt; size - index) { pre = head; for (int i = 0; i &lt; index; i++) pre = pre.next; succ = pre.next.next; } else { succ = last; // 从尾部查找元素，需要 -1 for (int i = 0; i &lt; size - index - 1; i++) succ = succ.pre; pre = succ.pre.pre; } pre.next = succ; succ.pre = pre; size--; }} Kotlin 实现class MyLinkedList2() { var head: LinkedNode = LinkedNode(0) var last: LinkedNode = LinkedNode(0) var size: Int = 0 init { head.next = last last.pre = head } /** * 获取指定位置的元素，找不到返回 -1 */ fun get(index: Int): Int { val k = index if (k &lt; 0 || k &gt;= size) return -1 var cur: LinkedNode? = head if ((k + 1) &lt; (size - k)) { // 因为将伪头作为头结点，所以需要 +1 才是当前查找元素所在的结点 for (i in 0 until k + 1) cur = cur?.next } else { cur = last for (i in 0 until size - k) cur = cur?.pre } return cur?.`val` ?: -1 } /** * 在头部添加元素 */ fun addAtHead(`val`: Int) { val pre: LinkedNode? = head val succ: LinkedNode? = head.next val node: LinkedNode = LinkedNode(`val`) node.next = succ node.pre = pre succ?.pre = node pre?.next = node size++ } /** * 在尾部添加元素 */ fun addAtTail(`val`: Int) { val pre = last.pre val succ = last val node = LinkedNode(`val`) node.next = succ node.pre = pre pre?.next = node succ?.pre = node size++ } /** * 在指定位置插入元素 */ fun addAtIndex(index: Int, `val`: Int) { var k = index if (k &gt; size) return if (k &lt; 0) k = 0 var pre: LinkedNode? = head var succ: LinkedNode? = last // 因为有伪头、伪尾结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点 if (k &lt; size - k) { for (i in 0 until k) pre = pre?.next succ = pre?.next } else { succ = last; for (i in 0 until size - k) succ = succ?.pre pre = succ?.pre } val node = LinkedNode(`val`) node.next = succ node.pre = pre pre?.next = node succ?.pre = node size++ } /** * 删除指定位置的元素 */ fun deleteAtIndex(index: Int) { val k = index if (k &lt; 0 || k &gt;= size) return var pre: LinkedNode? = head var succ: LinkedNode? = last // 因为有伪头、伪尾结点存在，所以 i &lt; index 找到的节点，一定是插入位置的前驱节点 if (k &lt; size - k) { for (i in 0 until k) pre = pre?.next succ = pre?.next?.next } else { succ = last; // 从尾部查找元素，需要 -1 for (i in 0 until size - k - 1) succ = succ?.pre pre = succ?.pre?.pre } pre?.next = succ succ?.pre = pre size-- }}","link":"/backup/LeetCode/linked-list/01-design-linked-list.html"},{"title":"剑指 Offer 12：矩阵中的路径","text":"题目来源于 LeetCode 剑指 offer 第 12 号问题：矩阵中的路径。题目难度为 Medium。和 第79号问题：单词搜索 一样 中文地址：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/ 题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的 3×4 的矩阵中包含一条字符串 “bfce” 的路径（路径中的字母用加粗标出）。 [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]] 但矩阵中不包含字符串 “abfb” 的路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例1: 输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true 示例2: 输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false 提示： 1 &lt;= board.length &lt;= 2001 &lt;= board[i].length &lt;= 200 思路：DFS 深度优先遍历(递归)DFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 递归的两个特点： 问题和子问题都会调用函数自身，所以要找寻问题与子问题的递归关系，采用自上而下的思考方式。 有个终止条件（临界点）结束当前递归。 参数说明： board 是一个二维数组，所以用 i 表示行的下标，j 表示列的下标，word 是一个字符串转为数组用 words 表示，k 表示数组 words 的下标。 算法过程： 按照题目所说，搜索过程中可以朝着上、下、左、右四个方向去遍历。 每个方向如果访问过了，将当前访问过的元素存为一个临时变量 tmp，并将访问过的元素修改为 '/'，表示已经访问过了不在重复访问。 如果匹配失败了，还原数组中修改过后的元素，从另外一个方向继续访问。 如果匹配成功了，也需要还原数组中修改过后的元素，回溯过程中，再次验证是否正确。 复杂度分析： M,N 分别为矩阵行列大小，K 为字符串 word 长度。 时间复杂度：O(3^k MN)，因为矩阵中有 M 行 N 列，所以时间复杂度为 O(MN)，搜索过程中可以朝着上、下、左、右四个方向去遍历，舍弃回溯那个方向，实际上只朝着三个方向去遍历，所以时间复杂度为 O(3^k)。 空间复杂度：O(K)，递归调用占用栈的空间，递归调用结束后，栈空间会被释放，只是使用了几个标示变量作为额外空间，这部分可以忽略不计，每次搜索中深度不会超过 K，因为占用栈的空间大小不会超过 O(K)。 Koltin 实现class Solution { fun exist(board: Array&lt;CharArray&gt;, word: String): Boolean { if (board.size &lt;= 0 || board[0].size &lt;= 0) { return false } val row = board.size val colum = board[0].size val words = word.toCharArray() for (i in 0 until row) { for (j in 0 until colum) { if (dfs(board, words, i, j, 0, row, colum)) { return true } } } return false } fun dfs(board: Array&lt;CharArray&gt;, words: CharArray, i: Int, j: Int, k: Int, row: Int, colum: Int): Boolean { if (i &gt; row - 1 || i &lt; 0 || j &gt; colum - 1 || j &lt; 0 || board[i][j] != words[k]) { return false } if (k == words.size - 1) { return true } val tmp = board[i][j] board[i][j] = '/' val result = dfs(board, words, i + 1, j, k + 1, row, colum) || dfs(board, words, i - 1, j, k + 1, row, colum) || dfs(board, words, i, j + 1, k + 1, row, colum) || dfs(board, words, i, j - 1, k + 1, row, colum) board[i][j] = tmp return result }} Java 实现class Solution { public boolean exist(char[][] board, String word) { if (board.length &lt;= 0 || board[0].length &lt;= 0) { return false; } char[] words = word.toCharArray(); int row = board.length; int colum = board[0].length; for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; colum; j++) { if (dfs(board, words, i, j, 0, row, colum)) { return true; } } } return false; } boolean dfs(char[][] borad, char[] words, int i, int j, int k, int row, int colum) { if (i &gt; row - 1 || i &lt; 0 || j &gt; colum - 1 || j &lt; 0 || borad[i][j] != words[k]) { return false; } if (k == words.length - 1) { return true; } char tmp = borad[i][j]; borad[i][j] = '/'; boolean result = dfs(borad, words, i + 1, j, k + 1, row, colum) || dfs(borad, words, i - 1, j, k + 1, row, colum) || dfs(borad, words, i, j + 1, k + 1, row, colum) || dfs(borad, words, i, j - 1, k + 1, row, colum); borad[i][j] = tmp; return result; }}","link":"/backup/LeetCode/offer/12-ju-zhen-zhong-de-lu-jing.html"},{"title":"剑指 offer 10-2：青蛙跳台阶问题","text":"题目来源于 LeetCode 剑指 offer 第 10_2 号问题：青蛙跳台阶问题。题目难度为 Easy。这道题和 第70号问题：爬楼梯 一样 中文地址：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/ 题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例1: 输入：n = 2输出：2 示例2: 输入：n = 7输出：21 提示： * 0 &lt;= n &lt;= 100思路：这道题 斐波那契（Fibonacci）问题一样，它们在公式稍微一些不同 斐波那契（Fibonacci）公式如下所示： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 青蛙跳台阶 公式如下所示： f(0)=1 , f(1)=1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 复杂度分析： 时间复杂度：O(n)，F(N) 需要循环 N 次，因此时间复杂度为 O(n) 空间复杂度：O(1)，只是使用了几个标示变量作为额外空间，可以忽略不计，因此空间复杂度 O(1) Koltin 实现class Solution { fun numWays(n: Int): Int { if (n == 1 || n == 0) { return 1; } var a = 1; var b = 2; var sum = b; for (i in 2 until n) { sum = (a + b) % 1000000007 a = b.also { b = sum } } return sum }} Java 实现class Solution { public int numWays(int n) { if (n == 0 || n == 1) { return 1; } int a = 1; int b = 2; int sum = b; for (int i = 2; i &lt; n; i++) { sum = (a + b) % 1000000007; a = b; b = sum; } return sum; }}","link":"/backup/LeetCode/offer/10-2-qing-wa-tiao-tai-jie-wen-ti-lcof:.html"},{"title":"剑指 offer 11：旋转数组的最小数字","text":"题目来源于 LeetCode 剑指 offer 第 11 号问题：旋转数组的最小数字。题目难度为 Easy。和 第154号问题：寻找旋转排序数组中的最小值 II 一样 中文地址：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/ 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例1: 输入：[3,4,5,1,2]输出：1 示例2: 输入：[2,2,2,0,1]输出：0 思路：二分查找这道题目给出一个有序数组，之后转换成一个旋转数组作为输入数据，求旋转数组的最小数字。 例如 原数组 [1,2,3,4,5] 转换之后的旋转数组是 [3,4,5,1,2] 也有可能是 [4,5,1,2,3] 等等，旋转数组最小的数字是1。 二分查找不仅能用在有序数组上，而且还能用在减治的问题上，这道题也是减治问题。 用二分查找就首先应该寻找比较点，这是一个旋转数组所以最左边和最右边也就是我们的比较点，那么如何进行选择呢 如果用最左边位置 left 和中间位置 mid 的值进行比较是否可以？ 例如： 旋转数组 [3, 4, 5, 1, 2] 中的值都比左边大，但是最小的在右边，因此不合适。 如果用最右边边位置 right 和中间位置 mid 的值进行比较是否可以？ 例如：旋转数组 [3, 4, 5, 1, 2] 和 [2,3,4,5,1] 或者 [4,5,1,2,3]，最后小的在右边，那么用右边位置和中间位置的元素比较，不断缩小范围去查找 复杂度分析： 时间复杂度：O(log2^N)，使用的二分查找算法，因此时间复杂度为 O(log2^N) 空间复杂度：O(1)，只是使用了几个标示变量作为额外空间，可以忽略不计，因此空间复杂度 O(1) Koltin 实现class Solution { fun minArray(numbers: IntArray): Int { var left = 0 var right = numbers.size - 1 while (left &lt; right) { val mid = (left + right) ushr 1 when { numbers[mid] &gt; numbers[right] -&gt; left = mid + 1 numbers[mid] &lt; numbers[right] -&gt; right = mid else -&gt; right = right - 1 } } return numbers[left] }} Java 实现class Solution { public int minArray(int[] numbers) { int left = 0; int right = numbers.length - 1; while (left &lt; right) { int mid = (left + right) &gt;&gt;&gt; 2; if (numbers[mid] &lt; numbers[right]) { right = mid; } else if (numbers[mid] &gt; numbers[right]) { left = mid + 1; } else { right = right - 1; } } return numbers[left]; }}","link":"/backup/LeetCode/offer/11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof.html"},{"title":"剑指 Offer 13：机器人的运动范围","text":"题目来源于 LeetCode 剑指 offer 第 13 号问题：机器人的运动范围。题目难度为 Medium。 中文地址：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/ 题目描述地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 输入：m = 2, n = 3, k = 1输出：3 示例 2： 输入：m = 3, n = 1, k = 0输出：1 提示： 1 &lt;= n,m &lt;= 100 0 &lt;= k &lt;= 20 思路一：BFS 广度优先搜索（队列）BFS: 通常利用队列实现广度优先遍历。 参数说明： queue 表示一个队列，存储访问过的单元格，robot 表示一个二维数组记录访问过的单元格，用 x 表示行的下标，y 表示列的下标。 过滤条件： 是否在单元格内（x&gt;m-1 或者 y&gt;n-1）。 是否已经访问过了。 数位之和是否超过了 k。 算法过程： 按照题目所说，机器人从 [0, 0] 开始移动，每次移动一格，表示 [0, 0] 是原始坐标，它只会向右或者向下移动。 初始化: 将起点坐标 [0, 0] 放进 queue 中。 循环遍历： 先使用 过滤条件： 过滤掉无用的坐标。 数组 robot 记录机器人访问过的单元格，如果访问过将单元格标记为 -1。 朝着右、下两个方向访问，并将其坐标添加进 queue。 并用一个辅助变量 res 计算机器人可到达的单元格。 复杂度分析： M,N 分别为矩阵行列大小。 时间复杂度：O(MN)，矩阵中有 M 行 N 列，最差的情况下遍历完所有的单元格，所以时间复杂度为 O(MN)。 空间复杂度：O(MN)，需要建立额外的数组记录当前格子是否已经访问过了，最差的情况下访问了所有的单元格，故占用额外空间 O(MN) 注意： 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 remove() poll() 查找 element() peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null Koltin 实现class Solution { fun movingCount(m: Int, n: Int, k: Int): Int { val robot = Array(m, { IntArray(n) }) val queue = LinkedList&lt;IntArray&gt;() var res = 0 queue.offer(intArrayOf(0,0)) while(!queue.isEmpty()){ val(x,y) = queue.poll() if(x&gt;m-1 || y&gt;n-1 || robot[x][y] == -1 || count(x) + count(y) &gt; k){ continue; } robot[x][y] = -1 res +=1 queue.offer(intArrayOf(x+1,y)) queue.offer(intArrayOf(x,y+1)) } return res } fun count(x: Int): Int { var sx = x var count = 0 while (sx &gt; 0) { count += sx % 10 sx = sx / 10 } return count }} Java 实现class Solution { public int bfs(int m, int n, int k) { int[][] robot = new int[m][n]; int res = 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]{0, 0}); while (!queue.isEmpty()) { int[] item = queue.poll(); int x = item[0]; int y = item[1]; if (x &gt; m - 1 || y &gt; n - 1 || count(x) + count(y) &gt; k || robot[x][y] == -1) { continue; } robot[x][y] = -1; res++; queue.offer(new int[]{x + 1, y}); queue.offer(new int[]{x, y + 1}); } return res; } int count(int x) { int count = 0; while (x &gt; 0) { count += x % 10; x = x / 10; } return count; }} 思路二：DFS 深度优先搜索(递归)DFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 递归的两个特点： 问题和子问题都会调用函数自身，所以要找寻问题与子问题的递归关系，采用自上而下的思考方式。 有个终止条件（临界点）结束当前递归。 参数说明： robot 表示一个二维数组记录访问过的单元格，用 x 表示行的下标，y 表示列的下标。 终止条件： 是否在单元格内（x&gt;m-1 或者 y&gt;n-1）。 是否已经访问过了。 数位之和是否超过了 k。 算法过程： 按照题目所说，机器人从 [0, 0] 开始移动，每次移动一格，表示 [0, 0] 是原始坐标，它只会向右或者向下移动。 数组 robot 记录机器人访问过的单元格，如果访问过将单元格标记为 -1。 朝着右、下两个方向访问，未访问过并且在单元格范围内，计算它们之和。 复杂度分析： M,N 分别为矩阵行列大小。 时间复杂度：O(MN)，矩阵中有 M 行 N 列，最差的情况下遍历完所有的单元格，所以时间复杂度为 O(MN)。 空间复杂度：O(MN)，需要建立额外的数组记录当前单元格是否已经访问过了，最差的情况下访问了所有的单元格，故占用额外空间 O(MN) Koltin 实现class Solution { fun movingCount(m: Int, n: Int, k: Int): Int { val robot = Array(m, { IntArray(n) }) return dfs(robot, 0, 0, m, n, k) } fun dfs(robot: Array&lt;IntArray&gt;, x: Int, y: Int, m: Int, n: Int, k: Int): Int { if (x &gt; m - 1 || y &gt; n - 1 || robot[x][y] == -1 || count(x) + count(y) &gt; k) { return 0 } robot[x][y] = -1 // 起点为0，0，每次只能移动一格，即向右 x +1 或者向下 y +1 return dfs(robot, x + 1, y, m, n, k) + dfs(robot, x, y + 1, m, n, k) + 1 } fun count(x: Int): Int { var sx = x var count = 0 while (sx &gt; 0) { count += sx % 10 sx = sx / 10 } return count }} Java 实现class Solution { public int movingCount(int m, int n, int k) { int[][] robot = new int[m][n]; return dfs(robot, 0, 0, k, m, n); } int dfs(int[][] robot, int x, int y, int k, int m, int n) { if (x &gt; m - 1 || y &gt; n - 1 || robot[x][y] == -1 || count(x) + count(y) &gt; k) { return 0; } robot[x][y] = -1; // 起点为0，0，每次只能移动一格，即向右 x +1 或者向下 y +1 return dfs(robot, x + 1, y, k, m, n) + dfs(robot, x, y + 1, k, m, n) + 1; } int count(int x) { int count = 0; while (x &gt; 0) { count += x % 10; x = x / 10; } return count; }}","link":"/backup/LeetCode/offer/13-ji-qi-ren-de-yun-dong-fan-wei.html"},{"title":"剑指 offer 10-1：斐波那契数列","text":"题目来源于 LeetCode 上第 10 号问题：斐波那契数列。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/ 题目描述写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2输出：1 示例 2： 输入：n = 5输出：5 提示： 0 &lt;= n &lt;= 100 思路：根据 斐波那契数列 公式求解即可，公式如下所示： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2) PS: 需要注意的是，每次计算的结果需要取模 复杂度分析： 时间复杂度：O(N)，当 F(N) 时需要循环 N 次，即时间复杂度为 O(N) 空间复杂度：O(N)，需要额外的空间存储已有元素 Kotlin 实现class Solution { fun fib(n: Int): Int { return when { n == 0 -&gt; return 0 n == 1 -&gt; return 1 else -&gt; { val data = mutableListOf&lt;Int&gt;() data.add(0) data.add(1) for (i in 2..n) { data.add((data[i - 1] + data[i - 2]) % 1000000007) } return data[n] } } }} Java 实现public class Solution { public int fib(int n) { if (n == 0) { return 0; } int[] data = new int[n + 1]; data[0] = 0; data[1] = 1; for (int i = 2; i &lt;= n; i++) { data[i] = (data[i - 1] + data[i - 2]) % 1000000007; } return data[n]; }} 思路二：思路一的优化方案复杂度分析： 时间复杂度：O(N)，当 F(N) 时需要循环 N 次，即时间复杂度为 O(N) 空间复杂度：O(1)，占用常量大小的空间 public int fib2(int n) { if (n == 0) return 0; if (n == 1) return 1; int a = 0; int b = 1; int sum = 0; for (int i = 2; i &lt;= n; i++) { sum = (a + b) % 1000000007; a = b; b = sum; } return sum;}","link":"/backup/LeetCode/offer/10-fei-bo-na-qi-shu-lie-lcof.html"},{"title":"剑指 offer 09：用两个栈实现队列","text":"题目来源于 LeetCode 上第 09 号问题：用两个栈实现队列。题目难度为 Easy。和 主站 509 号问题相同。 中文地址：https://leetcode-cn.com/problems/yong……。 题目描述用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )。 示例 1: 输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 示例 2: 输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 思路：先来了解一下栈和队列的基本概念 栈 (Stack)：是一种后进先出(last in first off，LIFO)的数据结构，如下图所示： 队列：是一种先进先出的结构。，一端用来加入新元素，另一端用来删除元素。 算法步骤： 两个栈分别为 Stack 1 和 Stack 2，Stack 1 用于存储元素，Stack 2 作为辅助栈。 插入元素：将元素存储在 Stack 1 中。删除元素：如果 Stack 1 和 Stack 2 都为空返回 -1， 不为空，将 Stack 1 中的元素 pop 出来放到 Stack 2 中之后返回 Stack 2 栈顶元素，即可实现队列功能，假设： 一组输入数据 [1，2，3，4],如果放到队里中，队列是一种先进先出的结构，即输出结果为：[1，2，3，4], 我看一下栈是如何实现的： Stack 1 元素 [1，2，3，4] pop 出来放到 Stack 2 中，Stack 2 中的元素为 [4，3，2，1]。 栈是后进先出的结构，然后依次弹出 Stack 2 中的元素，即输出结果为：[1， 2，3，4]。 复杂度分析： 时间复杂度：插入操作 appendTail() 时间复杂度 O(1)，删除操作 deleteHead() 时间复杂度 O(N)， 空间复杂度：O(N)，需要使用两个栈存储已有的元素 Koltin 实现class CQueue() { val stack1 = Stack&lt;Int&gt;() val stack2 = Stack&lt;Int&gt;() fun appendTail(value: Int) { stack1.push(value); } fun deleteHead(): Int { return when { !stack2.isEmpty() -&gt; stack2.pop() stack1.isEmpty() -&gt; -1 else -&gt; { while (!stack1.isEmpty()) { stack2.push(stack1.pop()) } return stack2.pop() } } }} Java 实现class CQueue { private Stack&lt;Integer&gt; stack1; private Stack&lt;Integer&gt; stack2; public CQueue() { stack1 = new Stack(); stack2 = new Stack(); } public void appendTail(int value) { stack1.push(value); } public int deleteHead() { if (!stack2.isEmpty()) { return stack2.pop(); } else if (stack1.isEmpty()) { return -1; } else { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } return stack2.pop(); } }}","link":"/backup/LeetCode/offer/09-yong-liang-ge-zhan-shi-xian-dui-lie.html"},{"title":"剑指 Offer 16：数值的整数次方","text":"题目来源于 LeetCode 剑指 offer 第 16 号问题：数值的整数次方。题目难度为 Medium。和第 50 号问题 相同 中文地址：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/ 50 号问题-英文地址：https://leetcode.com/problems/powx-n/ 50 号问题-中文地址：https://leetcode-cn.com/problems/powx-n/ 题目描述实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例 1： 输入: 2.00000, 10输出: 1024.00000 示例 2： 输入: 2.10000, 3输出: 9.26100 示例 3： 输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明： -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。 思路：这到题用到了位运算符，我们先来回顾一下： x &gt;&gt; 1 等价于 (x = x / 2)x &lt;&lt; 1 等价于 (x = x * 2)x &amp; 1 等价于 (x % 2 == 1) 以下图片来自 LeetCode 社区 算法流程如下： x 表示整数， m 表示平方，res 累计结果 当 x == 0 时，返回 0 ，避免后续的 x = 1 / x 出错 当 x &lt; 0 时，需要转为 x &gt;= 0，在这个范围内求解，即 x = 1 / x; m *= -1 初始化 res 为 1 循环计算，当 m == 0 时跳出循环 当 (m &amp; 1) == 1 时，即 res = res * x 执行 x = x * x 将 m 右移 1 位，即 m = m &gt;&gt; 1 注意： m 可以取到 -2147483648（整型负数的最小值），执行 m *= -1; 会因越界而出错，所以需要将 m 转换成 long 型 复杂度分析： 时间复杂度：O(log2^n) ，2 分查找时间复杂度为对数级别 空间复杂度：O(1)，需要几个变量，占常数大小的空间 Kotlin 实现class Solution { fun myPow(x: Double, n: Int): Double { if (x == 0.0) return 0.0 var x1 = x var res = 1.0 var m = n.toLong() if (m &lt; 0) { x1 = 1 / x1 m = -1 * m } while (m &gt; 0) { if ((m % 2).toInt() == 1) res = res * x1 x1 = x1 * x1 m = m / 2 } return res }} Java 实现class Solution { // x &gt;&gt; 1 ==&gt; (x = x / 2) // x &lt;&lt; 1 ==&gt; (x = x * 2) // x &amp; 1 ==&gt; (x % 2 == 1) public double myPow(double x, int n) { if (x == 0) return 0; long m = n; double res = 1.0; if (m &lt; 0) { x = 1 / x; m *= -1; } while (m &gt; 0) { if ((m &amp; 1) == 1) res = res * x; x = x * x; m = m &gt;&gt; 1; } return res; }}","link":"/backup/LeetCode/offer/16-shu-zhi-de-zheng-shu-ci-fang.html"},{"title":"剑指 Offer 14-1：剪绳子","text":"题目来源于 LeetCode 剑指 offer 第 14-1 号问题：剪绳子。题目难度为 Medium。 中文地址：https://leetcode-cn.com/problems/jian-sheng-zi-lcof 题目描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0] * k[1] * … * k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2： 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 58 思路：一绳子长度为 n，假设这条绳子被分为 2 段或者 3 段。按照经验切分成 3 段比切分成 2 段的乘积要大，但是也有少数情况切分成 2 段比 3 段乘积大。 例如 n = 6, 2 段 3x3 比 3 段 2 x 2 x 2 要大 故所以我们列出所有的可能性寻找规律： 绳子长度为 n 计算方式 结果 2 1 + 1 ——&gt; 1 x 1 dp[2] = 1 3 1 + 2 ——&gt; 1 x 2 dp[3] = 2 4 2 + 2 ——&gt; 2 x 2 dp[4] = 4 5 2 + 3 = 1 + 4 ——&gt; 2 + 3 &gt; 1 + 4 dp[5] = 6 6 3 + 3 = 2 + 2+ 2 ——&gt; 3 x 3 &gt; 2 x 2 x 2 dp[6] = 9 7 3 + 4 ——&gt; 3 x dp[7-3] dp[7] = 12 8 3 + 5 ——&gt; 3 x dp[8-3] dp[8] = 18 当 n &gt;= 7 ；其结果满足公式为 dp [n] = 3 * dp[n - 3] 复杂度分析： 时间复杂度：O(N)，长度为 N 的绳子，需要计算 [1,n] 累计的最大值，故时间复杂度为 O(N) 空间复杂度：O(N)，需要建立长度为 N 的数组，存储每次计算的值，所以空间复杂度为 O(N) Koltin 实现class Solution { fun cuttingRope(n: Int): Int { val dp = IntArray(if (n &lt; 7) 8 else n + 1) dp[1] = 1 dp[2] = 1 dp[3] = 2 dp[4] = 4 dp[5] = 6 dp[6] = 9 dp[7] = 12 for (i in 8..n) { dp[i] = 3 * dp[i - 3] } return dp[n] }} Java 实现public class Solution { public int cuttingRope(int n) { int m = n; if (n &lt; 7) { n = 7; } int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 1; dp[3] = 2; dp[4] = 4; dp[5] = 6; dp[6] = 9; dp[7] = 12; for (int i = 8; i &lt;= n; i++) { dp[i] = 3 * dp[i - 3]; } return dp[m]; }}","link":"/backup/LeetCode/offer/14-1-jian-sheng-zi.html"},{"title":"剑指 Offer 15：二进制中 1 的个数","text":"题目来源于 LeetCode 剑指 offer 第 15 号问题：二进制中 1 的个数。题目难度为 Easy。和第 191 号问题（位1的个数） 相同 中文地址：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/ 191 号问题-英文地址：https://leetcode.com/problems/number-of-1-bits/ 191 号问题-中文地址：https://leetcode-cn.com/problems/number-of-1-bits/ 题目描述编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量） 示例 1： 输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 思路：位运算：我们先来回顾一下基本的位运算规则： 或运算（|）： 两位同时为 0，结果为 0，否则为 1 0 | 0 = 0； 0 | 1 = 1； 1 | 0 = 1； 1 | 1 = 1 与运算符（&amp;）： 两位同时为 1，结果为 1，否则为 0 0 &amp; 0 = 0; 0 &amp; 1 = 0; 1 &amp; 0 = 0; 1 &amp; 1 = 1; 异或运算： 两个相应位 值不同 时，结果为 1，否则为 0. 0 ^ 0 = 0； 0 ^ 1 = 1； 1 ^ 0 = 1； 1 ^ 1 = 0； 取反运算符（~）： 对一个二进制数按位取反，即将 0 变 1，1 变 0。 ~1 = 0； ~0 = 1； 如上所示根据位运算规则，我们可以利用 与运算符（&amp;） 来解。 1 &amp; 1 = 1 1 &amp; 0 = 0 变量声定义： result 用来存储累加的结果 n 为无符号整数 我们可以逐位循环判断，算法流程如下： 初始化 result 为 0 当 n == 0 时即循环结束 将 n &amp; 1 的结果，累加到 result 上，故 result += n &amp; 1 n 为无符号整数，所以将 n 无符号右移动 1 位，故 n = n &gt;&gt;&gt; 1 复杂度分析： 时间复杂度：O(log2^n) ，其中 n 代表最高位 1 所在的位数 空间复杂度：O(1)，需要一个额外的变量 result 来存储累加结果，result 占了一个常数大小的空间 Java 实现public class Solution { public int hammingWeight(int n) { int result = 0; while (n != 0) { result += n &amp; 1; n = n &gt;&gt;&gt; 1; } return result; }}","link":"/backup/LeetCode/offer/15-er-jin-zhi-zhong-1de-ge-shu-lcof.html"},{"title":"剑指 Offer 14-2：剪绳子","text":"题目来源于 LeetCode 剑指 offer 第 14-2 号问题：剪绳子。题目难度为 Medium。和第 343 号问题（整数拆分） 相同 中文地址：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/ 整数拆分-英文地址：https://leetcode.com/problems/integer-break/ 整数拆分-中文地址：https://leetcode-cn.com/problems/integer-break/ 题目描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0] * k[1] * ... * k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2： 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 1000 思路：注意： 题目说了要做取模运算，凡是这种题，一定要注意精度问题。 一绳子长度为 n，假设这条绳子被分为 2 段或者 3 段。按照经验切分成 3 段比切分成 2 段的乘积要大，但是也有少数情况切分成 2 段比 3 段乘积大。 例如 n = 6, 2 段 3x3 比 3 段 2 x 2 x 2 要大 故所以我们列出所有的可能性寻找规律： 绳子长度为 n 计算方式 结果 2 1 + 1 ——&gt; 1 x 1 dp[2] = 1 3 1 + 2 ——&gt; 1 x 2 dp[3] = 2 4 2 + 2 ——&gt; 2 x 2 dp[4] = 4 5 2 + 3 = 1 + 4 ——&gt; 2 + 3 &gt; 1 + 4 dp[5] = 6 6 3 + 3 = 2 + 2+ 2 ——&gt; 3 x 3 &gt; 2 x 2 x 2 dp[6] = 9 7 3 + 4 ——&gt; 3 x dp[7-3] dp[7] = 12 8 3 + 5 ——&gt; 3 x dp[8-3] dp[8] = 18 当 n &gt;= 7 时可转化为多个短绳（长度 1~6）；其结果满足公式为 dp [n] = (dp[n - 3] * 3) % 1000000007 复杂度分析： 时间复杂度：O(N)，长度为 N 的绳子，需要计算 [1,n] 累计的最大值，故时间复杂度为 O(N) 空间复杂度：O(N)，需要建立长度为 N 的数组，存储每次计算的值，所以空间复杂度为 O(N) Koltin 实现class Solution { fun cuttingRope(n: Int): Int { val dp = LongArray(if (n &lt; 7) 8 else n + 1) dp[2] = 1 dp[3] = 2 dp[4] = 4 dp[5] = 6 dp[6] = 9 dp[7] = 12 for (i in 8..n) { dp[i] = (dp[i - 3] * 3) % 1000000007 } return dp[n].toInt() }} Java 实现class Solution { public int cuttingRope(int n) { int m = n; if (n &lt; 7) n = 7; long[] dp = new long[n + 1]; dp[2] = 1; dp[3] = 2; dp[4] = 4; dp[5] = 6; dp[6] = 9; dp[7] = 12; for (int i = 8; i &lt;= n; i++) { dp[i] = (dp[i - 3] * 3) % 1000000007; } return (int) dp[m]; }}","link":"/backup/LeetCode/offer/14-2-jian-sheng-zi-ii-lcof.html"},{"title":"剑指 Offer 22：链表中倒数第 k 个节点","text":"题目来源于 LeetCode 剑指 offer 第 22 号问题： 链表中倒数第 k 个节点。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof 题目描述输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5. 思路：快慢指针参数说明： slow：慢指针 fast: 快指针 算法流程如下： 初始化快慢指针，指向链表的头结点 让快指针 fast 沿着链表移动 k 次，此时 fast 指向第 k 个节点 循环遍历链表，当 fast.next == null 结束循环 移动慢指针 slow = slow.next 移动快指针 fast = fast.next 当循环结束时，即慢指针 slow 指向的是倒数第 k 个节点，返回 slow 复杂度分析： 时间复杂度：O(N) ，N 为链表的长度 空间复杂度：O(1)，快指针 fast 和 慢指针 slow 占用常数大小的空间 Kotlin 实现class Solution { fun getKthFromEnd(head: ListNode?, k: Int): ListNode? { if (head == null || k &lt; 0) return head var fast = head; (1 until k).forEach { fast = fast?.next } var slow = head; while (fast?.next != null) { fast = fast?.next; slow = slow?.next; } return slow; }} Java 实现class Solution { public ListNode getKthFromEnd(ListNode head, int k) { if (head == null || k &lt; 0) return head; ListNode fast = head; for (int i = 1; i &lt; k; i++) { fast = fast.next; } ListNode slow = head; while (fast.next != null) { fast = fast.next; slow = slow.next; } return slow; }}","link":"/backup/LeetCode/offer/22-lian-biao-zhong-dao-shu-di-kge-jie-dian.html"},{"title":"剑指 Offer 19：正则表达式匹配","text":"题目来源于 LeetCode 剑指 offer 第 19 号问题： 正则表达式匹配。题目难度为 Hard。 中文地址：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/ 题目描述请实现一个函数用来匹配包含 . 和 * 的正则表达式。模式中的字符 . 表示任意一个字符，而 * 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 aaa 与模式 a.a 和 ab*ac*a 匹配，但与 aa.a 和 ab*a 均不匹配。 示例 1： 输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2： 输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。 示例 3： 输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4： 输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5： 输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 说明： s 可能为空，且只包含从 a-z 的小写字母 p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 * 思路：注意： 假设输入的字符串 s = &quot;aab&quot; 和 p = &quot;c*a*b&quot;，其中 c* 或者 a* 它们是一个整体，例如 c* 可以是 0 个 c ，也可以是多个 c。 字符 .* 可以表示任意字符（0 个或者多个） 算法流程如下： 假设主串为 s，模式串为 p，需要关注正则表达式 p 的最后一个字符是谁，它有三种可能： p[j-1] = 正常字符 p[j-1] = '.' p[j-1] = '*' 只需要针对上面三种情况讨论即可 情况一：p[j-1] = 正常字符 需要看最后一个字符串是否相等: 如果相等的话，就要匹配前面的字符串是否相等， 即 s[i-1] == p[j-1] 公式为 dp[i][j] = dp[i-1][j-1] 如果不相等的话，就要看最后一个字符串是 . 还是 * 情况二：p[j-1] = ‘.’ 字符 . 是万能字符，可以直接让它等于 s[i-1]，同情况一处理 dp[i][j] = dp[i-1][j-1] 情况三：p[j-1] = ‘*’ 字符 * 可以匹配 0 个或多个前面的字符，而是否能取 0 个或者多个字符，需要看前面的 p[j-2] 是否等于 s[i-1] 当 p[j-2] != s[i-1] 如果它们不相等，则最后两个字符废掉了，即 dp[i][j] = dp[i][j-2] 当 p[j-2] == s[i-1] 或者 p[j-2] = '.' 字符 * 可以匹配 0 个或多个前面的字符，p[j-2] = '.' 可以直接让它等于 s[i-1] 取 0 个字符 例如：s = aab, p = aabb，虽然 j-2 和 i-1 相等，但是 dp[i][j-2] 已经匹配了，直接删除 j-1 和 j-2，即 dp[i][j] = dp[i][j-2] 取 1 个字符 例如：s = aab, p = aab，取1个字符，相当于去掉 p[j-1]，即 dp[i][j] = dp[i][j-1] 取多个字符 例如：s = aabb, p = aab，需要判断 s = aab 和 p = aab 是否匹配，如果可以匹配，那么 s 后面再加上一个 b 也没关系，因为 * 可以变成多个 b，即 dp[i][j] = dp[i-1][j] 总结： 情况一 和 情况二，可以当做一种情况来处理，即 val ms = s[i - 1]val mp = p[j - 1]if (mp == ms || mp == '.') { dp[i][j] = dp[i - 1][j - 1]} 无论 p[j-2] 是否等于 s[i-1]，都可以删除掉最后两个字符 dp[i][j] = dp[i][j] || dp[i][j - 2] 当 p[j-2] == s[i-1] 或者 p[j-2] = '.' 可以取 1 个或者多个字符 val mpLast = p[j - 2]if (ms == mpLast || mpLast == '.') { dp[i][j] = dp[i - 1][j] || dp[i][j - 1]} 初始化 空串和空正则是匹配的，即 dp[0][0] = true 需要初始化第一行，当 p[i-1] 为 * 可以把 i-2 和 i-1 处的字符删掉，并且只有 [0, i-3] 为 true 才可以让 dp[0][i] = true 复杂度分析： M 是字符串 s 的长度， N 是字符串 p 的长度 时间复杂度：O(MN) ，需要遍历每个字符进行匹配，即时间复杂度为 O(MN) 空间复杂度：O(MN)，需要建立数组 dp 保存匹配的结果 Kotlin 实现class Solution { fun isMatch(s: String, p: String): Boolean { val row = s.length val colum = p.length val dp = Array(row + 1) { BooleanArray(colum + 1) } dp[0][0] = true; for (i in 1..colum) { if (p[i - 1] == '*' &amp;&amp; dp[0][i - 2]) { dp[0][i] = true } } for (i in 1..row) { for (j in 1..colum) { val ms = s[i - 1] val mp = p[j - 1] if (mp == ms || mp == '.') { dp[i][j] = dp[i - 1][j - 1] } else if (mp == '*') { if (j &lt; 2) continue val mpLast = p[j - 2] if (ms == mpLast || mpLast == '.') { dp[i][j] = dp[i - 1][j] || dp[i][j - 1] } dp[i][j] = dp[i][j] || dp[i][j - 2] } } } return dp[row][colum] }} Java 实现class Solution { public boolean isMatch(String s, String p) { if (s == null || p == null) { return false; } int row = s.length(); int colum = p.length(); boolean[][] dp = new boolean[row + 1][colum + 1]; dp[0][0] = true; for (int j = 1; j &lt;= colum; j++) { if (p.charAt(j - 1) == '*' &amp;&amp; dp[0][j - 2]) { dp[0][j] = true; } } for (int i = 1; i &lt;= row; i++) { for (int j = 1; j &lt;= colum; j++) { char ms = s.charAt(i - 1); char mp = p.charAt(j - 1); /** * 两种情况 * 和 非* */ if (ms == mp || mp == '.') { // 非* dp[i][j] = dp[i - 1][j - 1]; } else if (mp == '*') { // 遇到 * 号，则代码 P[m−2]=c 可以重复0次或多次，它们是一个整体 c* if (j &lt; 2) continue; char mpLast = p.charAt(j - 2); if (mpLast == ms || mpLast == '.') { dp[i][j] = dp[i - 1][j] || dp[i][j - 1]; } // P[n−1] 是 0 个 c，P 最后两个字符废了 dp[i][j] = dp[i][j] || dp[i][j - 2]; } } } return dp[row][colum]; }}","link":"/backup/LeetCode/offer/19-zheng-ze-biao-da-shi-pi-pei.html"},{"title":"剑指 Offer 18：删除链表的节点","text":"题目来源于 LeetCode 剑指 offer 第 18 号问题： 删除链表的节点。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof 题目描述给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 示例 1： 输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2： 输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 思路：如何删除节点： 假设 current 指向 head 节点，tmpNode 为要删除的节点，算法如下 val tmpNode = current.next;current.next = tmpNode.next 算法流程如下： current 指向 head 节点 如果 head == null 即返回 head 节点 如果头节点是要删除的节点，即 head.val == val 返回 head.next, 删除头节点 循环遍历下一个节点是否为空 while (current?.next != null) { ... } 判断下一个节点是否是要删除的节点，如果是则调用删除节点算法 val tmpNode = current.next;current.next = tmpNode.next 循环遍历结束，返回 head 节点 复杂度分析： 时间复杂度：O(N) ，N 为链表长度，假设要删除的节点在末尾，即时间复杂度为 O(N) 空间复杂度：O(1)，current 占用常数大小的空间，可以不用计算，即空间复杂度为 O(1) Kotlin 实现class Solution { fun deleteNode(head: ListNode?, `val`: Int): ListNode? { if (head == null) return head if (head.`val` == `val`) return head.next var current = head while (current?.next != null) { val tmpNode = current.next; if (tmpNode.`val` == `val`) { current.next = tmpNode.next break; } current = tmpNode } return head }} Java 实现class Solution { public ListNode deleteNode(ListNode head, int val) { if (head == null) return head; if (head.val == val) return head.next; ListNode current = head; while (current.next != null) { ListNode tmp = current.next; if (tmp.val == val) { current.next = tmp.next; break; } current = tmp; } return head; }}","link":"/backup/LeetCode/offer/18-shan-chu-lian-biao-de-jie-dian.html"},{"title":"剑指 Offer 21：调整数组顺序使奇数位于偶数前面","text":"题目来源于 LeetCode 剑指 offer 第 21 号问题： 调整数组顺序使奇数位于偶数前面。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof 题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例 1： 输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 1 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10000 思路一：双指针 + 位运算参数说明： left：左指针 right：右指针 算法流程如下： 初始化左右指针指向数组两端 遍历数组，当 left &gt;= right 即退出循环 指针 left 从左边开始，遇到奇数 left++，直到遇到偶数停止 指针 right 从右边开始，遇到偶数 right–，直到遇到奇数停止 交换左右指针 返回交互后的数组 常用三种交换算法： int a = 1;int b = 2;// 中间变量int temp = a;a = b;b = temp;// 加减运算a = a + b;b = a - b;a = a - b; // 位运算a = a ^ b;b = a ^ b;a = a ^ b; 使用位运算判断奇数和偶数： int a = 2;a &amp; 1 == 1 // 奇数a &amp; 1 ！= 1 // 偶数 Kotlin 位运算符 shl(bits) – 左移位，等价于 Java &lt;&lt;shr(bits) – 右移位，等价于 Java &gt;&gt;ushr(bits) – 无符号右移位，等价于 Java &gt;&gt;&gt;and(bits) – 与，等价于 Java &amp;or(bits) – 或，等价于 Java ||xor(bits) – 异或，等价于 Java ^inv() – 反向，等价于 Java ~ 复杂度分析： 时间复杂度：O(N) ，为数组 nums 长度 空间复杂度：O(1)，使用常数大小的空间 Kotlin 实现class Solution { /** * 左右指针 */ fun exchange(nums: IntArray): IntArray { var left = 0 var right = nums.size - 1 while (left &lt; right) { // and == &amp; while (left &lt; right &amp;&amp; nums[left] and 1 == 1) left++ while (left &lt; right &amp;&amp; nums[right] and 1 != 1) right-- if (left &lt; right) { // xor == ^ nums[left] = nums[left] xor nums[right] nums[right] = nums[left] xor nums[right] nums[left] = nums[left] xor nums[right] } } return nums; }} Java 实现public class Solution { /** * 左右指针 */ public int[] exchange(int[] nums) { int left = 0; int right = nums.length - 1; while (left &lt; right) { while (left &lt; right &amp;&amp; (nums[left] &amp; 1) == 1) left++; while (left &lt; right &amp;&amp; (nums[right] &amp; 1) != 1) right--; if (left &lt; right) { nums[left] = nums[left] ^ nums[right]; nums[right] = nums[left] ^ nums[right]; nums[left] = nums[left] ^ nums[right]; } } return nums; }} 思路二：快慢指针 + 位运算参数说明： show：慢指针 fast: 快指针 size: 数组的长度 算法流程如下： 初始化快慢指针，指向数组开始的位置 遍历数组，当 fast &gt; size 即退出循环 快指针 fast 从左边开始，遇到偶数 fast++ 如果快指针 fast 遇到奇数，则交换快慢指针，交换后，慢指针 show++ 返回交互后的数组 复杂度分析： 时间复杂度：O(N) ，为数组 nums 长度 空间复杂度：O(1)，使用常数大小的空间 Kotlin 实现class Solution { /** * 快慢指针 */ fun exchange2(nums: IntArray): IntArray { var show = 0 var fast = 0 val size = nums.size while (fast &lt; size) { // and == &amp; if (nums[fast] and 1 == 1) { val tmp = nums[show] nums[show] = nums[fast]; nums[fast] = tmp; show++ } fast++ } return nums; }} Java 实现public class Solution { /** * 快慢指针 */ public int[] exchange2(int[] nums) { int low = 0; int fast = 0; int size = nums.length; while (fast &lt; size) { if ((nums[fast] &amp; 1) == 1) { int tmp = nums[low]; nums[low] = nums[fast]; nums[fast] = tmp; low++; } fast++; } return nums; }}","link":"/backup/LeetCode/offer/21-diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof.html"},{"title":"剑指 Offer 17：打印从1到最大的n位数","text":"题目来源于 LeetCode 剑指 offer 第 17 号问题： 打印从1到最大的n位数。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/ 题目描述输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1： 输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 说明： 用返回一个整数列表来代替打印 n 为正整数 思路一：由于本题要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内，但是在实际面试过程中，面试官肯定会考大数，也就意味着会越界。 算法流程如下： 如果考大数的话，无论 int 还是 long 类型它们的取值范围都是有限的，因此只能使用字符串 String 类型。 result 表示一个整数列表，num 存储生成的字符串，x 表示当前所在位数，假设 n = 2 时，生成 1 ~ 99 的全排列流程如下： 从下标 x = 0 开始，先固定十位为 0 ~ 9 x = x + 1, 开始递归遍历个位为 0 ~ 9 当 x == n 时，递归遍历结束 复杂度分析： n 表示需要生成数字的位数 时间复杂度：O(10^n) ，递归生成的数字的排列个数为 10^n 空间复杂度：O(n)，字符串 num 使用线性排列 Kotlin 实现class Solution { val defNum = charArrayOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9'); var index = 0; fun printNumbers(n: Int): IntArray { val num = CharArray(n) var max = 1 // kotlin 中使用 Math.pow 要求参数都是double类型，所以这里自动生成对应的位数 for (i in 1..n) { max = max * 10; } val result = IntArray(max - 1) dfs(num, result, 0) // 开始递归遍历 return result; } fun dfs(num: CharArray, result: IntArray, x: Int) { if (x == num.size) { // 生成的数字前面可能有 0 例如：000,001,002... 等等 // parstInt 方法删除高位多余的 0 val res = parstInt(num); // 过滤掉第一个数字 0 if (res &gt; 0) { result[index] = res index = index + 1 } return; } for (c in defNum) { num[x] = c dfs(num, result, x + 1) } } fun parstInt(num: CharArray): Int { var sum = 0 var isNotZero = false for (c in num) { // 生成的数字前面可能有 0 例如：000,001,002... 等等 // 过滤掉高位多余的 0 if (!isNotZero) { if (c == '0') { continue } else { isNotZero = true } } sum = sum * 10 + (c - '0') } return sum; }} Java 实现public class Solution { char[] defNum = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; int index = 0; public int[] printNumbers(int n) { char[] num = new char[n]; int[] result = new int[(int) Math.pow(10, n) - 1]; dfs(num, result, 0); // 开始递归遍历 return result; } public void dfs(char[] num, int[] result, int x) { if (x == num.length) { // 生成的数字前面可能有 0 例如：000,001,002... 等等 // parstInt 方法删除高位多余的 0 int res = parseInt(num); // 过滤掉第一个数字 0 if (res &gt; 0) { result[index++] = res; } return; } for (char c : defNum) { num[x] = c; dfs(num, result, x + 1); } } public int parseInt(char[] num) { int sum = 0; boolean isNotZero = false; for (char c : num) { // 生成的数字前面可能有 0 例如：000,001,002... 等等 // 过滤掉高位多余的 0 if (!isNotZero) { if (c == '0') { continue; } else { isNotZero = true; } } sum = sum * 10 + (c - '0'); } return sum; }} 思路二：思路二比较简单，题目要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内。 假设 n = 2 时，生成 1 ~ 99，数字范围等价于 [1, 100 -1] , 最大取值相当于 Math.pow(10, n) - 1 也可以循环生成最大取值，如下所示 var max = 1;for (i in 1..n) { max = max * 10;} Kotlinclass Solution { fun printNumbers(n: Int): IntArray { var max = 1; for (i in 1..n) { max = max * 10; } val result = IntArray(max - 1) for (i in 1 until max) { result[i - 1] = i } return result; }} Javapublic class Solution { public int[] printNumbers(int n) { int max = 1; for (int i = 1; i &lt;= n; i++) { max = max * 10; } int[] result = new int[max - 1]; for (int i = 1; i &lt; max; i++) { result[i - 1] = i; } return result; }}","link":"/backup/LeetCode/offer/17-da-yin-cong-1dao-zui-da-de-nwei-sh.html"},{"title":"剑指 Offer 24：反转链表","text":"题目来源于 LeetCode 剑指 offer 第 24 号问题：反转链表。题目难度为 Easy。与主站 206 号问题 相同。 中文地址：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof 题目描述定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制： 0 &lt;= 节点个数 &lt;= 5000 思路：递归和非递归算法流程如下： 初始化指针 pre 为空指针， ListNode pre = null 循环移动链表，当 head == null 结束循环 每次移动让 head.next = pre 实现局部反转 将 head 和 pre 移到下一个节点 当循环结束时，即 pre 指向原链表尾部 复杂度分析： 时间复杂度：O(N) ，N 为链表的长度 空间复杂度：O(1) ，指针 pre 占用常数大小的空间 Java 实现class Solution { /** * 非递归 */ public ListNode reverseList(ListNode head) { ListNode pre = null; while (head != null) { ListNode next = head.next; head.next = pre; pre = head; head = next; } return pre; } /** * 递归 */ public ListNode reverseList2(ListNode head) { if (head == null || head.next == null) return head; ListNode cur = reverseList(head.next); head.next.next = head; head.next = null; return cur; }} Kotlin 实现class Solution { /** * 非递归 */ fun reverseList(head: ListNode?): ListNode? { var pre: ListNode? = null var current = head while (current != null) { val next = current.next current.next = pre; pre = current; current = next } return pre; } /** * 递归 */ fun reverseList2(head: ListNode?): ListNode? { if (head == null || head.next == null) return head; val cur = reverseList(head.next); head.next.next = head; head.next = null; return cur; }}","link":"/backup/LeetCode/offer/24-fan-zhuan-lian-biao.html"},{"title":"剑指 Offer 25：合并两个排序的链表","text":"题目来源于 LeetCode 剑指 offer 第 25 号问题：合并两个排序的链表。题目难度为 Easy。与主站 21 号问题 相同 中文地址：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof 题目描述输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例 1： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 限制： 0 &lt;= 链表长度 &lt;= 1000 思路：算法流程如下： 初始化伪头节点 cur 和 head，并将 head 指向 cur 循环移动两个链表，当其中一个链表为空时结束循环 当 l1.val &lt; l2.val 时，cur.next = l1，并将 l1 和 cur 移到下一个节点，即 l1 = l1.next; cur = cur.next 当 l1.val &gt; l2.val 时，cur.next = l2，并将 l2 和 cur 移到下一个节点，即 l2 = l1.next; cur = cur.next 当循环结束时，合并剩余的节点 如果 l1 != null, 即 cur.next = l1 如果 l2 != null, 即 cur.next = l2 因为最开始建立一个伪头节点，所以最后应该返回伪头节点的下一个节点，即 head.next 复杂度分析： 时间复杂度：O(N) ，N 为链表的长度 空间复杂度：O(1) ，伪头节点 cur 和 head 占用常数大小的空间 Java 实现class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode head = new ListNode(0); ListNode cur = head; while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { cur.next = l1; l1 = l1.next; } else { cur.next = l2; l2 = l2.next; } cur = cur.next; } cur.next = l1 == null ? l2 : l1; return head.next; }} Kotlin 实现class Solution { fun mergeTwoLists(l1: ListNode?, l2: ListNode?): ListNode? { var head = ListNode(0) var cur = head var pl1 = l1; var pl2 = l2; while (pl1 != null &amp;&amp; pl2 != null) { if (pl1.`val` &lt; pl2.`val`) { cur.next = pl1 pl1 = pl1.next } else { cur.next = pl2 pl2 = pl2.next } cur = cur.next } cur.next = if (pl1 == null) pl2 else pl1 return head.next }}","link":"/backup/LeetCode/offer/25-he-bing-liang-ge-pai-xu-de-lian-biao.html"},{"title":"剑指 Offer 28：对称的二叉树","text":"题目来源于 LeetCode 剑指 offer 第 28 号问题：对称的二叉树。和第 101 号题 相同。 中文地址：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof 题目描述请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\2 2 \\ \\ 3 3 示例 1： 输入：root = [1,2,2,3,4,4,3]输出：true 示例 2： 输入：root = [1,2,2,null,3,null,3]输出：false 限制： 0 &lt;= 节点个数 &lt;= 1000 思路一：前序遍历变形算法流程如下： 假设二叉树的左右节点为 L 和 R 一颗对称的二叉树，一定满足以下特点 L.val == R.val，当前的对称节点是相等的 L.left.val, R.right.val，L 的左子树的节点 和 R 的右子树的节点是相等的 L.right.val, R.left.val，L 的右子树的节点 和 R 的左子树的节点是相等的 根据以上特点按照二叉树的前序遍历，判断是否是对称的二叉树 复杂度分析： 时间复杂度 O(N) ，其中 N 为二叉树的节点数量 空间复杂度 O(N) ， 最差情况下（当二叉树退化为链表） Kotlin 同 Java 的实现class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) return true; return symmetric(root.left, root.right); } public boolean symmetric(TreeNode L, TreeNode R) { if (L == null &amp;&amp; R == null) return true; if (L == null || R == null || L.val != R.val) return false; return symmetric(L.left, R.right) &amp;&amp; symmetric(L.right, R.left); }} 思路二：镜像对称一颗对称的二叉树，一定是镜像对称，步骤如下所示： 生成二叉树的镜像：利用后续遍历，交换左右子树即可 根据先序遍历，判断镜像二叉树和原二叉树是否相等 Java 同 Kotlin 实现class Solution { fun isSymmetric(root: TreeNode?): Boolean { if (root == null) return true val mirror = mirrorTree(root) return isSame(mirror, root) } /** * 根据先序遍历，判断镜像二叉树和原二叉树是否相等 */ fun isSame(a: TreeNode?, b: TreeNode?): Boolean { if (a == null &amp;&amp; b == null) return true if (a == null || b == null || a.`val` != b.`val`) return false return return isSame(a.left, b.left) &amp;&amp; isSame(a.right, b.right) } /** * 生成二叉树的镜像 */ fun mirrorTree(root: TreeNode?): TreeNode? { if (root == null) return root val node = TreeNode(root.`val`) node.left = mirrorTree(root.right) node.right = mirrorTree(root.left) return node }}","link":"/backup/LeetCode/offer/28-dui-cheng-de-er-cha-shu.html"},{"title":"剑指 Offer 27：二叉树的镜像","text":"题目来源于 LeetCode 剑指 offer 第 27 号问题：二叉树的镜像。和第 226 号题 相同 中文地址：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof 题目描述请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \\ 2 7 / \\ / \\1 3 6 9 镜像输出： 4 / \\ 7 2 / \\ / \\9 6 3 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 限制： 0 &lt;= 节点个数 &lt;= 1000 思路：递归 和 非递归算法流程如下： 后续遍历的特点 左 -&gt; 右 -&gt; 根 根据后续遍历 递归 和 非递归 的方式，交换左右节点的顺序即可 复杂度分析： 时间复杂度 O(N) ，其中 N 为二叉树的节点数量 空间复杂度 O(N) ， 最差情况下（当二叉树退化为链表） Kotlin 实现class Solution { /** * 根据后续遍历的特点 左 -&gt; 右 -&gt; 根，交换左右节点的顺序即可 */ fun mirrorTree(root: TreeNode?): TreeNode? { if (root == null) return root mirrorTree(root.left) mirrorTree(root.right) val tmp = root.left root.left = root.right root.right = tmp return root } /** * 利用 后续遍历 非递归的方式，交换左右节点顺序 */ fun mirrorTree2(root: TreeNode?): TreeNode? { if (root == null) return root val stack = Stack&lt;TreeNode&gt;() stack.push(root) while (!stack.isEmpty()) { val node = stack.pop() if (node.left != null) stack.push(node.left) if (node.right != null) stack.push(node.right) val tmp = node.left node.left = node.right node.right = tmp } return root }} Java 实现class Solution { /** * 根据后续遍历的特点 左 -&gt; 右 -&gt; 根，交换左右节点的顺序即可 */ public TreeNode mirrorTree(TreeNode root) { if (root == null) return root; mirrorTree(root.left); mirrorTree(root.right); TreeNode tmp = root.left; root.left = root.right; root.right = tmp; return root; } /** * 利用 后续遍历 非递归的方式，交换左右节点顺序 */ public TreeNode mirrorTree2(TreeNode root) { if (root == null) return root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); TreeNode tmp = node.left; node.left = node.right; node.right = tmp; } return root; }}","link":"/backup/LeetCode/offer/27-er-cha-shu-de-jing-xiang.html"},{"title":"剑指 Offer 26：树的子结构","text":"题目来源于 LeetCode 剑指 offer 第 26 号问题：树的子结构。 中文地址：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof 题目描述输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A: 3 / \\ 4 5 / \\1 2 给定的树 B： 4 /1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 输入：A = [1,2,3], B = [3,1]输出：false 示例 2： 输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制： 0 &lt;= 节点个数 &lt;= 10000 思路：如何判断两颗的节点是否相等： 定义一个递归函数 isSub(TreeNode A, TreeNode B) 判断两颗树的节点是否相同 递归函数 isSub 的终止条件： 如果 B 为空，说明每个节点都相等，说明是 A 的子树，返回 true 如果 B 不为空 A 为空 说明 B 不是 A 的子树，返回 false 如果两个节点值不相等，说明 B 不是 A 的子树，返回 false 递归函数 isSub 的返回值：判断两颗树的左右子树是否相等，即 isSub(A.left, B.left) &amp;&amp; isSub(A.right, B.right) 算法流程如下： 要判断 B 是否是 A 的子结构，需要从两面考虑： B 有可能是 A 的子结构，即从 根节点开始遍历 B 也有可能是 A 左子树的子结构 或者 右子树的子结构 所以我们需要从上面两个方面判断 B 是否是 A 的子结构，流程如下： 从根节点开始判断，通过函数 isSub 比较他的每一个子节点即可 然后继续判断 B 是不是 A 左子树的子结构和右子树的子结构 复杂度分析： 时间复杂度 O(MN) ，其中 M,N 分别为树 A 和树 B 的节点数量 空间复杂度 O(M) ， 当 M ≤ N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M Kotlin 实现class Solution { fun isSubStructure(A: TreeNode?, B: TreeNode?): Boolean { // 只要其中一个为空，返回 false 不是 A 的子树 if (A == null || B == null) return false val sub = isSub(A, B) // 从根节点开始遍历 || isSubStructure(A.left, B) // 从左子树开始遍历 || isSubStructure(A.right, B) // 从右子树开始遍历 return sub } fun isSub(A: TreeNode?, B: TreeNode?): Boolean { // 如果 B 为空，说明每个节点都相等，说明是 A 的子树 if (B == null) return true // 如果 B 不为空 A 为空 说明不是 A 的子树 // 如果两个节点值不相等，说明也不是 A 的子树 if (A == null || A.`val` != B.`val`) return false return isSub(A.left, B.left) &amp;&amp; isSub(A.right, B.right); }} Java 实现class Solution { public boolean isSubStructure(TreeNode A, TreeNode B) { // 只要其中一个为空，返回 false 不是 A 的子树 if (A == null || B == null) return false; boolean sub = isSub(A, B) // 从根节点开始遍历 || isSubStructure(A.left, B) // 从左子树开始遍历 || isSubStructure(A.right, B); // 从右子树开始遍历 return sub; } public boolean isSub(TreeNode A, TreeNode B) { // 如果 B 为空，说明每个节点都相等，说明是 A 的子树 if (B == null) return true; // 如果 B 不为空 A 为空 说明不是 A 的子树 // 如果两个节点值不相等，说明也不是 A 的子树 if (A == null || A.val != B.val) return false; return isSub(A.left, B.left) &amp;&amp; isSub(A.right, B.right); }}","link":"/backup/LeetCode/offer/26-shu-de-zi-jie-gou.html"},{"title":"面试题：反转栈","text":"题目描述一个栈依次压入1,2,3,4,5，那么从栈顶部到栈底部分别为5,4,3,2,1.将这个栈转置后，从栈顶到栈底为1,2,3,4,5.也就是实现栈中元素的逆序，但是只能用递归函数来实现，不能用其他数据结构。 示例 ： 输入：stack = [1,2,3,4,5], 从栈顶部到栈底部分别为 5,4,3,2,1输出：从栈顶到栈底分别为 1,2,3,4,5 思路方法一：辅助栈 使用辅助栈，反转起来很简单，算法步骤如下： 将原栈元素 push 到辅助栈里 之后将辅助栈在 pop 出来即可 复杂度分析： 时间复杂度 0(N)，N 为栈的元素个数 空间复杂度 0(N)，N 为栈的元素个数 方法二：递归 算法步骤如下： 第一次递归将 栈顶 元素弹出 第二次递归将 弹出的栈顶元素 放入栈底 复杂度分析： 时间复杂度 0(N)，N 为栈的元素个数 空间复杂度：O(height)，递归函数需要栈空间，而栈空间取决于递归的深度 Java 实现class ReverseStack { /** * 第一次递归将 栈顶 元素弹出 * * @param stack */ void reverseStack(Stack&lt;Integer&gt; stack) { if (stack.isEmpty()) return; int top = stack.pop(); // 弹出栈顶元素，暂存在栈中 reverseStack(stack); // 调用自身，直到所有元素弹出 addStackBottom(stack, top);// 将栈顶元素 放入栈底 } /** * 第二次递归将 弹出的栈顶元素 放入栈底 * * @param stack * @param top */ void addStackBottom(Stack&lt;Integer&gt; stack, int top) { if (stack.isEmpty()) { stack.push(top); // 栈顶元素入栈 return; } int item = stack.pop(); // 暂存栈中的元素 addStackBottom(stack, top); stack.push(item); // 将暂存的元素入栈 } public static void main(String... args) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); int index = stack.size() - 1; while (index &gt;= 0) { System.out.println(&quot;原栈：&quot; + stack.elementAt(index--)); } ReverseStack reverse = new ReverseStack(); reverse.reverseStack(stack); while (!stack.isEmpty()) { System.out.println(&quot;反转之后：&quot; + stack.pop()); } }}","link":"/backup/LeetCode/other/01-reverse-stack.html"},{"title":"LeetCode 搜索：完全平方数","text":"题目来源于 LeetCode 上 第 279 号问题：岛屿数量。题目难度为 Medium。 英文地址：https://leetcode.com/problems/perfect-squares/ 中文地址：https://leetcode-cn.com/problems/perfect-squares/ 题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1： 输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2： 输入: n = 13输出: 2解释: 13 = 4 + 9. 思路：广度优先遍历广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。 在 BFS 中使用队列的原因？ 结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。 队列的基本使用 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 remove() poll() 查找 element() peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null 算法流程如下： 将数字 N 转换为多树，按树的层次遍历即可（分解出 N 可能的组合），每一层的节点 = 用上一层的节点 - 完全平方数 新建一个 queue，用来存储访问的每个节点 用 HashSet 过滤掉计算过的组合，避免重复计算 循环判断队列是否为空，如果队列为空即循环终止 获取每层的长度，遍历每一层，计算出下一层的组合，添加到 queue 重复执行 3、4 遍历结束时，层数即是能组成完全平方数的最少个数 Kotlin 实现class Solution { fun numSquares(n: Int): Int { val square = mutableListOf&lt;Int&gt;() for (i in 1..n) { square.add(i * i) } val set = hashSetOf&lt;Int&gt;() val queue = LinkedList&lt;Int&gt;() queue.offer(n) var step = 0 while (queue.size &gt; 0) { step = step + 1 val count = queue.size for (i in 0 until count) { val item = queue.poll() loop@ for (j in square) { when { item == j -&gt; return step item &lt; j -&gt; break@loop else -&gt; { val sub = item - j; if (set.add(sub)) { queue.offer(sub) } } } } } } return step }} Java 实现class Solution { public int numSquares(int n) { List&lt;Integer&gt; square = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; n; i++) { square.add(i * i); } int step = 0; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(n); while (queue.size() &gt; 0) { step = step + 1; int count = queue.size(); for (int i = 0; i &lt; count; i++) { int item = queue.poll(); for (Integer subItem : square) { if (item == subItem) { return step; } else if (item &lt; subItem) { break; } else { int sub = item - subItem; if (set.add(sub)) { queue.offer(sub); } } } } } return step; }}","link":"/backup/LeetCode/search/02-perfect-squares.html"},{"title":"LeetCode 栈：最小栈","text":"题目来源于 LeetCode 上 第 155 号问题：最小栈。题目难度为 Easy。 英文地址：https://leetcode.com/problems/min-stack 中文地址：https://leetcode-cn.com/problems/min-stack 题目描述设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例： 输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用 思路：算法流程如下： 用一个辅助栈 minStack，每次 push 的时候，比较当前元素和栈顶元素，将最小值存入 minStack。 复杂度分析： 时间复杂度：O(1) ，因为栈的插入、删除与读取操作都是 O(1) 空间复杂度：O(N)，N 为总操作次数 Kotlin 实现class MinStack() { /** initialize your data structure here. */ val stack = ArrayDeque&lt;Int&gt;() val minStack = ArrayDeque&lt;Int&gt;() fun push(x: Int) { stack.push(x) if (minStack.peek() == null) { minStack.push(x) } else { minStack.push(Math.min(x, minStack.peek())) } } fun pop() { stack.poll() minStack.poll() } fun top(): Int { return stack.peek() } fun getMin(): Int { return minStack.peek() }} Java 实现class MinStack { ArrayDeque&lt;Integer&gt; stack; ArrayDeque&lt;Integer&gt; minStack; /** * initialize your data structure here. */ public MinStack() { stack = new ArrayDeque&lt;Integer&gt;(); minStack = new ArrayDeque&lt;Integer&gt;(); } public void push(int x) { stack.push(x); if (minStack.peek() == null) { minStack.push(x); } else { minStack.push(Math.min(x, minStack.peek())); } } public void pop() { stack.poll(); minStack.poll(); } public int top() { return stack.peek(); } public int getMin() { return minStack.peek(); }}","link":"/backup/LeetCode/stack/01-min-stack.html"},{"title":"LeetCode 二叉树：判断二叉树是不是平衡二叉树","text":"题目来源于 LeetCode 上第 110 号（Balanced Binary Tree）问题：判断二叉树是不是平衡二叉树。题目难度为 Easy。 英文地址：https://leetcode.com/problems/balanced-binary-tree/ 中文地址：https://leetcode-cn.com/problems/balanced-binary-tree/ 题目描述GGiven a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1.一个二叉树其中每个节点的两个子树的深度差不相差超过1 Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \\9 20 / \\ 15 7 Return true. Example 1: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \\ 2 2 / \\ 3 3 / \\4 4 Return false. 思路:平衡二叉树: 左右两个子树的深度差的绝对值不超过 1 任意一个节点的深度是由它左右两个子节点的深度决定的, 如果左右两个节点的最大深度分别为L1和R1，任意一个节点的差都满足 abs(L1 - R1)&lt;=1，那么就是平衡二叉树 复杂度分析： 时间复杂度：O(n)，n 是二叉树中的节点个数，使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次。 空间复杂度：O(height)，height 为树的高度，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度 Java实现public boolean isBalanced(TreeNode root) { return maxDepth(root) != -1;}public int maxDepth(TreeNode root) { if (root == null) { return 0; } int left = maxDepth(root.left); int right = maxDepth(root.right); if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) { return -1; } return Math.max(left, right) + 1;} Koltin尾递归实现fun isBalanced(root: TreeNode?): Boolean { return maxDepth(root) != -1}tailrec fun maxDepth(root: TreeNode?): Int { if (root == null) { return 0; } val left = maxDepth(root.left); val right = maxDepth(root.right); return if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) -1 else Math.max(left, right) + 1}","link":"/backup/LeetCode/binary-tree/08-balanced-binary-tree.html"},{"title":"LeetCode 搜索：岛屿数量","text":"题目来源于 LeetCode 上 第 200 号问题：岛屿数量。题目难度为 Medium。 英文地址：https://leetcode.com/problems/number-of-islands/ 中文地址：https://leetcode-cn.com/problems/number-of-islands/ 题目描述给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 输入:[['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]输出: 1 示例 2： 输入:[['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 思路一：广度优先遍历广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。 在 BFS 中使用队列的原因？ 结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。 队列的基本使用 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 remove() poll() 查找 element() peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null 算法流程如下： 广度优先搜索就是扫描整个二维网格，遇到 1 将其加入队列中，然后将其标记为 0, 直到队列为空，搜索结束。 复杂度分析： 时间复杂度：0(MN) ，M 是行数，N 是列数 空间复杂度：O(MN)，最坏的情况深度达到第 M 行 N 列 Kotlin 实现class Solution { fun numIslands(grid: Array&lt;CharArray&gt;): Int { if (grid.size == 0) { return 0; } var step = 0; val queue = LinkedList&lt;IntArray&gt;() val row = grid.size val colum = grid[0].size for (i in 0 until row) { for (j in 0 until colum) { if (grid[i][j] == '1') { step = step + 1 queue.offer(intArrayOf(i, j)) while (!queue.isEmpty()) { val (x1, y1) = queue.poll() if (x1 &lt; 0 || x1 &gt;= row || y1 &lt; 0 || y1 &gt;= colum || grid[x1][y1] == '0') { continue; } grid[x1][y1] = '0' queue.offer(intArrayOf(x1 + 1, y1)) queue.offer(intArrayOf(x1 - 1, y1)) queue.offer(intArrayOf(x1, y1 + 1)) queue.offer(intArrayOf(x1, y1 - 1)) } } } } return step }} Java 实现class Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int row = grid.length; int colum = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int step = 0; for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; colum; j++) { if (grid[i][j] == '1') { queue.offer(new int[]{i, j}); step++; while (!queue.isEmpty()) { int[] tmp = queue.poll(); int x1 = tmp[0]; int y1 = tmp[1]; if (x1 &lt; 0 || x1 &gt;= row || y1 &lt; 0 || y1 &gt;= colum || grid[x1][y1] == '0') { continue; } grid[x1][y1] = '0'; queue.offer(new int[]{x1 + 1, y1}); queue.offer(new int[]{x1 - 1, y1}); queue.offer(new int[]{x1, y1 + 1}); queue.offer(new int[]{x1, y1 - 1}); } } } } return step; }} 思路二：深度优先搜索DFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 递归的两个特点： 问题和子问题都会调用函数自身，所以要找寻问题与子问题的递归关系，采用自上而下的思考方式。 有个终止条件（临界点）结束当前递归。 参数说明： grid 表示一个二维网格 用 i 表示行的下标，j 表示列的下标 x1 表示当前所在的格子的横坐标 y1 表示当前所在的格子的纵坐标 终止条件： 是否在单元格内（x &gt;= row 或者 y &gt;= colum）。 如果当前格子已经访问过了，满足于 grid[x1][y1] == '0' 算法过程： 遍历整个网格 从坐标 [0, 0] 开始进行深度优先搜索，在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0 岛屿的数量就是进行深度优先搜索的次数 复杂度分析： 时间复杂度：0(MN) ，M 是行数，N 是列数 空间复杂度：O(MN)，最坏的情况深度达到第 M 行 N 列 Kotlinclass Solution { fun numIslands(grid: Array&lt;CharArray&gt;): Int { if (grid.size == 0) { return 0; } var step = 0; val row = grid.size val colum = grid[0].size for (i in 0 until row) { for (j in 0 until colum) { if (grid[i][j] == '1') { step = step + 1 dfs(i, j, row, colum, grid) } } } return step } fun dfs(x1: Int, y1: Int, row: Int, colum: Int, grid: Array&lt;CharArray&gt;) { if (x1 &lt; 0 || x1 &gt;= row || y1 &lt; 0 || y1 &gt;= colum || grid[x1][y1] == '0') { return; } grid[x1][y1] = '0' dfs(x1 + 1, y1, row, colum, grid) dfs(x1 - 1, y1, row, colum, grid) dfs(x1, y1 + 1, row, colum, grid) dfs(x1, y1 - 1, row, colum, grid) }} Javaclass Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int row = grid.length; int colum = grid[0].length; int step = 0; for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; colum; j++) { if (grid[i][j] == '1') { step++; dfs(i, j, row, colum, grid); } } } return step; } void dfs(int x1, int y1, int row, int colum, char[][] grid) { if (x1 &lt; 0 || x1 &gt;= row || y1 &lt; 0 || y1 &gt;= colum || grid[x1][y1] == '0') { return; } grid[x1][y1] = '0'; dfs(x1 + 1, y1, row, colum, grid); dfs(x1 - 1, y1, row, colum, grid); dfs(x1, y1 + 1, row, colum, grid); dfs(x1, y1 - 1, row, colum, grid); }}","link":"/backup/LeetCode/search/01-number-of-islands.html"},{"title":"LeetCode 队列：设计循环队列","text":"题目来源于 LeetCode 上 第 622 号问题：设计循环队列。题目难度为 Medium。 英文地址：https://leetcode.com/problems/design-circular-queue/ 中文地址：https://leetcode-cn.com/problems/design-circular-queue/ 题目描述设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例： MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 提示： 所有的值都在 0 至 1000 的范围内 操作数将在 1 至 1000 的范围内 请不要使用内置的队列库 思路：参数的含义： data ：表示固定的数组，用作循环队列 head ：表示的队列的头指针 tail ： 表示队列的尾指针 判断队列是否已满 (tail + 1) % size == head 判断队列是否为空 head == -1 或者 head == tail 具体实现可以看 Java 和 Kotlin，它们的实现方式各不相同 复杂度分析： 时间复杂度：O(1) ，数组存储都是按顺序存放的，具有随机访问的特点 空间复杂度：O(N)，N 为数组的长度 Kotlin 实现class MyCircularQueue(k: Int) { var head = -1; var tail = -1; var data = IntArray(k); val size = k; fun enQueue(value: Int): Boolean { if (isFull()) return false if (isEmpty()) head = 0 tail = (tail + 1) % size data[tail] = value return true } fun deQueue(): Boolean { if (isEmpty()) return false if (head == tail) { head = -1 tail = -1 return true } head = (head + 1) % size return true } fun Front(): Int { if (isEmpty()) return -1 return data[head] } fun Rear(): Int { if (isEmpty()) return -1 return data[tail] } fun isEmpty(): Boolean { return head == -1 } fun isFull(): Boolean { return (tail + 1) % size == head }} Java 实现思路和 Kotlin 的实现不同，为了避免冲突循环数组中任何时刻一定至少有一个位置不存放有效元素，不过这种方法实现，更方便进行扩容，参考 ArrayDeque 源码实现 class MyCircularQueue { int[] data; int head; int tail; int size; public MyCircularQueue(int k) { // k + 1 有两个原因 // 1. 为了避免冲突循环数组中任何时刻一定至少有一个位置不存放有效元素 // 2. 当 k = 4 ，下标从 0 开始的，假设不移动 head， k 也不 +1 ，第四个元素始终放不进去 size = k + 1; data = new int[size]; head = 0; tail = 0; } public boolean enQueue(int value) { if (isFull()) return false; data[tail] = value; tail = (tail + 1) % size; return true; } public boolean deQueue() { if (isEmpty()) return false; head = (head + 1) % size; return true; } public int Front() { if (isEmpty()) return -1; return data[head]; } public int Rear() { if (isEmpty()) return -1; // 因为数组中任何时刻一定至少有一个位置不存放有效元素，所以 tail - 1 取最近存放的元素 // 假设 tail = 0 时，tail - 1 就会变成负数，下标会越界，所以 tail - 1 + size) % size return data[(tail - 1 + size) % size]; } public boolean isEmpty() { return head == tail; } public boolean isFull() { return (tail + 1) % size == head; }}","link":"/backup/LeetCode/queue/01-design-circular-queue.html"},{"title":"LeetCode 栈：有效的括号","text":"题目来源于 LeetCode 上第 20 号问题：有效的括号。题目难度为 Easy。 英文地址：https://leetcode.com/problems/valid-parentheses 中文地址：https://leetcode-cn.com/problems/valid-parentheses 题目描述给定一个字符串, 只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’，判断字符串是否有效 有效字符串需要满足以下条件： 左括号必须用相同类型的右括号闭合 左括号必须以正确的顺序闭合 注意空字符串可被认为是有效字符串。 Example 1: Input: &quot;()&quot; Output: trueExample 2: Input: &quot;()[]{}&quot; Output: trueExample 3: Input: &quot;(]&quot; Output: falseExample 4: Input: &quot;([)]&quot; Output: falseExample 5: Input: &quot;{[]}&quot; Output: true 题目解析 遍历字符串 遇到左括号，则将其对应的右括号压入栈中 如果遇到右括号： 当前栈为空，直接返回false; 当前右括号对应的左括号，与栈顶元素不相等，直接返回false 重复执行 步骤 2 和步骤 3 循环结束之后，判断栈是否为空，不为空返回false Kotlin 实现class Solution { fun isValid(s: String): Boolean { val stack = ArrayDeque&lt;Char&gt;() // 遍历字符串 for (c in s) { when (c) { // 遇到左括号，则将其对应的右括号压入栈中 '(' -&gt; stack.push(')') '[' -&gt; stack.push(']') '{' -&gt; stack.push('}') else -&gt; { // 当前右括号，与栈顶元素不相等，不相等直接返回 false val tmp = stack.poll() if (c != tmp) { return false; } } } } return stack.isEmpty(); }} Java 实现class Solution { public boolean isValid(String s) { ArrayDeque&lt;Character&gt; stack = new ArrayDeque&lt;Character&gt;(); // 遍历字符串 for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); // 遇到左括号，则将其对应的右括号压入栈中 if (c == '(') { stack.push(')'); } else if (c == '[') { stack.push(']'); } else if (c == '{') { stack.push('}'); } else { // 当前栈为空，直接返回 false if (stack.isEmpty()) { return false; } // 当前右括号，与栈顶元素不相等，不相等直接返回 false char tmp = stack.poll(); if (c != tmp) { return false; } } } return stack.isEmpty(); }}","link":"/backup/LeetCode/stack/02-valid-parentheses.html"}],"posts":[{"title":"Android 常用资源汇总","text":"颜色透明度汇总半透明颜色值不同于平时使用的颜色，半透明颜色值共 8 位，例如： android:background=&quot;#AAxxxxxx&quot; 前 2 位(AA)是透明度，后 6 位(xxxxxx) 是颜色，透明度和颜色结合在一起就可以写出各种颜色的透明度。下面是透明度说明表。 透明度百分比 对应的值 备注 100% FF 完全不透明 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 50% 80 半透明 50% 45% 73 40% 40 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 0% 00 全透明 使用举例： 全透明：#00000000 半透明：#80000000 不透明：#FF000000 白色半透明：#80FFFFFF 不同像素密度的配置限定符官方链接：https://developer.android.com/training/multiscreen/screendensities?hl=zh-cn 密度限定符 说明 ldpi 适用于低密度 (ldpi) 屏幕 (~ 120dpi) 的资源 mdpi 适用于中密度 (mdpi) 屏幕 (~ 160dpi) 的资源（这是基准密度） hdpi 适用于高密度 (hdpi) 屏幕 (~ 240dpi) 的资源 xhdpi 适用于加高 (xhdpi) 密度屏幕 (~ 320dpi) 的资源 xxhdpi 适用于超超高密度 (xxhdpi) 屏幕 (~ 480dpi) 的资源 xxxhdpi 适用于超超超高密度 (xxxhdpi) 屏幕 (~ 640dpi) 的资源 nodpi 适用于所有密度的资源。这些是与密度无关的资源。无论当前屏幕的密度是多少，系统都不会缩放以此限定符标记的资源 tvdpi 适用于密度介于 mdpi 和 hdpi 之间的屏幕（约 213dpi）的资源。这不属于“主要”密度组。它主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将视情况对其进行缩放。如果您发现有必要提供 tvdpi 资源，应按一个系数来确定其大小，即 1.33*mdpi。例如，如果某张图片在 mdpi 屏幕上的大小为 100px x 100px，那么它在 tvdpi 屏幕上的大小应该为 133px x 133px 要针对不同的密度创建备用可绘制位图资源，您应遵循六种主要密度之间的 3:4:6:8:12:16 缩放比。例如，如果您有一个可绘制位图资源，它在中密度屏幕上的大小为 48x48 像素，那么它在其他各种密度的屏幕上的大小应该为： 36x36 (0.75x) - 低密度 (ldpi) 48x48（1.0x 基准）- 中密度 (mdpi) 72x72 (1.5x) - 高密度 (hdpi) 96x96 (2.0x) - 超高密度 (xhdpi) 144x144 (3.0x) - 超超高密度 (xxhdpi) 192x192 (4.0x) - 超超超高密度 (xxxhdpi) Android studio 插件版本与 gradle 版本对应关系Android studio 插件版本与 gradle 版本对应关系如下所示： AS 插件版本 Gradle 版本 1.0.0 - 1.1.3 2.2.1 - 2.3 1.2.0 - 1.3.1 2.2.1 - 2.9 1.5.0 2.2.1 - 2.13 2.0.0 - 2.1.2 2.10 - 2.13 2.1.3 - 2.2.3 2.14.1+ 2.3.0+ 3.3+ 3.0.0+ 4.1+ 3.1.0+ 4.4+ 3.2.0 - 3.2.1 4.6+ 3.3.0 - 3.3.3 4.10.1+ 3.4.0 - 3.4.3 5.1.1+ 3.5.0 - 3.5.4 5.4.1+ 3.6.0 - 3.6.4 5.6.4+ 4.0.0+ 6.1.1+ 4.1.0+ 6.5+ 以上信息参考 Android Gradle 插件版本说明 Android Studio 根据动物名称来命名，而 Android 系统 10.0 之前都是以甜点的方式来命名，我们在来会汇总一下 Android 系统的命名方案。 2007 年 11 月 5 日发布最初的版本（Android 0.5），至今 Android 发行了多个版本，Android 操作系统有预发行的内部版本，分别为铁臂阿童木（Astro）与机器人班亭（Bender），从 2009 年 5 月开始， Android 的版本代号以甜点来命名，且每个代号间的前缀以英文本母序接续排列。 Android 系统名字、版本、API level 的对应关系Android 系统名字、版本、API level 的对应关系如下所示： 名称 版本号 发版日期 API API Android 1.0 1.0 2008年9月23日 1 BASE Android 1.1 1.1 2009年2月9日 2 BASE_1_1 Android Cupcake（纸杯蛋糕） 1.5 2009年4月27日 3 CUPCAKE Android Donut（甜甜圈） 1.6 2009年9月15日 4 DONUT Android Eclair（闪电泡芙） 2.0 – 2.1 2009年10月26日 5 – 7 ECLAIR_MR1（2.1.x） ECLAIR_0_1（2.0.1） ECLAIR（2.0） Android Froyo（优格冰淇淋） 2.2 – 2.2.3 2010年5月20日 8 FROYO Android Gingerbread（姜饼） 2.3 – 2.3.7 2010年12月6日 9 - 10 GINGERBREAD_MR1（ 2.3.3 - 2.3.4） GINGERBREAD（2.3、2.3.1、2.3.2） Android Honeycomb（蜂巢） 3.0 – 3.2.6 2011年2月22日 11 - 13 HONEYCOMB_MR2（3.2） HONEYCOMB_MR1（3.1x） HONEYCOMB（3.0.x） Android Ice Cream Sandwich（冰淇淋三明治） 4.0 – 4.0.4 2011年10月18日 14 - 15 ICE_CREAM_SANDWICH_MR1（4.0.3、4.0.4） ICE_CREAM_SANDWICH （4.0、4.0.1、4.0.2） Android Jelly Bean（果冻豆） 4.1 – 4.3.1 2012年7月9日 16 – 18 JELLY_BEAN_MR2（4.3） JELLY_BEAN_MR1（4.2 - 4.2.2） JELLY_BEAN（4.1 - 4.1.1） Android KitKat（奇巧巧克力） 4.4 – 4.4.4 2013年10月31日 19 - 20 KITKAT Android Lollipop（棒棒糖） 5.0 – 5.1.1 2014年11月12日 21 - 22 LOLLIPOP_MR1（5.1） LOLLIPOP（5.0） Android Marshmallow（棉花糖） 6.0 – 6.0.1 2015年10月5日 23 M Android Nougat（牛轧糖） 7.0 – 7.1.2 2016年8月22日 24 - 25 N_MR1（7.1 - 7.11） N（7.0） Android Oreo（奥利奥） 8.0 – 8.1 2017年8月21日 26 – 27 O_MR1（8.1） O （8.0） Android Pie（派） 9 2018年8月6日 28 P Android 10 10 2019年9月3日 29 Q Android 11 11 2020年2月19日 30 R 从 Android Q 开始不再以甜品命名，且直接称 Android Q 为 Android 10。以上信息参考 uses-sdk 跳转到系统各个设置界面跳转常用方法如下： // 第一个参：包名// 第二个参数：各个设置的类名(可以参考下面)ComponentName cm = new ComponentName(&quot;com.android.settings&quot;, &quot;com.android.settings.RadioInfo&quot;); intent.setComponent(cm); intent.setAction(&quot;android.intent.action.VIEW&quot;); startActivity(intent); 各个设置的类名汇总 com.android.settings.AccessibilitySettings 辅助功能设置com.android.settings.ActivityPicker 选择活动com.android.settings.ApnSettings APN设置com.android.settings.ApplicationSettings 应用程序设置com.android.settings.BandMode 设置GSM/UMTS波段com.android.settings.BatteryInfo 电池信息com.android.settings.DateTimeSettings 日期和坝上旅游网时间设置com.android.settings.DateTimeSettingsSetupWizard 日期和时间设置com.android.settings.DevelopmentSettings 应用程序设置=》开发设置com.android.settings.DeviceAdminSettings 设备管理器com.android.settings.DeviceInfoSettings 关于手机com.android.settings.Display 显示——设置显示字体大小及预览com.android.settings.DisplaySettings 显示设置com.android.settings.DockSettings 底座设置com.android.settings.IccLockSettings SIM卡锁定设置com.android.settings.InstalledAppDetails 语言和键盘设置com.android.settings.LanguageSettings 语言和键盘设置com.android.settings.LocalePicker 选择手机语言com.android.settings.LocalePickerInSetupWizard 选择手机语言com.android.settings.ManageApplications 已下载（安装）软件列表com.android.settings.MasterClear 恢复出厂设置com.android.settings.MediaFormat 格式化手机闪存com.android.settings.PhysicalKeyboardSettings 设置键盘com.android.settings.PrivacySettings 隐私设置com.android.settings.ProxySelector 代理设置com.android.settings.RadioInfo 手机信息com.android.settings.RunningServices 正在运行的程序（服务）com.android.settings.SecuritySettings 位置和安全设置com.android.settings.Settings 系统设置com.android.settings.SettingsSafetyLegalActivity 安全信息com.android.settings.SoundSettings 声音设置com.android.settings.TestingSettings 测试——显示手机信息、电池信息、使用情况统计、Wifi information、服务信息com.android.settings.TetherSettings 绑定与便携式热点com.android.settings.TextToSpeechSettings 文字转语音设置com.android.settings.UsageStats 使用情况统计com.android.settings.UserDictionarySettings 用户词典com.android.settings.VoiceInputOutputSettings 语音输入与输出设置com.android.settings.WirelessSettings 无线和网络设置 Android 设备信息以及系统 APIBuild 系列 Build 系列 android.os.Build 系统版本 RELEASE 获取系统版本字符串。如4.1.2 或2.2 或2.3等 4.4.4 系统版本值 SDK_INT 19 品牌 BRAND 获取设备品牌 Huawei 型号 MODEL 获取手机的型号 HUAWEI G750-T01 ID ID 设备版本号 HUAWEITAG-TLOO DISPLAY DISPLAY 获取设备显示的版本包（在系统设置中显示为版本号）和ID一样 TAG-TLOOCO1B166-TLOO 产品名 PRODUCT 整个产品的名称 G750-T01 制造商 MANUFACTURER 获取设备制造商 HUAWEI 设备名 DEVICE 获取设备驱动名称 hwG750-T01 硬件 HARDWARE 设备硬件名称,一般和基板名称一样（BOARD） mt6592 指纹 FINGERPRINT 设备的唯一标识。由设备的多个信息拼接合成 Huawei/G750-T01/hwG750-T01:4.2.2/HuaweiG750-T01/C00B152:user/ota-rel-keys,release-keys 串口序列号 SERIAL 返回串口序列号 YGKBBBB5C1711949 设备版本类型 TYPE 主要为user 或eng. user 描述build的标签 TAGS 设备标签。如release-keys 或测试的 test-keys release-keys 设备主机地址 HOST 设备主机地址 scmbuild 设备用户名 USER 基本上都为android-build queen 固件开发版本代号 codename 设备当前的系统开发代号，一般使用REL代替 REL 源码控制版本号 build_incremental 系统源代码控制值，一个数字或者git hash值 C01B166 主板 board 获取设备基板名称 TAG-TL00 主板引导程序 bootloader 获取设备引导程序版本号 unkonwn Build时间 time Build时间 1476084456000 系统的API级别 SDK_INT 数字表示 19 cpu指令集1 CPU_ABI 获取设备指令集名称（CPU的类型） arm64-v8a cpu指令集1 CPU_ABI2 Android 硬件设备信息： 名称 接口参数名称 备注 示例 序列号 getDeviceId 序列号IMEI 865872025238821 andrlid_id getString android_id bcbc00f09479aa5b 手机号码 getLine1Number 手机号码 13117511178 手机卡序列号 getSimSerialNumber 手机卡序列号 89860179328595969501 手机卡IMSI号 getSubscriberId IMSI 460017932859596 手机卡国家 getSimCountryIso 手机卡国家 cn 运营商 getSimOperator 运营商 46001 运营商名字 getSimOperatorName 运营商名字 中国联通 国家iso代码 getNetworkCountryIso 国家iso代码字 cn 网络运营商类型 getNetworkOperator 返回MCC+MNC代码 (SIM卡运营商国家代码和运营商网络代码)(IMSI) 46001 网络类型名 getNetworkOperatorName 返回移动网络运营商的名字(SPN) 中国联通 网络 getNetworkType 网络 3 手机类型 getPhoneType 机类型 1 手机卡状态 getSimState 1 mac地址 getMacAddress mac地址 a8:a6:68:a3:d9:ef 蓝牙名称 getName HUAWEI TAG-TL00 固件版本 固件版本 无线电固件版本号，通常是不可用的 MOLY.WR8.W1328.MD.TG.MP.V1.P22, 2014/07/15 19:57 WifiManager WifiManager WIFI相关 蓝牙地址 getAddress 蓝牙地址MAC地址 6a: cd:57:f2:3b:59 无线路由器名 getSSID WIFI名字 210e03fcf0 无线路由器地址 getBSSID ce:ea:8c:1a:5c:b2 内网ip(wifl可用) getIpAddress 可以用代码转成192.168形式 -2023511872 Display 屏幕相关 Display 屏幕相关 屏幕密度 density 屏幕密度（像素比例：0.75/1.0/1.5/2.0） 2.0 屏幕密度 densityDpi 屏幕密度（每寸像素：120/160/240/320） 480 手机内置分辨率 getWidth 内置好的不准确已废弃API 720 手机内置分辨率 getHeight 字体缩放比例 scaledDensity 2.0","link":"/2021/05/23/android/07-Android-resource/"},{"title":"算法动画图解 | 被 &quot;废弃&quot; 的 Java 栈，为什么还在用","text":"在 LeetCode 上不知不觉已经刷了 210+ 题，总提交次数 1000+ 次，从这篇文章开始，每篇算法类型的文章，将会做成动画的形式，每篇文章都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路、时间复杂度、空间复杂度和源代码，更多内容点击下方链接前去查看。 剑指 Offer 及国内外大厂面试题解：在线阅读 LeetCode 系列题解：在线阅读 通过这篇文章你将学习到以下内容： 栈的定义 栈的实现 为什么不推荐使用 Java 栈 性能低 破坏了原有的数据结构 不推荐使用了，为什么现在还在用 为什么推荐使用 Deque 接口替换栈 效率比 Java 栈快 屏蔽掉无关的方法 Stack 和 ArrayDeque 区别 栈的时间复杂度 栈的应用：有效的括号 栈的定义栈是 后入先出（LIFO） 的数据结构，入栈通常使用 push 操作，往栈中插入数据到栈底，出栈使用 pop 操作，从栈顶删除数据。入栈和出栈操作动画如下所示。 栈的实现栈常用的实现方式是通过动态数组来实现的，在 Java 和 Kotlin 中也内置了栈库 Stack，但是 Stack 已经不推荐使用了。 为什么不推荐使用 性能低 性能低是因为 Stack 继承自 Vector， 而 Vector 在每个方法中都加了锁，如下所示： ......public synchronized void trimToSize() { }public synchronized void ensureCapacity(int minCapacity) { }public synchronized void setSize(int newSize) { }public synchronized int capacity() { }public synchronized int size() { }public synchronized boolean isEmpty() { }...... 由于需要兼容老的项目，很难在原有的基础上进行优化，因此 Vector 就被淘汰掉了，使用 ArrayList 和 CopyOnWriteArrayList 来代替，如果在非线程安全的情况下可以使用 ArrayList，线程安全的情况下可以使用 CopyOnWriteArrayList 。 破坏了原有的数据结构 栈的定义是在一端进行 push 和 pop 操作，除此之外不应该包含其他 入栈和出栈 的方法，但是 Stack 继承自 Vector，使得 Stack 可以使用父类 Vector 公有的方法，如下所示。 val stack = Stack&lt;Int&gt;()stack.push(6)stack.add(1,10)stack.removeAt(1)stack.pop()stack.addAll(arrayListOf())...... 正如你所见，除了调用 push() 和 pop() 方法之外，还可以调用 addXXX() 、 removeXXX() 等等方法，但是这样会破坏栈原有的结构。所以对于栈的数据结构，不应该有可以在任何位置添加或者删除元素的能力。 为什么现在还在用 但是为什么在实际项目中还有很多小伙伴在使用 Stack。如果你经常刷 LeetCode 应该会见到很多小伙伴使用 Stack 做相关的算法题。总结了一下主要有两个原因。 JDK 官方是不推荐使用 Stack，之所以还有很多人在使用，是因为 JDK 并没有加 deprecation 注解，只是在文档和注释中声明不建议使用，但是很少有人会去关注其实现细节 在做算法题的时候，关注点在解决问题的算法逻辑思路上，并不会关注在不同语言下 Stack 实现细节，但是对于使用 Java 语言的开发者，不仅需要关注算法逻辑本身，也需要关注它的实现细节 为什么推荐使用 Deque 接口替换栈 如果 JDK 不推荐使用 Stack，那应该使用什么集合类来替换栈，一起看看官方的文档。 正如图中标注部分所示，栈的相关操作应该由 Deque 接口来提供，推荐使用 Deque 这种数据结构， 以及它的子类，例如 ArrayDeque。 val stack: Deque&lt;Int&gt; = ArrayDeque() 使用 Deque 接口来实现栈的功能有什么好处： 速度比 Stack 快 这个类作为栈使用时可能比 Stack 快，作为队列使用时可能比 LinkedList 快。因为原来的 Java 的 Stack 继承自 Vector，而 Vector 在每个方法中都加了锁，而 Deque 的子类 ArrayDeque 并没有锁的开销。 屏蔽掉无关的方法 原来的 Java 的 Stack，包含了在任何位置添加或者删除元素的方法，这些不是栈应该有的方法，所以需要屏蔽掉这些无关的方法。 声明为 Deque 接口可以解决这个问题，在接口中声明栈需要用到的方法，无需管子类是如何是实现的，对于上层使用者来说，只可以调用和栈相关的方法。 Stack 和 ArrayDeque 区别如下所示。 集合类型 数据结构 是否线程安全 Stack 数组 是 ArrayDeque 数组 否 Stack 常用的方法如下所示。 操作 方法 入栈 push(E item) 出栈 pop() 查看栈顶 peek() 为空时返回 null ArrayDeque 常用的方法如下所示。 操作 方法 入栈 push(E item) 出栈 poll() 栈为空时返回 null pop() 栈为空时会抛出异常 查看栈顶 peek() 为空时返回 null 栈的时间复杂度 栈的核心实现是通过动态数组来实现的，所以在扩容的时候，时间复杂度为 O(n)，其他操作例如 push(E item) 和 pop() 、 peek() 等等时间复杂度为 O(1)。 栈的应用：有效的括号题解已收藏于 https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin。每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路、时间复杂度、空间复杂度和源代码， 题目描述给定一个字符串, 只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’，判断字符串是否有效 有效字符串需要满足以下条件： 左括号必须用相同类型的右括号闭合 左括号必须以正确的顺序闭合 注意空字符串可被认为是有效字符串。 Example 1: Input: &quot;()&quot; Output: trueExample 2: Input: &quot;()[]{}&quot; Output: trueExample 3: Input: &quot;(]&quot; Output: falseExample 4: Input: &quot;([)]&quot; Output: falseExample 5: Input: &quot;{[]}&quot; Output: true 算法流程 如果遇到左括号，将对应的右括号压入栈中 如果遇到右括号 判断当前栈是否为空 如果不为空，判断当前元素是否和栈顶元素相等 如果不相等，发现了不符合的括号，提前返回 false，结束循环 重复执行「步骤 1」 和「步骤 2」 循环结束之后，通过判断栈是否为空，来检查是否是有效的括号 复杂度分析 假设字符串的长度为 N 则： 时间复杂度：O(N)。正确有效的括号需要遍历了一次字符串，所需要的时间复杂度为 O(N)。 空间复杂度：O(N)。如果输入字符串全是左括号，例如 (((((((，栈的大小即为输入字符串的长度，所需要的空间复杂度为 O(N) Kotlin 实现class Solution { fun isValid(s: String): Boolean { val stack = ArrayDeque&lt;Char&gt;() // 开始遍历字符串 for (c in s) { when (c) { // 遇到左括号，将对应的右括号压入栈中 '(' -&gt; stack.push(')') '[' -&gt; stack.push(']') '{' -&gt; stack.push('}') else -&gt; { // 遇到右括号，判断当前元素是否和栈顶元素相等，不相等提前返回，结束循环 if (stack.isEmpty() || stack.poll() != c) { return false } } } } // 通过判断栈是否为空，来检查是否是有效的括号 return stack.isEmpty() }} Java 实现class Solution { public boolean isValid(String s) { Deque&lt;Character&gt; stack = new ArrayDeque&lt;Character&gt;(); // 开始遍历字符串 for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); // 遇到左括号，则将其对应的右括号压入栈中 if (c == '(') { stack.push(')'); } else if (c == '[') { stack.push(']'); } else if (c == '{') { stack.push('}'); } else { // 遇到右括号，判断当前元素是否和栈顶元素相等，不相等提前返回，结束循环 if (stack.isEmpty() || stack.poll() != c) { return false; } } } // 通过判断栈是否为空，来检查是否是有效的括号 return stack.isEmpty(); }} 仓库 KtKit 是用 Kotlin 语言编写的小巧而实用的工具库，包含了项目中常用的一系列工具, 正在逐渐完善中。 KtKit 仓库地址：https://github.com/hi-dhl/KtKit KtKit 在线阅读：https://ktkit.hi-dhl.com 如果这个仓库对你有帮助，请在仓库右上角帮我 star 一下，非常感谢你的支持，同时也欢迎你提交 PR 如果有帮助 点个赞 就是对我最大的鼓励 代码不止，文章不停 欢迎关注公众号：ByteCode，持续分享最新的技术","link":"/2021/09/14/algorithm/01-stack/"},{"title":"影响性能的 Kotlin 代码（一）","text":"要开始写新的 Kotlin 系列了 「影响性能的 Kotlin 代码」, 同时我也在写另一个系列 「为数不多的人知道的 Kotlin 技巧及解析」，没有看过的小伙伴，可以点击下方链接前去查看。 为数不多的人知道的 Kotlin 技巧及解析(一) 为数不多的人知道的 Kotlin 技巧及解析(二) 为数不多的人知道的 Kotlin 技巧及解析(三) Kotlin 高级函数的特性不仅让代码可读性更强，更加简洁，而且还提高了生产效率，但是简洁的背后是有代价的，隐藏着不能被忽视的成本，特别是在低端机上，这种成本会被放大，因此我们需要去研究 kotlin 语法糖背后的魔法，选择合适的语法糖，尽量避免这些坑。 Lambda 表达式Lambda 表达式语法简洁，避免了冗长的函数声明，代码如下。 fun requestData(type: Int, call: (code: Int, type: Int) -&gt; Unit) { call(200, type)} Lambda 表达式语法虽然简洁，但是隐藏着两个性能问题。 每次调用 Lambda 表达式，都会创建一个对象 图中标记 1 所示的地方，涉及一个字节码类型的知识点。 标识符 含义 I 基本类型 int L 对象类型，以分号结尾，如 Lkotlin/jvm/functions/Function2; Lambda 表达式 call: (code: Int, type: Int) -&gt; Unit 作为函数参数，传递到函数中，Lambda 表达式会继承 kotlin/jvm/functions/Function2 , 每次调用都会创建一个 Function2 对象，如图中标记 2 所示的地方。 Lambda 表达式隐含自动装箱和拆箱过程 正如你所见 lambda 表达式存在装箱和拆箱的开销，会将 int 转成 Integer，之后进行一系列操作，最后会将 Integer 转成 int。 如果想要避免 Lambda 表达式函数对象的创建及装箱拆箱开销，可以使用 inline 内联函数，直接执行 lambda 表达式函数体。 Inline 修饰符 Inline (内联函数) 的作用：提升运行效率，调用被 inline 修饰符标记的函数，会把函数内的代码放到调用的地方。 如果阅读过 Koin 源码的朋友，应该会发现 inline 都是和 lambda 表达式和 reified 修饰符配套在一起使用的，如果只使用 inline 修饰符标记普通函数，Android Studio 也会给一个大大大的警告。 编译器建议我们在含有 lambda 表达式作为形参的函数中使用内联，既然 Inline 修饰符可以提升运行效率，为什么编译器会给我们一个警告？ 这是为了防止 inline 操作符滥用而带来的性能损失。 inline 修饰符适用于以下情况 inline 修饰符适用于把函数作为另一个函数的参数，例如高阶函数​ filter、map、joinToString 或者一些独立的函数 repeat inline 操作符适合和 reified 操作符结合在一起使用 如果函数体很短，使用 inline 操作符可以提高效率 Kotlin 遍历数组这一小节主要介绍 Kotlin 数组，一起来看一下遍历数组都有几种方式。 通过 forEach 遍历数组 通过区间表达式遍历数组(.. 、 downTo 、 until) 通过 indices 遍历数组 通过 withIndex 遍历数组 通过 forEach 遍历数组先来看看通过 forEach 遍历数组，和其他的遍历数组的方式，有什么不同。 array.forEach { value -&gt;}反编译后：Integer[] var5 = array;int var6 = array.length;for(int var7 = 0; var7 &lt; var6; ++var7) { Object element$iv = var5[var7]; int value = ((Number)element$iv).intValue(); boolean var10 = false;} 正如你所见通过 forEach 遍历数组的方式，会创建额外的对象，并且存在装箱/拆箱开销，会占用更多的内存。 通过区间表达式遍历数组在 Kotlin 中区间表达式有三种 .. 、 downTo 、 until 用 .. 关键字，表示左闭右闭区间 用 downTo 关键字，实现降序循环 用 until 关键字，表示左闭右开区间 .. 、downTo 、until for (value in 0..size - 1) { // case 1}for (value in size downTo 0) { // case 2}for (value in 0 until size) { // case 3}反编译后// case 1 if (value &lt;= var4) { while(value != var4) { ++value; }}// case 2for(boolean var5 = false; value &gt;= 0; --value) {}// case 3for(var4 = size; value &lt; var4; ++value) {} 如上所示 区间表达式 ( .. 、 downTo 、 until) 除了创建一些临时变量之外，不会创建额外的对象，但是区间表达式 和 step 关键字结合起来一起使用，就会存在内存问题。 区间表达式 和 step 关键字 带 step 操作的 .. 、 downTo 、 until， 编译之后如下所示。 for (value in 0..size - 1 step 2) { // case 1}for (value in 0 downTo size step 2) { // case 2}反编译后：// case 1var10000 = RangesKt.step((IntProgression)(new IntRange(var6, size - 1)), 2);while(value != var4) { value += var5;}// case 2 var10000 = RangesKt.step(RangesKt.downTo(0, size), 2); while(value != var4) { value += var5; } 带 step 操作的 .. 、 downTo 、 until 除了创建一些临时变量之外，还会创建 IntRange 、 IntProgression 对象，会占用更多的内存。 通过 indices 遍历数组indices 通过索引的方式遍历数组，每次遍历的时候通过索引获取数组里面的元素，如下所示。 for (index in array.indices) {}反编译后：for(int var4 = array.length; var3 &lt; var4; ++var3) {} 通过 indices 遍历数组， 编译之后的代码 ，除了创建了一些临时变量，并没有创建额外的对象。 通过 withIndex 遍历数组withIndex 和 indices 遍历数组的方式相似，通过 withIndex 遍历数组，不仅可以获取的数组索引，同时还可以获取到每一个元素。 for ((index, value) in array.withIndex()) {}反编译后：Integer[] var5 = array;int var6 = array.length;for(int var3 = 0; var3 &lt; var6; ++var3) { int value = var5[var3];} 正如你所看到的，通过 withIndex 方式遍历数组，虽然不会创建额外的对象，但是存在装箱/拆箱的开销 总结： 通过 forEach 遍历数组的方式，会创建额外的对象，占用内存，并且存在装箱 / 拆箱开销 通过 indices 和区间表达式 ( .. 、 downTo 、 until) 都不会创建额外的对象 区间表达式 和 step 关键字结合一起使用， 会有创建额外的对象的开销，占用更多的内存 通过 withIndex 方式遍历数组，不会创建额外的对象，但是存在装箱/拆箱的开销 尽量少使用 toLowerCase 和 toUpperCase 方法 这一小节内容，在我之前的文章中分享过，但是这也是很多小伙伴，遇到最多的问题，所以单独拿出来在分析一次 当我们比较两个字符串，需要忽略大小写的时候，通常的写法是调用 toLowerCase() 方法或者 toUpperCase() 方法转换成大写或者小写，然后在进行比较，但是这样的话有一个不好的地方，每次调用 toLowerCase() 方法或者 toUpperCase() 方法会创建一个新的字符串，然后在进行比较。 调用 toLowerCase() 方法 fun main(args: Array&lt;String&gt;) {// use toLowerCase() val oldName = &quot;Hi dHL&quot; val newName = &quot;hi Dhl&quot; val result = oldName.toLowerCase() == newName.toLowerCase()// or use toUpperCase()// val result = oldName.toUpperCase() == newName.toUpperCase()} toLowerCase() 编译之后的 Java 代码 如上图所示首先会生成一个新的字符串，然后在进行字符串比较，那么 toUpperCase() 方法也是一样的如下图所示。 toUpperCase() 编译之后的 Java 代码 这里有一个更好的解决方案，使用 equals 方法来比较两个字符串，添加可选参数 ignoreCase 来忽略大小写，这样就不需要分配任何新的字符串来进行比较了。 fun main(args: Array&lt;String&gt;) { val oldName = &quot;hi DHL&quot; val newName = &quot;hi dhl&quot; val result = oldName.equals(newName, ignoreCase = true)} equals 编译之后的 Java 代码 使用 equals 方法并没有创建额外的对象，如果遇到需要比较字符串的时候，可以使用这种方法，减少额外的对象创建。 by lazyby lazy 作用是懒加载，保证首次访问的时候才初始化 lambda 表达式中的代码， by lazy 有三种模式。 LazyThreadSafetyMode.NONE 仅仅在单线程 LazyThreadSafetyMode.SYNCHRONIZED 在多线程中使用 LazyThreadSafetyMode.PUBLICATION 不常用 LazyThreadSafetyMode.SYNCHRONIZED 是默认的模式，多线程中使用，可以保证线程安全，但是会有 double check + lock 性能开销，代码如下图所示。 如果是在主线程中使用，和初始化相关的逻辑，建议使用 LazyThreadSafetyMode.NONE 模式，减少不必要的开销。 仓库 KtKit 是用 Kotlin 语言编写的小巧而实用的工具库，包含了项目中常用的一系列工具, 正在逐渐完善中，如果你有兴趣，想邀请你和我一起来完善这个库。 KtKit 仓库地址：https://github.com/hi-dhl/KtKit KtKit 在线阅读：https://ktkit.hi-dhl.com 如果这个仓库对你有帮助，请在仓库右上角帮我 star 一下，非常感谢你的支持，同时也欢迎你提交 PR 如果有帮助 点个赞 就是对我最大的鼓励 代码不止，文章不停 欢迎关注公众号：ByteCode，持续分享最新的技术","link":"/2021/09/05/kotlin/12-kotlin-optimize/"},{"title":"Jetpack Splashscreen 解析 | 助力新生代 IT 农民工 事半功倍","text":"Jetpack 家族迎来了一位新的成员 Core Splashscreen，所以我也要重新开始写 Jetpack 系列文章了，在这之前写过一系列 Jetpack 文章以及配套的实战应用，包含 App Startup 、 Paging3 、 Hilt 、 DataStore 、ViewBinding 等等实战项目，点击下方链接前去查看。 AndroidX-Jetpack-Practice 系列实战项目 Kotlin 插件的落幕，ViewBinding 的崛起 竟然如此简单，DataBinding 和 ViewBinding 再见 SharedPreferences 拥抱 Jetpack DataStore (一) 再见 SharedPreferences 拥抱 Jetpack DataStore (二) Jetpack 成员 AndroidX App Startup 实践以及原理分析 Jetpack 成员 Paging3 数据库实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack成员Paging3获取网络分页数据并更新到数据库中（三） Jetpack 成员 Hilt 实践（一）启程过坑记 Jetpack 成员 Hilt 实践之 App Startup（二）进阶篇 Jetpack 成员 Hilt 与 Dagger 大不同（三）落地篇 全方面分析 Hilt 和 Koin 性能 Jetpack 实战：神奇宝贝 而今天这篇文章主要介绍 Google 新库 Core Splashscreen ，众所周知在 Android 12 中增加了一个改善用户体验的功能 SplashScreen API，它可为所有应用添加启动画面。包括启动时进入应用的启动动画，以及退出动画。 通过这篇文章你将学习到以下内容 Core Splashscreen 解决了什么问题？ Core Splashscreen 工作原理？ 针对不同的场景，如何在项目中使用 Core Splashscreen？ Core Splashscreen 源码分析？ Core Splashscreen 实战项目地址，可以前往 GitHub 查看示例项目 Splashscreen。https://github.com/hi-dhl/AndroidX-Jetpack-Practice Core SplashscreenCore Splashscreen 解决了什么问题？在 Android 启动过程中会出现白屏 / 黑屏，为了改善这一体验，因此添加启动画面，从而改善视觉上的体验，为了实现这一功能，市面上也有很多实现方法，都有各自的优缺点，因此并不能保证在所有设备上都能够流畅的运行。 其次有的时候需要从本地磁盘或者网络异步加载数据，等待数据加载完之后，才会去渲染 View， 大多数时候，希望将数据加载提前，尽量保证用户进入到首页之后，看到数据，减少用户的等待时间。 在 Android 12 上新增的 SplashScreen API，可以解决这一系列问题，但是缺点是仅限于 Android 12。 Core Splashscreen 因此而诞生了，为 Android 12 新增的 SplashScreen API 提供了向后兼容，可以在 Android 5.0 （API 21） ~ Android 12 （API 31）所有的 API 上使用。来看一下 Google 提供的动画效果。 Core Splashscreen 工作原理Core Splashscreen 为 Android 12 新增的 SplashScreen API 提供了向后兼容，但是仅仅在以下情况下才会显示启动画面： 冷启动：用户打开 APP 时 APP 进程尚未运行 温启动：APP 进程正在运行，但是 Activity 尚未创建 启动动画只有在以上情况才会显示，但是在热启动期间是不会显示启动画面。 热启动：APP 进程正在运行，Activity 也已经创建，也就说用户按下 Home 键退到后台，直到 Activity 被销毁之前，是不会显示启动画面 如何使用 Core Splashscreen因为 Core Splashscreen 兼容了 Android 12 新增的 SplashScreen API， 因此需要将 compileSdkVersion 更新到 31 及其以上。 如果你的 SDK 还没有更新到 Android 12, 请先更新。SDK Manager -&gt; 选择 Android 12 android { compileSdkVersion 31} 在模块级别的 build.gradle 文件中添加以下依赖。 implementation 'androidx.core:core-splashscreen:1.0.0-alpha01' 当添加完依赖之后就可以开始使用 Core Splashscreen，只需要三步即可实现显示启动画面。 1. 在 res/values/themes.xml 文件下添加新的主题 Theme.AppSplashScreen &lt;style name=&quot;Theme.AppSplashScreen&quot; parent=&quot;Theme.SplashScreen&quot;&gt; &lt;item name=&quot;windowSplashScreenBackground&quot;&gt;@color/purple_200&lt;/item&gt; &lt;item name=&quot;windowSplashScreenAnimatedIcon&quot;&gt;@mipmap/ic_launcher&lt;/item&gt; &lt;item name=&quot;postSplashScreenTheme&quot;&gt;@style/Theme.AppTheme&lt;/item&gt;&lt;/style&gt;&lt;!-- Base application theme. --&gt;&lt;style name=&quot;Theme.AppTheme&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt; &lt;!-- 添加 APP 默认主题 --&gt;&lt;/style&gt; android:windowSplashScreenBackground : 设置背景颜色 windowSplashScreenAnimatedIcon : 设置显示在屏幕中间的图标， 如果是通过 AnimationDrawable 和 AnimatedVectorDrawable 创建的对象，可呈现动画效果，则会在页面显示的时候，播放动画 postSplashScreenTheme : 设置显示动画不可见时，使用 APP 的默认主题 2. 在 application 节点中，设置上一步添加主题 Theme.AppSplashScreen &lt;application android:theme=&quot;@style/Theme.AppSplashScreen&quot;&gt;&lt;/application&gt; 3. 在调用 setContentView() 方法之前调用 installSplashScreen() class MainActivity : AppCompatActivity() { private val binding: ActivityMainBinding by viewbind() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) installSplashScreen() with(binding) { // init view } }} 调用 installSplashScreen() 方法主要将 Activity 与我们添加的主题相关联。这一步完成之后，就可以在 APP 启动过程中，看到刚才设置的图标或者动画了。 扩展功能让启动动画持久一点 默认情况下当应用绘制第一帧后，启动画面会立即关闭，但是有的时候需要从本地磁盘或者网络异步加载数据，这个时候，希望启动画面能够等到数据加载完回来才结束。可以通过以下方法实现。 splashScreen.setKeepVisibleCondition { !appReady }// 模拟从本地磁盘或者网络异步加载数据的耗时操作Handler(Looper.getMainLooper()) .postDelayed({ appReady = true }, 3000) 调用以上方法，可以让应用暂停绘制第一帧这样启动画面就不会结束，当数据加载完之后，通过更新变量 appReady 来控制是否结束启动画面。 实现退出动画 当然我们也可以添加启动画面的退出动画，即从启动画面优雅的回到应用主界面。 splashScreen.setOnExitAnimationListener { splashScreenViewProvider -&gt; ...... // 自定义退出动画 val translationY = ObjectAnimator.ofFloat(......) translationY.doOnEnd { splashScreenViewProvider.remove() } translationY.start()} 效果可以前往 GitHub 查看示例项目 Splashscreen。 GitHub 示例项目：https://github.com/hi-dhl/AndroidX-Jetpack-Practice Core Splashscreen 源码解析Core Splashscreen 源码很简单，总共就只有两个类。 SplashScreen ：主要为实现 SplashScreen API 提供了向后兼容性，用于将 Activity 与主题相关联。 SplashScreenViewProvider : 用于控制退出动画（启动画面 -&gt; 应用主界面），当退出动画结束时需要手动调用 SplashScreenViewProvider#remove() 方法 初始化 SplashScreen通过调用 SplashScreen#installSplashScreen() 方法来进行初始化，将 Activity 与添加的主题相关联。androidx/core/splashscreen/SplashScreen.kt public companion object { @JvmStatic public fun Activity.installSplashScreen(): SplashScreen { val splashScreen = SplashScreen(this) splashScreen.install() return splashScreen }}private fun install() { impl.install()} 最终都是通过调用 impl.install() 方法来进行初始化，一起来看看成员变量 impl 是如何初始化的。 private val impl = when { SDK_INT &gt;= 31 -&gt; Impl31(activity) SDK_INT == 30 &amp;&amp; PREVIEW_SDK_INT &gt; 0 -&gt; Impl31(activity) SDK_INT &gt;= 23 -&gt; Impl23(activity) else -&gt; Impl(activity)} 到这里我们知道了 Google 为了向后兼容，针对于不同版本的系统，分别对应有不同的实现类。最终都是调用 install() 方法来进行初始化的，在 install() 方法内通过解析我们添加的主题，最后通过 activity.setTheme() 方法，将添加的主题和 Activity 关联在一起。 如何让启动动画持久一点在代码中，我们通过调用 SplashScreen#setKeepVisibleCondition() 方法，让启动动画持久一点，等待数据加完之后，才结束启动动画。一起来看看这个方法。androidx/core/splashscreen/SplashScreen.kt public fun setKeepVisibleCondition(condition: KeepOnScreenCondition) { // impl：针对于不同版本的系统，分别对应有不同的实现类 impl.setKeepVisibleCondition(condition)}open fun setKeepVisibleCondition(keepOnScreenCondition: KeepOnScreenCondition) { ...... observer.addOnPreDrawListener(object : OnPreDrawListener { override fun onPreDraw(): Boolean { if (splashScreenWaitPredicate.shouldKeepOnScreen()) { return false } contentView.viewTreeObserver.removeOnPreDrawListener(this) // 当开始绘制时，会调用 dispatchOnExitAnimation 方法，结束启动动画 mSplashScreenViewProvider?.let(::dispatchOnExitAnimation) return true } })} 最后通过 ViewTreeObserver 来监听视图的变化，当视图将要开始绘制时，会回调 OnPreDrawListener#onPreDraw() 方法。最后调用 dispatchOnExitAnimation 方法，结束启动动画。 实现退出动画最后一起来看一下，源码中是如何实现退出动画，即从启动画面优雅的回到应用主界面，源码中只是提供了一个 OnExitAnimationListener 接口，将退出动画交给了开发者去实现，一起来看一下SplashScreen#setOnExitAnimationListener() 方法。androidx/core/splashscreen/SplashScreen.kt Android 12 以上 override fun setOnExitAnimationListener( exitAnimationListener: OnExitAnimationListener) { activity.splashScreen.setOnExitAnimationListener { val splashScreenViewProvider = SplashScreenViewProvider(it, activity) exitAnimationListener.onSplashScreenExit(splashScreenViewProvider) }} 在 Android 12 中是通过系统源码提供的接口 activity.splashScreen.setOnExitAnimationListener ，回调对外暴露的接口 OnExitAnimationListener 让开发者去实现退出动画的效果。 Android 12 以下 open fun setOnExitAnimationListener(exitAnimationListener: OnExitAnimationListener) { animationListener = exitAnimationListener val splashScreenViewProvider = SplashScreenViewProvider(activity) ...... splashScreenViewProvider.view.addOnLayoutChangeListener( object : OnLayoutChangeListener { override fun onLayoutChange(......) { ...... dispatchOnExitAnimation(splashScreenViewProvider) } })}fun dispatchOnExitAnimation(splashScreenViewProvider: SplashScreenViewProvider) { ...... splashScreenViewProvider.view.postOnAnimation { finalListener.onSplashScreenExit(splashScreenViewProvider) }} 通过向屏幕中显示的 View 添加 addOnLayoutChangeListener 方法，来监听布局的变化，当布局会发生改变时，会回调 onLayoutChange 方法，最后通过回调对外暴露的接口 OnExitAnimationListener 让开发者去实现退出动画。 不过这里需要注意的是，最后都需要调用 SplashScreenViewProvider#remove() 方法在合适的时机移除动画，可以在退出动画结束时，调用这个方法。 总结本文从不同的角度分别分析了 Core Splashscreen。如何在项目中使用 Core Splashscreen，可以前往 GitHub 查看示例项目 Splashscreen。 仓库地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 另外 KtKit 是用 Kotlin 语言编写的小巧而实用工具库，包含了项目中常用的一系列工具，我添加了许多新的功能，包含了很多 Kotlin 技巧。文章分析可前往查看 为数不多的人知道的 Kotlin 技巧以及解析(三)。 监听 EditText 将 Flow 通过 lifecycleScope 将 EditText 与 Activity / Fragment 的生命周期绑定在一起，在 Activity / Fragment 生命周期结束时，会结束 flow , flow 结束时会断开它们之间的引用，有效的避免内存泄漏。 ......// 监听 TextWatcher#onTextChanged 的回调函数editText.textChange(lifecycleScope) { Log.e(TAG, &quot;textChange = $it&quot;)}// 监听 TextWatcher#beforeTextChanged 的回调函数editText.textChangeWithbefore(lifecycleScope) { Log.e(TAG, &quot;textChangeWithbefore = $it&quot;)}// 监听 TextWatcher#afterTextChanged 的回调函数editText.textChangeWithAfter(lifecycleScope) { Log.e(TAG, &quot;textChangeWithbefore = $it&quot;)}...... 监听蜂窝网络变化 lifecycleScope.launch { listenCellular().collect { Log.e(TAG, &quot;listenNetwork = $it&quot;) }} 监听 wifi 网络的变化 lifecycleScope.launch { listenWifi().collect { Log.e(TAG, &quot;listenNetwork = $it&quot;) }} 监听蓝牙网络的变化 lifecycleScope.launch { listenNetworkFlow().collect { Log.e(TAG, &quot;listenNetwork = $it&quot;) }} 更多 API 使用方式点击这里前往查看: KtKit 仓库地址：https://github.com/hi-dhl/KtKit KtKit 在线阅读：https://ktkit.hi-dhl.com 如果这个仓库对你有帮助，请在仓库右上角帮我 star 一下，非常感谢你的支持，同时也欢迎你提交 PR ❤️❤️❤️ 如果有帮助 点个赞 就是对我最大的鼓励 代码不止，文章不停 欢迎关注公众号：ByteCode，持续分享最新的技术 推荐文章： 为数不多的人知道的 Kotlin 技巧及解析(三) 为数不多的人知道的 Kotlin 技巧以及 原理解析（二） 为数不多的人知道的 Kotlin 技巧以及 原理解析（一） 揭秘 Kotlin 中的 == 和 === Kotlin 密封类进化了 Kotlin 中的密封类 优于 带标签的类 Kotlin Sealed 是什么？为什么 Google 都在用 Kotlin Sealed 是什么？为什么 Google 都在用 Android 12 行为变更，对应用产生的影响 图解多平台 AndroidStudio 技巧(三) Kotlin StateFlow 搜索功能的实践 DB + NetWork Kotlin 插件的落幕，ViewBinding 的崛起 竟然如此简单，DataBinding 和 ViewBinding","link":"/2021/08/18/jetpack/14-Splashscreen/"},{"title":"为数不多的人知道的 Kotlin 技巧及解析(三)","text":"文章中没有奇淫技巧，都是一些在实际开发中常用的技巧 Google 引入 Kotlin 的目的就是为了让 Android 开发更加方便，自从官宣 Kotlin 成为了 Android 开发的首选语言之后，已经有越来越多的团队，在项目使用 Kotlin。 众所周知 xml 十分耗时，因此在 Android 10.0 上新增加 tryInflatePrecompiled 方法，这是一个在编译期运行的一个优化，因为布局文件越复杂 XmlPullParser 解析 XML 越耗时, tryInflatePrecompiled 方法根据 XML 预编译生成 compiled_view.dex, 然后通过反射来生成对应的 View，从而减少 XmlPullParser 解析 XML 的时间，但是目前一直处于禁用状态。源码解析请查看 Android 资源加载源码分析一。 因此一些体量比较大的应用，为了极致的优化，缩短一点时间，对于简单的布局，会使用 Kotlin 去重写这部分 UI，但是门槛还是很高，随着 Jetpack Compose 的出现，其目的是让您更快、更轻松地构建原生 Android 应用，前不久 Google 正式发布了 Jetpack Compose 1.0。 Kotlin 优势已经体现在了方方面面，结合着 Kotlin 的高级函数的特性可以让代码可读性更强，更加简洁，但是如果使用不当会对性能造成一些损耗，更多内容可前往查看。 为数不多的人知道的 Kotlin 技巧及解析(二) 为数不多的人知道的 Kotlin 技巧及解析(一) 以上两篇文章，主要分享了 Kotlin 在实际项目中使用的技巧，以及如果使用不当会对 性能 和 内存 造成的那些影响以及如何规避这些问题等等。 通过这篇文章你将学习到以下内容： 什么是 Contract，以及如何使用？ Kotlin 注解在项目中的使用？ 一行代码接受 Activity 或者 Fragment 传递的参数？ 一行代码实现 Activity 之间传递参数？ 一行代码实现 Fragment 之间传递参数？ 一行代码实现点击事件，避免内存泄露？ KtKit 仓库这篇文章主要围绕一个新库 KtKit 来介绍一些 Kotlin 技巧，正如其名 KtKit 是用 Kotlin 语言编写的工具库，包含了项目中常用的一系列工具，是 Jetpack ktx 系列的补充，涉及到了很多从 Kotlin 源码、Jetpack ktx、anko 等等知名的开源项目中学习到的技巧，包含了 Kotlin 委托属性、高阶函数、扩展函数、内联、注解的使用等等。 KtKit 仓库地址：https://github.com/hi-dhl/KtKit KtKit 在线阅读：https://ktkit.hi-dhl.com 如果想要使用文中的 API 需要将下列代码添加在模块级 build.gradle 文件内, 最新版本号请查看 版本记录。 implementation &quot;com.hi-dhl:ktkit:${ktkitVersion}&quot; 因为篇幅原因，文章中不会过多的涉及源码分析，源码部分将会在后续的文章中分享。 什么是 Contract，以及如何使用众所周知 Kotlin 是比较智能的，比如 smart cast 特性，但是在有些情况下显得很笨拙，并不是那么智能，如下所示。 public inline fun String?.isNotNullOrEmpty(): Boolean { return this != null &amp;&amp; !this.trim().equals(&quot;null&quot;, true) &amp;&amp; this.trim().isNotEmpty()}fun testString(name: String?) { if (name.isNotNullOrEmpty()) { println(name.length) // 1 }} 正如你所见，只有字符串 name 不为空时，才会进入注释 1 的地方，但是以上代码却无法正常编译，如下图所示。 编译器会告诉你一个编译错误，经过代码分析只有当字符串 name 不为空时，才会进入注释 1 的地方，但是编译器却无法正常推断出来，真的是编译器做不到吗？看看官方文档是如何解释的。 However, as soon as these checks are extracted in a separate function, all the smartcasts immediately disappear: 将检查提取到一个函数中， smart cast 所带来的效果都会消失 编译器无法深入分析每一个函数，原因在于实际开发中我们可能写出更加复杂的代码，而 Kotlin 编译器进行了大量的静态分析，如果编译器去分析每一个函数，需要花费时间分析上下文，增加它的编译耗时的时间。 如果要解决上诉问题，这就需要用到 Contract 特性，Contract 是 Kotlin 提供的非常有用的特性，Contract 的作用就是当 Kotlin 编译器没有足够的信息去分析函数的情况的时候，Contracts 可以为函数提供附加信息，帮助 Kotlin 编译器去分析函数的情况，修改代码如下所示。 inline fun String?.isNotNullOrEmpty(): Boolean { contract { returns(true) implies (this@isNotNullOrEmpty != null) } return this != null &amp;&amp; !this.trim().equals(&quot;null&quot;, true) &amp;&amp; this.trim().isNotEmpty()}fun testString(name: String?) { if (name != null &amp;&amp; name.isNotNullOrEmpty()) { println(name.length) // 1 }} 相比于之前的代码，在 isNotNullOrEmpty() 函数中添加了 contract 代码块即可正常编译通过，这行代码的意思就是，如果返回值是 true ，this 所指向对象就不为 null。 而在 Kotlin 标准库中大量的用到 contract 特性。 上述示例的使用可前往查看 KtKit/ProfileActivity.kt。 Kotlin 注解在项目中的使用contract 是 Kotlin 1.3 添加的实验性的 API，如果我们调用实验性的 API 需要添加 @ExperimentalContracts 注解才可以正常使用，但是如果添加 @ExperimentalContracts 注解，所有调用这个方法的地方都需要添加注解，如果想要解决这个问题。只需要在声明 contract 文件中的第一行添加以下代码即可。 @file:OptIn(ExperimentalContracts::class) 在上述示例中使用了 inline 修饰符，但是编译器会有一个黄色警告，如下图所示。 编译器建议我们将函数作为参数时使用 Inline，Inline (内联函数) 的作用：提升运行效率，调用被 inline 修饰符的函数，会将方法内的代码段放到调用处。 既然 Inline 修饰符可以提升运行效率，为什么还给出警告，因为 Inline 修饰符的滥用会带来性能损失，更多内容前往查看 Inline 修饰符带来的性能损失。 Inline 修饰符常用于下面的情况，编译器才不会有警告： 将函数作为参数（例如：lambda 表达式） 结合 reified 实化类型参数一起使用 但是在普通的方法中，使用 Inline 修饰符，编译会给出警告，如果方法体的代码段很短，想要通过 Inline 修饰符提升性能（虽然微乎其微），可以在文件的第一行添加下列代码，可消除警告。 @file:Suppress(&quot;INVISIBLE_REFERENCE&quot;, &quot;INVISIBLE_MEMBER&quot;) 然后在使用 Inline 修饰符的地方添加以下注解，即可愉快的使用。 @kotlin.internal.InlineOnly 注解 @kotlin.internal.InlineOnly 的作用： 消除编译器的警告 修改内联函数的可见性，在编译时修改成 private // 未添加 InlineOnly 编译后的代码public static final void showShortToast(@NotNull Context $this$showShortToast, @NotNull String message) { ...... Toast.makeText($this$showShortToast, (CharSequence)message, 0).show();}// 添加 InlineOnly 编译后的代码@InlineOnlyprivate static final void showShortToast(Context $this$showShortToast, String message) { ...... Toast.makeText($this$showShortToast, (CharSequence)message, 0).show();} 关于注解完整的使用案例，可前往仓库 KtKit 查看。 一行代码接受 Activity 或者 Fragment 传递的参数如果想要实现一行代码接受 Activity 或者 Fragment 传递的参数，可以通过 Kotlin 委托属性来实现，在仓库 KtKit 中提供了两个 API，根据实际情况使用即可。案例可前往查看 KtKit/ProfileActivity.kt。 class ProfileActivity : Activity() { // 方式一： 不带默认值 private val userPassword by intent&lt;String&gt;(KEY_USER_PASSWORD) // 方式二：带默认值：如果获取失败，返回一个默认值 private val userName by intent&lt;String&gt;(KEY_USER_NAME) { &quot;公众号：ByteCode&quot; }} 一行代码实现 Activity 之间传递参数这个思路是参考了 anko 的实现，同样是提供了两个 API ， 根据实际情况使用即可，可以传递 Android 支持的任意参数，案例可前往查看 KtKit/ProfileActivity.kt。 // API:activity.startActivity&lt;ProfileActivity&gt; { arrayOf( KEY_USER_NAME to &quot;ByteCode&quot; ) }activity.startActivity&lt;ProfileActivity&gt;( KEY_USER_NAME to &quot;ByteCode&quot; )// Example: class ProfileActivity : Activity() { ...... companion object { ...... // 方式一 activity.startActivity&lt;ProfileActivity&gt; { arrayOf( KEY_USER_NAME to &quot;ByteCode&quot;, KEY_USER_PASSWORD to &quot;1024&quot; ) } // 方式二 activity.startActivity&lt;ProfileActivity&gt;( KEY_USER_NAME to &quot;ByteCode&quot;, KEY_USER_PASSWORD to &quot;1024&quot; ) }} Activity 之间传递参数 和 并回传结果 // 方式一context.startActivityForResult&lt;ProfileActivity&gt;(KEY_REQUEST_CODE, KEY_USER_NAME to &quot;ByteCode&quot;, KEY_USER_PASSWORD to &quot;1024&quot;)// 方式二context.startActivityForResult&lt;ProfileActivity&gt;(KEY_REQUEST_CODE) { arrayOf( KEY_USER_NAME to &quot;ByteCode&quot;, KEY_USER_PASSWORD to &quot;1024&quot; )} 回传结果 // 方式一setActivityResult(Activity.RESULT_OK) { arrayOf( KEY_RESULT to &quot;success&quot;, KEY_USER_NAME to &quot;ByteCode&quot; )} // 方式二setActivityResult( Activity.RESULT_OK, KEY_RESULT to &quot;success&quot;, KEY_USER_NAME to &quot;ByteCode&quot;) 一行代码实现 Fragment 之间传递参数和 Activity 一样提供了两个 API 根据实际情况使用即可，可以传递 Android 支持的任意参数，源码前往查看 KtKit/LoginFragment.kt。 // API: LoginFragment().makeBundle( KEY_USER_NAME to &quot;ByteCode&quot; )LoginFragment().makeBundle { arrayOf( KEY_USER_NAME to &quot;ByteCode&quot; ) }// Example: class LoginFragment : Fragment(R.layout.fragment_login) { ...... companion object { ...... // 方式一 fun newInstance1(): Fragment { return LoginFragment().makeBundle( KEY_USER_NAME to &quot;ByteCode&quot;, KEY_USER_PASSWORD to &quot;1024&quot; ) } // 方式二 fun newInstance2(): Fragment { return LoginFragment().makeBundle { arrayOf( KEY_USER_NAME to &quot;ByteCode&quot;, KEY_USER_PASSWORD to &quot;1024&quot; ) } } }} 一行代码实现点击事件，避免内存泄露KtKit 提供了常用的三个 API：单击事件、延迟第一次点击事件、防止多次点击 单击事件 view.click(lifecycleScope) { showShortToast(&quot;公众号：ByteCode&quot; } 延迟第一次点击事件 // 默认延迟时间是 500msview.clickDelayed(lifecycleScope){ showShortToast(&quot;公众号：ByteCode&quot; }// orview.clickDelayed(lifecycleScope, 1000){ showShortToast(&quot;公众号：ByteCode&quot;) } 防止多次点击 // 默认间隔时间是 500msview.clickTrigger(lifecycleScope){ showShortToast(&quot;公众号：ByteCode&quot;) }// orview.clickTrigger(lifecycleScope, 1000){ showShortToast(&quot;公众号：ByteCode&quot;) } 但是 View#setOnClickListener 造成的内存泄露，如果做过性能优化的同学应该会见到很多这种 case。 根本原因在于不规范的使用，在做业务开发的时候，根本不会关注这些，那么如何避免这个问题呢，Kotlin Flow 提供了一个非常有用的 API callbackFlow，源码如下所示。 fun View.clickFlow(): Flow&lt;View&gt; { return callbackFlow { setOnClickListener { safeOffer(it) } awaitClose { setOnClickListener(null) } }} callbackFlow 正如其名将一个 callback 转换成 flow，awaitClose 会在 flow 结束时执行。 那么 flow 什么时候结束执行 源码中我将 Flow 通过 lifecycleScope 与 Activity / Fragment 的生命周期绑定在一起，在 Activity / Fragment 生命周期结束时，会结束 flow , flow 结束时会将 Listener 置为 null，有效的避免内存泄漏，源码如下所示。 inline fun View.click(lifecycle: LifecycleCoroutineScope, noinline onClick: (view: View) -&gt; Unit) { clickFlow().onEach { onClick(this) }.launchIn(lifecycle)} 总结仓库 KtKit 是用 Kotlin 语言编写的工具库，包含了项目中常用的一系列工具，但是目前还不是很完善，正在陆续将一些常用的功能，结合着 Kotlin 的高级函数的特性，不仅让代码可读性更强，使用更加简单，而且还可以帮助我们解决项目中常见的问题。 KtKit 仓库地址：https://github.com/hi-dhl/KtKit KtKit 在线阅读：https://ktkit.hi-dhl.com 项目中引用了 spotless 插件，执行 ./gradlew spotlessApply 会将 Java 、Kotlin 、xml 、gradle 、md 、gitignore 等等文件按照官方标准去格式化代码。这也是 Google 提交代码的时候，推荐的方式。 全文到这里就结束了，如果这个仓库对你有帮助，请在仓库右上角帮我 star 一下，非常感谢你的支持，同时也欢迎你提交 PR ❤️❤️❤️ 如果有帮助 点个赞 就是对我最大的鼓励 代码不止，文章不停 欢迎关注公众号：ByteCode，持续分享最新的技术","link":"/2021/08/02/kotlin/11-kotlin-tip3/"},{"title":"揭秘 Kotlin 中的 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;","text":"之前分别写了三篇文章，从原理、优化、实战、新特性（密封接口）以不同的角度分别介绍了 Sealed Classes。 Kotlin 密封类进化了 Kotlin 中的密封类 优于 带标签的类 Kotlin Sealed 是什么？为什么 Google 都在用 而这篇文章我们主要来分析 Kotlin 中的操作符 == 和 === 的区别，以及它们分别在什么场景下使用。这些操作符在实际项目和开源项目中，使用的频率非常的高。主要包含以下内容： Java 中的 == 和 equals 的区别？ Kotlin 提供的操作符 == 和 === 分别做什么用？ 比较对象的结构是否相等 ( == 或者 equals ) 比较对象的引用是否相等 ( === ) Kotlin 中的操作符在以下场景中的使用 基本数据类型 包装类 普通类 数据类 在开始分析之前，我们先来简单回顾一下 Java 中的操作符 == 和 equals 的区别。 Java 中的操作符 == 和 equals 的区别操作符 == 如果是基本数据类型比较的是值 如果是引用数据类型比较的是地址 操作符 equals 默认情况下在不重写 equals 方法时，等价于 ==，比较的是地址 public boolean equals(Object obj) { return (this == obj);} 重写 equals 方法时，一般用于比较结构是否相等，例如 String public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 但是需要注意的是重写 equals 方法时，需要重写 hashCode() 方法，否则无法和 hash 集合类一起正常工作，可以通过快捷键自动生成 equals() 、hashCode() 、 toString() 等等方法。 Mac: Cmd + N Win/Linux: Alt+Insert 更多 AndroidStudio 快捷键使用技巧查看下列文章： 图解多平台 AndroidStudio 技巧(一) 图解多平台 AndroidStudio 技巧(二) 图解多平台 AndroidStudio 技巧(三) 关于 Java 的操作符介绍就到这里了，接下来重点来分析 Kotlin 中的操作符。 Kotlin 中的操作符 == 和 === 及 equalsKotlin 提供了两种方式用于对象的比较。 比较对象的结构是否相等（ == 或者 equals ） Kotlin 中的操作符 == 等价于 equals 用于比较对象的结构是否相等, 很多情况下使用的是 ==，因为对于浮点类型 Float 和 Double，其实现方法 equals 不遵循 IEEE 754 浮点运算标准。 比较对象的引用是否相等 ( === ) Kotlin 中的操作符 === 用于比较对象的引用是否指向同一个对象，运行时如果是基本数据类型 === 等价于 ==。 我们知道了基本概念之后，接下来一起来看一下这些操作符（ == 和 === 及 equals ），在以下场景中的使用。 基本数据类型 包装类 普通类 数据类 基本数据类型我们先来看一个例子： val a1 = -0val a2 = 0println(a1 == a2) // trueprintln(a1.equals(a2)) // trueprintln(a1 === a2) // truea1 = 100a2 = 100println(a1 == a2) // trueprintln(a1.equals(a2)) // trueprintln(a1 === a2) // true 运行时，对于基本数据类型 === 等价于 == 比较的是值（即对象的结构是否相等），如果比较基本数据类型时使用 ===，编译器就会给出一个警告，不建议使用。 但是 equals 比较特殊, 对于浮点类型 Float 和 Double 却有不同的表现，代码如下所示。 val a3 = -0fval a4 = 0fprintln(a3 == a4) // trueprintln(a3.equals(a4)) // falseprintln(a3 === a4) // true``` 正如你所看到的 `a3.equals(a4)` 结果为 false，那么为什么会这样呢，一起来查看反编译后的 Java 代码都做了什么。`Tools → Kotlin → Show Kotlin Bytecode` 。 float a3 = -0.0F;float a4 = 0.0F;boolean var2 = Float.valueOf(a3).equals(a4);boolean var3 = false;System.out.println(var2); 将 float 转换为包装类型 Float，调用其 `equals` 方法来进行比较，来看一下 `equals` 方法。![](http://img.hi-dhl.com/16259165159999.jpg)运行结果正如源码注释高亮部分一样，使用 `equals` 方法比较 `+0.0f` 和 `-0.0f` 其结果为 false, 如果使用操作符 `==` 结果为 true。在 `equals` 方法中调用了 `floatToIntBits` 方法，在这个方法中是根据 **IEEE 754 浮点算法标准**，返回指定浮点值的表示形式，结果是一个整数，如下所示： System.out.println(Float.floatToIntBits(-0f)); // -2147483648System.out.println(Float.floatToIntBits(0f)); // 0 正如你所见，`Float.floatToIntBits(-0f)` 计算出来的结果，是整数的最小值 -2147483648，从结果来看它不遵循 **IEEE 754 浮点运算标准**，一起来看一下官方是如何解释的，更多信息点击查看 [IEEE 754 浮点运算标准](https://kotlinlang.org/docs/basic-types.html#unsigned-integers)![](http://img.hi-dhl.com/16259736647490.jpg)对于浮点类型 Float 和 Double，其实现方法 `equals` 不遵循 **IEEE 754 浮点运算标准**：* `NaN` 被认为和它自身相等* `NaN` 被认为比包括正无穷在内的任何其他元素都大* `-0.0` 小于 `+0.0`因此在 Kotlin 中如果使用 `equals` 方法进行比较的时候，需要注意这个情况。### 包装类无论是 Java 还是 Kotlin 每一种基本类型都会对应一个唯一的包装类，只不过它们的区分方式不一样。| 基本数据类型 | 包装类 || --- | --- || byte | Byte || short | Short || int | Integer || long | Long || float | Float || double | Double || char | Character || boolean | Boolean | val a5 = Integer(10)val a6 = Integer(10)println(a5 == a6) // trueprintln(a5.equals(a6)) // trueprintln(a5 === a6) // false 因为包装类重写了 `equals` 方法，所以使用操作符 `==` 和 `equals` 比较的是对象的结构是否相等，所以结果为 true。而操作符 `===` 比较的是对象的引用，是否指向同一个对象，因为是不同的对象，所以结果为 false。### 普通的类普通的类其实就是我们自己新建的类，并没有重写 `equals` 方法，一起来看一下这三种操作符的运行结果。 class Person1(val name: String, val age: Int) val p1 = Person1(name = “hi-dhl”, age = 10)val p2 = Person1(name = “hi-dhl”, age = 10)println(p1 == p2) // falseprintln(p1.equals(p2)) // falseprintln(p1 === p2) // false println(p1.name == p2.name) // trueprintln(p1.name.equals(p2.name)) // trueprintln(p1.name === p2.name) // true 因为普通的类 Person1 并没有实现 `equals` 方法，所以使用操作符 `==` 和 `equals` 比较的结果为 false，而 p1 和 p2 是不同的对象所以操作符 `===` 的结果为 false。参数 name 是 String 类型，在上文分析过了 String 重写了 `equals` 方法，操作符 `==` 和 `equals` 比较的结果为 true。而 `p1.name === p2.name` 结果为 true , 是因为会先去常量池中查找是否存在 &quot;hi-dhl&quot;，如果存在直接返回常量池中的引用。### 数据类最后我们在来看一下这三种操作符在数据类中的表现。 data class Person2(val name: String, val age: Int) val p3 = Person2(name = “ByteCode”, age = 10)val p4 = Person2(name = “ByteCode”, age = 10)println(p3 == p4) // trueprintln(p3.equals(p4)) // trueprintln(p3 === p4) // false println(p3.name == p4.name) // trueprintln(p3.name.equals(p4.name))// trueprintln(p3.name === p4.name) // true 因为编译器会根据数据类中的参数，自动生成 `equals` 、 `hashCode` 、 `toString` 等等方法，编译后的代码如下所示。 public int hashCode() { String var10000 = this.name; return (var10000 != null ? var10000.hashCode() : 0) * 31 + Integer.hashCode(this.age);} public boolean equals(@Nullable Object var1) { if (this != var1) { if (var1 instanceof Person2) { Person2 var2 = (Person2)var1; if (Intrinsics.areEqual(this.name, var2.name) &amp;&amp; this.age == var2.age) { return true; } } return false; } else { return true; }} 所以使用操作符 `==` 和 `equals`，输出结果为 true，但是 p3 和 p4 是不同的对象所以操作符 `===` 的结果为 false。## 总结### Java 中的操作符**操作符 ==*** 如果是基本数据类型比较的是值* 如果是引用数据类型比较的是地址**操作符 equals*** 默认情况下在不重写 `equals` 方法时，等价于 `==`，比较的是地址* 重写 `equals` 方法时，常用于比较结构是否相等，可以通过快捷键自动生成 `equals()` 、`hashCode()` 、 `toString()` 等等方法。 - Mac: Cmd + N - Win/Linux: Alt+Insert### Kotlin 中的操作符Kotlin 提供了两种方式用于对象的比较。* 比较对象的结构是否相等（ `==` 或者 `equals` ） Kotlin 中的操作符 `==` 等价于 `equals` 用于比较对象的结构是否相等, 很多情况下使用的是 `==`，因为对于浮点类型 Float 和 Double，其实现方法 `equals` 不遵循 IEEE 754 浮点运算标准。 * 比较对象的引用是否相等 ( `===` ) Kotlin 中的操作符 `===` 用于比较对象的引用是否指向同一个对象，运行时如果是基本数据类型 `===` 等价于 `==`。全文到这里就结束了，最后附上文章的精简示例，你能够在不运行程序的情况下，说出下面代码的运行结果吗？ class Person1(val name: String, val age: Int)data class Person2(val name: String, val age: Int) fun main() { val a1 = -0 val a2 = 0 println(a1 == a2) println(a1.equals(a2) val a3 = -0f val a4 = 0f println(a3 == a4) println(a3.equals(a4)) //------------- val p1 = Person1(name = &quot;hi-dhl&quot;, age = 10) val p2 = Person1(name = &quot;hi-dhl&quot;, age = 10) println(p1 == p2) println(p1.equals(p2)) println(p1 === p2) println(p1.name === p2.name) //------------- val p3 = Person2(name = &quot;ByteCode&quot;, age = 10) val p4 = Person2(name = &quot;ByteCode&quot;, age = 10) println(p3 == p4) println(p3.equals(p4)) println(p3 === p4) println(p3.name === p4.name)} 运行结果如下所示： a1 == a2 truea1.equals(a2) truea3 == a4 truea3.equals(a4) false p1 == p2 falsep1.equals(p2) falsep1 === p2 falsep1.name === p2.name true p3 == p4 truep3.equals(p4) truep3 === p4) falsep3.name === p4.name true &lt;p align=&quot;center&quot;&gt; &lt;br/&gt; &lt;p align=&quot;center&quot;&gt;&lt;b&gt;如果有帮助 点个赞 就是对我最大的鼓励&lt;/b&gt;&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;&lt;b&gt;代码不止，文章不停&lt;/b&gt;&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;&lt;b&gt;欢迎关注公众号：ByteCode，持续分享最新的技术&lt;/b&gt;&lt;/p&gt; &lt;br/&gt; &lt;/p&gt;","link":"/2021/07/14/kotlin/10-kotlin-equality/"},{"title":"Kotlin 密封类进化了","text":"这是 Sealed Classes（密封类）系列的第三篇文章，之前的文章从原理、优化、实战以不同的角度分别介绍了 Sealed Classes 的强大。 在 Kotlin Sealed 是什么？为什么 Google 都在用 文章中主要包含以下内容： Sealed Classes 原理分析？ 枚举、抽象类、Sealed Classes 分别有那些优缺点？ 分别在什么情况下使用枚举和 Sealed Classes？ 为什么 Sealed Classes 用于表示受限制的类层次结构？ 在项目中如何使用 Sealed Classes？ 禁止在 Sealed Classes 所定义的文件外使用， Kotlin 是如何做到的呢？ …… 在 Kotlin 中的密封类 优于 带标签的类 文章中主要包含以下内容： 什么是 Tagged Classes（标记类）？ Tagged Classes 的优缺点，以及在项目中所带来的影响？ 如何使用 Sealed Classes 优化现有的代码，可以带来那些收益？ 而这篇文章主要来介绍 Sealed Classes 在 Kotlin 1.5.0 上带来的新特性及原理分析，在开始分析之前，先来简单的回顾一下之前文章的内容。 Sealed Classes什么是 Sealed Classes？ Sealed Classes 用于表示受限制的类层次结构，其实这句话可以拆成两句话来理解。 Sealed Classes 用于表示层级关系： 子类可以是任意的类， 数据类、Kotlin 对象、普通的类，甚至也可以是另一个 Sealed Sealed Classes 受限制： 必须在同一文件中，或者在 Sealed Classes 内部中使用，在 Kotlin 1.1 之前，规则更加严格，子类只能在 Sealed Classes 内部中使用 Sealed Classes 的优点： Sealed Classes 使类之间的职责分明，提高代码的可读性 扩展性强，可以在不修改原有的代码结构的基础上添加新的参数或者子类 每个类中不包含无关的字段，在一定程度上减少对象所占用的内存 Sealed Classes 结合 when 表达式一起使用会更加的方便，when 语句下的所有分支可以通过快捷键 Mac/Win/Linux：Alt + Enter 自动生成，效果如下所示： 这里只是简单的回顾了一下之前的内容，接下来我们一起来看看，在新版本 Kotlin 1.5.0 中 Sealed Classes 给我们带来了那些优化。 Sealed Classes 进化了在 2021 年 5 月份，Kotlin 官方发布了 1.5.0，在这个版本中带来几个非常有用的特性，而在这篇文章我们主要介绍 Sealed Classes，更多信息请查看 What’s new in Kotlin 1.5.0。 在 Kotlin 1.0 时，子类只能在 Sealed Classes 内部中使用，因为 Sealed class 会被编译成 abstract class，并且默认的构造方法被私有化了，所以子类必须嵌套在 Sealed Classes 类中。 在 Kotlin 1.1 时，允许顶级的 Sealed Classes 和它顶级子类在同一个文件中，因为编译器会自动生成了一个 公有 的构造方法，在子类的构造方法中调用了父类 公有 的构造方法，而这些都是 Kotlin 编译器帮我们做的。 在 Kotlin 1.5.0 中，放宽了对 Sealed Classes 限制，只需要保证 Sealed Classes 和它的子类，在同一个包名和 module 下面即可，这些都是 Kotlin 编译器帮我们做的。 接下里我们一起来分析一下为什么 Kotlin 需要升级 Sealed Classes？在之前的文章 Kotlin 中的密封类 优于 带标签的类 分析了 Sealed Classes 有很多优点，但是它也有很多不足之处，这也是为什么需要升级 Sealed Classes 的原因： Sealed Classes 的子类，被限制在单个父类中 把所有的代码放在一个文件中，会造成文件臃肿，可读性下降，如下所示 sealed class Color { class Red : Color() class Blue : Color() // ...... 更多的颜色}sealed class Figure { abstract fun draw()}class Rectangle(val color: Color) : Figure() { override fun draw() { }}class Round(val color: Color) : Figure() { override fun draw() { }}class Triangle(val color: Color) : Figure() { override fun draw() { }}...... // 随着需求的增加，文件会越发庞大// 通过快捷键 Mac/Win/Linux：Alt + Enter 自动生成fun drawFigure(figure: Figure) { when (figure) { is Rectangle -&gt; TODO() is Round -&gt; TODO() is Triangle -&gt; when (figure.color) { is Color.Blue -&gt; TODO() is Color.Red -&gt; TODO() } }} 在 Kotlin 1.1 中被限制在一个文件中，随着需求的增加，文件只会越发的庞大，现在放宽了限制之后，我们可以将子类拆分成单独的文件，可以进一步的提高代码的可读性。 只允许顶级的 Sealed Classes 和它顶级的子类在同一个文件中，对于非顶级的 Sealed Classes，所有子类都应该在其内部声明，以下代码编译会失败 正如你所见 Sealed Classes 还是不够灵活，非顶级子类 Yellow 定在 Color 的外面，编译就会出错，而在 Koltin 1.5.0 放宽了限制之后，以上代码可以正常编译通过，不仅提高代码的可读性，而且灵活性也提高了。 除此之外还允许在 Sealed Classes 中声明受保护的构造函数。在 1.5.0 之前所有 Sealed Classes 的默认构造函数都是 private，但是在 1.5.0 之后默认构造函数都是 protected。 sealed class Figure { constructor() // 默认为 protected private constructor(area: Double) : this()} 但是不允许声明为 public，因为编译器会自动生成，如果声明为 public 编译就会出错： 一起来看看声明为 protected 的构造函数，反编译后的 Java 代码都做了什么。Tools → Kotlin → Show Kotlin Bytecode 。 public abstract class Figure { private Figure() { } private Figure(double area) { this(); } // $FF: synthetic method public Figure(DefaultConstructorMarker $constructor_marker) { this(); } // $FF: synthetic method public Figure(double area, DefaultConstructorMarker $constructor_marker) { this(area); }}public final class Rectangle extends Figure { public Rectangle() { super(1.0D, (DefaultConstructorMarker)null); }} 正如你所见，生成的构造方法还是私有的，只不过编译器会自动生成 公有 的构造方法，在子类的构造方法中调用了父类 公有 的构造方法。除此变化之外，另外还有一个重要的特性，增加了密封接口（Sealed Interface）。 注意： 如果你已经升级到 Kotlin 1.5.0，编译器还提示出错，请将下面的代码添加在 build.gradle 中。 compileKotlin { kotlinOptions { languageVersion = &quot;1.5&quot; }} Sealed InterfaceSealed Interface 和 Sealed Classes 一样都是用于表示受限制的类层次结构，所以它也拥有 Sealed Classes 所有的优点，Sealed Classes 拥有的特性 Sealed Interface 也都拥有。 但是不同之处在于 Sealed Classes 被限制在单个父类中，而 Sealed Interface 支持更灵活的受限制类层次结构，因为子类可以实现多个 Sealed Interface，如下所示。 // IColor.ktsealed interface IColorclass Red : IColorclass Blue : IColor// IArea.ktsealed interface IArea { fun area(): Double}// IFigure.ktsealed interface IFigureclass Round() : IFigure, IColorclass Rectangle(val length: Double, val width: Double) : IFigure, IArea, IColor { override fun area(): Double = length * width} Sealed Interface 允许子类有多个实现，自由度更高，使得代码更加的灵活，但是它和 Sealed Classes 一样，被限制在了同一个包名和 module 下面，如果违反这个限制编译就会出错。 关于 Sealed Interface 相关的内容，就先介绍到这里，这篇文章主要分析了 Sealed Classes 以及 Sealed Interface 优缺点，在 Kotlin 1.5.0 中还增加了其他的特性，将会在后续的文章中介绍。 全文到这里就结束了，如果有帮助 点个赞 就是对我最大的鼓励 代码不止，文章不停 欢迎关注公众号：ByteCode，持续分享最新的技术","link":"/2021/06/29/kotlin/09-kotlin-interface/"},{"title":"Kotlin 中的密封类 优于 带标签的类","text":"在之前的文章中我也分析过 Sealed Classes 原理，以及 Google 和很多开源项目为什么都在大量的使用它，如果你对 Sealed Classes 还不是很了解，可以前往查看 Kotlin Sealed 是什么？为什么 Google 都在用 主要内容如下： Sealed Classes 原理分析？ 枚举和抽象类都有那些局限性？ 为什么枚举可以作为单例？枚举作为单例有那些优点？ 分别在什么情况下使用枚举和 Sealed Classes？ Sealed Classes 究竟是什么？ 为什么 Sealed Classes 用于表示受限制的类层次结构？ 为什么说 Sealed Classes 是枚举类的扩展？ Sealed Classes 的子类可以表示不同状态的实例，那么在项目中如何使用？ 禁止在 Sealed Classes 所定义的文件外使用， Kotlin 是如何做到的呢？ 而今天这篇文章，我们主要从类层次结构来讨论一下 Sealed Classes（密封类） 和 Tagged Classes（标记类）的优缺点。在开始分析之前，我们先介绍一下什么是 Tagged Classes（标记类）以及都有那些缺点。 Tagged Classes 是什么在一个类中包含一个指示操作的标记字段或者特征，方便在它们之间切换的类称为 Tagged Classes（标记类），在 Effective Java 中也指出了 Tagged Classes 存在很多问题，这里引用 Effective Java Item 23 中的一个案例来分析 Tagged Classes 存在的问题，这里用 Kotlin 重写了。 class Figure( // 这个标签字段：用来表示图形的形状 val shape: Shape, // 这个字段用于圆形 val radius: Double = 0.0, // 这两个字段用于矩形 val length: Double = 0.0, val width: Double = 0.0) { // 定义了两个形状 矩形、圆形 enum class Shape { RECTANGLE, CIRCLE } // 计算当前图形的面积 fun area(): Double = when (shape) { Shape.RECTANGLE -&gt; length * width Shape.CIRCLE -&gt; Math.PI * (radius * radius) else -&gt; throw AssertionError(shape) } companion object { fun createRectangle(radius: Double) { Figure( shape = Shape.RECTANGLE, radius = radius ) } fun createCircle(length: Double, width: Double = 0.0) { Figure( shape = Shape.CIRCLE, length = length, width = width ) } }} 正如你所见，代码中包含了很多模板代码，包括标记字段、切换语句、枚举等等，在一个类中包含了很多不同的操作，如果以后增加新的操作，有需要增加新的标记，实际情况这样的代码在项目中非常的常见，主要存在以下几个问题： 增加了很多模板代码 内存是非常稀缺的资源，当我们创建圆形的时候，与它无关的字段也要保留，增加当前类所占用的内存 降低了代码的可读性，类中混合了很多操作例如枚举、切换语句等等，为了保证对象正确的创建，通常需要用到工厂模式等等设计模式​ 如果增加新的图形，不得不去修改原有的代码结构 …… 那么有没有很好的替换方案，可以解决以上所有的问题，而且还可以在不修改原有的代码结构基础上增加新的图形，这就需要用到类的层次结构。 类的层次结构无论是 Java 还是 Kotlin 我们都会使用类的层次结构代替标记类，而在 Kotlin 中我们常用 Sealed Classes 表示受限制的类层次结构, 在之前的文章 Kotlin Sealed 是什么？ 中已经详细分析过 Sealed Classes。接下来一起来看一下如何使用 Sealed Classes 优化上面的代码。 sealed class Figure { abstract fun area(): Double class Rectangle(val length: Double, val width: Double) : Figure() { override fun area(): Double = length * width } class Circle(val radius: Double) : Figure() { override fun area(): Double = Math.PI * (radius * radius) }} 正如你所见，代码简洁干净了很多，不包含模板代码，并且类之间的职责分明，提高了代码的灵活性，完美的解决了上述所有的缺点。每个类中不包含无关的字段，同时在类中添加新的参数，并不会影响其他类。 如果我们需要增加新的图形，只需要新增加一个类即可，并不会破坏原有的代码结构，例如这里我们增加一个球形。 class Ball(val radius: Double) : Figure() { override fun area(): Double = 4.0 * Math.PI * Math.pow(radius, 2.0)} 不仅仅如此，Sealed Classes 结合 when 表达式一起使用会更加的方便，when 语句下的所有分支可以通过快捷键 Mac/Win/Linux：Alt + Enter 自动生成，如下所示。 fun Figure.Valida() { when (this) { is Figure.Ball -&gt; { println(&quot;I am Ball&quot;) area() } is Figure.Circle -&gt; { println(&quot;I am Circle&quot;) area() } is Figure.Rectangle -&gt; { println(&quot;I am Rectangle&quot;) area() } }} 在 Effective Java 中也说明了 Tagged classes（标记类）很少有适合的场景，但是往往在开发过程中，为了快速的开发一个功能，往往会忽略它所带来的影响，但是我们在做优化的时候，遇到这种 Tagged classes 是否可以考虑使用类的层次结构来代替，如果是 Kotlin 建议使用 Sealed Classes。 参考文章 Effective Java Item 23: Prefer class hierarchies to tagged classes Effective Kotlin Item 40: Prefer class hierarchies to tagged classes 全文到这里就结束了，如果有帮助 点个赞 就是对我最大的鼓励 代码不止，文章不停 欢迎关注公众号：ByteCode，持续分享最新的技术","link":"/2021/06/26/kotlin/08-kotlin-Sealed-Tagged/"},{"title":"LeetCode 从 0 到 200 学到了什么","text":"LeetCode 不知不觉刷了 210 题，总提交次数 1069 次，想写一篇文章，跟大家聊聊 LeetCode 刷题感受以及经验，主要包含以下内容。 LeetCode 刷题历程？ 为什么刷题？ 刷题真的能找到工作吗？ 如何刷题？ 平时除了刷 LeetCode，同时也会做 Daily Coding Problem 上面的题目，Daily Coding Problem 包含了很多国外大厂（Google、FaceBook、Uber、Amazon 等等）的算法题，我也在刷题过程中梳理了一些题目和题解，为了方便查看，我用 docsify 工具整理了这些题解。其中包含了 LeetCode / 剑指 Offer / 多线程 / 国内外大厂算法题，后期我会用图解算法的方式，重写这些内容。 剑指 Offer 及国内外大厂面试题解：在线阅读 LeetCode 系列题解：在线阅读 刷题历程数据结构和算法现在已经是每个程序员必须掌握的基础技能之一了，也是面试的入门门槛之一，无论是外企，还是国内的企业，算法已经成为了必问的问题，我相信有很多朋友跟我一样刚开始刷 LeetCode 都是为了面试做准备。 我第一次刷 LeetCode 是在 3 年前，如下图所示，这是我第一次的提交记录 当时我使用的国际版，主要有两个目的，其一是学习英语，其二是为了面试做准备，所以断断续续的开始刷题。 2020 年开始从国际版切换到国内版，因为国内版本做的越来越好了，题库也更加完善，除了基本的算法、数据库、Shell、多线程之外，还有程序员面试宝典、剑指 offer 等等系列题目。而且还有一个选项 「题目以中文显示」或者「题目以英文显示」，完全满足我个人在刷题过程中同时也可以学习英语需求。以下图所示是我 2020 年 LeetCode 上的年度报告。 Google 这几年一直在强力推荐 Kotlin，自从用了 Kotlin 了之后爱不释手，工作效率提高了很多，所以我在刷 LeetCode 会分别使用 Java、Kotlin 两种语言，目前我也在重拾 C 语言。 2020 年是我突飞猛进的一年，也是我刷题最多的一年，以下是我 2020 年 LeetCode 年度报告的提交记录。 LeetCode 年度报告功能真的很棒，不知不觉中 2020 年居然提交了 700 次，在这一年基本每周都会刷 1 ~ 3 题，每隔一段时间，会把之前刷过的题目在重新刷一遍。我做题的速度比较慢，重在掌握每一个知识点，LeetCode 上做的快的大半年能刷 400+、700+ 题目，可能它们的基础算法能力很强，所以刷题很快吧。 为什么刷题我最开始刷 LeetCode 和很多朋友一样都是为了面试做准备，因为有一次出去面试，我并没有准备任何算法，因为在大学的时候参加过一些算法类竞赛，还是有点算法基础的，所以我认为对于 Android 开发来说，算法不会很难，结果那次挂了。 自从那次经历之后就开始刷题了，等面试通过之后就断掉，中间偶尔会也会刷刷题，让我持续不断的刷题，意识到算法的重要性，是因为有次在做一个功能优化的时候，突然发现可以用之前刷过的一道算法题来提升它运行速度。 从那个时候我就意识到了算法的重要性，我们通常在开发一个功能的时候，因为时间短的原因，没有多余的时间去思考，很多地方都是暴利解法，先把功能先实现了，当开始做性能优化的时候，这部分功能，可以用高效的算法和数据结构去解决，从而提升它的运行速度。 因此从 2020 年开始持续不断的刷题，不在是为了面试而刷题，而是意识到它的重要性，一边刷题一边梳理知识点，然后不断重复的刷之前做过的题，当你在刷题的时候想到解法和官方最优解法相同的时候，心里有一种不言而喻的成就感，慢慢的不知不觉的就爱上了刷题，截止到现在为止我已经刷了 210 题，总提交次数 1069 次。 刷题真的能找到工作吗如果是国外的企业它们注重点在算法上，所以算法好能提高自己的通过率，但是对于国内企业，算法好不一定能通过，除了考察算法能力之外，还有专业的基础知识、系统源码、开源库的源码、数据结构设计、网络知识、做过的项目相关的知识等等。算法难度大部分都在 Medium，我也遇到过几个 Hard。总之一句话国内企业招人，要招全才，方方面面不仅要会而且还要知道其原理。 分享一下我印象中遇到过的算法题： 最长不含重复字符的子字符串 直线上最多的点数 K 个一组翻转链表 最长回文子串 柱状图中最大的矩形 数组中的第K个最大元素 多线程：实现奇数和偶数顺序打印 复杂链表的复制 调整数组顺序使奇数位于偶数前面，且保持相对顺序不变 从含有重复数字的排序数组中输出重复数字的下标 扑克牌中的顺子 圆圈中最后剩下的数字 二叉树中和为某一值的路径 反转从位置 left 到位置 right 的链表节点 删除链表的倒数第 N 个结点 仅含 1 的子串数 二叉树最长路径 实现生产者在和消费者 最少移动次数使数组元素相等 从数组中找出两个出现一次的数，其他数出现了两次 …… 如何刷题我刚开始刷题的时候也遇到过这个问题，LeetCode 题库非常庞大，如何开始刷题，正在我比较疑惑的时候，看到 K 神的经验心得 扬帆，起航，我猜刷过题的朋友 95% 的小伙们都应该看过 K 神的题解，在这里感谢 K 神的付出。 正因为 K 神分享的这篇文章，让我开始刷 「剑指 Offer」 系列题目，目前已经用 Java 语言将 「剑指 Offer」系列题目全部刷了一遍，现在我正打算使用其他语言在刷一遍，同时也会将题目和题解整理起来，后续会持续分享。「剑指 Offer」 部分截图如下所示。 如果对 数组、字符串、栈、队列、链表、树、深度优先遍历、广度优先遍历、查找算法等等比较了解的朋友，可以直接刷 「剑指 Offer」系列题目。 但是如果你对上述算法不是很了解，建议先从 「LeeeCode 首页」-&gt; 「导航条：学习」-&gt; 「筛选 常用数据结构」 开始学起，如下图所示。 里面的题目都是一些基础题，LeetCode 上还有很多数据结构的电子书，小伙伴们可以从中找自己想学习的内容，一点一点的开始学习，日积月累，刷题不在于你刷多少题，而在于你是否掌握每一个知识点。恰恰这些基础知识点，在实际项目中、源码中都非常的常见，强烈建议一定要掌握。 当你对 数组、字符串、栈、队列、链表、树、深度优先遍历、广度优先遍历、查找算法等等都很了解了，就可以开始刷 「剑指 Offer」系列题目。 如果「剑指 Offer」刷完之后，就可以开始做「设计」相关的题目，可以从「标签分类」 中找到 「设计」的标签， 查看所有和 「设计」 相关的题目。 设计这个标签里，梳理了实际问题的场景，需要我们用已经学习过的数据结构组装成一个新的，适用于当前问题场景的数据结构。例如 LRU 缓存机制、设计链表（单链表、双向链表）、设计循环队列 等等。 当基础的算法掌握之后，不要只刷一种类型的题目，不同类型的题目互相刷，例如做几道 「设计」 相关的题目， 然后可以切换到做「多线程」 相关的题目或者其他类型题目。以下是我刷 「多线程」相关的题目截图。 总结现在 LeetCode 平台资源越来越完善了，包含了 设计模式、算法、数据结构、多线程、程序设计等等很多资源，已经成为了我每天必登陆的一个网站，但是 LeetCode 题库非常庞大，每个分类都能筛选出很多题目，我结合着网友的分享和自己刷题过程中的总结，按照算法及数据结构的类型去分类，如下图所示，小伙伴们可以按照我的分类，前期列出自己的计划按照每个知识点去刷题，在这个过程中不断总结和回顾找到一个适合自己的方式。 剑指 Offer 及国内外大厂面试题解：在线阅读 LeetCode 系列题解：在线阅读 LeetCode 不仅助力了很多人拿到了大厂的 Offer，同时也学习到了很多国内外大神的思路，而且还可以和很多同学一起探讨，也有很多非常有意思的评论，让刷题的过程变得不在那么枯燥，LeetCode 见证了我们成长的步伐。当你经历了无数个枯燥泛味的夜晚，最终会收获自己想要的结果。希望本文能给小伙伴们带来一些帮助。 全文到这里就结束了，如果有帮助 点个赞 就是对我最大的鼓励 代码不止，文章不停 欢迎关注公众号：ByteCode，持续分享最新的技术","link":"/2021/06/12/Note/leetcode-0-200/"},{"title":"开篇，初识 Compose，永久激活 IntelliJ IDEA","text":"Jetpack Compose 是 Android UI 的现代工具包，简化了 Android 上 UI 的开发。你无需编辑任何 XML 布局，使用声明性函数即可构建一个简单的 UI 组件，UI 构建工作将由 Compose 编译器完成。通过更少的代码、强大的工具和直观的 Kotlin api，加速 Android 上 UI 的开发——来自官网。 Compose 是用 Kotlin 编写的 UI 工具包，JetBrains 基于 Google 提供的 Compose 开发了 Compose for Desktop 简化了桌面应用程序 UI 的开发，因此 Android 和 桌面应用程序之间大部分 UI 代码是共享的。也就是说在 Android 上使用的部分 UI 组件，同样也适用于桌面应用程序 UI 开发，降低了学习成本，在后文中会有详细的演示案例。 在 Compose for Desktop 之前也提供了 JavaFX 、Java Swing 等等，都是为 Java 设计的 UI 工具包。 之前我用 JavaFX 开发过 Win 和 Mac 桌面应用程序，最近我也打算用 Compose for Desktop 重写之前开发的桌面应用程序，后面会出一系列文章。 如何将程序打包成可安装的桌面应用程序，提供给使用者在 Win、Mac 上进行安装，因为篇幅限制，会在后续的文章中介绍。 通过这篇文章你将学习到以下内容： 使用破解补丁无限制的使用 IntelliJ IDEA 破解补丁源码分析 Compose for Desktop or Android 应用程序所需的环境配置 如何配置多个不同版本的 JDK Compose for Desktop or Android 示例 环境使用 Compose for Desktop 开发桌面应用程序，需要如下工具： IntelliJ.IDEA-2020.3 以上 JDK 11 以上 Kotlin 1.4.2 以上 如果你的电脑上安装的是低版本的 JDK，我不建议你贸然升级到最新版本，因为你之前很多项目都是基于当前 JDK 版本进行开发的，而且有一些软件只在低版本的 JDK 上才能运行，例如 JD-GUI，所以可以在电脑上安装多个 JDK，例如开发 Compose for Desktop 使用 JDK 11，开发 Android 项目使用 JDK 8。 IntelliJ IDEA 开发工具是收费的，而且价格相对而言挺贵的，如果资金允许的前提下，可以前去购买，在本文中也会提供破解补丁，永久激活 IntelliJ IDEA。 我已经将 JDK 11 、IntelliJ.IDEA-(2020.3 ~ 2021.1) 以及 IntelliJ.IDEA 破解补丁已经上传到网盘上，可以 「关注下方公众号」或者「搜索关注公众号：ByteCode」，回复关键词：compose，即可获取所有软件。 如何配置多个 JDK这一小节中将会介绍如何在 MAC 上安装多个 JDK（PS: win 配置方式网上有很多教程，可自行搜索）： 首先从 Oracle 官网下载并安装 JDK 11 也可以在公众号内，回复关键词：compose，即可获取 我们自己安装的 JDK 默认存放在 /Library/Java/JavaVirtualMachines/ 目录下。 在命令行中输入 vi ~/.bash_profile 打开 bash_profile 文件 在 bash_profile 文件中配置不同版本 JDK 的路径 export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Homeexport JAVA_11_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.11.jdk/Contents/Homeexport JAVA_16_HOME=/Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home 在 bash_profile 文件中添加下面命令，用于切换不同 JDK 版本 alias jdk8='export JAVA_HOME=$JAVA_8_HOME'alias jdk11='export JAVA_HOME=$JAVA_11_HOME'alias jdk16='export JAVA_HOME=$JAVA_16_HOME' 验证是否配置成功 使用别名 alias jdk8 切换到 JDK 8 ，然后输入 java -version 获取当前 JDK 的版本。 localhost:~ $ jdk8localhost:~ $localhost:~ $ java -versionjava version &quot;1.8.0_51&quot;Java(TM) SE Runtime Environment (build 1.8.0_51-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode) 切换到其他 JDK 版本同样如此。 高版本的 JDK 造成很多软件无法正常运行 如果我们安装了高版本的 JDK ，即使电脑上有低版本的 JDK，还是会造成很多软件无法正常运行，例如 JD-GUI，所以我们需要修改一下系统默认的 JDK，查看 JD-GUI 执行脚本可知，在 Mac OS 上都是通过下面的命令来获取系统默认的版本。 /usr/libexec/java_home 系统默认的排序是根据 JDK 的版本从高到低进行排序的，所以通过上面的命令获取到的是最高版本的 JDK，可以通过下面的命令查看 JDK 的排序。 /usr/libexec/java_home -V 执行结果如下所示： Matching Java Virtual Machines (2): 16.0.1, x86_64: &quot;Java SE 16.0.1&quot; /Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home 11.0.11, x86_64: &quot;Java SE 11.0.11&quot; /Library/Java/JavaVirtualMachines/jdk-11.0.11.jdk/Contents/Home 1.8.0_51, x86_64: &quot;Java SE 8&quot; /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home 默认的话使用第一条作为系统默认的 JDK，如果我们想设置 JDK 8 作为默认系统的 JDK，可以修改 Info.plist 文件 JVMVersion 的版本号来调整它的顺序，将 JDK 8 放在第一条，将 JDK 11 和 JDK 16 放在最底下，达到修改默认 JDK 的目的，JDK 11 和 JDK 16 的 Info.plist 文件路径如下所示： /Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home/Info.plist/Library/Java/JavaVirtualMachines/jdk-11.0.11.jdk/Contents/Home/Info.plist 只需要将 JDK 11 的 Info.plist 文件 JVMVersion 从 11.0.11 修改至 !11.0.11，JDK 16 的 Info.plist 文件 JVMVersion 从 16.0.1 修改至 !16.0.1，通过这种方式即可将高版本的 JDK 放在最底下，修改完成之后，执行上述命令 /usr/libexec/java_home -V 查看 JDK 的排序，结果如下所示： Matching Java Virtual Machines (2): 1.8.0_51, x86_64: &quot;Java SE 8&quot; /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home !16.0.1, x86_64: &quot;Java SE 16.0.1&quot; /Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home !11.0.11, x86_64: &quot;Java SE 11.0.11&quot; /Library/Java/JavaVirtualMachines/jdk-11.0.11.jdk/Contents/Home 最后执行 /usr/libexec/java_home 命令，返回的就是你设置的低版本的 JDK，这样就可以解决高版本的 JDK 造成很多软件无法正常运行的问题。 IntelliJ.IDEA 破解补丁的使用在这一小节中将会介绍如何使用破解补丁永久激活 IntelliJ IDEA。感谢作者 pengzhile/ide-eval-resetter 提供的插件 IntelliJ IDEA 破解补丁，仅供个人学习使用, 请勿商用，建议购买正版 破解补丁适用于 IntelliJ IDEA 2020 ~ 2021.1 所有的版本，其他版本尚未尝试 破解教程适用于 Windows/Mac/Linux 系统 只需要五步即可永久使用 IntelliJ IDEA： 首先从 IDEA 官网下载 2021.1 版本并安装，也可以在公众号内，回复关键词：compose，即可获取 安装成功之后运行 IDEA 会弹出一个注册框，勾选 Evaluate for free , 点击 Evaluate, 之后随便创建一个新的项目即可 将破解补丁 ide-eval-resetter-2.1.6.zip 拖入 IDEA 界面中, 会弹出如下界面，点击 Restart 重启 IDEA 即可（PS：破解补丁放在固定位置，不要移动） 重启 IDEA，点击顶部菜单栏 Help，若列表中出现 Eval Reset 选项，则代表安装成功 点击顶部菜单栏 Help -&gt; Eval Reset，弹出如下界面，勾选 Auto reset before per restart，每次重启 IDE 会自动重置所有信息，你无需做额外的事情 验证是否永久激活 IntelliJ IDEA： 运行 IDEA，将系统时间修改到 30 天之后 点击顶部菜单栏 Help -&gt; Register 查看剩余时间 重启 IDEA，再次查看剩余时间，破解补丁会重置试用时间为 30 天 执行完以上步骤就，恭喜你现在可以开始使用 IDEA 开发桌面应用程序了。 破解补丁不仅适用于 IntelliJ IDEA，还适用于 Jetbrains 其他系列产品：AppCode 、 CLion 、 DataGrip 、GoLand 、PhpStorm 、PyCharm 、Rider 、RubyMine 、WebStorm。 以上是关于 Compose for Desktop 所需要的工具配置，Compose for Android 的环境配置非常的简单，从官网下载并安装 Android Studio 2020.3.1 Canary 14 然后在模板列表中选择 Empty Compose Activity ，等待 AS 构建完就可以开始使用了。 破解补丁分析 IntelliJ IDEA 是 Jetbrains 旗下的产品，Jetbrains 的产品会允许你试用 30 天，所以作者 pengzhile 写了一个插件，无限重置 30 天试用期，从而达到永久激活 IDEA 的目的。（PS: 如果 IntelliJ IDEA 版本有更新，千万不要升级）。 首次运行 IntelliJ IDEA 会弹出一个注册框，勾选 Evaluate for free , 点击 Evaluate 会在 /Users/用户名/Library/Application\\ Support/JetBrains/IntelliJIdea2021.1/eval/ 目录下生成 idea211.evaluation.key 文件，这个文件记录当前的时间戳，作者会读取当前文件内容，重新写入新的时间戳，重置 30 天试用期，核心源码如下：src/main/java/io/zhile/research/intellij/ier/ui/form/MainForm.java Resetter.reset(Resetter.getEvalRecords()); 调用 Resetter.getEvalRecords() 会遍历 /Users/用户名/Library/Application\\ Support/JetBrains/IntelliJIdea2021.1/ 文件夹下面的内容 调用 Resetter.reset() 方法，重新写入新的时间戳 接下里我们一起来看一下 Resetter.getEvalRecords() 方法的实现。 src/main/java/io/zhile/research/intellij/ier/common/Resetter.java protected static File getEvalDir() { String configPath = PathManager.getConfigPath(); return new File(configPath, &quot;eval&quot;);} public static List&lt;EvalRecord&gt; getEvalRecords() { List&lt;EvalRecord&gt; list = new ArrayList&lt;&gt;(); File evalDir = getEvalDir(); if (evalDir.exists()) { File[] files = evalDir.listFiles(); if (files == null) { NotificationHelper.showError(null, &quot;List eval license file failed!&quot;); } else { for (File file : files) { if (!file.getName().endsWith(&quot;.key&quot;)) { continue; } list.add(new LicenseFileRecord(file)); } } } ....... 调用 getEvalRecords() 方法获取 /Users/用户名/Library/Application\\ Support/JetBrains/IntelliJIdea2021.1/eval/ 文件夹下以 .key 结尾的文件，然后重写里面的时间戳。src/main/java/io/zhile/research/intellij/ier/common/LicenseFileRecord.java public void reset() throws Exception { if (!FileUtil.delete(file)) { throw new Exception(&quot;Remove &quot; + type + &quot; failed: &quot; + file.getAbsolutePath()); } try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) { dos.writeLong(~System.currentTimeMillis()); }} Compose for Android or Desktop 示例在文章开头讲述了，Compose 是由 Kotlin 开发的 UI 工具包，Android 和 桌面应用程序之间大部分 UI 代码是共享的，也就是说在 Android 上使用的部分 UI 组件，同样也适用于桌面应用程序开发。如下图所示。 如上图所示 「创建 Button」核心的代码都是一样的， 如果你之前没有了解过 Compose， 上面的代码可能觉得很陌生，可以先忽略，只需要知道 Android 和 桌面应用程序之间大部分 UI 代码是共享的即可。 参考文章 https://developer.android.google.cn/jetpack/compose/setup https://gitee.com/pengzhile/ide-eval-resetter 全文到这里就结束了，如果有帮助 点个赞 就是对我最大的鼓励 代码不止，文章不停 欢迎关注公众号：ByteCode，持续分享最新的技术 推荐文章： 为数不多的人知道的 Kotlin 技巧以及 原理解析（一） 为数不多的人知道的 Kotlin 技巧以及 原理解析（二） Jetpack 最新成员 AndroidX App Startup 实践以及原理分析 Jetpack 成员 Paging3 实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack成员Paging3获取网络分页数据并更新到数据库中（三） Jetpack 成员 Hilt 实践（一）启程过坑记 Jetpack 成员 Hilt 结合 App Startup（二）进阶篇）进阶篇 Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇 全方面分析 Hilt 和 Koin 性能 神奇宝贝(PokemonGo) 眼前一亮的 Jetpack + MVVM 极简实战 Kotlin Sealed 是什么？为什么 Google 都用 Kotlin StateFlow 搜索功能的实践 DB + NetWork 再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度 [Google] 再见 SharedPreferences 拥抱 Jetpack DataStore Kotlin 插件的落幕，ViewBinding 的崛起 竟然如此简单，DataBinding 和 ViewBinding 图解多平台 AndroidStudio 技巧(三) Android 12 行为变更，对应用产生的影响","link":"/2021/05/09/jetpack/13-compose/"},{"title":"Android 12 行为变更，对应用产生的影响","text":"众所周知在春节过后 Google 发布了 「 Android 12 首个开发者预览版 」，3 月份的时候发布了 「 开发者预览版 2 」，在 Android 12 中让人眼前一亮的是系统界面做了很大改动，根据 Google 今年的发版计划，预计在今年 9 月份正式版将会发出来。 在 Android 12 中包含了很多的功能和一些行为的变更，接下来我们一起来分析这些行为的变更对我们的应用产生了那些影响以及 Google 为什么需要这么做。 通过这篇文章你将学习到以下内容： 为什么 Google 需要开发者显示声明 android:exported 属性？ 为什么 Google 需要开发者显示指定 PendingIntent 的可变性？ Google 为什么限制 adb 备份的默认行为？ 如何检查 App 的安全漏洞？ PS ：文章中分析 Google 为什么需要做此行为的变更，纯属个人根据一些案例来分析，如果你遇到过其他安全性问题欢迎留言一起讨论。 android:exported 属性在 Android 12 中包含 &lt;intent-filter&gt; 的 activity 、 service 或 receiver 必须为这些应用组件显示声明 android:exported 属性，如下所示： &lt;activity android:name=&quot;.TestActivity&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; ...... &lt;/intent-filter&gt;&lt;/activity&gt; 如果在包含 &lt;intent-filter&gt; 的 activity 、 service 或 receiver 组件中，没有显示声明 android:exported 的值，你的应用将无法安装，错误日志如下所示。 Installation did not succeed.The application could not be installed: INSTALL_FAILED_VERIFICATION_FAILUREList of apks:[0] '.../build/outputs/apk/debug/app-debug.apk'Installation failed due to: 'null' 如果您的应用在需要声明 android:exported 的值时未进行此声明，错误日志如下所示。 Targeting S+ (version 10000 and above) requires that an explicit value for \\android:exported be defined when intent filters are present 如果对上面的异常产生的条件，不是很理解，可以点击下方链接查看，目前已经有很多开源项目都已经开始适配这个行为的变更了，例如 leakcanary 等等，详情前往查看下列地址： Update launcher activity attribute to Android 12 Declared android:exported explicitly for components with intent-filter. Android 12 requirement 这个行为的变更无论是对库开发者 和 还是应用开发者、或者是开源项目影响都非常大。 为什么 Google 需要开发者显示声明 android:exported 属性 android:exported 属性的默认值取决于是否包含 &lt;intent-filter&gt;，如果包含 &lt;intent-filter&gt; 那么默认值为 true，否则 false。 当 android:exported=&quot;true&quot; 时，如果不做任何处理，可以接受来自其他 App 的访问 当 android:exported=&quot;false&quot; 时，限制为只接受来自同一个 App 或一个具有相同 user ID 的 App 的访问 正因为 android:exported 的属性的默认值的问题，Twicca App 发生过一次安全性问题，因为另一个没有访问 SD 卡或网络权限的 App，可以通过 Twicca App 将存储在 SD 卡上的图片或电影上传到 Twicca 用户的 Twitter 账户上的社交网络上。 产生问题的代码如下所示： &lt;activity android:configChanges=&quot;keyboard|keyboardHidden|orientation&quot; android:name=&quot;.media.yfrog.YfrogUploadDialog&quot; android:theme=&quot;@style/Vulnerable.Dialog&quot; android:windowSoftInputMode=&quot;stateAlwaysHidden&quot;&gt; &lt;intent-filter android:icon=&quot;@drawable/yfrog_icon&quot; android:label=&quot;@string/YFROG&quot;&gt; &lt;action android:name=&quot;jp.co.vulnerable.ACTION_UPLOAD&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;image/*&quot; /&gt; &lt;data android:mimeType=&quot;video/*&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 因为添加了 intent-filter 所以 android:exported 的属性的默认值为 true，因此可以接受来自其他 App 的访问，进而造成了上述问题（通过 Twicca App 将存储在 SD 卡上的图片或电影上传到 Twicca 用户的 Twitter 账户上的社交网络上），而解决方案有两个： 方案一：添加 android:exported=&quot;false&quot; 属性 &lt;activity android:exported=&quot;false&quot; android:configChanges=&quot;keyboard|keyboardHidden|orientation&quot; android:name=&quot;.media.yfrog.YfrogUploadDialog&quot; android:theme=&quot;@style/ VulnerableTheme.Dialog&quot; android:windowSoftInputMode=&quot;stateAlwaysHidden&quot; &gt; &lt;/activity&gt; 方案二： Twicca App 没有使用方式一，而是检查调用者的包名是否与自身的包名相同 public void onCreate(Bundle arg5) { super.onCreate(arg5); ... ComponentName v0 = this.getCallingActivity(); if(v0 == null) { this.finish(); } else if(!jp.r246.twicca.equals(v0.getPackageName())) { this.finish(); } else { this.a = this.getIntent().getData(); if(this.a == null) { this.finish(); } ... } }} 这种方案也是可行的，因为在一台设备上，不可能会出现两个包名相同的应用，更多详细的信息可以前往查看 Restrict access to sensitive activities。 这仅仅是关于 activity 的安全漏洞的其中一个，在不同的场景下利用这些漏洞做的事情也可能不一样。当然还有 service 和 receiver 组件也都是一样，存在安全性问题。 指定 PendingIntent 的可变性在 Android 12 中创建 PendingIntent 的时候，需要显示的声明是否可变，请分别使用 PendingIntent.FLAG_MUTABLE 或 PendingIntent.FLAG_IMMUTABLE 标志，如果您的应用试图在不设置任何可变标志的情况下创建 PendingIntent 对象，系统会抛出 IllegalArgumentException 异常，错误日志如下所示： PACKAGE_NAME: Targeting S+ (version 10000 and above) requires that one of \\FLAG_IMMUTABLE or FLAG_MUTABLE be specified when creating a PendingIntent.Strongly consider using FLAG_IMMUTABLE, only use FLAG_MUTABLE if \\some functionality depends on the PendingIntent being mutable, e.g. if \\it needs to be used with inline replies or bubbles. 为什么 Google 需要开发者显示的指定 PendingIntent 的可变性? 在 Adnroid 12 之前，默认创建一个 PendingIntent 它是可变的，因此其他恶意应用程序可能会拦截，重定向或修改此 Intent。（但是是有条件限制的） 一个 PendingIntent 是一个可以给另一个应用程序使用的 Intent，PendingIntent 接收待处理意图的应用程序可以使用与产生待处理意图的应用程序相同的权限和身份执行待处理意图中指定的操作。 因此，创建待处理意图时必须小心，为了安全性 Google 在 Android 12 中需要开发者自己来指定 PendingIntent 的可变性。 更多关于 PendingIntent 安全性介绍，可以前往查看 Always pass explicit intents to a PendingIntent adb 备份限制Android 开发者都应该知道这个命令 adb backup , 它可以备份应用的数据，在 Android 12 中，为了保护私有应用数据，用户运行 adb backup 命令时，从设备导出的任何其他系统数据都不包含应用数据。 如果你在测试和开发过程中需要使用 adb backup 来备份应用数据，你可以在 AndroidManifest 中将 android:debuggable 设置为 true 来导出应用数据。 &lt;application android:name=&quot;.App&quot; android:debuggable=&quot;true&quot; ....../&gt; 注意：在发布应用前将 android:debuggable 设置为 false 为什么 Google 在 Android 12 限制了 adb backup 命令的默认行为 因为这个存在严重的安全问题，当初 Google 为了提供 App 数据备份和恢复功能，可以在 AndroidManifest 中添加 android:allowBackup 属性，默认值为 true, 当你创建一个应用的时候，会默认添加这个属性，如下所示： &lt;application android:name=&quot;.App&quot; android:allowBackup=&quot;true&quot; ....../&gt; 当 android:allowBackup=&quot;true&quot; 时，用户可以通过 adb backup 和 adb restore 命令对应用数据进行备份和恢复，也就是说可以在其他的 Android 手机上安装同一个应用，通过如上命令恢复用户的数据。 为了安全起见，我们在发布出去的 Apk 中一定要将 android:allowBackup 属性设置为 false 来关闭应用程序的备份和恢复功能，以免造成信息泄露。国民级应用 XX 信, 在曾今发出的版本中 allowBackup 的属性值是 true，被其他逆向开发者利用之后，现在的版本中这个值已经修改为 false了，有兴趣的小伙们可以反编译看看。 如何检查 App 的安全漏洞在这里推荐一个开源项目 linkedin/qark 这是由 LinkedIn 开源的项目，这个工具被设计用来寻找与安全相关的 Android 应用程序漏洞，无论是源代码还是打包的 APK，具体的用法文档上写的非常的清楚了，这里不做详细的介绍了。 这个开源项目的检查结果，作为参考即可。当然也有很多公司花了重金去购买第三方的服务来检查 App 的安全漏洞。 在 Android 12 上这几个行为的变更它们都有一个共性：安全性，可见 Google 这几年在安全上做了很多的努力，当然还有其他的一些行为的变更，可以前往查看 行为变更：以 Android 12 为目标平台的应用 开发中 App 安全的注意事项 从 Google 在 Android 12 上的安全行为变更来看，Google 应该收到了很多安全漏洞的案例，是通过这几个基本组件来进行的，要不然也不会做此重要的改变（纯属个人看法）。 在很早之前，看到过一篇文章 谈谈 Android 下 App 的安全性问题，这篇文章包含：activity 、 service 、 Broadcast 、 webview 、 Content Provider 开发中的一些注意事项和安全编码建议，以及一些测试方法，找了很久才找到，有兴趣的小伙们可以前往查看，这里就不详细列出来了，原文有更加详细的介绍。 参考文章 行为变更：以 Android 12 为目标平台的应用 Update launcher activity attribute to Android 12 Declared android:exported explicitly for components with intent-filter. Android 12 requirement confluence 结语这篇文章主要介绍了在 Android 12 上行为的变更，对 App 都有些影响，以及这些行为在 App 中都有那些安全漏洞，我们在开发中应该如何注意这些潜在的问题。 全文到这里就结束了，如果有帮助 点个赞 就是对我最大的鼓励 代码不止，文章不停 欢迎关注公众号：ByteCode，持续分享最新的技术 推荐文章： 为数不多的人知道的 Kotlin 技巧以及 原理解析（一） 为数不多的人知道的 Kotlin 技巧以及 原理解析（二） Jetpack 最新成员 AndroidX App Startup 实践以及原理分析 Jetpack 成员 Paging3 实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack成员Paging3获取网络分页数据并更新到数据库中（三） Jetpack 成员 Hilt 实践（一）启程过坑记 Jetpack 成员 Hilt 结合 App Startup（二）进阶篇）进阶篇 Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇 全方面分析 Hilt 和 Koin 性能 神奇宝贝(PokemonGo) 眼前一亮的 Jetpack + MVVM 极简实战 Kotlin Sealed 是什么？为什么 Google 都用 Kotlin StateFlow 搜索功能的实践 DB + NetWork 再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度 [Google] 再见 SharedPreferences 拥抱 Jetpack DataStore Kotlin 插件的落幕，ViewBinding 的崛起 竟然如此简单，DataBinding 和 ViewBinding 图解多平台 AndroidStudio 技巧(三)","link":"/2021/04/17/android/06-andrid12-change/"},{"title":"图解多平台 AndroidStudio 技巧(三)","text":"好的 idea 能提高我们的工作效率，如果掌握一些快捷键，能帮我们从繁琐重复的工作中解放出来，写代码的效率就越高。 近期在开发过程中发现了一些非常好用的快捷键分享给小伙伴们，在之前的文章中我也分享过一些常用的快捷键，可以点击下列链接前往查看。 图解多平台 AndroidStudio 技巧(一) 图解多平台 AndroidStudio 技巧(二) 文章中没有奇淫技巧，都是一些在实际开发中、阅读源码的时候常用的快捷键，强烈建议收藏。 软件环境: Mac/Win/Linux: 内置默认快捷键 AndroidStudio V4.1.2 不同的外接键盘使用下列快捷键，需要根据自己的键盘做相应的调整 批量修改这是一个非常好用的功能，在开发过程中可能会遇到批量修改某个相同的字符串，这个快捷键可以让你的效率提高 N 倍。 Mac: Ctrl + G Win/Linux: Alt + Ｊ when 快捷键Sealed Classes 用于表示受限制的类层次结构，其实这句话可以拆成两句话来理解。 Sealed Classes 用于表示层级关系： 子类可以是任意的类， 数据类、Kotlin 对象、普通的类，甚至也可以是另一个 Sealed Sealed Classes 受限制： 必须在同一文件中，或者在 Sealed Classes 类的内部中使用，在Kotlin 1.1 之前，规则更加严格，子类只能在 Sealed Classes 类的内部中使用 Sealed Classes 通常和 when 表达式一起使用，接下来我们来看一段示例。 sealed class Color { class Red(val value: Int) : Color() class Green(val value: Int) : Color() class Blue(val name: String) : Color()}fun isInstance(color: Color) { when (color) { is Color.Red -&gt; TODO() is Color.Green -&gt; TODO() is Color.Blue -&gt; TODO() }} 如果我们手写 when 表达式，开发效率是非常低效的，所以在这里推荐大家一个快捷键，可以补全 when 语句下的所有分支，效果如下所示： Mac: Option + enter（回车键） Win/Linux: Alt + enter（回车键） 在布局文件之间轻松跳转在开发过程中经常需要在 Activity / Fragment / Adapter / Dialog 与之关联的布局文件之间跳转，常用的两种方式： 方式一： 点击图中所示图标，跳转到相对应的布局文件 方式二： 使用快捷键跳转，效果如下所示 Mac: Ctrl + Cmd + Up（向上箭头） Win/Linux: Ctrl + Alt + Home 转换为 DataBinding随着 Google 废弃 kotlin-android-extensions 插件消息出来之后，已经越来越多的小伙伴开始使用 ViewBinding 和 DataBinding，接下来介绍一个快捷键将布局文件转换为 data binding layout。 Mac: Option + enter（回车键） Win/Linux: Alt + enter（回车键） 书签我们经常在开发过程中或者阅读代码的时候，需要在不同的类中进行跳转，只需要在某处打个书签，很方便跳转回原处，这是一个非常实用的功能，快来试试吧。 增加/删除书签： Mac: Fn + F3 Win/Linux: F11 增加/删除书签（同时打上标记）： Mac: Fn + Option + F3 Win/Linux: Ctrl + F11 查看所有书签，并跳转回原处 Mac: Fn + Cmd + F3 Win/Linux: Shift + F11 隐藏面板隐藏面板功能就是让编辑器充满整个界面，节省空间，可以更专注于敲代码。 Mac: Cmd +Shift + F12 Win/Linux: Ctrl + Shift + F12 汇总为了方便查看将上面的快捷键做一个汇总。 说明 快捷键 批量修改 Mac: Mac: Ctrl + G Win/Linux: Alt + Ｊ when 快捷键 Mac: Option + enter Win/Linux: Alt + enter 在布局文件之间轻松跳转 Mac: Ctrl + Cmd + Up Win/Linux: Ctrl + Alt + Home 转换为 DataBinding Mac: Option + enter Win/Linux: Alt + enter 增加/删除书签 Mac: Fn + F3 Win/Linux: F11 增加/删除书签（同时打上标记） Mac: Fn + Option + F3 Win/Linux: Ctrl + F11 查看所有书签 Mac: Fn + Cmd + F3 Win/Linux: Shift + F11 隐藏面板 Mac: Cmd +Shift + F12 Win/Linux: Ctrl + Shift + F12 AndroidStudio 是非常好用且强大的工具，还有很多快捷键等着我们一起来探索，这是 图解多平台 AndroidStudio 技巧系列第三篇，未来还会继续分享更多实用技巧，相同的快捷键，在不同的场景下有不同的用法，也欢迎你来分享更多好用的技巧，想了解更多快捷键，前往查看 Google 官方文档。","link":"/2021/01/26/AndroidStudio/04-androidstuido-3/"},{"title":"竟然如此简单，DataBinding 和 ViewBinding","text":"前言首先祝小伙伴们新年快乐，2020 一个不平凡的一年，2021 是你我新的起点。 2021 新签名：代码不止，文章不停。 2021 第一篇文章是对 2020 年末最后一篇文章 Kotlin 插件的落幕，ViewBinding 的崛起 的一个补充。 在之前的文章 Kotlin 插件的落幕，ViewBinding 的崛起 中介绍了 Google 为什么不建议在项目中使用 Kotlin 合成方法（Synthetic 视图）， Google 建议使用 ViewBinding 替换 Kotlin 合成方法，那么 ViewBinding 和 DataBinding 都有什么区别。 ViewBinding： 仅仅支持绑定 View 不需要在布局文件中添加 layout 标签 需要在模块级 build.gradle 文件中添加 viewBinding = true 即可使用 效率高于 DataBinding，因为避免了与数据绑定相关的开销和性能问题 相比于 kotlin-android-extensions 插件避免了空异常 DataBinding： 包含了 ViewBinding 所有的功能 需要在模块级 build.gradle 文件内添加 dataBinding = true 并且需要在布局文件中添加 layout 标签才可以使用 支持 data 和 view 双向绑定 效率低于 ViewBinding，因为注释处理器会影响数据绑定的构建时间。 ViewBinding 可以实现的， DataBinding 都可以实现，但是 DataBinding 的性能低于 ViewBinding，DataBinding 和 ViewBinding 会为每个 XML 文件生成绑定类。 R.layout.activity_main -&gt; ActivityMainBindingR.layout.fragment_main -&gt; FragmentMainBindingR.layout.dialog_app -&gt; DialogAppBinding 在 Kotlin 插件的落幕，ViewBinding 的崛起 文章中同时也分析了 Kotlin 合成方法所带来的问题。即使 Kotlin 合成方法有很多问题，但是还有小伙伴愿意使用。 ViewBinding 和 DataBinding 为我们解决了这么多问题，但是为什么很多小伙伴们不愿意使用 ViewBinding 和 DataBinding，今天我们从使用的角度来分析。 ViewBinding 和 DataBinding我大概汇总了 ViewBinding 和 DataBinding 在不同场景的所有用法，我们来看一下在项目中如何使用。 基本配置 从 Android Studio 3.6 版本开始，就内置在 Gradle 插件中了，不需要添加任何额外的库来使用它们，但是在 Android Studio 3.6 和 Android Studio 4.0 中使用方式不一样。 // Android Studio 3.6android { viewBinding { enabled = true } dataBinding{ enabled = true }}// Android Studio 4.0android { buildFeatures { dataBinding = true viewBinding = true }} ViewBinding 的使用因为涉及到的场景比较多，为了减少篇幅，我只列出来核心部分，如果之前从来没有用过，这里只需要知道 ViewBinding 的门槛比 Kotlin 合成方法要高即可。 不想为某个布局生成 binding 类，将下面属性添加到布局文件的根视图中 &lt;LinearLayout tools:viewBindingIgnore=&quot;true&quot; &gt;&lt;/LinearLayout&gt; 在 Activity 中使用 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding: ActivityMainBinding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root)} 在 Fragment 中使用 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View { val binding = FragmentViewBindBinding.inflate(inflater,container,false) return binding.root} 在 Adapter 中的使用 override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { RecycleItemProductBinding.inflate(LayoutInflater.from(parent.context), parent, false)} 在 Dialog 中使用 override fun onCreate(savedInstanceState: Bundle?) { binding = DialogAppBinding.inflate(layoutInflater) setContentView(binding.root)} include 标签的使用 include 标签不带 merge 标签，需要给 include 标签添加 id, 直接使用 id 即可，用法如下所示。 &lt;include android:id=&quot;@+id/include&quot; layout=&quot;@layout/layout_include_item&quot; /&gt; val binding: ActivityMainBinding = ActivityMainBinding.inflate(layoutInflater)binding.include.includeTvTitle.setText(&quot;使用 include 布局中的控件, 不包含 merge&quot;) include 标签带 merge 标签，注意这里和 DataBinding 用法不一样，给 include 标签添加 id，在 DataBinding 中可以直接使用 id，ViewBinding 则不行，ViewBinding 的用法如下所示。 &lt;include layout=&quot;@layout/layout_merge_item&quot; /&gt;val binding: ActivityMainBinding = ActivityMainBinding.inflate(layoutInflater)val mergeItemBinding = LayoutMergeItemBinding.bind(binding.root)mergeItemBinding.mergeTvTitle.setText(&quot;使用 include 布局中的控件, 包含 merge&quot;) ViewStub 标签的使用 根据实践证明，截止到这篇文章发布时，在 Android Studio 4.2.0 bata 2 中，无法直接在 ViewBinding 布局中使用 ViewStub 标签，仅仅只能在 DataBinding 布局（带 layout 标签）中使用，详见 issue 因为没有找到比较权威的资料证明，这里建议小伙们直接在项目 Binding 中进行尝试，如果有其他在 ViewBinding 布局中的实现方式，欢迎留言告知我 DataBinding 的使用因为涉及到的场景比较多，为了减少篇幅，我只列出来核心部分，如果之前从来没有用过，这里只需要知道 DataBinding 的门槛比 Kotlin 合成方法要高即可。 需要给布局文件添加 layout 标签 &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;LinearLayout...&gt; ... &lt;/LinearLayout&lt;/layout&gt; 在 Activity 中使用 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.lifecycleOwner = this setContentView(binding.root)} 在 Fragment 中使用 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View { val binding = FragmentViewBindBinding.inflate(inflater,container,false) binding.lifecycleOwner = this return binding.root} 在 Adapter 中的使用 override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { val view = LayoutInflater.from(parent.context).inflate(viewType, parent, false) val bidning:RecycleItemProductBinding = DataBindingUtil.bind(view) } 在 Dialog 中使用 override fun onCreate(savedInstanceState: Bundle?) { binding = DataBindingUtil.inflate(LayoutInflater.from(context), R.layout.dialog_data_binding, null, false) setContentView(binding.root)} include 标签的使用 include 标签不带 merge 标签，需要给 include 标签添加 id, 直接使用 id 即可。 &lt;include android:id=&quot;@+id/includeData&quot; layout=&quot;@layout/layout_include_data_item&quot;/&gt; val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)binding.includeData.includeTvTitle.setText(&quot;通过代码设置 include layout 的控件&quot;) include 标签带 merge 标签，注意这里和 ViewBinding 用法不一样，给 include 标签添加 id，在 DataBinding 中可以直接使用，在 ViewBinding 中则不行。 &lt;include android:id=&quot;@+id/includeDataMerge&quot; layout=&quot;@layout/layout_merge_data_item&quot;/&gt;val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)binding.includeDataMerge.mergeTvTitle.setText(&quot;通过代码设置 merge layout 的控件&quot;) ViewStub 标签的使用 给 ViewStub 标签添加 id, 在 DataBinding 中可以直接使用 id 即可。 &lt;ViewStub android:id=&quot;@+id/stub&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout=&quot;@layout/view_stub&quot; /&gt;binding.stub.setOnInflateListener { stub, inflated -&gt; // ViewBinding val viewStub: ViewStubBinding = ViewStubBinding.bind(inflated) viewStub.tvTitle.setText(&quot;使用 ViewStub 加载 ViewBinding 布局&quot;)}binding.stub.setOnInflateListener { stub, inflated -&gt; // DataBinding val dataViewStub: ViewStubDataBinding = DataBindingUtil.bind(inflated)!! dataViewStub.tvTitle.setText(&quot;使用 ViewStub 加载 DataBinding 布局&quot;)} if (!binding.stub.isInflated) { binding.stub.viewStub!!.inflate()} ``` 正如你所见，在 `Ativity` 、 `Fragment` 、 `Dialog` 、 `Adapter` 、 `include` 、 `merge` 、 `ViewStub` 等等场景中，使用 ViewBinding 或者 DataBinding 都要进行不同的处理，相比于 Kotlin 合成方法，这使用门槛太高了。那么能不能用一种方法，可以统一这些初始化方案，在 Kotlin 中仅仅需要一行代码即可实现 DataBinding 和 ViewBinding。### 一行代码如果在每个场景中都需要手动进行不同的处理，这样的成本是非常大的，因此我推出了一个新库 [Binding](https://github.com/hi-dhl/Binding) ，Binding 结合 Kotlin 委托属性，统一封装了 DataBinding 和 ViewBinding 不同的处理， 提供了简单的 API 如下所示。**ViewBinding 中的使用** val binding: ActivityViewBindBinding by viewbind() **DataBinding 中的使用** val binding: ActivityDataBindBinding by databind(R.layout.activity_data_bind)或者val binding: ActivityDataBindBinding by databind() 正如你所见，只需要简单的几个 API 即可实现上述所有场景，我们先来介绍一下 [Binding](https://github.com/hi-dhl/Binding)。Binding 未来的规划提供通用的 `findViewById` 解决方案，因技术的迭代更新从 `butterknife` 、 `DataBinding` 、 Kotlin 合成方法（Synthetic 视图）到现在 ViewBinding ， 未来也有可能出现新的技术，无论技术怎么变化，只要 Binding 对外的使用保持不变，只需要更新 Binding ，即可完成迁移。**[Binding](https://github.com/hi-dhl/Binding) 具有以下优点：*** 提供了很多实战案例包含 `Ativity` 、 `Fragment` 、 `Dialog` 、 `Adapter` 、 `include` 、 `merge` 、 `ViewStub` 、 `Navigation` 、 数据双向绑定 等等场景* 简单的 API 只需要一行代码即可实现 DataBinding 或者 ViewBinding* 支持在 `Activity` 、`AppCompatActivity` 、`FragmentActivity` 、`Fragment` 、`Dialog` 中的使用 DataBinding 或者 ViewBinding* 支持在 `ListAdapter` 、 `PagedListAdapter` 、 `PagingDataAdapter` 、 `RecyclerView.Adapter` 中的使用 DataBinding 或者 ViewBinding* 支持在 Navigaion Fragment 管理框架、 BottomSheetDialogFragment 等等场景中使用 DataBinding 和 ViewBinding* 避免大量的模板代码* 避免内存泄露，具有生命周期感知能力，当生命周期处于 `onDestroyed()` 时会自动销毁数据接下来我们一起来分析一下如何在项目中使用 [Binding](https://github.com/hi-dhl/Binding)，将下列代码添加在模块级 `build.gradle` 文件内，并且需要开启 DataBinding 或者 ViewBinding。 dependencies { implementation ‘com.hi-dhl:binding:1.0.7’} 在 `Activity` 、`AppCompatActivity` 、`FragmentActivity` 中使用，添加 `by viewbind()` 或者 `by databind(R.layout.activity_main)` 即可，示例如下所示。 class MainActivity : AppCompatActivity() { // DataBinding val binding: ActivityMainBinding by databind(R.layout.activity_main) // ViewBinding val binding: ActivityMainBinding by viewbind()} 在 `Fragment` 中提供了两种方式： * 方式一：在 `onCreateView` 中使用，这种方式适用于所有使用 `Fragment` 的场景* 方式二：在 `onViewCreated` 中使用**方式一：** class FragmentNav1 : Fragment(R.layout.fragment_main) { // DataBinding val binding: FragmentMainBinding by databind() // ViewBinding val binding: FragmentMainBinding by viewbind() override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { return binding.root }} **方式二，需要注意以下几点：*** 不能在 `Navigaion Fragment` 和 `BottomSheetDialogFragment` 中使用* 在其他 Fragment 场景中，如果使用 `方式二` 界面不显示，改用 `方式一` 即可解决 class FragmentNav1 : Fragment(R.layout.fragment_main) { // DataBinding val binding: FragmentMainBinding by databind() // ViewBinding val binding: FragmentMainBinding by viewbind() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.apply { textView.setText(&quot;Binding&quot;) } }} 在 `Dialog` 中使用方式如下所示。 class AppDialog(context: Context) : Dialog(context, R.style.AppDialog) { // DataBinding val binding: DialogAppBinding by databind(R.layout.dialog_data_binding) // ViewBinding val binding: DialogAppBinding by viewbind()} 或者添加具有生命周期感知的 `Dialog`。 class AppDialog(context: Context,lifecycle: Lifecycle) : Dialog(context, R.style.AppDialog) { // DataBinding 监听生命周期 val binding: DialogAppBinding by databind(R.layout.dialog_data_binding, lifecycle) // ViewBinding 监听生命周期 val binding: DialogAppBinding by viewbind(lifecycle)} 在 Adapter 中使用 DataBinding 和 ViewBinding，只需要在 ViewHolder 中添加 `by viewbind()` 或者 `by databind()` 即可，示例如下所示。 class ProductViewHolder(view: View) : RecyclerView.ViewHolder(view) { // DataBinding val binding: RecycleItemProductBinding by databind() // ViewBinding val binding: RecycleItemProductHeaderBinding by viewbind()} 扩展方法，支持 DataBinding 初始化的时候绑定数据。 val binding: ActivityDataBindBinding by databind(R.layout.activity_data_bind) { val account = Account() account.name = “test” this.account = account} 上面只是常见的几种用法，当然还有更多实战案例（`include` 、 `merge` 、 `ViewStub` 、 `Navigation` 、 数据双向绑定 等等）已经上传到 GitHub 欢迎前去仓库 [Binding](https://github.com/hi-dhl/Binding) 查看。 GitHub 仓库: [https://github.com/hi-dhl/Binding](https://github.com/hi-dhl/Binding) 这篇文章可以理解为对之前的文章 [Kotlin 插件的落幕，ViewBinding 的崛起](https://juejin.cn/post/6905942568467759111) 的一个补充，从使用的角度分析了 DataBinding 和 ViewBinding 不同之处，同时也介绍了如何用更简单的方式实现 DataBinding 和 ViewBinding。","link":"/2021/01/26/kotlin/07-use-viewbinding/"},{"title":"Kotlin 插件的落幕，ViewBinding 的崛起","text":"前言最近小伙们应该都会收到 Kotlin 1.4.20 的升级通知，在 Kotlin 1.4.20 中做了一个重要的更新 如下图所示： 简单总结一下，主要有以下几点： 废弃了 kotlin-android-extensions 编译插件 Parcelable 相关的功能，移到了新的插件 kotlin-parcelize 按照 Google 的解释，kotlin-android-extensions 插件只会保留至少一年的时间，将会在 2021 年 9 月或之后的 Kotlin 版本中将被移除 kotlin-android-extensions 主要有以下两个功能： 使用 Kotlin 合成方法（Synthetic 视图）取代 findViewById，通过引入 kotlinx.android.synthetic 可以直接使用控件的 ID，我猜当初也是因为这个特性，吸引了很多开发者开始学习和尝试使用 Kotlin 手动实现 Parcelize 比较麻烦，所以 Kotlin 提供了 @Parcelize 注解帮助快速实现 Parcelize 其实这并不是什么新的新闻了，早在 2019 年的时候，Google 就提出了不建议在项目中使用 kotlinx.android.synthetic，详见这个 commit，部分内容如下图所示： 通过引入 kotlinx.android.synthetic 可以直接使用控件的 ID，这么方便为什么不建议使用？主要有以下问题： 通过 Kotlin 合成方法（Synthetic 视图）取代 findViewById，这是通过全局空间缓存 ID，与 Layout 无关，没有针对 ID 进行无效检查 在不同的 Layout 文件中，使用了相同的 ID，或者删除了 ID ，它并不会提示空异常，导致增加了 App 的崩溃次数 仅仅支持 Kotlin 默认是通过 HashMap 缓存 ID 浪费空间，虽然可以通过在模块级 build.gradle 文件内添加 defaultCacheImplementation = &quot;SPARSE_ARRAY&quot; 来修改默认的实现方式为 SparseArray …… 因此 ViewBinding 出现了，ViewBinding 解决了上述所有问题，ViewBinding 虽然好，但是也有它的不足之处。 ViewBinding 相比于 kotlinx.android.synthetic 使用方式比较复杂 在 Activity 、 Fragment 、Dialog 、 Adapter 中 ViewBinding 和 DataBinding 初始化方式有些不同 需要单独处理 include 带 merge 标签的布局，和不带 merge 标签的布局等等 DataBinding 结合 LiveData 一起使用需要做单独的处理 …… 无论 ViewBinding 和 DataBinding 它们的使用方式都比较复杂，稍后我会介绍一种方法，只需要一行代码即可使用 ViewBinding(视图绑定) 和 DataBinding(数据绑定)，那么 ViewBinding 和 DataBinding 有什么区别呢？ ViewBinding 和 DataBindingViewBinding： 仅仅支持绑定 View 不需要在布局文件中添加 layout 标签 需要在模块级 build.gradle 文件中添加 viewBinding = true 即可使用 效率高于 DataBinding，因为避免了与数据绑定相关的开销和性能问题 相比于 kotlin-android-extensions 插件避免了空异常 DataBinding： 包含了 ViewBinding 所有的功能 需要在模块级 build.gradle 文件内添加 dataBinding = true 并且需要在布局文件中添加 layout 标签才可以使用 支持 data 和 view 双向绑定 效率低于 ViewBinding，因为注释处理器会影响数据绑定的构建时间。 ViewBinding 可以实现的， DataBinding 都可以实现，但是 DataBinding 的性能低于 ViewBinding，DataBinding 和 ViewBinding 会为每个 XML 文件生成绑定类。 R.layout.activity_main -&gt; ActivityMainBindingR.layout.fragment_main -&gt; FragmentMainBindingR.layout.dialog_app -&gt; DialogAppBinding 从 Android Studio 3.6 版本开始，就内置在 Gradle 插件中了，不需要添加任何额外的库来使用它们，但是在 Android Studio 3.6 和 Android Studio 4.0 中使用方式不一样。 // Android Studio 3.6android { viewBinding { enabled = true } dataBinding{ enabled = true }}// Android Studio 4.0android { buildFeatures { dataBinding = true viewBinding = true }} 接下来我们看一下如何在项目中使用 DataBinding 和 ViewBinding，因文章篇幅原因，这里仅仅演示在 Activity 中使用，更多用法可以查看 Binding 库的示例。 在模块级 build.gradle 文件内 开启 DataBinding 或者 ViewBinding 之后，需要在 Activity 中进行初始化，获取到 ViewBinding 实例即可使用。 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // Viewbinding val binding: ActivityMainBinding = ActivityMainBinding.inflate(layoutInflater) // DataBinding // val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) with(binding){ textView.setText(&quot;Binding&quot;) } }} 如果在每个 Activity 中都需要添加 ActivityMainBinding.inflate() 或者 DataBindingUtil.setContentView() 方法来进行初始化，这样无疑增加了很多模板代码，不仅仅是 Activity 在 Fragment 、Dialog 、Adapter 中都需要添加对应的方法来初始化。 那么能不能用一种方法，可以统一这些初始化方案，在 Kotlin 中是可以实现的，仅仅需要一行代码即可实现 DataBinding 和 ViewBinding。 一行代码实现 DataBinding 和 ViewBinding如果在每个 Activity 、 Fragment 、Dialog 、 Adapter 中都需要手动来添加相同的方法来初始化，这样的成本是非常大的，所以我们结合 Kotlin 委托属性，简化模板代码。 因此我推出了一个新库 Binding ，Binding 简化 DataBinding 和 ViewBinding 的使用， 只需要一行代码即可实现 DataBinding 和 ViewBinding，他们的实现方式并不相同。 Binding 未来的规划提供通用的 findViewById 解决方案，因技术的迭代更新从 butterknife 、 DataBinding 、 Kotlin 合成方法（Synthetic 视图）到现在 ViewBinding ， 未来也有可能出现新的技术，无论技术怎么变化，只需要更新 Binding ，对外的使用保持不变。我们来看一下如何在项目中使用 Binding 库。 将下列代码添加在模块级 build.gradle 文件内，并且需要开启 DataBinding 或者 ViewBinding dependencies { implementation 'com.hi-dhl:binding:1.0.4'} 在 Adapter（ListAdapter、PagingDataAdapter、RecyclerView.Adapter 等等）中使用 DataBinding 和 ViewBinding，添加 by viewbind() 或者 by databind() 即可，示例如下所示，查看详细示例 class ProductViewHolder(view: View) : RecyclerView.ViewHolder(view) { // 通过 DataBinding 绑定的 itemView val binding: RecycleItemProductBinding by databind() fun bindData(data: Product?, position: Int) { binding.apply { product = data executePendingBindings() } }}class ProductViewHolderHeader(view: View) : RecyclerView.ViewHolder(view) { // ViewBinding val binding: RecycleItemProductHeaderBinding by viewbind() fun bindData(data: Product?, position: Int) { binding.apply { name.text = &quot;通过 ViewBinding 绑定的 head&quot; } }} 在 Activity 、AppCompatActivity 、FragmentActivity 中使用，继承对应的类添加 by viewbind() 即可如下所示。 class MainActivity : AppCompatActivity() { // DataBinding val binding: ActivityMainBinding by databind(R.layout.activity_main) // ViewBinding val binding: ActivityMainBinding by viewbind()} 在 Fragment 中使用方式如下所示。 class MainFragment : Fragment(R.layout.fragment_main) { // DataBinding val binding: FragmentMainBinding by databind() // ViewBinding val binding: FragmentMainBinding by viewbind()} 在 Dialog 中使用方式如下所示。 class AppDialog(context: Context) : Dialog(context, R.style.AppDialog) { val binding: DialogAppBinding by viewbind()} 添加具有生命周期感知的 Dialog class AppDialog(context: Context,lifecycle: Lifecycle) : Dialog(context, R.style.AppDialog) { val binding: DialogAppBinding by viewbind(lifecycle)} 更多详细的用法，可以前去仓库 Binding 查看，Binding 具有以下优点： 可以在 Activity 、AppCompatActivity 、FragmentActivity 、Fragment 、Dialog 、 ListAdapter 、 PagingDataAdapter 、 RecyclerView.Adapter 中的使用 DataBinding 或者 ViewBinding 简单的 API 只需要一行代码即可实现 DataBinding 或者 ViewBinding 避免大量的模板代码 避免内存泄露，具有生命周期感知能力，当生命周期处于 onDestroyed() 时会自动销毁数据 源码分析，将会在后续的文章中分享，如果这个仓库对你有帮助，请在仓库右上角帮我 star 一下，非常感谢。 如何迁移 ParcelableKotlin 将 Parcelable 相关的功能，移到了新的插件 kotlin-parcelize，迁移只需要两步，如下所示。 在模块级 build.gradle 文件中，将 kotlin-android-extensions 修改为 kotlin-parcelize 将 import kotlinx.android.parcel.Parcelize 修改为 import kotlinx.parcelize.Parcelize 但是这一步不是必须的，kotlinx.android.parcel.Parcelize 可以继续使用，到目前为止还没有发现什么问题（PS: 如果出现，只需要将包名替换就好） 结语文章中相关代码，已经上传到 GitHub 欢迎前去仓库 Binding 查看 Binding 地址：https://github.com/hi-dhl/Binding 感谢 Simple one-liner ViewBinding in Fragments and Activities with Kotlin 文章带来的思路，以及从 Anko 、和 ViewBindingDelegate 等等开源库中学习到技巧。 陆陆续续有一些小伙伴们问我在哪里，可以看一些国外技术文章，所以我也给大家总结了一些不错的网站。 地址：https://site.51git.cn/gonav/2 全文到这里就结束了，如果有帮助 点个赞 就是对我最大的鼓励！！！","link":"/2020/12/30/kotlin/06-viewbinding/"},{"title":"「译」官宣 有趣的 Android Studio 版本新方案","text":"原标题：Announcing Android Studio Arctic Fox (2020.3.1) &amp; Android Gradle plugin 7.0 原地址：https://android-developers…… 原作者：Google 译者：hi-dhl Android Studio 版本命名新方案，带来的好处是升级 Android Studio 不需要同时升级 Gradle 插件，有趣的是以动物的名字来命名，全文分为译文和译者思考两部分。 译文于 2020.12.1 号 发布了 Android Studio Arctic Fox(2020.3.1) canary 版本，以及 Android Gradle 插件(AGP) 7.0.0-alpha01 版本，在新版本中，我们调整了 Android Studio 和 Gradle 插件的版本方案，这一变化将 Gradle 插件从 Android Studio 版本中分离出来，这样更加清楚的知道 Android Studio 在每个版本中使用的 IntelliJ 版本。 Android Studio 新的版本方案 随着 Android Studio Arctic Fox(2020.3.1) 的推出，我们将使用更接近 IntelliJ IDEA (Android Studio 所基于的IDE) 的基于年的版本方案，我们正在改变版本命名方案，同时也添加了一些重要的属性：年份， IntelliJ 的版本，加入了 feature 和 patch 级别。通过名字的改变，你可以很快地知道 Android Studio 使用的 IntelliJ 的版本号。此外，每个主要版本都有一个规范的代号，从 Arctic Fox 开始，然后按字母顺序进行，以方便查看哪个版本是最新的。 我们建议您使用最新的 Android Studio，以便可以使用最新功能和质量改进。 为了使更新更容易，我们对版本进行了更改，将 Android Studio 与 Gradle 插件版本分离。 要记住的一个重要细节是，更新 IDE 的时候，对构建系统编译和打包应用程序的方式没有影响。 相反，应用程序构建过程的更改和 APK/Bundles 由项目 AGP 版本决定。 因此，即使在开发周期的后期，也可以安全地更新 Android Studio 版本，因为项目中使用的 AGP 版本可以和 Android Studio 版本不同。 最后，在新的版本系统中，只要您将 AGP 版本保持在稳定版本，可以很方便的在项目中同时运行 Android Studio 的稳定版本和预览版本。 按照以前的版本命名方案，这个版本是 Android Studio 4.3，但是在新的版本方案中，这个版本是 Android Studio Arctic Fox (2020.3.1) Canary 1 或者 Arctic Fox。 接下来，我们将介绍 Android Studio 新的版本命名方案。 &lt;Year of IntelliJ Version&gt;.&lt;IntelliJ major version&gt;.&lt;Studio major version&gt; 前两个数字代表 Android Studio 使用的 IntellIj 的版本号，对于这个版本，是 2020.3 第三个数字表示 Android Studio 主要的版本，从 1 开始递增 为了更容易引用每个版本，我们给主要版本起了一个名称，根据动物名称从 a 开始递增到 Z。最初发行的名字是 Arctic Fox Android Gradle 插件版本新方案 在 AGP 7.0.0 中，我们采用了 semantic versioning 的原则，并与 AGP 要求的 Gradle 版本保持一致，Android Studio 和 Gradle 插件之间的兼容性保持不变。使用 AGP 稳定版本的项目可以使用最新的 Android Studio 版本打开。 我们将会发布另外一篇文章，详细介绍 AGP 版本控制方案和 AGP 7.0 的新特性。 译者思考对于新版本的命名方案最大的好处就是，升级 Android Studio 不需要同时升级 Gradle 插件，也就意味着，只要将 Gradle 插件的版本保持在稳定版本，可以很方便的在项目中同时运行 Android Studio 的稳定版本和预览版本。 但是新的 Gradle 插件会带来一些新特性，所以升级 Android Studio 版本的同时，可以同时升级 Gradle 插件的版本到稳定版本，我们来汇总一下 Android Studio 之前的命名方案 和 Gradle 插件的对应关系。 Android studio 插件版本与 gradle 版本对应关系如下所示： AS 插件版本 Gradle 版本 1.0.0 - 1.1.3 2.2.1 - 2.3 1.2.0 - 1.3.1 2.2.1 - 2.9 1.5.0 2.2.1 - 2.13 2.0.0 - 2.1.2 2.10 - 2.13 2.1.3 - 2.2.3 2.14.1+ 2.3.0+ 3.3+ 3.0.0+ 4.1+ 3.1.0+ 4.4+ 3.2.0 - 3.2.1 4.6+ 3.3.0 - 3.3.3 4.10.1+ 3.4.0 - 3.4.3 5.1.1+ 3.5.0 - 3.5.4 5.4.1+ 3.6.0 - 3.6.4 5.6.4+ 4.0.0+ 6.1.1+ 4.1.0+ 6.5+ 以上信息参考 Android Gradle 插件版本说明 Android Studio 根据动物名称来命名，而 Android 系统 10.0 之前都是以甜点的方式来命名，我们在来会汇总一下 Android 系统的命名方案。 2007 年 11 月 5 日发布最初的版本（Android 0.5），至今 Android 发行了多个版本，Android 操作系统有预发行的内部版本，分别为铁臂阿童木（Astro）与机器人班亭（Bender），从 2009 年 5 月开始， Android 的版本代号以甜点来命名，且每个代号间的前缀以英文本母序接续排列。 Android 系统名字、版本、API level 的对应关系如下所示： 名称 版本号 发版日期 API API Android 1.0 1.0 2008年9月23日 1 BASE Android 1.1 1.1 2009年2月9日 2 BASE_1_1 Android Cupcake（纸杯蛋糕） 1.5 2009年4月27日 3 CUPCAKE Android Donut（甜甜圈） 1.6 2009年9月15日 4 DONUT Android Eclair（闪电泡芙） 2.0 – 2.1 2009年10月26日 5 – 7 ECLAIR_MR1（2.1.x） ECLAIR_0_1（2.0.1） ECLAIR（2.0） Android Froyo（优格冰淇淋） 2.2 – 2.2.3 2010年5月20日 8 FROYO Android Gingerbread（姜饼） 2.3 – 2.3.7 2010年12月6日 9 - 10 GINGERBREAD_MR1（ 2.3.3 - 2.3.4） GINGERBREAD（2.3、2.3.1、2.3.2） Android Honeycomb（蜂巢） 3.0 – 3.2.6 2011年2月22日 11 - 13 HONEYCOMB_MR2（3.2） HONEYCOMB_MR1（3.1x） HONEYCOMB（3.0.x） Android Ice Cream Sandwich（冰淇淋三明治） 4.0 – 4.0.4 2011年10月18日 14 - 15 ICE_CREAM_SANDWICH_MR1（4.0.3、4.0.4） ICE_CREAM_SANDWICH （4.0、4.0.1、4.0.2） Android Jelly Bean（果冻豆） 4.1 – 4.3.1 2012年7月9日 16 – 18 JELLY_BEAN_MR2（4.3） JELLY_BEAN_MR1（4.2 - 4.2.2） JELLY_BEAN（4.1 - 4.1.1） Android KitKat（奇巧巧克力） 4.4 – 4.4.4 2013年10月31日 19 - 20 KITKAT Android Lollipop（棒棒糖） 5.0 – 5.1.1 2014年11月12日 21 - 22 LOLLIPOP_MR1（5.1） LOLLIPOP（5.0） Android Marshmallow（棉花糖） 6.0 – 6.0.1 2015年10月5日 23 M Android Nougat（牛轧糖） 7.0 – 7.1.2 2016年8月22日 24 - 25 N_MR1（7.1 - 7.11） N（7.0） Android Oreo（奥利奥） 8.0 – 8.1 2017年8月21日 26 – 27 O_MR1（8.1） O （8.0） Android Pie（派） 9 2018年8月6日 28 P Android 10 10 2019年9月3日 29 Q Android 11 11 2020年2月19日 30 R 从 Android Q 开始不再以甜品命名，且直接称 Android Q 为 Android 10。以上信息参考 uses-sdk 结语全文到这里就结束了，如果有帮助 点个赞 就是对我最大的鼓励！ 最后推荐我一直在更新维护的项目和网站： 全新系列视频：现代 Android 开发 (MAD) 技巧系列教程：在线查看 计划建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，欢迎前去查看：AndroidX-Jetpack-Practice LeetCode / 剑指 offer / 国内外大厂面试题 / 多线程 题解，语言 Java 和 kotlin，包含多种解法、解题思路、时间复杂度、空间复杂度分析 剑指 offer 及国内外大厂面试题解：在线阅读 LeetCode 系列题解：在线阅读 最新 Android 10 源码分析系列文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，仓库持续更新，欢迎前去查看 Android10-Source-Analysis 整理和翻译一系列精选国外的技术文章，每篇文章都会有译者思考部分，对原文的更加深入的解读，仓库持续更新，欢迎前去查看 Technical-Article-Translation 「为互联网人而设计，国内国外名站导航」涵括新闻、体育、生活、娱乐、设计、产品、运营、前端开发、Android 开发等等网址，欢迎前去查看 为互联网人而设计导航网站 历史文章 为数不多的人知道的 Kotlin 技巧以及 原理解析（一） 为数不多的人知道的 Kotlin 技巧以及 原理解析（二） Jetpack 最新成员 AndroidX App Startup 实践以及原理分析 Jetpack 成员 Paging3 实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack成员Paging3获取网络分页数据并更新到数据库中（三） Jetpack 成员 Hilt 实践（一）启程过坑记 Jetpack 成员 Hilt 结合 App Startup（二）进阶篇）进阶篇 Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇 全方面分析 Hilt 和 Koin 性能 神奇宝贝(PokemonGo) 眼前一亮的 Jetpack + MVVM 极简实战 Kotlin Sealed 是什么？为什么 Google 都用 Kotlin StateFlow 搜索功能的实践 DB + NetWork 再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度 [Google] 再见 SharedPreferences 拥抱 Jetpack DataStore","link":"/2020/12/07/translate/09-android-studio-version/"},{"title":"如何在项目中封装 Kotlin + Jetpack Databinding","text":"在之前的文章 0xA05 Android 10 源码分析：Dialog 加载绘制流程以及在 Kotlin、DataBinding 中的使用 分析了 Dialog 加载绘制流程、设计模式，以及基于 DataBinding 封装的 DataBindingDialog 的基础库 JDataBinding。 这篇文章主要来分析如何基于 DataBinding 封装 DataBindingActivity 、DataBindingFragment 、DataBindingDialog 、 DataBindingListAdapter 等等，成员陆续增加中，代码已经上传到 GitHub 欢迎前去查看仓库 JDataBinding。 JDataBinding 源码地址：https://github.com/hi-dhl/JDataBinding 什么是 DataBinding？ DataBinding 是 Google 在 Jetpack 中推出的一个数据绑定的支持库，利用该库可以实现在页面组件中直接绑定应用程序的数据源。 利用 Kotlin 中的 inline 、 reified 、 DSL 等等语法, 结合着 DataBinding，可以设计出更加简洁并利于维护的代码，首先我们先来看一下 DataBinding 在 ListAdapter 中的使用。 DataBindingListAdapterDataBindingListAdapter 是基于 ListAdapter 封装的，使用更少的代码快速实现 RecyclerView adapter 和 ViewHolder。 什么是 ListAdapter？ ListAdapter 是 Google 推出的一个新的类库，相比传统的 Adapter，它能够用较少的代码实现更多的 RecylerView 的动画，并且可以自动存储之前的 list，ListAdapter 还加入了 DiffUtil 的工具类，只有当 items 变化的时候进行刷新，而不用刷新整个 list，大大提高 RecyclerView 的性能。 什么是 DiffUtil？ DiffUtil 主要在后台计算 list 是否相同，然后回到回主线程刷新数据，主要使用了 Myers Diff Algorithm 算法, 而我们日常使用的 git diff 就用到了该算法。 好了介绍完基础概念之后，来看一下 DataBindingListAdapter 是如何使用的。 Step1: 继承 BaseViewHolder 创建一个自定义的 ViewHolder 类，继承 BaseViewHolder ，通过 viewHolderBinding 可以快速实现 DataBinding 的绑定。 class TestViewHolder(view: View) : BaseViewHolder&lt;Model&gt;(view) { val binding: RecycieItemTestBinding by viewHolderBinding(view) override fun bindData(data: Model) { binding.apply { model = data executePendingBindings() } }} Step2: 继承 DataBindingListAdapter 实现带头部和尾部的 Adapter，创建自定义的 Adapter，继承 DataBindingListAdapter class TestAdapter : DataBindingListAdapter&lt;Model&gt;(Model.CALLBACK) { override fun viewHolder(layout: Int, view: View): DataBindingViewHolder&lt;Model&gt; = when (layout) { R.layout.recycie_item_header -&gt; HeaderViewHolder(view) else -&gt; TestViewHolder(view) } override fun layout(position: Int): Int = when (position) { 0 -&gt; R.layout.recycie_item_header getItemCount() - 1 -&gt; R.layout.recycie_item_footer else -&gt; R.layout.recycie_item_test } override fun getItemCount(): Int = super.getItemCount() + 2} 构造方法需要传入了 Model.CALLBACK，Model.CALLBACK 实现了 DiffUtil.ItemCallback，用于计算 list 的两个非空 item 的不同。需要重写两个抽象方法 areItemsTheSame 和 areContentsTheSame 。 val CALLBACK: DiffUtil.ItemCallback&lt;Model&gt; = object : DiffUtil.ItemCallback&lt;Model&gt;() { // 判断两个Objects 是否代表同一个item对象， 一般使用Bean的id比较 override fun areItemsTheSame(oldItem: Model, newItem: Model): Boolean = oldItem.id == newItem.id // 判断两个Objects 是否有相同的内容。 override fun areContentsTheSame(oldItem: Model, newItem: Model): Boolean = true } Step3: 绑定 RecyclerView 和 Adapter &lt;data&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.hi.dhl.jdatabinding.demo.ui.MainViewModel&quot; /&gt; &lt;variable name=&quot;testAdapter&quot; type=&quot;com.hi.dhl.jdatabinding.demo.ui.TestAdapter&quot; /&gt;&lt;/data&gt; &lt;androidx.recyclerview.widget.RecyclerView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:adapter=&quot;@{testAdapter}&quot; app:adapterList=&quot;@{viewModel.mLiveData}&quot; app:layoutManager=&quot;androidx.recyclerview.widget.LinearLayoutManager&quot; /&gt; 这里用到了 DataBinding 的自定义数据绑定部分，具体实现可以参考仓库 JDataBinding 中的 fragment_test.xml 文件。 DataBindingDialog在 Kotlin 中应该尽量避免使用构建者模式，使用 Kotlin 的具名可选参数构造类，实现构建者模式，代码更加简洁。 在 “Effective Java” 书中介绍构建者模式时，是这样子描述它的：本质上 builder 模式模拟了具名的可选参数，就像 Ada和 Python中的一样。 幸运的是，Kotlin 是一门拥有具名可选参数的变成语言，DataBindingDialog 通过使用 Kotlin 的具名可选参数构造类，实现了 Dailog 构建者模式，用 DataBinding 进行二次封装，加上 DataBinding 数据绑定的特性，使 Dialog 变得更加简洁、易用。 Step1: 继承 DataBindingDialog class AppDialog( context: Context, val title: String? = null, val message: String? = null, val yes: AppDialog.() -&gt; Unit) : DataBindingDialog(context, R.style.AppDialog) { private val mBinding: DialogAppBinding by binding(R.layout.dialog_app) init { requireNotNull(message) { &quot;message must be not null&quot; } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) requestWindowFeature(Window.FEATURE_NO_TITLE) mBinding.apply { setContentView(root) display.text = message btnNo.setOnClickListener { dismiss() } btnYes.setOnClickListener { yes() } } }} Step2: 简洁的调用方式 AppDialog( context = this@MainActivity, message = msg, yes = { // do something }).show() DataBindingActivityKotlin 中的函数和构造器都支持具名可选参数，在使用上更加灵活，在 DataBindingActivity 中使用 Kotlin 的 inline、reified 强大的特性，将类型参数实化，初始化 View 更加简洁。 继承 DataBindingActivity class MainActivity : DataBindingActivity() { private val mBinding: ActivityMainBinding by binding(R.layout.activity_main) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) mBinding.apply { dialog.setOnClickListener { val msg = getString(R.string.dialog_msg) AppDialog( context = this@MainActivity, message = msg, yes = { Toast.makeText(this@MainActivity, msg, Toast.LENGTH_SHORT).show() }).show() } } }} DataBindingFragment在 Fragment 当中如何使用 Kotlin 的 inline、reified 初始化 View，可以查看 DataBindingFragment 继承自 DataBindingFragment class FragmentTest : DataBindingFragment() { val testViewModel: MainViewModel by viewModel() override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return binding&lt;FragmentTestBinding&gt;( inflater, R.layout.fragment_test, container ).apply { viewModel = testViewModel testAdapter = TestAdapter() lifecycleOwner = this@FragmentTest }.root }} JDataBinding 是基于 DataBinding 封装的 DataBindingActivity 、 DataBindingFragment 、 DataBindingDialog 、 DataBindingListAdapter 基础库。 文章中相关示例，已经上传到 GitHub 欢迎前去查看仓库 JDataBinding。 参考文献https://github.com/..BaseRecyclerViewAdapter","link":"/2020/11/11/kotlin/05-kotlin-databinding/"},{"title":"Google | 再见 SharedPreferences 拥抱 Jetpack DataStore(二)","text":"前言Google 增加了一个新 Jetpack 的成员 DataStore，主要用来替换 SharedPreferences， 而 Jetpack DataStore 有两种实现方式： Proto DataStore：存储类的对象（typed objects ），通过 protocol buffers 将对象序列化存储在本地 Preferences DataStore：以键值对的形式存储在本地和 SharedPreferences 类似 在上一篇文章 [Google] 再见 SharedPreferences 拥抱 Jetpack DataStore 中介绍了 SharedPreferences 都有那些坑，以及 Preferences DataStore 为我们解决了什么问题。 而今天这篇文章主要来介绍 Proto DataStore，Proto DataStore 通过 protocol buffers 将对象序列化存储在本地，所以首先需要安装 Protobuf 编译 proto 文件，Protobuf 编译大致分为 Gradle 插件编译和命令行编译，这两种方式已经发布到了博客上，欢迎点击下方链接前往查看。 Protobuf | 安装 Gradle 插件编译 proto 文件 Protobuf | 如何在 ubuntu 上安装 Protobuf 编译 proto 文件 Protobuf | 如何在 MAC 上安装 Protobuf 编译 proto 文件 由于目前主要在 MAC 和 ubuntu 上开发，所以只提供了这两种命令行编译方式，如果在 Win 上开发的同学，可以使用 Gradle 插件编译的方式。 这篇文章相关示例，已经上传到 GitHub 欢迎前去仓库 AndroidX-Jetpack-Practice/DataStoreSimple 切换到 datastore_proto 分支查看。 GitHub 地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 通过这篇文章你将学习到以下内容： 为何要有 Proto DataStore? 什么序列化？什么是对象序列化？什么是数据的序列化？ 什么是 Protocol Buffer？为什么需要它？为我们解决了什么问题？ 如何在项目中使用 Proto DataStore？ 如何迁移 SharedPreferences 到 Proto DataStore？ proto2 和 proto3 语法如何选择？ 常用 proto3 语法解析？ MAD Skills 是什么？ 为何要有 Proto DataStore既生 Preference DataStore 何生 Proto DataStore，它们之间有什么区别？ Preference DataStore 主要是为了解决 SharedPreferences 所带来的性能问题 Proto DataStore 比 Preference DataStore 更加灵活，支持更多的类型 Preference DataStore 支持 Int 、 Long 、 Boolean 、 Float 、 String protocol buffers 支持的类型，Proto DataStore 都支持 Preference DataStore 以 XML 的形式存储 key-value 数据，可读性很好 Proto DataStore 使用了二进制编码压缩，体积更小，速度比 XML 更快 从源码的角度 如果源码部分不是很了解，可以先忽略，继续往下看，之后回过头在来看就能理解了。 Preference DataStore 源码里定义了一个 proto 文件，通过 PreferencesSerializer 将每一对 key-value 数据映射到 proto 文件定义的 message 类型，proto 文件内容如下： syntax = &quot;proto2&quot;;......message PreferenceMap { map&lt;string, Value&gt; preferences = 1;}message Value { oneof valueName { bool boolean = 1; float float = 2; int32 integer = 3; int64 long = 4; string string = 5; double double = 7; }} 在 DataStore 中使用的是 proto2 语法，将 XML 中 key-value 数据映射到 Map 中，并且在 proto 文件中只定义了 Int 、 Long 、 Boolean 、 Float 、 String 这几种类型。 Proto DataStore 我们可以自定义 proto 文件，并实现了 Serializer&lt;T&gt; 接口，所以更加灵活，支持更多的类型 刚才说到 Proto DataStore 通过 protocol buffers 使用了二进制编码压缩，将对象序列化存储在本地，那么序列化到底是什么？我们先来了解一些基本概念，方便我们对后续的内容有更好的理解。 序列化序列化：将一个对象转换成可存储或可传输的状态，数据可能存储在本地或者在蓝牙、网络间进行传输。序列化大概分为对象序列化、数据序列化。 对象的序列化Java 对象序列化 将一个存储在内存中的对象转化为可传输的字节序列，便于在蓝牙、网络间进行传输或者存储在本地。把字节序列还原为存储在内存中的 Java 对象的过程称为反序列化。 在 Android 中可以通过 Serializable 和 Parcelable 两种方式实现对象序列化。 Serializable Serializable 是 Java 原生序列化的方式，主要通过 ObjectInputStream 和 ObjectOutputStream 来实现对象序列化和反序列化，但是在整个过程中用到了大量的反射和临时变量，会频繁的触发 GC，序列化的性能会非常差，但是实现方式非常简单，来看一下 ObjectInputStream 和 ObjectOutputStream 源码里有很多反射的地方。 ObjectOutputStream.javaprivate void writeObject0(Object obj, boolean unshared) throws IOException{ ...... Class&lt;?&gt; cl = obj.getClass(); ......}ObjectInputStream.javavoid readFields() throws IOException { ...... ObjectStreamField[] fields = desc.getFields(false); for (int i = 0; i &lt; objVals.length; i++) { objVals[i] = readObject0(fields[numPrimFields + i].isUnshared()); objHandles[i] = passHandle; } ......} 在 Android 中存在大量跨进程通信，由于 Serializable 性能差的原因，所以 Android 需要更加轻量且高效的对象序列化和反序列化机制，因此 Parcelable 出现了。 Parcelable Parcelable 的出现解决了 Android 中跨进程通信性能差的问题，而且 Parcelable 比 Serializable 要快很多，因为写入和读取的时候都是采用自定义序列化存储的方式，通过 writeToParcel() 方法和 describeContents() 方法来实现，不需要使用反射来推断它，因此性能得到提升，但是使用起来比 Serializable 要复杂很多。 为了解决复杂性问题， AndroidStudio 也有对应插件简化使用过程，如果是 Java 语言可以使用 android parcelable code generator 插件， 如果 Kotlin 语言的话可以使用 @Parcelize 注解，快速的实现 Parcelable 序列化。 用一张表格汇总一下 Serializable 和 Parcelable 的区别 数据序列化对象序列化记录了很多信息，包括 Class 信息、继承关系信息、变量信息等等，但是数据序列化相比于对象序列化就没有这么多沉余信息，数据序列化常用的方式有 JSON、Protocol Buffers、FlatBuffers。 JSON ：是一种轻量级的数据交互格式，支持跨平台、跨语言，被广泛用在网络间传输，JSON 的可读性很强，但是序列化和反序列化性能却是最差的，解析过程中，要产生大量的临时变量，会频繁的触发 GC，为了保证可读性，并没有进行二进制压缩，当数据量很大的时候，性能上会差一点。 Protocol Buffers ：它是 Google 开源的跨语言编码协议，可以应用到 C++ 、C# 、Dart 、Go 、Java 、Python 等等语言，Google 内部几乎所有 RPC 都在使用这个协议，使用了二进制编码压缩，体积更小，速度比 JSON 更快，但是缺点是牺牲了可读性 RPC 指的是跨进程远程调用，即一个进程调用另外一个进程的方法。 FlatBuffers ：同 Protocol Buffers 一样是 Google 开源的跨平台数据序列化库，可以应用到 C++ 、 C# , Go 、 Java 、 JavaScript 、 PHP 、 Python 等等语言，空间和时间复杂度上比其他的方式都要好，在使用过程中，不需要额外的内存，几乎接近原始数据在内存中的大小，但是缺点是牺牲了可读性 最后我们用一张图来分析一下 JSON、Protocol Buffers、FlatBuffers 它们序列化和反序列的性能，数据来源于 JSON vs Protocol Buffers vs FlatBuffers FlatBuffers 和 Protocol Buffers 无论是序列化还是反序列都完胜 JSON，FlatBuffers 最初是 Google 为游戏或者其他对性能要求很高的应用开发的，接下来我们来看一下今天主角 Protocol Buffer。 Protocol BufferProtocol Buffer ( 简称 Protobuf ) 它是 Google 开源的跨语言编码协议，可以应用到 C++ 、C# 、Dart 、Go 、Java 、Python 等等语言，Google 内部几乎所有 RPC 都在使用这个协议，使用了二进制编码压缩，体积更小，速度比 JSON 更快。 从 Proto3.0.0 Release Note 得知： protocol buffers 最初开源时，它实现了 Protocol Buffers 语言版本 2（称为 proto2）, 这也是为什么版本数从 v2.0.0 开始，从 v3.0.0 开始， 引入新的语言版本（proto3），而旧的版本（proto2）继续被支持。所以到目前为止 Protobuf 共两个版本 proto2 和 proto3。 proto2 和 proto3 应该学习那个版本？ proto3 简化了 proto2 的语法，提高了开发的效率，因此也带来了版本不兼容的问题，因为 2019 年的时候才发布 proto3 稳定版本，所以在这之前使用 Protocol Buffer 的公司，大部分项目都是使用 proto2 的版本，从上文的源码分析部分可知，在 DataStore 中使用了 proto2 语法，所以 proto2 和 proto3 这两种语法都同时在使用。 对于初学者而言直接学习 proto3 语法就可以了，为了适应技术迭代的变化，当掌握 proto3 语法之后，可以顺带了解一下 proto2 语法以及 proto3 和 proto2 语法的区别，这样可以更好的理解其他的开源项目。 为了避免混淆 proto3 和 proto2 语法，在本文仅仅分析 proto3 语法，当我们了解完这些基本概念之后，我们开始分析 如何在项目中使用 Proto DataStore。 如何在项目中使用 Proto DataStoreProto DataStore 同 Preferences DataStore 一样主要应用在 MVVM 当中的 Repository 层，在项目中使用 Proto DataStore 非常简单。 1. 添加 Proto DataStore 依赖 在 app 模块 build.gradle 文件内，添加以下依赖 // Proto DataStoreimplementation &quot;androidx.datastore:datastore-core:1.0.0-alpha01&quot;// protobufimplementation &quot;com.google.protobuf:protobuf-javalite:3.10.0&quot; Google 推荐 Android 开发使用 protobuf-javalite 因为它的代码更小，做了大量的优化。 当添加完依赖之后需要新建 proto 文件，在本文示例项目中新建了一个 common-protobuf 模块，将新建的 person.proto 文件，放到了 common-protobuf 模块 src/main/proto 目录下。 proto 文件默认存放路径 src/main/proto，也可以通过修改 gradle 的配置，来修改默认存放路径 在 common-protobuf 模块，build.gradle 文件内，添加以下依赖 implementation &quot;com.google.protobuf:protobuf-javalite:3.10.0&quot; 2. 新建 Person.proto 文件，添加以下内容 syntax = &quot;proto3&quot;;option java_package = &quot;com.hi.dhl.datastore.protobuf&quot;;option java_outer_classname = &quot;PersonProtos&quot;;message Person { // 格式：字段类型 + 字段名称 + 字段编号 string name = 1;} syntax ：指定 protobuf 的版本，如果没有指定默认使用 proto2，必须是.proto文件的除空行和注释内容之外的第一行 option ：表示一个可选字段 java_package ： 指定生成 java 类所在的包名 java_outer_classname ： 指定生成 java 类的名字 message 中包含了一个 string 类型的字段(name)。注意 ：= 号后面都跟着一个字段编号 每个字段由三部分组成：字段类型 + 字段名称 + 字段编号，在 Java 中每个字段会被编译成 Java 对象 在这里只需要了解这些 proto 语法即可，在文章后面会更详细的介绍这些语法。 3. 执行 protoc ，编译 proto 文件 以输出 Java 文件为例，执行以下命令即可输出对应的 Java 文件，如果配置了 Gradle 插件，可以忽略这一步，直接点击 Build -&gt; Rebuild Project 即可生成对应的 Java 文件。 protoc --java_out=./src/main/java -I=./src/main/proto ./src/main/proto/*.proto --java_out ： 指定输出 Java 文件所在的目录 -I ：指定 proto 文件所在的目录 *.proto ： 表示在 -I 指定的目录下查找以 .proto 结尾的文件 4. 构建 DataStore object PersonSerializer : Serializer&lt;PersonProtos.Person&gt; { override fun readFrom(input: InputStream): PersonProtos.Person { try { return PersonProtos.Person.parseFrom(input) // 是编译器自动生成的，用于读取并解析 input 的消息 } catch (exception: Exception) { throw CorruptionException(&quot;Cannot read proto.&quot;, exception) } } override fun writeTo(t: PersonProtos.Person, output: OutputStream) = t.writeTo(output) // t.writeTo(output) 是编译器自动生成的，用于写入序列化消息} 实现了 Serializer&lt;T&gt; 接口，这是为了告诉 DataStore 如何从 proto 文件中读写数据 PersonProtos.Person 是通过编译 proto 文件生成的 Java 类 Person.parseFrom(input) 是编译器自动生成的，用于读取并解析 input 的消息 t.writeTo(output) 是编译器自动生成的，用于写入序列化消息 5. 从 Proto DataStore 中读取数据 fun readData(): Flow&lt;PersonProtos.Person&gt; { return protoDataStore.data .catch { if (it is IOException) { it.printStackTrace() emit(PersonProtos.Person.getDefaultInstance()) } else { throw it } }} DataStore 是基于 Flow 实现的，所以通过 dataStore.data 会返回一个 Flow&lt;T&gt;，每当数据变化的时候都会重新发出 catch 用来捕获异常，当读取数据出现异常时会抛出一个异常，如果是 IOException 异常，会发送一个 PersonProtos.Person.getDefaultInstance() 来重新使用，如果是其他异常，最好将它抛出去 4. 向 Proto DataStore 中写入数据 在 Proto DataStore 中是通过 DataStore.updateData() 方法写入数据的，DataStore.updateData() 是一个 suspend 函数，所以只能在协程体内使用，每当遇到 suspend 函数以挂起的方式运行，并不会阻塞主线程。 以挂起的方式运行，不会阻塞主线程 ：也就是协程作用域被挂起, 当前线程中协程作用域之外的代码不会阻塞。 首先我们需要创建一个 suspend 函数，然后调用 DataStore.updateData() 方法写入数据即可。 suspend fun saveData(personModel: PersonModel) { protoDataStore.updateData { person -&gt; person.toBuilder().setAge(personModel.age).setName(personModel.name).build() }} person.toBuilder() 是编译器为每个类生成 Builder 类，用于创建消息实例 到这里关于 Proto DataStore 读取数据和写入数据已经全部分析完了，接下来分析一下如何迁移 SharedPreferences 到 Proto DataStore。 迁移 SharedPreferences 到 Proto DataStore迁移 SharedPreferences 到 Proto DataStore 只需要 3 步 1. 创建映射关系 将 SharedPreferences 数据迁移到 Proto DataStore 中，需要实现一个映射关系，将 SharedPreferences 中每一对 key-value 数据映射到 proto 文件定义的 message 类型。 private val shardPrefsMigration = SharedPreferencesMigration&lt;PersonProtos.Person&gt;( context, SharedPreferencesRepository.PREFERENCE_NAME ) { sharedPreferencesView, person -&gt; // 获取 SharedPreferences 的数据 val follow = sharedPreferencesView.getBoolean( PreferencesKeys.KEY_ACCOUNT, false ) // 将 SharedPreferences 每一对 key-value 的数据映射到 Proto DataStore 中 // 将 SP 文件中 ByteCode : true 数据映射到 Person 的成员变量 followAccount 中 person.toBuilder() .setFollowAccount(follow) .build() } 获取 SharedPreferences 存储的 key = ByteCode 的值 将 key = ByteCode 数据映射到 Person 的成员变量 followAccount 中 2. 构建 DataStore 并传入 shardPrefsMigration protoDataStore = context.createDataStore( fileName = FILE_NAME, serializer = PersonSerializer, migrations = listOf(shardPrefsMigration)) 当 DataStore 对象构建完了之后，需要执行一次读取或者写入操作，即可完成 SharedPreferences 迁移到 DataStore，当迁移成功之后，会自动删除 SharedPreferences 使用的文件，Proto DataStore 和 Preferences DataStore 文件存储路径都是一样的，如下图所示 到这里关于 Jetpack DataStore 实现方式之一 Proto DataStore 全部都分析完了，我们一起来看一下 proto 语法。 常用的 proto3 语法我梳理了常用的 proto3 语法，应该能满足大部分情况，更多语法可以参考 Google 官方教程 ，当掌握 proto3 语法之后，可以顺带了解一下 Proto2 语法，Proto3 虽然简化了 Proto2 的使用，提高了开发的效率，但是因为版本兼容问题，对于早期使用 Protocol Buffer 的团队，大部分都是使用 Proto2 语法。 一个基本的消息类型syntax = &quot;proto3&quot;;option java_package = &quot;com.hi.dhl.datastore.protobuf&quot;;option java_outer_classname = &quot;PersonProtos&quot;;message Person { // 格式：字段类型 + 字段名称 + 字段编号 string name = 1; int32 age = 2; bool followAccount = 3; repeated string phone = 4; Address address = 5;}message Address{ ......} syntax ：指定 protobuf 的版本，如果没有指定默认使用 proto2，必须是.proto文件的除空行和注释内容之外的第一行 option ：表示一个可选字段 java_package ： 指定生成 java 类所在的包名 java_outer_classname ： 指定生成 java 类的名字 在一个 proto 文件中，可以定义多个 message message 中包含了 3 个字段：一个 string 类型(name)、一个整型类型(age)、一个 bool 类型(followAccount)。注意 ：= 号后面都跟着一个字段编号 每个字段由三部分组成：字段类型 + 字段名称 + 字段编号，在 Java 中每个字段会被编译成 Java 对象，其他语言会被编译其他语言类型 字段类型 每一个消息类型中包含了很多个消息字段，每个消息字段都有一个类型，接下里用一个表格展示 proto 文件中的类型，以及对应的 Java 类型，如果其他语言可以查看官方文档。 .proto Type Notes Java Type double double float float int32 使用变长编码，如果字段是负值，效率很低，使用 sint32 代替 int int64 使用变长编码。如果字段是负值，效率很低，使用 sint64 代替 long sint32 使用变长编码，如果是负值比普通的 int32 更高效 int sint64 使用变长编码，如果是负值比普通的 int64 更高效 long bool boolean string 字符串必须始终包含 UTF-8 编码或 7-bit ASCII 文本，长度不能超过23 String 以上类型是经常会用到的，当然还有其他类型：uint32 、 uint64 、 fixed32 、 fixed64 、 sfixed32 、 sfixed64 、 bytes 等等，更多编码类型可以点击这里查看 Encoding 字段默认值 在 Proto3 中使用以下规则，编译成 Java 语言的默认值： 对于 string 类型，默认值为空字符串（&quot;&quot;） 对于 byte 类型，默认值是一个大小为 0 空 byte 数组 对于 bool 类型，默认为 false 对于数值类型，默认值为 0 对于枚举类型，默认值是第一个定义的枚举值, 且这个值必须是 0 （这是为了兼容 proto2 语法） 使用其他消息类型用作字段类型，默认值是 null （下文会详细分析） 被 repeated 修饰字段，默认值是一个大小为 0 的空 List 字段编号 在每一个消息字段 = 号后面都跟着一个字段编号，如下所示： string name = 1; 字段编号用于在消息的二进制格式中识别各个字段，字段编号非常重要，一旦开始使用就不能够再改变，字段编号的范围在 [1, 2^29 - 1] 之间，其中 [19000－19999] 作为 Protobuf 预留字段，不能使用。 注意 ：在范围 [1, 15] 之间的字段编号在编码的时候会占用一个字节，包括字段编号和字段类型，在范围 [16, 2047] 之间的字段编号占用两个字节，因此，应该为频繁出现的消息字段保留 [1, 15] 之间的字段编号，一定要为将来频繁出现的元素留出一些空间。 repeated 在刚才的示例中，我给一个字段添加了 repeated 修饰符，如下所示： repeated string phone = 4; 被 repeated 修饰的字段，对应 Java 类型中的 List，来看一下编译后的代码。 private com.google.protobuf.Internal.ProtobufList&lt;java.lang.String&gt; phone_; ProtobufList 其实是 List 子类，如下所示： public static interface ProtobufList&lt;E&gt; extends List&lt;E&gt; 包含其他消息类型 消息字段除了可以使用 int32 、 bool 、string 等等作为字段类型，还可以使用其他消息类型作为字段类型，如下所示： message Person { // 格式：字段类型 + 字段名称 + 字段编号 Address address = 5;}message Address{ ......} 消息嵌套在一个 proto 文件中，可以定义多个 message 如下所示： message Person { // 格式：字段类型 + 字段名称 + 字段编号 string name = 1; int32 age = 2; bool followAccount = 3; repeated string phone = 4; Address address = 5;}message Address{ string city = 1} 当然 message 也是可以层级嵌套的，来看个示例： message Person { // 格式：字段类型 + 字段名称 + 字段编号 string name = 1; int32 age = 2; bool followAccount = 3; repeated string phone = 4; message Address{ string city = 1; } Address address = 5;} 这些 message 会被编译成静态内部类，如下所示： public static final class Address extends com.google.protobuf.GeneratedMessageLite&lt; Address, Address.Builder&gt; implements AddressOrBuilder { ......} 枚举类型同样我们可以给 message 添加枚举类型，也可以使用枚举类型作为字段类型，如下所示： message Person { string name = 1; message Address{ string city = 1; } Address address = 5; enum Weekday{ SUN = 0; MON = 1; TUE = 2; WED = 3; THU = 4; FRI = 5; SAT = 6; } Weekday weekday = 6;} 正如你所看到的，消息字段除了可以使用 int32 、 bool 、string 、其他消息类型作为字段类型之外，还可以使用枚举类型作为字段类型。 注意 ：每一个枚举类型第一个枚举值必须为 0，因为： 必须有一个 0 值，因为需要将 0 作为默认值 值为 0 的元素必须是第一个枚举值，这是为了兼容 proto2 语法，在 proto2 中默认值总是第一个枚举值 oneof根据 Google 文档分析 oneof 有两层意思： 在 oneof 中声明多个字段，同时只有一个字段会被赋值，共享一块内存，主要用来节省内存 如果 oneof 当中一个字段被赋值，然后在给其他字段赋值，会清除其他已赋值字段的值，最终 oneof 所有字段中只会有一个字段有值 我们来看一下简单的示例 message PreferenceMap { map&lt;string, Value&gt; preferences = 1;}message Value { oneof valueName { bool boolean = 1; float float = 2; int32 integer = 3; int64 long = 4; string string = 5; double double = 7; }} 在一个名为 valueName 的 oneof 中声明了很多个字段，这些字段会共享一块内存空间，同时只有一个字段会被赋值 在名为 PreferenceMap 的 message 中声明了一个 map，Key 是字符串类型，Value 其实是 oneof 中声明的字段，同一时间，一个 Key 只会对应一个 Value 其实在编译的时候，会为每个 oneof 生成一个 Java 枚举类型，代码如下所示 public enum ValueNameCase { BOOLEAN(1), FLOAT(2), INTEGER(3), LONG(4), STRING(5), DOUBLE(7), VALUENAME_NOT_SET(0); // 如果都没有赋值，会返回 `VALUENAME_NOT_SET` private final int value; private ValueNameCase(int value) { this.value = value; } 编译器会自动生成 getValueNameCase() 方法，用来检查哪个字段被赋值了，如果都没有赋值，会返回 VALUENAME_NOT_SET 常用的 proto3 语法到这里就介绍完了，文章只列举了常用的语法，如果需要把 proto3 语法都分析完，至少需要 2 篇文章才有可能介绍完，因为篇幅原因，源码分析部分会在后续的文章中分析。 MAD Skills 是什么Google 近期发布了 MAD Skills（Modern Android Development）新系列教程，旨在帮助开发者使用最新的技术，开发更好的应用程序，以视频和文章形式介绍 MAD 各个部分，包括 Kotlin、Android Studio、Jetpack、App Bundles 等等, Google 仅仅提供了视频和文章，我在这基础上，我做了一些扩展： 视频添加上了中英文字幕，帮助更好的学习 视频的实战部分，将会提供对应的实战案例 除了实战案例，还会提供对应的源码分析 每隔几个星期 Google 会发布一系列教程，目前已经开始了一系列关于导航组件 (Navigation component) 的视频教程。双语视频已经同步到 GitHub 仓库 MAD-Skills 可以先看视频部分，文章以及案例正在火速赶来。 参考文章 Google-DataStore – Jetpack Alternative For SharedPreferences Google-Language Guide (proto3) GitHub-protobuf FlatBuffers 体验 Java 对象序列化 JSON vs Protocol Buffers vs FlatBuffers 总结全文到这里就结束了，文章中相关的示例，已经上传到 GitHub 欢迎前去仓库 AndroidX-Jetpack-Practice/DataStoreSimple 切换到 datastore_proto 分支查看。 GitHub 地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 当这篇文章写完时，已经写了 4 篇文章了，在准备写这篇文章之前，写了三篇文章介绍了 MAC 和 ubuntu 两种命令行编译方式以及 Gradle 插件的方式编译 proto 文件，因为看了下网上的方式都太老了，而且也不是很清楚，Gradle 插件的方式网上大部分都是 3.0.x ~ 3.7.x 的配置方式，当 protoc &gt;= 3.8 之后有一些不同之处，所以重新写了这三种编译方式，以及记录了在这个过程中遇到的问题。 Protobuf | 安装 Gradle 插件编译 proto 文件 Protobuf | 如何在 ubuntu 上安装 Protobuf 编译 proto 文件 Protobuf | 如何在 MAC 上安装 Protobuf 编译 proto 文件 由于目前主要在 MAC 和 ubuntu 上开发，所以只提供了这两种命令行编译方式，如果在 Win 上开发的同学，可以使用 Gradle 插件编译的方式，如果有帮助 点个赞 就是对我最大的鼓励！","link":"/2020/11/08/jetpack/12-porot-datastore/"},{"title":"「译」Google 官方正解是否应该学习 Kotlin","text":"原标题：Should I learn Kotlin for Android and other FAQs 原地址：https://medium.com/androiddevelopers… 原作者：Florina Muntenescu 译者：hi-dhl 本文已收录于仓库 Technical-Article-Translation 这篇文章来自 Google 开发技术推广工程师 Florina Muntenescu 分享的一篇文章，在这篇文章里精选了 Google 宣布支持 Kotlin 以来最热门的几个问题，回答了是否应该学习 Kotlin、以及如何学习 Kotlin。全文分为 译文 和 译者思考 两个部分。 译文自从我们在 2017 年宣布支持 Kotlin 以来，收到了很多关于 Kotlin 在 Android 上的问题：如何学习它 Kotlin，如何在 App 上使用 Kotlin，有什么好的 Kotlin 学习教程，以及 Google 内部是否在使用 Kotlin，和未来对 Java 语言的规划是什么，将通过这篇文章来回答这些问题。 Q: 是否应该学习 Kotlin ? 我们收到了很多类似的问题，总结如下： 对于 Android 初学者，应该先学习 Java 还是 Kotlin？ 如果已经掌握了 Java 基础知识，现在应该切换到 Kotlin 开发 Android 吗？ 对于 Java 开发人员，如果想要学习 Android，建议先学习 Kotlin 还是 Java? 用一句简短的话，回答上面的问题：是的，开始学习和使用 Kotlin 。 下面会用很长的文字来分析，为什么应该学习和使用 Kotlin。 Kotlin &amp; Android2017年，我们在 Google I / O 上宣布支持 Kotlin，从那个时候我们已经开始准备关于 Kotlin 的 API、文档、案例，在 2019 年 Kotlin 成为 Android 的首选语言之后，我们开始更加依赖 Kotlin 的特性，例如，我们推荐使用协程执行异步任务。 Kotlin-first libraries 首先我们在 Jetpack(Room、LiveData、ViewModel 和 WorkManager) 中添加了协程的支持，从而改变了在 Android 上执行异步操作的方式，Firebase Android SDK 和大量的 Jetpack 库都用到了 Kotlin extension libraries (KTX)。 现在很多库例如 Paging 3.0 和 DataStore 首先使用 Kotlin 开发的。Jetpack Compose 是我们新的、未绑定的声明式 UI 工具包，它也是使用 Kotlin 开发的。 Tooling 开发的效率来源于强大的工具。因此，我们对 Kotlin 编译工具做了很多改进，包括对 Kotlin JVM 编译器、Kotlin 的 R8 优化，甚至开发了 Kotlin Symbol Processing。我们添加了 Android Kotlin Live 模板，会自动在 App 中添加一些通用模块，而且新的 Kotlin 的 Lint 检查工具可以帮助你检查 Kotlin 语言规范，当您将代码从 Java 转到 Kotlin 的时候，这个工具特别有用。 Q: Google 内部是否在使用 Kotlin在 Google 内部我们也在推荐使用 Kotlin，我们有超过 60 个应用（例如：Home、Drive、Maps 等等） 已经开始使用 Kotlin 开发了，到目前为止，在我们的代码库中有超过 200 万行 Kotlin 代码。 Q: 是否应该将 App 迁移到 Kotlin？我们收到了很多类似的问题，但是是否迁移到 Kotlin 取决于你，如果您对当前的代码库和技术栈感到满意，并且熟练地使用您的解决方案来管理异步任务，并且有一个有效的方法来捕获错误，迁移到 Kotlin 可能不是一个很好的方案。 如果你喜欢 Kotlin，而且想使用最新的 Jetpack API，那么你应该考虑将 Kotlin 加入到你的 App 中，Kotlin 优点之一是它与 Java 有很好的互操作性，您可以在项目中逐步使用它，可能首先在测试用例中使用 Kotlin，然后在新功能中使用 Kotlin，当熟悉之后，可以尝试将 Java 代码转为 Kotlin 代码。 如果想要迁移到 Kotlin , 可以查看我们的教程 Converting to Kotlin codelab。 Q: 在 Android 中使用 Java 怎么样？Kotlin 会编译成 Java 代码，它们是可以共存的，我们喜欢 Kotlin 因为使用它编写代码的更简洁、也更加安全，同时我们也会继续支持 Java 语言。例如，在 Android 11 中，我们增加了 OpenJDK 13 一系列 API 的支持，而 Android Studio 也允许你在所有 Android 设备上使用其中一些 API，无论操作系统版本是什么, 点击 这里 阅读更多新的 API。 Q: 学习 Kotlin 的最好方法是什么?切换到一种新的语言不是一件容易的事，但是我们也正努力使它变得更容易。 点击 courses 开始学习 Kotlin，针对所有级别的开发者，从初级到高级所有课程，这些课程将帮助你提高在 Android 中使用 Kotlin，Android Basics in Kotlin 这是给没有经验的人提供的一个新的在线课程，还有一些高级课程教你如何使用协程。 所有的文档都包含了 Kotlin 代码片段，可以非常方便的比较两种语言，而且所有示例都有 Kotlin 版本。 你可以查看 文章 和 视频 来学习如何使用 Kotlin。 对于开发者或者团队想要切换到 Kotlin 我们提供一些指导，可以查看网页 developers.android.com/kotlin 宣布支持 Kotlin 到现在已经三年了，我们一直在努力支持 Kotlin 和这个生态，与 JetBrains 一起为 Kotlin 建立了一个基础，以确保该语言能够很好的使用。不仅仅如此而已，在 Google 内部有一个团队专门研究 Kotlin 编译器，我们正在构建的 Jetpack API 不仅仅支持 Kotlin，但是会优先支持 Kotlin，我们也在努力让 Kotlin 在 Android 上的体验更好。 译者思考自从 Google 宣布 Kotlin 成为 Android 开发的首选语言开始，Google 一直致力于让 Kotlin 变得更加的简单。 在 Kotlin 之初有个非常著名的库 Anko，Anko 是 JetBrains 开发的一个非常强大的库，它主要的目的是替代以前 XML 的方式，使用代码生成 UI 布局，并且封装了一系列工具，帮助开发者快速的使用 Kotlin，简化了 Kotlin 在 Android 上的使用，它有好几个扩展库： Anko Commons：一个轻量级的库，包含了一些通用功能 intents、 dialogs、 logging 等等 Anko Layouts： 替代以前 XML 的方式，使用代码生成 UI 布局 Anko SQLite：简化了 SQLite 的使用 Anko Coroutines：基于 kotlinx.coroutines 开发，简化了协程的使用 Anko 是非常成功的项目，它的出现让 Kotlin 在 Android 上的体验更好，但是遗憾的是 在 2019 年的时候这个库已经不在维护，不在维护，不在维护 ，因为自从 Google 宣布支持 Kotlin，让 Kotlin 成为 Android 开发的首选语言开始，Google 开发了很多库使得 Kotlin 在 Android 上体验更好，完全可以替代 Anko 的各个部分，所以 Anko 团队宣布不在维护了。 Android KTX： 是 Kotlin 扩展库，封装了一系列工具，简化了 Kotlin 的使用 Jetpack Compose ： 替代以前 XML 的方式，用于构建原生 UI 的工具 Room：Google 提供的 ORM 框架，简化了 SQLite 的使用 Flow：flow 是对 Kotlin 协程的扩展，让我们可以像运行同步代码一样运行异步代码，简化了对协程的使用，而且功能非常强大 MAD Skills不仅仅如此 Google 近期发布了 MAD Skills（Modern Android Development）新系列教程，旨在帮助开发者使用最新的技术，开发更好的应用程序，以视频和文章形式介绍 MAD 各个部分，包括 Kotlin、Android Studio、Jetpack、App Bundles 等等, Google 仅仅提供了视频和文章，我在这基础上，我做了一些扩展： 视频上添加上了中英文字幕，帮助更好的学习新技术 将会提供对应的实战案例，与视频一一对应 除了实战案例，还会提供对应的源码分析 每隔几个星期 Google 会发布一系列教程，目前已经开始了一系列关于导航组件 (Navigation component) 的视频教程。 双语视频已经同步到 GitHub 仓库 MAD-Skills 可以先看视频部分，文章以及案例正在火速赶来，点击在线查看。 除此之外，我还写了 Kotlin 和 Jetpack 系列文章，并且提供了对应的实战案例。 Kotlin 系列 为数不多的人知道的 Kotlin 技巧以及 原理解析（一） 为数不多的人知道的 Kotlin 技巧以及 原理解析（二） Kotlin StateFlow 搜索功能的实践 DB + NetWork Kotlin Sealed 是什么？为什么 Google 都用 如何在项目中封装 Kotlin + Android Databinding 放弃 Dagger 拥抱 Koin Kotlin 的性能优化那些事 Kotlin 新秀 Coil VS Glide and Picasso Jetpack 系列 Jetpack 成员 App Startup 实践及原理分析 Jetpack 成员 Paging3 实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack 成员 Paging3 获取网络分页数据并更新到数据库中（三） Jetpack 成员 Hilt 实践（一）启程过坑记 Jetpack 成员 Hilt 结合 App Startup（二）进阶篇）进阶篇 Jetpack 成员 Hilt 与 Dagger 区别 (三) 落地篇 全方面分析 Hilt 和 Koin 性能 神奇宝贝(PokemonGo) 眼前一亮的 Jetpack + MVVM 极简实战 Google 推荐在 MVVM 架构中使用 Kotlin Flow 再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度 Fragment 新特性 : Fragment Result API 使用以及源码分析 Google 建议使用这些 Fragment 的新特性 再见 SharedPreferences 拥抱 Jetpack DataStore (一) 再见 SharedPreferences 拥抱 Jetpack DataStore (二) Android 10 系列 0xA01 Android 10 源码分析：APK 是如何生成的 0xA02 Android 10 源码分析：APK 的安装流程 0xA03 Android 10 源码分析：APK 加载流程之资源加载 0xA04 Android 10 源码分析：APK 加载流程之资源加载（二） 0xA05 Android 10 源码分析：Dialog 加载绘制流程以及在 Kotlin、DataBinding 中的使用 0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构 0xA07 Android 10 源码分析：Window 的类型 以及 三维视图层级分析 更多 GitHub 仓库以及 网站 计划建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，欢迎前去查看：AndroidX-Jetpack-Practice LeetCode / 剑指 offer / 国内外大厂面试题 / 多线程 题解，语言 Java 和 kotlin，包含多种解法、解题思路、时间复杂度、空间复杂度分析 剑指 offer 、多线程、国内外大厂面试题：在线阅读 LeetCode 系列题解：在线阅读 最新 Android 10 源码分析系列文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，仓库持续更新，欢迎前去查看 Android10-Source-Analysis 整理和翻译一系列精选国外的技术文章，每篇文章都会有译者思考部分，对原文的更加深入的解读，仓库持续更新，欢迎前去查看 Technical-Article-Translation 「为互联网人而设计，国内国外名站导航」涵括新闻、体育、生活、娱乐、设计、产品、运营、前端开发、Android 开发等等网址，欢迎前去查看 为互联网人而设计导航网站","link":"/2020/11/08/translate/08-java-or-kotlin/"},{"title":"Protobuf | 安装 Gradle 插件编译 proto 文件","text":"相关系列： Protobuf | 安装 Gradle 插件编译 proto 文件 Protobuf | 如何在 ubuntu 上安装 Protobuf 编译 proto 文件 Protobuf | 如何在 MAC 上安装 Protobuf 编译 proto 文件 前言Google 除了提供命令行的方式编译 proto 文件，还提供了 AndroidStudio 插件 protobuf-gradle-plugin 来编译 proto 文件。 如何在项目中添加 Gradle 插件在项目中添加 Gradle 插件编译 proto 文件，非常简单，我先给出全部配置，文件内容比较长，稍后会逐个分析，将下列内容添加在 protobuf 文件所在的 module 的 build.gradle 文件内。 /** * plugins 和 apply plugin 的区别： * plugins 是一种比较新的方法，它所引用的插件必须在 Gradle plugin repository 的仓库可见的 * apply plugin 是一种比较老的方式，在 Android4.1 的时候，创建项目的时候，已经将 apply plugin 方法替换为 plugins * */plugins { id 'com.android.library' id &quot;com.google.protobuf&quot; version &quot;0.8.12&quot;}// 或者使用下面的方式，但是不建议使用//apply plugin: 'com.android.library'//apply plugin: &quot;com.google.protobuf&quot;android { compileSdkVersion 30 // 设置 proto 文件位置 sourceSets { main { proto { // proto 文件默认路径是 src/main/proto // 可以通过 srcDir 修改 proto 文件的位置 srcDir 'src/main/proto' } } }}/** * 注意配置 protoc 命令，分为不同的版本，版本不同配置的方式不同， * 网上大部分都是 3.0.x ~ 3.7.x 的配置方式，关于这种配置方法，可以查看 [protobuf-gradle-plugin](https://github.com/google/protobuf-gradle-plugin) 文档，这里不在演示了，也不建议使用 * 在此项目中使用的是 3.8 以后 的配置的配置， */protobuf { // 设置 protoc 的版本 protoc { // //从仓库下载 protoc 这里的版本号需要与依赖 com.google.protobuf:protobuf-javalite:xxx 版本相同 artifact = 'com.google.protobuf:protoc:3.10.0' } generateProtoTasks { all().each { task -&gt; task.builtins { java { option &quot;lite&quot; } } } } // 默认生成目录 $buildDir/generated/source/proto 通过 generatedFilesBaseDir 改变生成位置 generatedFilesBaseDir = &quot;$projectDir/src/main&quot;}// 添加 protobuf 需要的依赖，这里是用的是 javalite 版本dependencies { implementation &quot;com.google.protobuf:protobuf-javalite:3.10.0&quot;} 只需要将上面的内容添加在 protobuf 文件所在的 module 的 build.gradle 文件内，就可以开始编译 proto 文件，proto 文件默认存放路径 src/main/proto，需要在该目录下新建 proto 文件。 新建 Person.proto 文件，添加以下内容 syntax = &quot;proto3&quot;;option java_package = &quot;com.hi.dhl.datastore.protobuf&quot;;option java_outer_classname = &quot;PersonProtos&quot;;message Person { // 格式：字段类型 + 字段名称 + 字段编号 string name = 1;} 之后点击 Build -&gt; Rebuild Project，即可生成对应的 Java 文件，默认生成目录 $buildDir/generated/source/proto 接下里我们来分析如何在项目中添加 Gradle 插件编译 proto 文件，别看文件内容很长，总共拆分下来只需要三步。 步骤一：添加 Protobuf 插件 AndroidStudio 提供了两种方式 plugins{...} 和 apply plugin，来添加 Protobuf 插件 使用 apply plugin 方法 apply plugin: &quot;com.google.protobuf&quot; 使用 plugins{...} 方法， plugins { id &quot;com.google.protobuf&quot; version &quot;0.8.12&quot;} 建议使用 plugins{...} 方式，在 AndroidStudio 4.1 以上，创建项目的时候，已经将 apply plugin 方法替换为 plugins{...} 步骤二：配置 protoc 命令 注意： protoc 命令，分为不同的版本，版本不同配置的方式不同，网上大部分都是 3.0.x ~ 3.7.x 的配置方式，关于这种配置方法，可以查看 protobuf-gradle-plugin 文档，这里不在演示了，也不建议使用。 我们直接来看看 protoc &gt;= 3.8 之后的方法，添加下面内容到 protobuf 文件所在的 module 的 build.gradle 文件内。 protobuf { // 设置 protoc 的版本 protoc { // //从仓库下载 protoc 这里的版本号需要与依赖 com.google.protobuf:protobuf-javalite:xxx 版本相同 artifact = 'com.google.protobuf:protoc:3.10.0' } generateProtoTasks { all().each { task -&gt; task.builtins { java { option &quot;lite&quot; } } } }} 通过 artifact 指定的 protoc 的版本号，需要与 添加 protobuf 需要的依赖 的版本相同。 默认生成目录 $buildDir/generated/source/proto 可以通过 generatedFilesBaseDir 改变生成位置。 protobuf { ...... // 默认生成目录 $buildDir/generated/source/proto 通过 generatedFilesBaseDir 改变生成位置 generatedFilesBaseDir = &quot;$projectDir/src/main&quot;} 步骤三：添加 protobuf 需要的依赖 // 这里是用的是 javalite 版本dependencies { implementation &quot;com.google.protobuf:protobuf-javalite:3.10.0&quot;} 只需要完成前面三步，就可以开始编译 proto 文件，每次 proto 文件内容变更的时候，只要重新点击 Build -&gt; Rebuild Project，即可生成对应的 Java 文件。 proto 文件默认存放路径是 src/main/proto, 可以添加下面配置更改 proto 文件存放的位置。 android { // 设置 proto 文件位置 sourceSets { main { proto { // proto 文件默认路径是 src/main/proto // 可以通过 srcDir 修改 proto 文件的位置 srcDir 'src/main/proto' } } }} 常见问题错误一：编译没有报错，为什么没有生成对应的目标文件？ 如果没有更改 proto 文件存储路径，默认存放路径是 src/main/proto，请检查你的 proto 文件存放位置是否正确 总结安装 Gradle 插件编译 proto 文件，相比于 ubuntu 和 MAC 安装方式，要复杂点，但是用起来是相当方便的，如果在使用过程中遇到了任何问题，欢迎在评论区留言，一起来完善这份教程，如果没有及时回复，可以来公众号：ByteCode 找我咨询。","link":"/2020/10/28/jetpack/05-probuff-AndroidStudio/"},{"title":"Protobuf | 如何在 MAC 上安装 Protobuf 编译 proto 文件","text":"相关系列： Protobuf | 安装 Gradle 插件编译 proto 文件 Protobuf | 如何在 ubuntu 上安装 Protobuf 编译 proto 文件 Protobuf | 如何在 MAC 上安装 Protobuf 编译 proto 文件 为什么需要配置 Protobuf 环境因为 Protobuf 是 Google 开源的跨语言编码协议，所以它使用特殊的语法，需要使用 protoc 命令编译成我们需要的语言，目前 Protobuf 可以编译成 6 中语言，分别是：C++ 、C# 、Dart 、Go 、Java 、Python。 Protobuf 环境搭建在 MAC 上配置 Protobuf 环境，相比于 ubuntu 和 Gradle 插件的方式，要简单很多，首先执行以下命令下载Protobuf 编译需要的依赖。 brew install automakebrew install libtoolbrew install protobuf 下载 protobuf 源码并编译 git@github.com:protocolbuffers/protobuf.gitcd protobuf./autogen.sh./configuremakemake install 按照上面所示的命令依次执行完，等待 10 ~ 20 分钟左右，即可安装成功，等待安装完成之后，执行以下命令验证是否安装成功。 protoc --version 如果出现以下信息代表安装成功。 libprotoc 3.12.3 接下来就可以开始编译 proto 文件，请参考文末 常见问题 的解决方案。 编写 proto 文件测试1. 创建 Person.proto 文件，添加以下内容 syntax = &quot;proto3&quot;;option java_package = &quot;com.hi.dhl.datastore.protobuf&quot;;option java_outer_classname = &quot;PersonProtos&quot;;message Person { string name = 1;} syntax ：指定 protobuf 的版本，如果没有指定默认使用 proto2，必须是.proto文件的除空行和注释内容之外的第一行 option ：表示一个可选字段 java_package ： 指定生成 java 类所在的包名 java_outer_classname ： 指定生成 java 类的名字 message 中包含了一个 string 类型的字段(name)。注意 ：= 号后面都跟着一个字段编号 每个字段由三部分组成：字段类型 + 字段名称 + 字段编号，在 Java 中每个字段会被编译成 Java 对象，其他语言会被编译其他语言类型 2. 执行 protoc 命令 以输出 Java 文件为例，执行以下命令即可输出对应的 Java 文件。 protoc --java_out=./src/main/java -I=./ *.proto --java_out ： 指定输出的 Java 文件所在的目录 -I ：指定 proto 文件所在的目录 *.proto ： 表示在 -I 指定的目录下查找 以 .proto 文件结尾的文件 常见错误错误一：Library not loaded 执行 make 命令，如果出现下列错误。 Library not loaded: /usr/local/opt/readline/lib/libreadline.7.dylib 执行以下命令即可解决。 cd /usr/local/opt/readline/libln -s libreadline.8.0.dylib libreadline.7.dylib 错误二：No syntax specified for the proto file 执行 protoc 命令，编译 proto 文件，出现以下错误。 [libprotobuf WARNING google/protobuf/compiler/parser.cc:648] No syntax specified for the proto file: test.proto. Please use 'syntax = &quot;proto2&quot;;' or 'syntax = &quot;proto3&quot;;' to specify a syntax version. (Defaulted to proto2 syntax.) 原因是因为没有指定版本号，在 proto 文件第一行添加以下代码即可解决。 syntax = &quot;proto3&quot;; // 或者 proto2 总结在 MAC 上配置 Protobuf 环境，相比于 ubuntu 和 Gradle 插件的方式，要简单很多，只要按照命令依次执行，基本上不会太大问题。 如果在安装过程中遇到了任何问题，欢迎在评论区留言，一起来完善这份教程，如果没有及时回复，可以来公众号：ByteCode 咨询。","link":"/2020/10/28/android/05-probuff-mac/"},{"title":"Protobuf | 如何在 ubuntu 上安装 Protobuf 编译 proto 文件","text":"相关系列： Protobuf | 安装 Gradle 插件编译 proto 文件 Protobuf | 如何在 ubuntu 上安装 Protobuf 编译 proto 文件 Protobuf | 如何在 MAC 上安装 Protobuf 编译 proto 文件 为什么需要配置 Protobuf 环境因为 Protobuf 是 Google 开源的跨语言编码协议，所以它使用特殊的语法，需要使用 protoc 命令编译成我们需要的语言，目前 Protobuf 可以编译成 6 中语言，分别是：C++ 、C# 、Dart 、Go 、Java 、Python。 Protobuf 环境搭建在 ubuntu 上配置 Protobuf 环境非常简单，首先执行以下命令，下载 Protobuf 编译需要的依赖。 sudo apt-get install autoconf automake libtool curl make g++ unzip -y 下载 protobuf 源码并编译 git clone https://github.com/google/protobuf.gitcd protobufgit submodule update --init --recursive./autogen.sh./configuremakemake checksudo make installsudo ldconfig 按照上面所示的命令依次执行完，等待 10 ~ 20 分钟左右，即可安装成功，等待安装完成之后，执行以下命令验证是否安装成功。 protoc --version 如果出现以下信息代表安装成功。 libprotoc 3.12.3 接下来就可以开始编译 proto 文件。如果出现问题，请参考文末 常见问题 的解决方案 编写 proto 文件测试1. 创建 Person.proto 文件，添加以下内容 syntax = &quot;proto3&quot;;option java_package = &quot;com.hi.dhl.datastore.protobuf&quot;;option java_outer_classname = &quot;PersonProtos&quot;;message Person { string name = 1;} syntax ：指定 protobuf 的版本，如果没有指定默认使用 proto2，必须是.proto文件的除空行和注释内容之外的第一行 option ：表示一个可选字段 java_package ： 指定生成 java 类所在的包名 java_outer_classname ： 指定生成 java 类的名字 message 中包含了一个 string 类型的字段(name)。注意 ：= 号后面都跟着一个字段编号 每个字段由三部分组成：字段类型 + 字段名称 + 字段编号，在 Java 中每个字段会被编译成 Java 对象，其他语言会被编译其他语言类型 2. 执行 protoc 命令 以输出 Java 文件为例，执行以下命令即可输出对应的 Java 文件 protoc --java_out=./src/main/java -I=./ *.proto --java_out ： 指定输出 Java 文件所在的目录 -I ：指定 proto 文件所在的目录 *.proto ： 表示在 -I 指定的目录下查找以 .proto 结尾的文件 常见问题错误一 ： not found 在安装过程中可能会出现以下错误。 ./autogen.sh: 4: ./autogen.sh: autoreconf: not found 原因在于没有按照上面所示的命令执行，重新执行以下命令，即可解决。 sudo apt-get install autoconf automake libtool curl make g++ unzip -y 错误二：cannot open shared object file 安装完成之后，执行 protoc --version 命令后出现以下异常。 protoc: error while loading shared libraries: libprotoc.so.24: cannot open shared object file: No such file or directory 如果出现这个错误，执行以下命令即可解决。 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib 总结在 ubuntu 和 Mac 上安装 Protocol Buffer 相比在 Win 上安装要简单很多，只要按照命令依次执行，基本上不会太大问题。 如果在安装过程中遇到了任何问题，欢迎在评论区留言，一起来完善这份教程，如果没有及时回复，可以来公众号：ByteCode 咨询。 参考文献： https://gist.github.com/diegopacheco/cd795d36e6ebcd2537cd18174865887b","link":"/2020/10/28/android/04-probuff-ubuntu/"},{"title":"Google | 再见 SharedPreferences 拥抱 Jetpack DataStore(一)","text":"Google 新增加了一个新 Jetpack 的成员 DataStore，主要用来替换 SharedPreferences， DataStore 应该是开发者期待已久的库，DataStore 是基于 Flow 实现的，一种新的数据存储方案，它提供了两种实现方式： Proto DataStore：存储类的对象（typed objects ），通过 protocol buffers 将对象序列化存储在本地，protocol buffers 现在已经应用的非常广泛，无论是微信还是阿里等等大厂都在使用，我们在部分业务场景中也用到了 protocol buffers，会在后续的文章详细分析 Preferences DataStore：以键值对的形式存储在本地和 SharedPreferences 类似，但是 DataStore 是基于 Flow 实现的，不会阻塞主线程，并且保证类型安全 Jetpack DataStore 将会分为至少 2 篇文章来分析，今天这篇文章主要来介绍 Jetpack DataStore 其中一种实现方式 Preferences DataStore，文章中的示例代码，已经上传到 GitHub 欢迎前去查看 AndroidX-Jetpack-Practice/DataStoreSimple。 GitHub 地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 这篇文章会涉及到 Koltin flow 相关内容，如果不了解可以先去看另外一篇文章 Kotlin Flow 是什么？Channel 是什么？ 通过这篇文章你将学习到以下内容： 那些年我们所经历的 SharedPreferences 坑？ 为什么需要 DataStore？它为我们解决了什么问题？ 如何在项目中使用 DataStore？ 如何迁移 SharedPreferences 到 DataStore？ MMKV、DataStore、SharedPreferences 的不同之处? 一个新库的出现必定为我们解决了一些问题，那么 Jetpack DataStore 为我们解决什么问题呢，在分析之前，我们需要先来了解 SharedPreferences 都有那些坑。 那些年我们所经历的 SharedPreferences 坑SharedPreference 是一个轻量级的数据存储方式，使用起来也非常方便，以键值对的形式存储在本地，初始化 SharedPreference 的时候，会将整个文件内容加载内存中，因此会带来以下问题： 通过 getXXX() 方法获取数据，可能会导致主线程阻塞 SharedPreference 不能保证类型安全 SharedPreference 加载的数据会一直留在内存中，浪费内存 apply() 方法虽然是异步的，可能会发生 ANR，在 8.0 之前和 8.0 之后实现各不相同 apply() 方法无法获取到操作成功或者失败的结果 接下来我们逐个来分析一下 SharedPreferences 带来的这些问题，在文章中 SharedPreference 简称 SP。 getXXX() 方法可能会导致主线程阻塞所有 getXXX() 方法都是同步的，在主线程调用 get 方法，必须等待 SP 加载完毕，会导致主线程阻塞，下面的代码，我相信小伙伴们并不陌生。 val sp = getSharedPreferences(&quot;ByteCode&quot;, Context.MODE_PRIVATE) // 异步加载 SP 文件内容sp.getString(&quot;jetpack&quot;, &quot;&quot;); // 等待 SP 加载完毕 调用 getSharedPreferences() 方法，最终会调用 SharedPreferencesImpl#startLoadFromDisk() 方法开启一个线程异步读取数据。frameworks/base/core/java/android/app/SharedPreferencesImpl.java private final Object mLock = new Object();private boolean mLoaded = false;private void startLoadFromDisk() { synchronized (mLock) { mLoaded = false; } new Thread(&quot;SharedPreferencesImpl-load&quot;) { public void run() { loadFromDisk(); } }.start();} 正如你所看到的，开启一个线程异步读取数据，当我们正在读取一个比较大的数据，还没读取完，接着调用 getXXX() 方法。 public String getString(String key, @Nullable String defValue) { synchronized (mLock) { awaitLoadedLocked(); String v = (String)mMap.get(key); return v != null ? v : defValue; }}private void awaitLoadedLocked() { ...... while (!mLoaded) { try { mLock.wait(); } catch (InterruptedException unused) { } } ......} 在同步方法内调用了 wait() 方法，会一直等待 getSharedPreferences() 方法开启的线程读取完数据才能继续往下执行，如果读取几 KB 的数据还好，假设读取一个大的文件，势必会造成主线程阻塞。 SP 不能保证类型安全调用 getXXX() 方法的时候，可能会出现 ClassCastException 异常，因为使用相同的 key 进行操作的时候，putXXX 方法可以使用不同类型的数据覆盖掉相同的 key。 val key = &quot;jetpack&quot;val sp = getSharedPreferences(&quot;ByteCode&quot;, Context.MODE_PRIVATE) // 异步加载 SP 文件内容sp.edit { putInt(key, 0) } // 使用 Int 类型的数据覆盖相同的 keysp.getString(key, &quot;&quot;); // 使用相同的 key 读取 Sting 类型的数据 使用 Int 类型的数据覆盖掉相同的 key，然后使用相同的 key 读取 Sting 类型的数据，编译正常，但是运行会出现以下异常。 java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String SP 加载的数据会一直留在内存中通过 getSharedPreferences() 方法加载的数据，最后会将数据存储在静态的成员变量中。 // 调用 getSharedPreferences 方法，最后会调用 getSharedPreferencesCacheLocked 方法public SharedPreferences getSharedPreferences(File file, int mode) { ...... final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked(); return sp;}// 通过静态的 ArrayMap 缓存 SP 加载的数据private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;// 将数据保存在 sSharedPrefsCache 中private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() { ...... ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName); if (packagePrefs == null) { packagePrefs = new ArrayMap&lt;&gt;(); sSharedPrefsCache.put(packageName, packagePrefs); } return packagePrefs;} 通过静态的 ArrayMap 缓存每一个 SP 文件，而每个 SP 文件内容通过 Map 缓存键值对数据，这样数据会一直留在内存中，浪费内存。 apply() 方法是异步的，可能会发生 ANRapply() 方法是异步的，为什么还会造成 ANR 呢？曾今的字节跳动就出现过这个问题，具体详情可以点击这里前去查看 剖析 SharedPreference apply 引起的 ANR 问题 而且 Google 也明确指出了 apply() 的问题。 简单总结一下：apply() 方法是异步的，本身是不会有任何问题，但是当生命周期处于 handleStopService() 、 handlePauseActivity() 、 handleStopActivity() 的时候会一直等待 apply() 方法将数据保存成功，否则会一直等待，从而阻塞主线程造成 ANR，一起来分析一下为什么异步方法还会阻塞主线程，先来看看 apply() 方法的实现。frameworks/base/core/java/android/app/SharedPreferencesImpl.java public void apply() { final long startTime = System.currentTimeMillis(); final MemoryCommitResult mcr = commitToMemory(); final Runnable awaitCommit = new Runnable() { @Override public void run() { mcr.writtenToDiskLatch.await(); // 等待 ...... } }; // 将 awaitCommit 添加到队列 QueuedWork 中 QueuedWork.addFinisher(awaitCommit); Runnable postWriteRunnable = new Runnable() { @Override public void run() { awaitCommit.run(); QueuedWork.removeFinisher(awaitCommit); } }; // 8.0 之前加入到一个单线程的线程池中执行 // 8.0 之后加入 HandlerThread 中执行写入任务 SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);} 将一个 awaitCommit 的 Runnable 任务，添加到队列 QueuedWork 中，在 awaitCommit 中会调用 await() 方法等待，在 handleStopService 、 handleStopActivity 等等生命周期会以这个作为判断条件，等待任务执行完毕 将一个 postWriteRunnable 的 Runnable 写任务，通过 enqueueDiskWrite 方法，将写入任务加入到队列中，而写入任务在一个线程中执行 注意：在 8.0 之前和 8.0 之后 enqueueDiskWrite() 方法实现逻辑各不相同 在 8.0 之前调用 enqueueDiskWrite() 方法，将写入任务加入到 单个线程的线程池 中执行，如果 apply() 多次的话，任务将会依次执行，效率很低，android-7.0.0_r34 源码如下所示。 // android-7.0.0_r34: frameworks/base/core/java/android/app/SharedPreferencesImpl.javaprivate void enqueueDiskWrite(final MemoryCommitResult mcr, final Runnable postWriteRunnable) { ...... QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);}// android-7.0.0_r34: frameworks/base/core/java/android/app/QueuedWork.javapublic static ExecutorService singleThreadExecutor() { synchronized (QueuedWork.class) { if (sSingleThreadExecutor == null) { sSingleThreadExecutor = Executors.newSingleThreadExecutor(); } return sSingleThreadExecutor; }} 通过 Executors.newSingleThreadExecutor() 方法创建了一个 单个线程的线程池，因此任务是串行的，通过 apply() 方法创建的任务，都会添加到这个线程池内。 在 8.0 之后将写入任务加入到 LinkedList 链表中，在 HandlerThread 中执行写入任务，android-10.0.0_r14 源码如下所示。 // android-10.0.0_r14: frameworks/base/core/java/android/app/SharedPreferencesImpl.javaprivate void enqueueDiskWrite(final MemoryCommitResult mcr, final Runnable postWriteRunnable) { ...... QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);}// android-10.0.0_r14: frameworks/base/core/java/android/app/QueuedWork.javaprivate static final LinkedList&lt;Runnable&gt; sWork = new LinkedList&lt;&gt;();public static void queue(Runnable work, boolean shouldDelay) { Handler handler = getHandler(); // 获取 handlerThread.getLooper() 生成 Handler 对象 synchronized (sLock) { sWork.add(work); // 将写入任务加入到 LinkedList 链表中 if (shouldDelay &amp;&amp; sCanDelay) { handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY); } else { handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN); } }} 在 8.0 之后通过调用 handlerThread.getLooper() 方法生成 Handler，任务都会在 HandlerThread 中执行，所有通过 apply() 方法创建的任务，都会添加到 LinkedList 链表中。 当生命周期处于 handleStopService() 、 handlePauseActivity() 、 handleStopActivity() 的时候会调用 QueuedWork.waitToFinish() 会等待写入任务执行完毕，我们以其中 handlePauseActivity() 方法为例。 public void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, PendingTransactionActions pendingActions, String reason) { ...... // 确保写任务都已经完成 QueuedWork.waitToFinish(); ...... }} 正如你所看到的在 handlePauseActivity() 方法中，调用了 QueuedWork.waitToFinish() 方法，会等待所有的写入执行完毕，Google 在 8.0 之后对这个方法做了很大的优化，一起来看一下 8.0 之前和 8.0 之后的区别。 注意：在 8.0 之前和 8.0 之后 waitToFinish() 方法实现逻辑各不相同 在 8.0 之前 waitToFinish() 方法只做了一件事，会一直等待写入任务执行完毕，我先来看看在 android-7.0.0_r34 源码实现。android-7.0.0_r34: frameworks/base/core/java/android/app/QueuedWork.java private static final ConcurrentLinkedQueue&lt;Runnable&gt; sPendingWorkFinishers = new ConcurrentLinkedQueue&lt;Runnable&gt;(); public static void waitToFinish() { Runnable toFinish; while ((toFinish = sPendingWorkFinishers.poll()) != null) { toFinish.run(); // 相当于调用 `mcr.writtenToDiskLatch.await()` 方法 }} sPendingWorkFinishers 是 ConcurrentLinkedQueue 实例，apply 方法会将写入任务添加到 sPendingWorkFinishers 队列中，在 单个线程的线程池 中执行写入任务，线程的调度并不由程序来控制，也就是说当生命周期切换的时候，任务不一定处于执行状态 toFinish.run() 方法，相当于调用 mcr.writtenToDiskLatch.await() 方法，会一直等待 waitToFinish() 方法就做了一件事，会一直等待写入任务执行完毕，其它什么都不做，当有很多写入任务，会依次执行，当文件很大时，效率很低，造成 ANR 就不奇怪了，尤其像字节跳动这种大规模的 App 在 8.0 之后 waitToFinish() 方法做了很大的优化，当生命周期切换的时候，会主动触发任务的执行，而不是一直在等着，我们来看看 android-10.0.0_r14 源码实现。android-10.0.0_r14: frameworks/base/core/java/android/app/QueuedWork.java private static final LinkedList&lt;Runnable&gt; sFinishers = new LinkedList&lt;&gt;();public static void waitToFinish() { ...... try { processPendingWork(); // 主动触发任务的执行 } finally { StrictMode.setThreadPolicy(oldPolicy); } try { // 等待任务执行完毕 while (true) { Runnable finisher; synchronized (sLock) { finisher = sFinishers.poll(); // 从 LinkedList 中取出任务 } if (finisher == null) { // 当 LinkedList 中没有任务时会跳出循环 break; } finisher.run(); // 相当于调用 `mcr.writtenToDiskLatch.await()` } } ......} 在 waitToFinish() 方法中会主动调用 processPendingWork() 方法触发任务的执行，在 HandlerThread 中执行写入任务。 另外还做了一个很重要的优化，当调用 apply() 方法的时候，执行磁盘写入，都是全量写入，在 8.0 之前，调用 N 次 apply() 方法，就会执行 N 次磁盘写入，在 8.0 之后，apply() 方法调用了多次，只会执行最后一次写入，通过版本号来控制的。 SharedPreferences 的另外一个缺点就是 apply() 方法无法获取到操作成功或者失败的结果，而 commit() 方法是可以接收 MemoryCommitResult 里面的一个 boolean 参数作为结果，来看一下它们的方法签名。 public void apply() { ... }public boolean commit() { ... } SP 不能用于跨进程通信我们在创建 SP 实例的时候，需要传入一个 mode，如下所示： val sp = getSharedPreferences(&quot;ByteCode&quot;, Context.MODE_PRIVATE) Context 内部还有一个 mode 是 MODE_MULTI_PROCESS，我们来看一下这个 mode 做了什么 public SharedPreferences getSharedPreferences(File file, int mode) { if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) { // 重新读取 SP 文件内容 sp.startReloadIfChangedUnexpectedly(); } return sp;} 在这里就做了一件事，当遇到 MODE_MULTI_PROCESS 的时候，会重新读取 SP 文件内容，并不能用 SP 来做跨进程通信。 到这里关于 SharedPreferences 部分分析完了，接下来分析一下 DataStore 为我们解决什么问题？ DataStore 解决了什么问题Preferences DataStore 主要用来替换 SharedPreferences，Preferences DataStore 解决了 SharedPreferences 带来的所有问题 Preferences DataStore 相比于 SharedPreferences 优点 DataStore 是基于 Flow 实现的，所以保证了在主线程的安全性 以事务方式处理更新数据，事务有四大特性（原子性、一致性、 隔离性、持久性） 没有 apply() 和 commit() 等等数据持久的方法 自动完成 SharedPreferences 迁移到 DataStore，保证数据一致性，不会造成数据损坏 可以监听到操作成功或者失败结果 另外 Jetpack DataStore 提供了 Proto DataStore 方式，用于存储类的对象（typed objects ），通过 protocol buffers 将对象序列化存储在本地，protocol buffers 现在已经应用的非常广泛，无论是微信还是阿里等等大厂都在使用，我们在部分场景中也使用了 protocol buffers，在后续的文章会详细的分析。 注意： Preferences DataStore 只支持 Int , Long , Boolean , Float , String 键值对数据，适合存储简单、小型的数据，并且不支持局部更新，如果修改了其中一个值，整个文件内容将会被重新序列化，可以运行 AndroidX-Jetpack-Practice/DataStoreSimple 体验一下，如果需要局部更新，建议使用 Room。 在项目中使用 Preferences DataStorePreferences DataStore 主要应用在 MVVM 当中的 Repository 层，在项目中使用 Preferences DataStore 非常简单，只需要 4 步。 1. 需要添加 Preferences DataStore 依赖 implementation &quot;androidx.datastore:datastore-preferences:1.0.0-alpha01&quot; 2. 构建 DataStore private val PREFERENCE_NAME = &quot;DataStore&quot;var dataStore: DataStore&lt;Preferences&gt; = context.createDataStore( name = PREFERENCE_NAME 3. 从 Preferences DataStore 中读取数据 Preferences DataStore 以键值对的形式存储在本地，所以首先我们应该定义一个 Key. val KEY_BYTE_CODE = preferencesKey&lt;Boolean&gt;(&quot;ByteCode&quot;) 这里和我们之前使用 SharedPreferences 的有点不一样，在 Preferences DataStore 中 Key 是一个 Preferences.Key&lt;T&gt; 类型，只支持 Int , Long , Boolean , Float , String，源码如下所示： inline fun &lt;reified T : Any&gt; preferencesKey(name: String): Preferences.Key&lt;T&gt; { return when (T::class) { Int::class -&gt; { Preferences.Key&lt;T&gt;(name) } String::class -&gt; { Preferences.Key&lt;T&gt;(name) } Boolean::class -&gt; { Preferences.Key&lt;T&gt;(name) } Float::class -&gt; { Preferences.Key&lt;T&gt;(name) } Long::class -&gt; { Preferences.Key&lt;T&gt;(name) } ...... // 如果是其他类型就会抛出异常 }} 当我们定义好 Key 之后，就可以通过 dataStore.data 来获取数据 override fun readData(key: Preferences.Key&lt;Boolean&gt;): Flow&lt;Boolean&gt; = dataStore.data .catch { // 当读取数据遇到错误时，如果是 `IOException` 异常，发送一个 emptyPreferences 来重新使用 // 但是如果是其他的异常，最好将它抛出去，不要隐藏问题 if (it is IOException) { it.printStackTrace() emit(emptyPreferences()) } else { throw it } }.map { preferences -&gt; preferences[key] ?: false } Preferences DataStore 是基于 Flow 实现的，所以通过 dataStore.data 会返回一个 Flow&lt;T&gt;，每当数据变化的时候都会重新发出 catch 用来捕获异常，当读取数据出现异常时会抛出一个异常，如果是 IOException 异常，会发送一个 emptyPreferences() 来重新使用，如果是其他异常，最好将它抛出去 4. 向 Preferences DataStore 中写入数据 在 Preferences DataStore 中是通过 DataStore.edit() 写入数据的，DataStore.edit() 是一个 suspend 函数，所以只能在协程体内使用，每当遇到 suspend 函数以挂起的方式运行，并不会阻塞主线程。 以挂起的方式运行，不会阻塞主线程 ：也就是协程作用域被挂起, 当前线程中协程作用域之外的代码不会阻塞。 首先我们需要创建一个 suspend 函数，然后调用 DataStore.edit() 写入数据即可。 override suspend fun saveData(key: Preferences.Key&lt;Boolean&gt;) { dataStore.edit { mutablePreferences -&gt; val value = mutablePreferences[key] ?: false mutablePreferences[key] = !value }} 到这里关于 Preferences DataStore 读取数据和写入数据就已经分析完了，接下来分析一下如何迁移 SharedPreferences 到 DataStore。 迁移 SharedPreferences 到 DataStore迁移 SharedPreferences 到 DataStore 只需要 2 步。 在构建 DataStore 的时候，需要传入一个 SharedPreferencesMigration dataStore = context.createDataStore( name = PREFERENCE_NAME, migrations = listOf( SharedPreferencesMigration( context, SharedPreferencesRepository.PREFERENCE_NAME ) )) 当 DataStore 对象构建完了之后，需要执行一次读取或者写入操作，即可完成 SharedPreferences 迁移到 DataStore，当迁移成功之后，会自动删除 SharedPreferences 使用的文件 注意： 只从 SharedPreferences 迁移一次，因此一旦迁移成功之后，应该停止使用 SharedPreferences。 相比于 MMKV 有什么不同之处最后用一张表格来对比一下 MMKV、DataStore、SharedPreferences 的不同之处，如果发现错误，或者有其他不同之处，期待你来一起完善。 另外在附上一张 Google 分析的 SharedPreferences 和 DataStore 的区别 全文到这里就结束了，这篇文章主要分析了 SharedPreferences 和 DataStore 的优缺点，以及为什么需要引入 DataStore 和如何使用 DataStore，为了节省篇幅源码分析部分会在后续的文章中分析。 关于 SharedPreferences 和 DataStore 相关的代码，已经上传到了 GitHub 欢迎前去查看 AndroidX-Jetpack-Practice/DataStoreSimple ，可以运行一下示例项目，体验一下 SharedPreferences 和 DataStore 效果。 GitHub 地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 参考文献 Preferences DataStore codelab Now in Android #25 Prefer Storing Data with Jetpack DataStore 剖析 SharedPreference 引起的 ANR 问题 SharedPreferences 问题分析和解决 结语在国庆期间我梳理了 LeetCode / 剑指 offer 及国内外大厂面试题解，截止到目前为止我已经在 LeetCode 上 AC 了 124+ 题，每题都会用 Java 和 kotlin 去实现，并且每题都有多种解法、解题思路、时间复杂度、空间复杂度分析，题库逐渐完善中，欢迎前去查看。 剑指 offer 及国内外大厂面试题解：在线阅读 LeetCode 系列题解：在线阅读","link":"/2020/10/19/jetpack/11-DataStore/"},{"title":"Kotlin StateFlow 搜索功能的实践 DB + NetWork","text":"前言在之前分享过一篇文章 Google 推荐在 MVVM 架构中使用 Kotlin Flow ，在这篇文章中分析了如何在 MVVM 架构中使用 Kotlin Flow，以及 Kotlin Flow 为我们解决了以下问题： LiveData 是一个生命周期感知组件，最好在 View 和 ViewModel 层中使用它，如果在 Repositories 或者 DataSource 中使用会有几个问题 它不支持线程切换，其次不支持背压，也就是在一段时间内发送数据的速度 &gt; 接受数据的速度，LiveData 无法正确的处理这些请求 使用 LiveData 的最大问题是所有数据转换都将在主线程上完成 RxJava 虽然支持线程切换和背压，但是 RxJava 那么多傻傻分不清楚的操作符，实际上在项目中常用的可能只有几个例如 Observable 、 Flowable 、 Single 等等，如果我们不去了解背后的原理，造成内存泄露是很正常的事，大家可以从 StackOverflow 上查看一下，有很多因为 RxJava 造成内存泄露的例子 RxJava 入门的门槛很高，学习过的朋友们，我相信能够体会到从入门到放弃是什么感觉 解决回调地狱的问题 而相对于以上的不足，Flow 有以下优点： Flow 支持线程切换、背压 Flow 入门的门槛很低，没有那么多傻傻分不清楚的操作符 简单的数据转换与操作符，如 map 等等 Flow 是对 Kotlin 协程的扩展，让我们可以像运行同步代码一样运行异步代码，使得代码更加简洁，提高了代码的可读性 易于做单元测试 而这篇文章主要来分析一下 PokemonGo 搜索功能的实践，主要包含以下几个方面的内容： Kotlin Flow 是什么？以及如何使用？ 如何区分末端操作符还是中间操作符？ Kotlin Channel 是什么？以及如何使用？ Kotlin Channel 都有那几种类型？ BroadcastChannels 是什么？以及如何在项目中使用？ StateFlow 是什么？以及如何在项目中使用？ Kotlin 常用操作符 debounce 、filter 、flatMapLatest 、 distinctUntilChanged 解析？ 之前有很多朋友跟我反馈，如何使用 Flow 实现搜索功能，所以我在 PokemonGo 项目中增加了两种搜索场景，分别演示 BroadcastChannels 和 StateFlow 的用法。 使用 ConflatedBroadcastChannel 实现 DB 搜索 使用 StateFlow 实现 NetWork 搜索 在分析这两种实现方式之前，需要先了解几个基本概念， Flow 和 Channel 是什么，以及常用的操作符 debounce 、filter 、flatMapLatest 、 distinctUntilChanged 等等的使用，Flow 和 Channel 是一个比较大的概念，后面我会花好几篇文章来分析它们，本文只会概述它们之间的区别。 Kotlin Flow 是什么先来看看 Kotlin 官方文档是如何介绍 Flow 将上面这段话，简单的总结一下： Flow 是非阻塞的，以挂起的方式执行，只有遇到末端操作符，才会触发所有操作的执行 所有操作都在相同的代码块内顺序执行 发射出来的值都是顺序执行的，只有在某一时刻结束（遇到 末端操作符 或者出现异常） map , filter , take , zip 等等是中间操作符，collect , collectLatest , single , reduce , toList 等等末端操作符 中间操作符构建了一个待执行的调用链，如下图所示： 不阻塞，以挂起的方式执行 ：也就是协程作用域被挂起, 当前线程中协程作用域之外的代码不会阻塞 接下来我们来看一段示例： suspend fun printValue() = flow&lt;Int&gt; { for (index in 1..10) { emit(index) }}.map { it -&gt; it * it } // map, filter, take, zip 等等是中间操作符.filter { it -&gt; it &gt; 5 } .toList() // 只有遇到末端操作符 collect, collectLatest,single, reduce, toList 等等才会触发所有操作的执行 遇到中间操作符，并不会执行任何操作，也不会挂起函数本身，这些操作符构建了一个待执行的调用链 末端操作符是可挂起函数，遇到末端操作符会触发所有操作的执行 如何区分末端操作符还是中间操作符区分末端操作符还是中间操作符，可以按照是否是挂起函数来区分，我个人觉得按照挂起函数来区分，方便去记忆上面提到的 Flow 的几个特点，当然也可以按照其他方式来区分，我们一起来分析一下源码。 // 中间操作符是 Flow 的扩展函数，它们最后都是通过 emit 来发射数据public inline fun &lt;T&gt; Flow&lt;T&gt;.filter(crossinline predicate: suspend (T) -&gt; Boolean): Flow&lt;T&gt; = transform { value -&gt; if (predicate(value)) return@transform emit(value)}// 末端操作符是一个挂起函数// 末端操作符无论是 collectLatest,single, reduce, toList 最后都是调用 collectpublic suspend fun &lt;T&gt; Flow&lt;T&gt;.toList(destination: MutableList&lt;T&gt; = ArrayList()): List&lt;T&gt; = toCollection(destination)public suspend fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Flow&lt;T&gt;.toCollection(destination: C): C { collect { value -&gt; destination.add(value) } return destination} 中间操作符是 Flow 的扩展函数，它们最后都是通过 emit 来发射数据 末端操作符是一个挂起函数 末端操作符无论是 collectLatest , single , reduce , toList 最后都是调用 collect Kotlin Channel 是什么来看看 Kotlin 官方文档是如何介绍 Channel 将上面这段话，简单的总结一下： Channel 是非阻塞的，它用于发送方 (SendChannel) 和接收方 (ReceiveChannel) 之间通信 Channel 实现了 SendChannel 和 ReceiveChannel 接口，所以既可以发送数据又可以接受数据 Channel 和 Java 中的 BlockingQueue 类似，不同之处在于 BlockingQueue 是阻塞的，而 Channel 是挂起的 发送方 (SendChannel) 和接收方 (ReceiveChannel) 之间通过缓冲区进行同步的，如下图所示： 通过发送方 (SendChannel) 将数据发送到缓冲区 通过接收方 (ReceiveChannel) 从缓冲区获取数据 发送方 (SendChannel) 和 接收方 (ReceiveChannel) 之间有一个通道，也就是缓冲区 缓冲区的作用帮我们同步发送方 (SendChannel) 和 接收方 (ReceiveChannel) 发送和接受的数据，也就意味着多个协程可以向同一个 channel 发送数据, 一个 channel 的数据也可以被多个协程接收 我们来实现一个简易的消息发送和接受的例子： val channel = Channel&lt;Int&gt;()// 接受消息suspend fun receiveEvent() { coroutineScope { while (!channel.isClosedForReceive) { // receive()方法异步获取元素，如果缓冲区是空，receive() 调用者将被挂起，直到一个新值被发送到缓冲区 // receive() 是一个挂起函数，用于同步发送方和接收方的一种机制 channel.receive() // poll()方法同步获取一个元素，如果缓冲区是空的，则返回null // channel.poll() } }}// 发送消息suspend fun postEvent() { coroutineScope { if (!channel.isClosedForSend) { (1..10).forEach { // 如果缓冲区没有满，则立即添加元素， // 如果缓冲区满了调用者会被挂起 // send() 是一个挂起函数，用于同步发送方和接收方的一种机制 channel.send(it) // offer()：如果缓冲区存在并且没有满立即向缓冲区添加一个元素 // 如果添加成功会返回true, 失败会返回 false // channel.offer(it) } } }} 正如你所看到的 发送 和 接受 都有两个方法，分别来分析一下他们的区别。 send() 和 offer() 的区别： send(element: E) ：如果缓冲区没有满，则立即添加元素， 如果缓冲区满了调用者会被挂起，send() 方法是一个挂起函数，用于同步发送方和接收方的一种机制 offer(element: E): Boolean ：如果缓冲区存在并且没有满立即向缓冲区添加一个元素，添加成功会返回 true, 失败会返回 false receive() 和 poll() 的区别： receive(): E ：异步获取元素，如果缓冲区是空时调用者会被挂起，直到一个新值被发送到缓冲区，receive() 方法是一个挂起函数，用于同步发送方和接收方的一种机制 poll(): E?：用于同步获取一个元素，如果缓冲区是空的，则返回 null Flow 与 Channel 的区别： Flow ：中间操作符 (map , filter 等等) 会构建了一个待执行的调用链，只有遇到末端操作符 (collect , toList 等等) 才会触发所有操作的执行，所以 Flow 也被称为冷数据流 Channel ：发送方 (SendChannel) 发送数据，并不依赖于接受方（ReceiveChannel），所以 Channel 也被称为热数据流 Channel 的不同类型Channel 对应着有四种不同的类型： RendezvousChannel ：这是默认的类型，大小为 0 的缓冲区，只有当 send() 方法和 receive() 方法都调用的时候，元素才会从发送方传输到接收方，否则将会被挂起 LinkedListChannel ：通过 Channel.Factory.CONFLATED 会创建一个容量无限的缓冲区 (受限于内存的大小) ，send() 方法远不会挂起，offer() 方法始终返回 true ConflatedChannel ：最多缓冲一个元素，新元素会覆盖掉旧元素，只会接收最后发送的元素，之前的元素都会丢失，send() 方法永远不会挂起，offer() 方法始终返回 true ArrayChannel ：通过 Channel.Factory.BUFFERED 或者 指定大小 会创建一个固定容量的数组缓冲区，send() 方法仅在缓冲区满时挂起，receive() 方法仅在缓冲区为空时挂起 创建四种不同类型 channel 的方式: val rendezvousChannel = Channel&lt;Int&gt;()val linkedListChannel = Channel&lt;Int&gt;(Channel.Factory.UNLIMITED)val conflatedChannel = Channel&lt;Int&gt;(Channel.Factory.CONFLATED)// 指定数字 或者 通过 Channel.Factory.BUFFERED 都会创建创建一个固定容量的数组缓冲区val bufferedChannel = Channel&lt;Int&gt;(Channel.Factory.BUFFERED) // 创建默认容量的数组缓冲区val arrayChannel = Channel&lt;Int&gt;(30) // 创建指定容量的数组缓冲区 上面创建 channel 的方式，对应的源码： public fun &lt;E&gt; Channel(capacity: Int = RENDEZVOUS): Channel&lt;E&gt; = when (capacity) { RENDEZVOUS -&gt; RendezvousChannel() UNLIMITED -&gt; LinkedListChannel() CONFLATED -&gt; ConflatedChannel() BUFFERED -&gt; ArrayChannel(CHANNEL_DEFAULT_CAPACITY) else -&gt; ArrayChannel(capacity) } BroadcastChannels 是什么来看看 Kotlin 官方文档是如何介绍 BroadcastChannels BroadcastChannels 是非阻塞的，它用于发送方 (SendChannel) 和接收方 (ReceiveChannel) 之间通信 BroadcastChannels 实现了 SendChannel 接口，所以只可以发送数据 BroadcastChannels 提供了 openSubscription 方法，会返回一个新的 ReceiveChannel，可以从缓冲区获取数据 通过 BroadcastChannels 发送的数据，所有接收方 (ReceiveChannel) 都会收到，如下图所示 BroadcastChannels 是一个接口，而它的子类有 ConflatedBroadcastChannel、ArrayBroadcastChannel，这里主要介绍一下 ConflatedBroadcastChannel，ConflatedBroadcastChannel 重写了 openSubscription 方法。 public override fun openSubscription(): ReceiveChannel&lt;E&gt; { val subscriber = Subscriber(this) ...... // 省略很多无关的代码 return subscriber} openSubscription 方法返回一个 ReceiveChannel 作为接受者 在 openSubscription 方法内，创建了一个 Subscriber 的实例 Subscriber 其实是 ConflatedBroadcastChannel 的内部类，它实现了 ReceiveChannel 接口。 private class Subscriber&lt;E&gt;( private val broadcastChannel: ConflatedBroadcastChannel&lt;E&gt;) : ConflatedChannel&lt;E&gt;(), ReceiveChannel&lt;E&gt; 正如你所见 Subscriber 继承 ConflatedChannel 同时实现了 ReceiveChannel 接口，而 ConflatedChannel 在上文介绍过了，最多缓冲一个元素，新元素会覆盖掉旧元素，只会接收最后发送的元素，之前的元素都会丢失，所以 ConflatedBroadcastChannel 适合用来实现搜索相关的功能，因为用户只对最后一次搜索结果感兴趣。 注意： StateFlow 将会取代 ConflatedBroadcastChannel 下文有介绍 使用 ConflatedBroadcastChannel 实现 DB 搜索我在 PokemonGo 项目中增加了两种搜索场景，分别通过 BroadcastChannels 和 StateFlow 来实现，通过 ConflatedBroadcastChannel 实现 DB 搜索，只需要两步 1.在 Activity 中监听 ConflatedBroadcastChannel 的变化src/main/java/com/hi/dhl/pokemon/ui/main/MainActivity.kt // searchView 是一个 AppCompatEditText，当然你可以使用 androidx.appcompat.widget.SearchView，或者其他searchView.addTextChangedListener { val result = it.toString() // 调用 queryParamterForDb 方法过滤用户的输入，并查询数据库 mViewModel.queryParamterForDb(result) }// 监听查询结果mViewModel.searchResultForDb.observe(this, Observer { mPokemonAdapter.submitData(lifecycle, it)}) 接受用户输入的数据，并调用 queryParamterForDb 方法过滤用户的输入，然后查询数据库 通过 searchResultForDb.observe 方法监听查询结果 2. 在 MainViewModel 中实现 queryParamterForDb 方法src/main/java/com/hi/dhl/pokemon/ui/main/MainViewModel.kt // 根据关键词搜索fun queryParamterForDb(paramter: String) = mChanncel.offer(paramter)// 使用 ConflatedBroadcastChannel 进行搜索val searchResultForDb = mChanncel.asFlow() // 避免在单位时间内，快输入造成大量的请求 .debounce(200) // 避免重复的搜索请求。假设正在搜索 dhl，用户删除了 l 然后输入 l。最后的结果还是 dhl。它就不会再执行搜索查询 dhl // distinctUntilChanged 对于 StateFlow 任何实例是没有效果的 .distinctUntilChanged() .flatMapLatest { search -&gt; // 只显示最后一次搜索的结果，忽略之前的请求 pokemonRepository.fetchPokemonByParameter(search).cachedIn(viewModelScope) } .catch { throwable -&gt; // 异常捕获 }.asLiveData() 通过 mChanncel.offer 发送数据 通过 mChanncel.asFlow() 方法，将 Channel 转换为 Flow 并调用 debounce 、 distinctUntilChanged 、 flatMapLatest 过掉用户的输入数据，这些操作符在后文会详细分析 最后查询数据库，返回结果，项目中使用的是通过 Paging3 查询本地数据库，关于如何实现可以查看另外一篇文章 Jetpack 成员 Paging3 数据实践以及源码分析（一） 重点： 在 Kotlin coroutines library (1.3.6) 版本中增加了一个新类 StateFlow，它的设计和 ConflatedBroadcastChannel 相同，将来计划完全取代 ConflatedBroadcastChannel StateFlow 是什么在前面的内容提到了很多次 StateFlow，那么 StateFlow 是什么，它与 Flows 和 Channels 有什么关系呢，来看看 Kotlin 官方文档是如何介绍 StateFlow 将上面这段话，简单的总结一下： StateFlow 实现了 Flow 接口，它仅仅表示一种可读的状态，它的值是不变的，用于外部调用 public interface StateFlow&lt;out T&gt; : Flow&lt;T&gt; { public val value: T // val 关键字表示不可变的} StateFlow 提供了一个可变的版本 MutableStateFlow，它的值是可变的，用于内部调用 public interface MutableStateFlow&lt;T&gt; : StateFlow&lt;T&gt; { public override var value: T // var 表示可变的} StateFlow 与 Flow 的不同之处在于，StateFlow 仅仅表示一种状态，不依赖于特定的上下文，而 Flow 操作执行是在 CoroutineScope 内的，换句话说 StateFlow 不需要在协程的作用域内，它也可以执行 刚才我们提到 StateFlow 的出现是为了取代 ConflatedBroadcastChannel，那么它与 ConflatedBroadcastChannel 有什么不同之处： StateFlow 实现更加简单，不需要实现所有 Channel API，而 ConflatedBroadcastChannel 在其内部封装了 ConflatedChannel 和 BroadcastChannels StateFlow 内部有个变量 value，无论任何时候都可以安全的访问 StateFlow 实现读写分离，StateFlow 用来读而 MutableStateFlow 用来写 StateFlow 内部使用 Any.equals 来比较新值与旧值，和 distinctUntilChanged 方式相同，所以在 StateFlow 上应用 distinctUntilChanged 是没有效果的 StateFlow 源码： if (oldState == newState) return // 如果值没有改变，不会做任何事 distinctUntilChanged 源码 public fun &lt;T, K&gt; Flow&lt;T&gt;.distinctUntilChangedBy(keySelector: (T) -&gt; K): Flow&lt;T&gt; = distinctUntilChangedBy(keySelector = keySelector, areEquivalent = { old, new -&gt; old == new }) 使用 StateFlow 实现 NetWork 搜索StateFlow 和 ConflatedBroadcastChannel 一样，实现搜索功能只需要两步 1.在 Activity 中监听 ConflatedBroadcastChannel 的变化src/main/java/com/hi/dhl/pokemon/ui/main/MainActivity.kt // searchView 是一个 AppCompatEditText，当然你可以使用 androidx.appcompat.widget.SearchView 或者其他searchView.addTextChangedListener { val result = it.toString() // 调用 queryParamterForNetWork 方法过滤用户的输入，并查询网络 mViewModel.queryParamterForNetWork(result)}mViewModel.searchResultMockNetWork.observe(this, Observer { // 网络搜索回调监听}) 接受用户输入的数据，并调用 queryParamterForNetWork 方法过滤用户的输入，通过网络查询关键字 通过 searchResultMockNetWork.observe 方法监听查询结果 2. 在 MainViewModel 中实现 queryParamterForNetWork 方法src/main/java/com/hi/dhl/pokemon/ui/main/MainViewModel.kt // 根据关键词搜索fun queryParamterForNetWork(paramter: String) { _stateFlow.value = paramter}// 因为没有合适的搜索接口，在这里模拟进行网络搜索val searchResultMockNetWork = // 避免在单位时间内，快输入造成大量的请求 stateFlow.debounce(200) .filter { result -&gt; if (result.isEmpty()) { // 过滤掉空字符串等等无效输入 return@filter false } else { return@filter true } } .flatMapLatest { // 只显示最后一次搜索的结果，忽略之前的请求 // 网络请求，这里替换自己的实现即可 } .catch { throwable -&gt; // 异常捕获 } .asLiveData() 通过 _stateFlow.value 更新数据 调用 debounce 、filter 、flatMapLatest 等等操作符过滤掉无效的请求 常用操作符解析在 PokemonGo 项目中使用 debounce 、filter 、flatMapLatest 、 distinctUntilChanged 等等操作符，一起来详细的分析一下这些操作符的含义，以及如何使用。 debounce debounce 也叫做防抖动函数，当用户在很短的时间内输入 “d”，”dh”，”dhl”，但是用户可能只对 “dhl” 的搜索结果感兴趣，因此我们必须舍弃 “d”，”dh” 过滤掉不需要的请求，针对于这个情况，我们可以使用 debounce 函数，在指定时间内出现多个字符串，debounce 始终只会发出最后一个字符串，我们来看个例子。 val result = flow { emit(&quot;h&quot;) emit(&quot;i&quot;) emit(&quot;d&quot;) delay(90) emit(&quot;dh&quot;) emit(&quot;dhl&quot;)}.debounce(200).toList()println(result) // 最后输出：dhl filter filter 操作符用于过滤不需要的字符串，在 PokemonGo 项目中只过滤了空字符串，我们来看个例子。 val result = flow { emit(&quot;h&quot;) emit(&quot;i&quot;) emit(&quot;d&quot;) delay(90) emit(&quot;dh&quot;) emit(&quot;dhl&quot;)}.filter { result -&gt; if (!result.equals(&quot;dhl&quot;)) { return@filter false } else { return@filter true }}.toList()println(result) // 最后输出：dhl flatMapLatest flatMapLatest 避免向用户展示不需要的结果，只提供最后一个搜索查询（最新）的结果，例如，正在查询 “dh”，然后用户输入 “dhl”, 这个时候用户对 “dh” 的结果不感兴趣，可能只对 “dhl” 的结果感兴趣，这个时候可以使用 flatMapLatest，我们来看个例子。 flow { emit(&quot;dh&quot;) emit(&quot;dhl&quot;)}.flatMapLatest { value -&gt; flow&lt;String&gt; { delay(100) println(&quot;collected $value&quot;) // 最后输出 collected dhl }}.collect() 注意： flatMapLatest 在 Kotlin coroutines library (1.3.20) 以下版本使用会出现以下错误。 IllegalStateException crash: call to 'resume' before 'invoke' with coroutine Kotlin 团队在 Kotlin coroutines library (1.3.20) 以上修复了这个问题，如果出现这个问题，将版本升级到 1.3.20 以上即可 issues 地址。 DistinctUntilChanged distinctUntilChanged 操作符用来过滤掉重复的请求，只有当前值与最后一个值不同时才将其发出，我们来看个例子。 val result = flow { emit(&quot;d&quot;) emit(&quot;d&quot;) emit(&quot;d&quot;) emit(&quot;d&quot;) emit(&quot;dhl&quot;) emit(&quot;dhl&quot;) emit(&quot;dhl&quot;) emit(&quot;dhl&quot;)}.distinctUntilChanged().toList()println(result) // 输出 [d, dhl] StateFlow 内部已经实现了类似于 distinctUntilChanged 操作符的功能，因此 distinctUntilChanged 应用在 StateFlow 上是没有效果的 我们一起来分析 distinctUntilChanged 操作符源码是如何实现的 public fun &lt;T&gt; Flow&lt;T&gt;.distinctUntilChanged(): Flow&lt;T&gt; = when (this) { is StateFlow&lt;*&gt; -&gt; this else -&gt; distinctUntilChangedBy { it } } distinctUntilChanged 是 Flow 的扩展函数 如果当前对象是 StateFlow，直接返回调用者本身 如果不是 StateFlow 就会调用 distinctUntilChangedBy 方法 public fun &lt;T, K&gt; Flow&lt;T&gt;.distinctUntilChangedBy(keySelector: (T) -&gt; K): Flow&lt;T&gt; = distinctUntilChangedBy(keySelector = keySelector, areEquivalent = { old, new -&gt; old == new }) 最后会调用 areEquivalent 方法进行比较，会过滤掉所有相同值的 全文到这里就结束了，效果图如下所示，如果效果图无法查看，请点击这里查看 效果图 文章中提到的 PokemonGo(神奇宝贝) 是基于 Jetpack + MVVM + Data Mapper + Repository + Paging3 + App Startup + Hilt + Kotlin Flow + Motionlayout + Coil 等等技术综合实战项目，点击这里前往查看 参考文献 kotlinx.coroutines.channels kotlinx.coroutines.flow Implementing Search Filter using Kotlin Going deep on Flows &amp; Channels Implement Instant Search Using Kotlin Flow Operators","link":"/2020/09/29/kotlin/04-StateFlow/"},{"title":"Kotlin Sealed 是什么？为什么 Google 都用","text":"写这篇文章之前，做了很多调研，查阅了很多资料，文章也反复推敲打磨了很多遍，为什么我要去做这么多的调研工作，因为 Sealed Classes 概念很简单，但是想要写好它很难，由于目前我对 Sealed Classes 的理解也有限，所以做了很多工作。希望这篇文章的内容不会让小伙伴们失望，如果你对 Sealed Classes 有独到的理解，也欢迎在评论区和大家一起分享。 在上一篇文章 Google 推荐在项目中使用 Sealed 和 RemoteMediator 中介绍了如何使用 Sealed Classes 在 Flow 基础上对网络请求成功和失败进行处理，而这篇文章是对 Sealed Classes 更加深入的解析，结合函数式编程功能很强大，掌握并且灵活运用它，需要大量的实践。 通过这篇文章你将学习到以下内容： Sealed Classes 原理分析？ 枚举和抽象类都有那些局限性？ 为什么枚举可以作为单例？枚举作为单例有那些优点？ 分别在什么情况下使用枚举和 Sealed Classes？ Sealed Classes 究竟是什么？ 为什么 Sealed Classes 用于表示受限制的类层次结构？ 为什么说 Sealed Classes 是枚举类的扩展？ Sealed Classes 的子类可以表示不同状态的实例，那么在项目中如何使用？ 禁止在 Sealed Classes 所定义的文件外使用， Kotlin 是如何做到的呢？ 枚举和抽象类的局限性在分析 Sealed Classes 之前，我们先来分析一下枚举和抽象类都有那些局限性，注意：这些局限性是相对于 Sealed Classes 而言的，但是相对于它们自身而言是优点，而 Sealed Classes 出现也正是为了解决这些问题。先来看一下枚举的局限性： 限制枚举每个类型只允许有一个实例 限制所有枚举常量使用相同的类型的值 限制枚举每个类型只允许有一个实例enum class Color(val value: Int) { Red(1)}fun main(args: Array&lt;String&gt;) { val red1 = Color.Red val red2 = Color.Red println(&quot;${red1 == red2}&quot;) // true} 最后输出结果 red1 == red2 : true 正如你看到的，我们定义了一个单元素的枚举类型，无论 Color.Red 有多少个对象，最终他们的实例都是一个，每个枚举常量仅作为一个实例存在，而一个密封类的子类可以有多个包含状态的实例，这既是枚举的局限性也是枚举的优点。 枚举常量作为一个实例存在的优点： 枚举不仅能防止多次实例化，而且还可以防止反序列化，还能避免多线程同步问题，所以它也被列为实现单例方法之一。简单汇总一下。 是否只有一个实例 是否反序列化 是否是线程安全 是否是懒加载 是 是 是 否 《Effective Java》 一书的作者 Josh Bloch 建议我们使用枚举作为单例，虽然使用枚举实现单例的方法还没有广泛采用，但是单元素的枚举类型已经成为实现 Singleton 的最佳方法。 我们来看一下如何用枚举实现一个单例（与 Java 的实现方式相同），这里不会深究其原理，因为这不是本文的重点内容，小伙伴们可以从掘金搜索，有很多分析这方面原理的文章。 interface ISingleton { fun doSomething()}enum class Singleton : ISingleton { INSTANCE { override fun doSomething() { // to do } }; fun getInstance(): Singleton = Singleton.INSTANCE} 但是在实际项目中使用枚举作为单例的很少，我看了很多开源项目，将枚举作为单例的场景少之有少，很大部分原因是因为使用枚举的时候非常不方便。 我这有个建议如果涉及反序列化创建对象的时候，建议使用枚举，因为 Java 规定，枚举的序列化和反序列化是有特殊定制的，因此禁用编译器使用 writeObject 、readObject 、readObjectNoData 、 writeReplace 、readResolve 等方法。 限制所有枚举常量使用相同的类型的值限制所有枚举常量使用相同的类型的值，也就是说每个枚举常量类型的值是相同的，我们还是用刚才的例子做个演示。 enum class Color(val value: Int) { Red(1), Green(2), Blue(3);} 正如你所见，我们在枚举 Color 中定义了三个常量 Red 、Green 、Blue，但是它们只能使用 Int 类型的值，不能使用其他类型的值，如果使用其它类型的值会怎么样？如下所示： 编译器会告诉你只接受 Int 类型的值，无法更改它的类型，也就是说你无法为枚举类型，添加额外的信息。 抽象类的局限性对于一个抽象类我们可以用一些子类去继承它，但是子类不是固定的，它可以随意扩展，同时也失去枚举常量的受限性。 Sealed Classes 包含了抽象类和枚举的优势：抽象类表示的灵活性和枚举常量的受限性 到这里可能会有一个疑问，如果 Sealed Classes 没有枚举和抽象类的局限性，那么它能在实际项目中给我们带来哪些好处呢？在了解它能带来哪些好处之前，我们先来看看官方对 Sealed Classes 的解释。 Sealed Classes 是什么？我们先来看一下官方对 Sealed Classes 的解释 我们将上面这段话，简单的总结一下： Sealed Classes 用于表示受限制的类层次结构 从某种意义上说，Sealed Classes 是枚举类的扩展 枚举的不同之处在于，每个枚举常量仅作为单个实例存在，而 Sealed Classes 的子类可以表示不同状态的实例 那上面这三段话分别是什么意思呢？接下来我们围绕这三个方面来分析。 Sealed Classes 用于表示受限制的类层次结构Sealed Classes 用于表示受限制的类层次结构，其实这句话可以拆成两句话来理解。 Sealed Classes 用于表示层级关系： 子类可以是任意的类， 数据类、Kotlin 对象、普通的类，甚至也可以是另一个 Sealed Sealed Classes 受限制： 必须在同一文件中，或者在 Sealed Classes 类的内部中使用，在Kotlin 1.1 之前，规则更加严格，子类只能在 Sealed Classes 类的内部中使用 Sealed Classes 的用法也非常的简单，我们来看一下如何使用 Sealed Classes。 sealed class Color { class Red(val value: Int) : Color() class Green(val value: Int) : Color() class Blue(val name: String) : Color()}fun isInstance(color: Color) { when (color) { is Color.Red -&gt; TODO() is Color.Green -&gt; TODO() is Color.Blue -&gt; TODO() }} 在这里推荐大家一个快捷键 Mac/Win/Linux：Alt + Enter 可以补全 when 语句下的所有分支，效果如下所示： 更多 AndroidStudio 快捷键，可以看之前的两篇文章 为数不多的人知道的AndroidStudio快捷键(一) 为数不多的人知道的AndroidStudio快捷键(二) Sealed Classes 是枚举类的扩展从某种意义上说，Sealed Classes 是枚举类的扩展，其实 Sealed Classes 和枚举很像，我们先来看一个例子。 正如你所看到的，在 Sealed Classes 内部中，使用 object 声明时，我们可以重用它们，不需要每次创建一个新实例，当这样使用时候，它看起来和枚举非常相似。 注意：实际上很少有人会这么使用，而且也不建议这么用，因为在这种情况枚举比 Sealed Classes 更适合 在什么情况下使用枚举如果你不需要多次实例化，也不需要不提供特殊行为，或者也不需要添加额外的信息，仅作为单个实例存在，这个时候使用枚举更加合适。 我们来看一下 Paging3 中是如何使用枚举的，一起来看一下 androidx.paging.LoadType 这个类的源码。 enum class LoadType { REFRESH, PREPEND, APPEND} 枚举常量 作用 refresh 在初始化刷新的使用 append 在加载更多的时候使用 prepend 在当前列表头部添加数据的时候使用 它们不需要多次实例化，也不需要添加任何额外的信息，仅仅表示某种状态，而且它在很多地方都会用到比如 RemoteMediator、PagingSource 等等，想了解更多关于 Paging3 原理和实战案例可以看之前写的几篇文章。 Jetpack 成员 Paging3 数据库实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack 成员 Paging3 使用 RemoteMediator 实现加载网络分页数据并更新到数据库中（三） 神奇宝贝(PokemonGo) 眼前一亮的 Jetpack + MVVM 极简实战 4.Sealed Classes 的子类可以表示不同状态的实例与枚举的不同之处在于，每个枚举常量仅作为单个实例存在，而 Sealed Classes 的子类可以表示不同状态的实例，我们来看个例子可能更容易理解这句话。 这里我们延用之前在 Google 推荐在项目中使用 sealed 和 RemoteMediator 这篇文章中用到的例子，在请求网络的时候需要对成功或者失败进行处理，我们来看一下用 Sealed Classes 如何进行封装。 sealed class PokemonResult&lt;out T&gt; { data class Success&lt;out T&gt;(val value: T) : PokemonResult&lt;T&gt;() data class Failure(val throwable: Throwable?) : PokemonResult&lt;Nothing&gt;()} 这里只贴出来部分代码，核心实现可以查看项目 PokemonGoGitHub 地址：https://github.com/hi-dhl/PokemonGo代码路径：PokemonGo/app/…/com/hi/dhl/pokemon/data/remote/PokemonResult.kt 一起来看一下如何使用 when (result) { is PokemonResult.Failure -&gt; { // 进行失败提示 } is PokemonResult.Success -&gt; { // 进行成功处理 }} 我们在来看另外一个例子，在一个列表中可能会有不同类型的数据，比如图片、文本等等，那么用 Sealed Classes 如何表示。 sealed class ListItem { class Text(val title: String, val content: String) : ListItem() class Image(val url: String) : ListItem()} 这是两个比较常见的例子，当然 Sealed Classes 强大不止于此，还有更多场景，等着一起来挖掘。 我们来看一下大神 Antonio Leiva 在这篇文章 Sealed classes in Kotlin: enums with super-powers 分享的一个比较有趣的例子，对 View 进行的一系列操作可以封装在 Sealed Classes 中，我们来看一下会有什么样的效果。 sealed class UiOp { object Show: UiOp() object Hide: UiOp() class TranslateX(val px: Float): UiOp() class TranslateY(val px: Float): UiOp()}fun execute(view: View, op: UiOp) = when (op) { UiOp.Show -&gt; view.visibility = View.VISIBLE UiOp.Hide -&gt; view.visibility = View.GONE is UiOp.TranslateX -&gt; view.translationX = op.px is UiOp.TranslateY -&gt; view.translationY = op.px} 在 Sealed Classes 类中，我们定义了一系列 View 的操作 Show 、 Hide 、 TranslateX 、 TranslateY ，现在我们创建一个类，将这些对视图的操作整合在一起。 class Ui(val uiOps: List = emptyList()) { operator fun plus(uiOp: UiOp) = Ui(uiOps + uiOp)} 在 Ui 这个类中声明了一个 List 存储了所有的操作，并重写了 plus 操作符，关于 plus 操作符可以看之前的文章 为数不多的人知道的 Kotlin 技巧以及 原理解析，通过 plus 操作符将这些对视图的操作拼接在一起，这样不仅可以提高代码的可读性，而且使用起来也非常的方便，都定义好之后，我们来看一下如何使用这个类。 val ui = Ui() + UiOp.Show + UiOp.TranslateX(20f) + UiOp.TranslateY(40f) + UiOp.Hide run(view, ui) 定义了一系列操作之后，然后通过 run 方法来执行这些操作，来看一下 run 方法的实现。 fun run(view: View, ui: Ui) { ui.uiOps.forEach { execute(view, it) }} 代码很简单，这里就不多做解释了，在 kotlin 中函数可以作为参数传递，可以将 run 方法传递给另一个函数或者一个类，并且这些操作完全可互换的，将它们结合在一起功能将非常强大。 Sealed Classes 强大不止于此，还有很多很多非常实用的场景，现在我对 Sealed Classes 的理解也非常有限，还不够灵活的使用它，我相信在更多项目，更多的场景，会看到更多实用的一些技巧。 Sealed Classes 原理在这里我们还是使用上文中用到的例子，来分析 Sealed Classes 原理。 sealed class Color { object Red : Color() object Green : Color() object Blue : Color()} 一起来分析一下反编译后的 Java 代码都做了什么。PS：Tools → Kotlin → Show Kotlin Bytecode ... // 省略部分代码@Metadata( mv = {1, 1, 13}, bv = {1, 0, 3}, k = 1, d1 = {&quot;\\u0000\\u001a\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0010\\u0000\\n\\u0002\\b\\u0004\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0018\\u0002\\n\\u0000\\b6\\u0018\\u00002\\u00020\\u0001:\\u0003\\u0003\\u0004\\u0005B\\u0007\\b\\u0002¢\\u0006\\u0002\\u0010\\u0002\\u0082\\u0001\\u0003\\u0006\\u0007\\b¨\\u0006\\t&quot;}, d2 = {&quot;Lcom/hidhl/leetcode/test/saledvsemun/Color;&quot;, &quot;&quot;, &quot;()V&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Red&quot;, &quot;Lcom/hidhl/leetcode/test/saledvsemun/Color$Red;&quot;, &quot;Lcom/hidhl/leetcode/test/saledvsemun/Color$Green;&quot;, &quot;Lcom/hidhl/leetcode/test/saledvsemun/Color$Blue;&quot;, &quot;Java-kotlin&quot;})public abstract class Color { private Color() { } public Color(DefaultConstructorMarker $constructor_marker) { this(); }}... // 省略部分代码 @Metadata 这个注解会出现在 Kotlin 编译器生成的任何类文件中，可以通过反射的方式获取 @Metadata 信息。参数名称都非常短，可以帮助减少 class 文件的大小。 @Metadata 存储了 Kotlin 主要的语法信息例如扩展函数、typealias 等等，这些信息都是由 kotlinc 编译器，并以注解的形式存放在 Java 的字节码中的，如果元数据被丢弃掉，运行在 JVM 上会抛出异常，那么如何才能确定它们之间的对应关系呢，其实就是通过 @Metadata 这个注解提供的信息。 正因为元数据不能被丢掉，R8 带了新的优化，将元数据信息记录在 R8 的内部数据结构中，当 R8 完成对第三库或者应用程序的优化和收缩时，它会为所有 Kotlin 类合成新的正确的 Kotlin 元数据，其目的就是为了减少应用程序的大小，目前我也在研究中，日后会分享。 而在本例中 @Metadata 保存了一个子类的列表，编译器在使用的时候会用到这些信息。正如你看到的 Sealed class 被编译成了 abstract class，它本身是不能被实例化，只能用它的子类实例化对象。 抽象类 Color 默认的构造方法被私有化了，所以在 Kotlin 1.1 之前，子类必须嵌套在 Sealed Classes 类中，后来放宽了要求，禁止在 Sealed Classes 所定义的文件外使用， Kotlin 是如何做到的呢？如果我们在 Sealed Classes 所定义的文件外使用会怎么样？ 正如你所看到，会导致编译错误，那么为什么 Sealed Classes 可以在同文件内使用呢？来看一下反编译后的代码。 // sealedsealed class Color// 同文件中使用 sealed classclass Red : Color() // 以下是反编译代码 ... // 省略部分代码 public final class Red extends Color { public Red() { super((DefaultConstructorMarker)null); }}... // 省略部分代码 public abstract class Color { private Color() { } // $FF: synthetic method public Color(DefaultConstructorMarker $constructor_marker) { this(); }}... // 省略部分代码 可以看到 Red class 被编译成了 final class， Sealed class 被编译成了 abstract class，同时编译器生成了一个 公有 的构造方法，其他的类无法直接调用，只有 Kotlin 编译器可以使用，Red class 被编译成 final class，在其构造方法内调用了 Color class 公有 的构造方法，而这些都是 Kotlin 编译器帮我们做的。 构造函数私有化，限制了子类必须嵌套在 Sealed Classes 类中 编译器生成了一个 公有 的构造方法，在子类的构造方法中调用了父类 公有 的构造方法，而这些都是 Kotlin 编译器帮我们做的 总结枚举的局限性 限制枚举每个类型只允许有一个实例 限制所有枚举常量使用相同的类型的值 抽象类的局限性 对于一个抽象类我们可以用一些子类去继承它，但是子类不是固定的，它可以随意扩展，同时也失去枚举常量受限性。 枚举作为单例的优点 是否只有一个实例 是否反序列化 是否是线程安全 是否是懒加载 是 是 是 否 Sealed Classes 是什么？ Sealed 是一个 abstract 类，它本身是不能被实例化，只能用它的子类实例化对象。Sealed 的构造方法私有化，禁止在 Sealed 所定义的文件外使用。 Sealed Classes 用于表示受限制的类层次结构 从某种意义上说，Sealed Classes 是枚举类的扩展 枚举的不同之处在于，每个枚举常量仅作为单个实例存在，而 Sealed Classes 的子类可以表示不同状态的实例。 在什么情况下使用枚举或者 Sealed？ 如果涉及反序列化创建对象的时候，建议使用枚举，因为 Java 规定，枚举的序列化和反序列化是有特殊定制的，因此禁用编译器使用 writeObject 、readObject 、readObjectNoData 、 writeReplace 、readResolve 等方法。 如果你不需要多次实例化，也不需要不提供特殊行为，或者也不需要添加额外的信息，仅作为单个实例存在，这个时候使用枚举更加合适。 其他情况下使用 Sealed Classes，在一定程度上可以使用 Sealed Classes 代替枚举 自动补全 when 语句下的所有分支 推荐给大家一个快捷键 Mac/Win/Linux：Alt + Enter 可以补全 when 语句下的所有分支，效果如下所示： 参考文献 Sealed classes in Kotlin: enums with super-powers Sealed Classes Kotlin Vocabulary | 密封类 sealed class Kotlin Metadata 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，目前已经包含了 App Startup、Paging3、Hilt 等等，正在逐渐增加其他 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请仓库右上角帮我点个赞。","link":"/2020/08/22/kotlin/03-sealed/"},{"title":"Google 推荐在项目中使用 sealed 和 RemoteMediator","text":"之前分享过一篇 Jetpack + MVVM 综合实战应用 神奇宝贝(PokemonGo) 眼前一亮的 Jetpack + MVVM 极简实战 主要包了以下功能： 自定义 RemoteMediator 实现 network + db 的混合使用 ( RemoteMediator 是 Paging3 当中重要成员 ) 使用 Data Mapper 分离数据源 和 UI Kotlin Flow 结合 Retrofit2 + Room 的混合使用 Kotlin Flow 与 LiveData 的使用 使用 Coil 加载图片 使用 ViewModel、LiveData、DataBinding 协同工作 使用 Motionlayout 做动画 App Startup 与 Hilt 的使用 在 Flow 基础上封装成功或者失败处理 这篇文章是对 神奇宝贝(PokemonGo) 的部分功能做全面的分析，主要包含以下内容： 如何在 Flow 基础上封装成功或者失败处理？ 如何自定义 RemoteMediator 实现 数据库 和 网络 加载数据？ Paging3 当中的 RemoteMediator 和 PagingSource 的区别？ Paging3 中的 cachedIn 是什么？它为我们解决了什么问题？ 在开始阅读本文之前，建议更新 PokemonGo 最新的代码，对照着代码一起看，为了节省篇幅，文中只会列出核心代码。 如何在 Flow 基础上封装成功或者失败处理之前有小伙们问过我，如何在 Flow 基础上封装成功或者失败处理逻辑，关于这个问题，其实 Google Android 团队的工程师在 medium 上发表过一篇文章 Sealed with a class 建议我们使用 sealed，在 Paging3 源码里面也大量用到了 sealed。 在分析封装逻辑之前，我们先来看一下 Paging3 源码是如何处理的，在 Paging3 中有个很重要的类 RemoteMediator，在 RemoteMediator 中有个重要的方法 load() abstract suspend fun load(loadType: LoadType, state: PagingState&lt;Key, Value&gt;): MediatorResult load() 方法返回值是 MediatorResult，我们来看一下 MediatorResult 源码的实现。 sealed class MediatorResult { class Error(val throwable: Throwable) : MediatorResult() class Success( @get:JvmName(&quot;endOfPaginationReached&quot;) val endOfPaginationReached: Boolean ) : MediatorResult()} 其实 MediatorResult 是一个密封类，密封类有两个子类分别为 Error 和 Success 封装了成功和失败处理逻辑。 我们在来看一下另外一个类 LoadState，在 Jetpack 新成员 Paging3 网络实践及原理分析（二）- 监听网路请求状态 文章中也提到 refresh、prepend 和 append 都是 LoadState 的对象，我们来看一下 LoadState 源码实现。 sealed class LoadState( val endOfPaginationReached: Boolean) { class NotLoading( endOfPaginationReached: Boolean) :LoadState(endOfPaginationReached) { ...... } object Loading : LoadState(false) { ...... } class Error(val error: Throwable) : LoadState(false) { ...... }} LoadState 是一个密封类，它有三个子类 NotLoading 、 Loading 、 Error 代表网络请求状态。 变量 作用 Error 表示加载失败 Loading 表示正在加载 NotLoading 表示当前未加载 正如你所见在 Paging3 源码中对于成功和失败处理都用到了 sealed，我们可以仿照 Paging3 源码，使用 sealed 在 Flow 基础上封装成功或者失败处理。PokemonGo/app/src/main/java/com/hi/dhl/pokemon/data/remote/PokemonResult.kt sealed class PokemonResult&lt;out T&gt; { data class Success&lt;out T&gt;(val value: T) : PokemonResult&lt;T&gt;() data class Failure(val throwable: Throwable?) : PokemonResult&lt;Nothing&gt;()} PokemonResult 是一个密封类，同样它也有两个子类 Success 和 Failure 分别表示成功和失败，我们来看一下如何使用。PokemonGo/app/src/main/java/com/hi/dhl/pokemon/data/repository/PokemonRepositoryImpl.kt override suspend fun featchPokemonInfo(name: String): Flow&lt;PokemonResult&lt;PokemonInfoModel&gt;&gt; { return flow { try { emit(PokemonResult.Success(model)) // 成功 } catch (e: Exception) { emit(PokemonResult.Failure(e.cause)) // 失败 } }.flowOn(Dispatchers.IO) // 通过 flowOn 切换到 io 线程} 如果请求成功返回 PokemonResult.Success(model) 如果出现错误返回 PokemonResult.Failure(e.cause) 这只是一个简单的封装，可以在这个基础上，针对于不同的场景进行二次封装，接下来看一下在 ViewModel 中如何处理。PokemonGo/app/src/main/java/com/hi/dhl/pokemon/ui/detail/DetailViewModel.kt when (result) { is PokemonResult.Failure -&gt; { _failure.value = result.throwable?.message ?: &quot;failure&quot; } is PokemonResult.Success -&gt; { _pokemon.postValue(result.value) }} 使用强大的 when 表达式，针对于成功或者失败进行不同的处理，在 Pokemon 项目中，如果没有网，进入详情页，会弹出一个失败的 toast。 when 表达式虽然强大，但是有一个问题，在一个项目中进行网络请求的地方会有很多，如果每次都要写 when 表达式，就会出现很多重复的代码，那么如何减少这样的模板代码呢，可以利用 Kotlin 提供的强大的扩展函数，代码如下所示： inline fun &lt;reified T&gt; PokemonResult&lt;T&gt;.doSuccess(success: (T) -&gt; Unit) { if (this is PokemonResult.Success) { success(value) }}inline fun &lt;reified T&gt; PokemonResult&lt;T&gt;.doFailure(failure: (Throwable?) -&gt; Unit) { if (this is PokemonResult.Failure) { failure(throwable) }} 使用扩展函数进一步封装的目的是减少模板代码，我们重新修改一下之前使用 when 表达式的地方。 result.doFailure { throwable -&gt; _failure.value = throwable?.message ?: &quot;failure&quot;}result.doSuccess { value -&gt; _pokemon.postValue(value) emit(value)} 如果在其他地方也需要进行成功 或者 失败处理，只需要调用对应的扩展函数即可，到这里关于如何在 Flow 基础上封装成功或者失败处理就分析完了。 接下来我们一起来分析一下今天的主角 如何自定义 RemoteMediator 实现 数据库 和 网络 加载数据，建议在了解这部分内容之前，先看一下之前的两篇文章，因为它们都是关联在一起的。 Jetpack 成员 Paging3 数据库的实践以及源码分析（一） Jetpack 新成员 Paging3 网络实践及原理分析（二） RemoteMediator 主要用来实现加载网络分页数据并更新到数据库中，在开始分析之前，我们先来了解一下基本概念。 Paging3 类的职能 PagingData ：用于分页数据的容器，每次数据刷新都有一个单独的对应 PagingData Pager ：是 Paging3 的主要的入口，在其构造方法中接受 PagingConfig 、initialKey 、remoteMediator 、pagingSourceFactory Pager.flow ：将会构建一个 Flow&lt;PagingData&gt;，在 PagingConfig 构造方法中定义了 pageSize、prefetchDistance、initialLoadSize 等等 PagingDataAdapter ：是一个处理分页数据的可回收视图适配器，可以使用 AsyncPagingDataDiffer 组件来构建自己的自定义适配器 PagingSource ：每个 PagingSource 对象定义一个数据源以及如何从该数据源查找数据 RemoteMediator ：RemoteMediator 实现加载网络分页数据并更新到数据库中 到这里小伙伴们应该会有一个疑惑 RemoteMediator 和 PagingSource 都是用来加载数据源的数据，那么它们有什么区别？ RemoteMediator 和 PagingSource 的区别 RemoteMediator：实现加载网络分页数据并更新到数据库中，但是数据源的变动不能直接映射到 UI 上 PagingSource：实现单一数据源以及如何从该数据源中查找数据，例如 Room，数据源的变动会直接映射到 UI 上 上图来自 Google 官网，正如你所见，使用 RemoteMediator 实现从网络加载分页数据更新到数据库中，使用 PagingSource 从数据库中查找数据并显示在 UI 上。 在项目中如何进行选择？ PagingSource：用于加载有限的数据集（本地数据库）例如手机通讯录等等 ，可以参考 Jetpack 成员 Paging3 数据库的实践以及源码分析（一） 这篇文章的实现 RemoteMediator：主要用来加载网络分页数据并更新到数据库中，当我们没有更多的数据时，我们向网络请求更多的数据，结合 PagingSource 当保存更多数据时会直接映射到 UI 上 注意： RemoteMediator 目前是实验性的 API ，所有实现 RemoteMediator 的类都需要添加 @OptIn(ExperimentalPagingApi::class) 注解。 当我们使用 OptIn 注解，需要在 App 模块下的 build.gradle 文件内添加以下代码 android { kotlinOptions { freeCompilerArgs += [&quot;-Xopt-in=kotlin.RequiresOptIn&quot;] }} 当我们了解完基本概念之后，接下来一起来分析一下如何实现 RemoteMediator，在这里建议更新 PokemonGo 最新代码，对照着项目中的代码一起看，为了节省篇幅文章中只会列出核心代码。 三步实现 RemoteMediator 如上面图片所示在 Repository 中通过 RemoteMediator 获取网络分页数据并更新到数据库中，PagingSource 当保存更多数据时会直接映射到 UI 上。 其实实现一个 RemoteMediator 贯穿了数据源、Repository、ViewModel，接下来我们来分析一下如何在每层中，分三步实现一个 RemoteMediator。 1. 定义数据源使用 Room 作为本地的数据源，将网络分页数据存储在本地数据库中。PokemonGo/app/src/main/java/com/hi/dhl/pokemon/data/local/PokemonDao.kt @Daointerface PokemonDao { @Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insertPokemon(pokemonList: List&lt;PokemonEntity&gt;) @Query(&quot;SELECT * FROM PokemonEntity&quot;) fun getPokemon(): PagingSource&lt;Int, PokemonEntity&gt;} 在 Paging3 中使用的是 Flow，所以 insertPokemon 方法前需要添加 suspend 修饰符。 需要注意的是 getPokemon() 方法返回了一个 PagingSource&lt;Key, Value&gt;，意味着数据源更新时会映射到 UI 上，其中 Key 和 Value 和实现 RemoteMediator 有很大关系，后面会提到。 2. 在 Repository 中实现 RemoteMediatorRemoteMediator 和 PagingSource 相似，都需要覆盖 load() 方法，但是不同的是 RemoteMediator 不是加载分页数据到 RecyclerView 列表上，而是获取网络分页数据并更新到数据库中。PokemonGo/app/src/main/java/com/hi/dhl/pokemon/data/repository/PokemonRemoteMediator.kt 注意： 刚才我们在数据源中定义 getPokemon() 方法，其返回值是 PagingSource&lt;Int, PokemonEntity&gt;，那我们在实现 RemoteMediator&lt;Key, Value&gt; 的时候，其中 Key 和 Value，应该和 PagingSource&lt;Int, PokemonEntity&gt; Key 和 Value 相同，代码如下所示。 @OptIn(ExperimentalPagingApi::class)class PokemonRemoteMediator( val api: PokemonService, val db: AppDataBase) : RemoteMediator&lt;Int, PokemonEntity&gt;() { override suspend fun load( loadType: LoadType, state: PagingState&lt;Int, PokemonEntity&gt; ): MediatorResult { /** * 在这个方法内将会做三件事 * * 1. 参数 LoadType 有个三个值，关于这三个值如何进行判断 * LoadType.REFRESH * LoadType.PREPEND * LoadType.APPEND * * 2. 请问网络数据 * * 3. 将网络数据插入到本地数据库中 */ }} load() 方法有两个重要的参数，它们的意思如下所示： PagingState：这个类当中有两个重要的变量 pages: List&lt;Page&lt;Key, Value&gt;&gt; 返回的上一页的数据，主要用来获取上一页最后一条数据作为下一页的开始位置 config: PagingConfig 返回的初始化设置的 PagingConfig 包含了 pageSize、prefetchDistance、initialLoadSize 等等 LoadType 是一个枚举类，里面定义了三个值，如下所示 类名 作用 LoadType.Refresh 在初始化刷新的使用 LoadType.Append 在加载更多的时候使用 LoadType.Prepend 在当前列表头部添加数据的时候使用 load() 的返回值 MediatorResult，MediatorResult 是一个密封类，根据不同的结果返回不同的值 请求出现错误，返回 MediatorResult.Error(e) 请求成功且有数据，返回 MediatorResult.Success(endOfPaginationReached = true) 请求成功但是没有数据，返回 MediatorResult.Success(endOfPaginationReached = false) 参数 endOfPaginationReached 表示是否还有更多数据 在 load() 方法里面将会做三件事 1. 如何判断参数 LoadType 、2. 请问网络数据 、3. 将网络数据插入到本地数据库中 1. 如何判断参数 LoadType val pageKey = when (loadType) { // 首次访问 或者调用 PagingDataAdapter.refresh() LoadType.REFRESH -&gt; null // 在当前加载的数据集的开头加载数据时 LoadType.PREPEND -&gt; return MediatorResult.Success(endOfPaginationReached = true) LoadType.APPEND -&gt; { // 下来加载更多时触发 /** * 方式一：这种方式比较简单，当前页面最后一条数据是下一页的开始位置 * 通过 load 方法的参数 state 获取当页面最后一条数据 */// val lastItem = state.lastItemOrNull()// if (lastItem == null) {// return MediatorResult.Success(// endOfPaginationReached = true// )// }// lastItem.page /** * 方式二：比较麻烦，当前分页数据没有对应的远程 key，这个时候需要我们自己建表 */ val remoteKey = db.withTransaction { db.remoteKeysDao().getRemoteKeys(remotePokemon) } if (remoteKey == null || remoteKey.nextKey == null) { return MediatorResult.Success(endOfPaginationReached = true) } remoteKey.nextKey }} LoadType.REFRESH：首次访问 或者调用 PagingDataAdapter.refresh() 触发，加载第一页数据，这里不需要做任何操作，返回 null 就可以。 LoadType.PREPEND：在当前列表头部添加数据的时候时触发，需要注意的是当 LoadType.REFRESH 触发了，LoadType.PREPEND 也会触发，所以为了避免重复请求，直接返回 MediatorResult.Success(endOfPaginationReached = true) 即可 LoadType.APPEND：下拉加载更多时触发，这里获取下一页的 key，如果 key 不存在，直接返回 MediatorResult.Success(endOfPaginationReached = true) 不会在进行请求 2. 请问网络数据 val page = pageKey ?: 0val result = api.fetchPokemonList( state.config.pageSize, page * state.config.pageSize).results 这里不需要调用 withContext(Dispatcher.IO) { ... } 因为 Retrofit 的协程是发生在 worker thread 中的 3. 将网络分页数据并更新到数据库中 remoteKeysDao.insertAll(entity)pokemonDao.insertPokemon(item) 所有实现 RemoteMediator 的类都需要重写 load() 方法，在 load() 方法内按照如上三步实现即可，具体逻辑需要根据需求而定。 PokemonRemoteMediator 完整代码太长了，这里就不贴了，可以点击 PokemonRemoteMediator 前去查看。 3. 在 Repository 中构建 PagerPager 是 Paging3 的主要的入口，是从数据源获取数据的入口，其构造方法接受 pagingConfig 、initialKey 、remoteMediator 、pagingSourceFactory，其中 initialKey、remoteMediator 是可选的，pageConfig 和 pagingSourceFactory 必填的，代码如下所示。PokemonGo/app/src/main/java/com/hi/dhl/pokemon/data/repository/PokemonRepositoryImpl.kt Pager( config = pageConfig, remoteMediator = PokemonRemoteMediator(api, db)) { db.pokemonDao().getPokemon()}.flow.map { pagingData -&gt; pagingData.map { mapper2ItemMolde.map(it) }} config ：初始化 Pager 参数 pageSize、prefetchDistance、initialLoadSize 等等 remoteMediator ：提供 RemoteMediator 的实现类，这里是 PokemonRemoteMediator pagingSourceFactory ：是一个 lambda 表达式，在 Kotlin 中可以直接用花括号表示，在花括号内执行加载分页数据，这里直接调用 db.pokemonDao().getPokemon()。 调用 getPokemon() 方法返回的是一个 PagingSource，在 PokemonRemoteMediator 中获取网络分页数据，更新数据库的时候，这里返回的是你请求的网络分页数据 到这里关于 如何自定义 RemoteMediator 实现 数据库 和 网络 加载数据 就分析完了，接下来就是在 ViewModel 中调用 Repository 获取数据。 4. 在 ViewModel 获取数据在 ViewModel 中调用 Repository 请求数据，通过构建 Pager 加载网络分页数据并更新到数据库中，当数据库更新时，会映射到 UI 上。PokemonGo/app/src/main/java/com/hi/dhl/pokemon/ui/main/MainViewModel.kt fun postOfData(): LiveData&lt;PagingData&lt;PokemonItemModel&gt;&gt; = polemonRepository.featchPokemonList().cachedIn(viewModelScope).asLiveData() 正如你所见在 ViewModel 中就两行代码，结合着 DataBinding 一起使用，在 Activity 或者 Fragment 只需要不到 20 行代码甚至更少。 注意： 在 ViewModel 中的 postOfData 方法中调用了 cachedIn() 方法 Paging3 中的 cachedIn 是什么？它为我们解决了什么问题？ cachedIn() 是 Flow&lt;PagingData&gt; 的扩展方法，主要用来缓存 Flow&lt;PagingData&gt; 返回的内容，当我们在使用 Flow 进行 map 或者 filter 操作后调用 cachedIn() 是为了确保不需要再次触发它们，我们来看一下 cachedIn() 方法的源码。 fun &lt;T : Any&gt; Flow&lt;PagingData&lt;T&gt;&gt;.cachedIn( scope: CoroutineScope) 正如你所见 cachedIn() 是 Flow&lt;PagingData&gt; 的扩展方法，cachedIn() 方法接受一个 CoroutineScope，CoroutineScope 表示协程的作用域，在 ViewModel 中对应的是 androidx.lifecycle.viewModelScope.，也就意味在作用域内防止不需要再次触发它们，在屏幕旋转的时候也可以复用。 全文到这里就结束了，在这里强烈建议至少体验一次，结合 Kotlin Flow + DataBinding + Jetpack + MVVM 神奇宝贝 (PokemonGo) 基于 Jetpack + MVVM + Repository + Data Mapper + Kotlin Flow 的实战项目，我也正在为 PokemonGo 项目设计更多的场景，也会加入更多的 Jetpack 成员，在 PokemonGo 项目首页增加了更新记录，可以点击下方链接前往查看 PokemonGo 项目的更新记录。 PokemonGo GitHub 地址：https://github.com/hi-dhl/PokemonGo 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请在仓库右上角帮我点个赞，后面我会陆续完成更多 Jetpack 新成员的项目实践","link":"/2020/08/22/jetpack/10-remoteMediator/"},{"title":"Google 推荐在 MVVM 架构中使用 Kotlin Flow","text":"前言在之前分享过一篇 Jetpack 综合实战应用 神奇宝贝(PokemonGo) 眼前一亮的 Jetpack + MVVM 极简实战 ，这个项目主要包了以下功能： 自定义 RemoteMediator 实现 network + db 的混合使用 ( RemoteMediator 是 Paging3 当中重要成员 ) 使用 Data Mapper 分离数据源 和 UI Kotlin Flow 结合 Retrofit2 + Room 的混合使用 Kotlin Flow 与 LiveData 的使用 使用 Coil 加载图片 使用 ViewModel、LiveData、DataBinding 协同工作 使用 Motionlayout 做动画 App Startup 与 Hilt 的使用 我近期也在开发另外一个 Jetpack + MVVM 实战应用，和神奇宝贝(PokemonGo) 有很多不同之处，神奇宝贝(PokemonGo) 主要偏向于 Paging3 的分页处理，以及 Flow 在 MVVM 中的实战。 而今天这篇文章主要来分析一下 神奇宝贝(PokemonGo) 项目，主要包含以下几个方面的内容： 在 Repositories 或者 DataSource 中直接使用 LiveData 这种做法对吗？ Kotlin Flow 是什么？ Kotlin Flow 解决了什么问题？ Kotlin Flow 如何在 MVVM 中使用? Kotlin Flow 如何与 Retrofit2 + Room 混合使用? Google 推荐在 MVVM 中使用 Kotlin Flow我相信如今几乎所有的 Android 开发者至少都听过 MVVM 架构，在 Google Android 团队宣布了 Jetpack 的视图模型之后，它已经成为了现代 Android 开发模式最流行的架构之一，如下图所示： 在官宣 Jetpack 的视图模型之后，同时 Google 在 Jetpack Guide 文章中的示例，也在 Repositories 或者 DataSource 中使用 LiveData，以至于在很多开源的 MVVM 项目中也是直接使用 LiveData，但是在 Repositories 或者 DataSource 中直接使用 LiveData 这种做法对吗？这是我一直以来的一个疑问？ 直到我打开 Android 架构组件 页面，看了在页面上增加了最新的文章，这几篇文章大概的内容是说如何在 MVVM 中使用 Flow 以及如何与 LiveData 一起使用，当我看完并通过实践之后大概明白了，LiveData 是一个生命周期感知组件，它并不属于 Repositories 或者 DataSource 层，下文会有详细的分析。 在 Google 发布的 Jetpack 的最新成员 Paging3，在其内部的源码实现也是使用的 Flow，关于 Paging3 的使用可以参考以下链接： Jetpack 成员 Paging3 实践以及源码分析（一） Jetpack 新成员 Paging3 网络实践及原理分析（二） 自定义 RemoteMediator 实现 network + db 的混合使用 不仅仅是 Jetpack 成员支持 Flow，在 Google 提供的 Demo 里面也都在使用 Flow，也有很多开源的 MVVM 项目也在逐渐切换到 Flow，为什么 Google 会推荐使用它呢，使用 Flow 能带来那些好处呢，为我们解决了什么问题？ Kotlin Flow 是什么？Kotlin Flow 解决了什么问题？Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库，也叫做异步流，类似 RxJava 的 Observable 、 Flowable 等等，所以很多人都用 Flow 与 RxJava 做对比。 Flow 相比于 RxJava 简单的太多了，你还记得那些 RxJava 傻傻分不清楚的操作符吗 Observable 、 Flowable 、 Single 、 Completable 、 Maybe 等等。 那么 Flow 为我们解决了什么问题，我主要从以下几个方面思考： LiveData 是一个生命周期感知组件，最好在 View 和 ViewModel 层中使用它，如果在 Repositories 或者 DataSource 中使用会有几个问题 它不支持线程切换，其次不支持背压，也就是在一段时间内发送数据的速度 &gt; 接受数据的速度，LiveData 无法正确的处理这些请求 使用 LiveData 的最大问题是所有数据转换都将在主线程上完成 RxJava 入门的门槛很高，学习过的朋友们，我相信能够体会到从入门到放弃是什么感觉 RxJava 虽然支持线程切换和背压，但是 RxJava 那么多傻傻分不清楚的操作符，实际上在项目中常用的可能只有几个例如 Observable 、 Flowable 、 Single 等等 如果我们不去了解背后的原理，很容易造成内存泄露，在 StackOverflow 上有很多因为 RxJava 造成内存泄露的例子 RxJava 的链式调用虽然方便，在复杂的业务逻辑里面，层层的 RxJava 的链式调用 ，让代码难易阅读 成本很高，团队所有人都要了解 RxJava 原理以及用法，自然也出现了很多种不可思议的 RxJava 用法 解决回调地狱的问题 而相对于以上的不足，Flow 有以下优点： Flow 是对 Kotlin 协程的扩展，让我们可以像运行同步代码一样运行异步代码，使得代码更加简洁，提高了代码的可读性 Flow 支持线程切换、背压 Flow 入门的门槛很低，加上 Google 的支持，API 调用更加简单，没有那么多傻傻分不清楚的操作符，新的 Jetpack 源码也在大量使用 Flow 简单的数据转换与操作符，如 map 等等 易于做单元测试 Kotlin Flow 如何在 MVVM 中使用Jetpack 的视图模型 MVVM 架构由 View + DataBinding + ViewModel + Model 组成，如下所示，我相信下面这张图大家非常熟悉了， 接下来我们一起来探究一下 Kotlin Flow 在 MVVM 当中每层是如何实现的。 Kotlin Flow 在数据源中的使用在 PokemonGo 项目中，进入详情页，会检查本地是否有数据，如果没有会去请求 pokeapi 详情页接口，获得最新的数据，然后存储在数据库中。 Flow 是协程的扩展，如果要在 Room 和 Retrofit 中使用，Room 和 Retrofit 需要支持协程才可以，在 Retrofit &gt;= 2.6.0 和 Room &gt;= 2.1 版本都支持协程，我们来看一下 Room 和 Retrofit 数据源的配置。 Room:PokemonGo/app/src/main/java/com/hi/dhl/pokemon/data/local/PokemonInfoDao.kt @Query(&quot;SELECT * FROM PokemonInfoEntity where name = :name&quot;)suspend fun getPokemon(name: String): PokemonInfoEntity? 或者直接返回 Flow&lt;PokemonInfoEntity&gt; @Query(&quot;SELECT * FROM PokemonInfoEntity where name = :name&quot;)fun getPokemon(name: String): Flow&lt;PokemonInfoEntity&gt; Retrofit:PokemonGo/app/src/main/java/com/hi/dhl/pokemon/data/remote/PokemonService.kt @GET(&quot;pokemon/{name}&quot;)suspend fun fetchPokemonInfo(@Path(&quot;name&quot;) name: String): NetWorkPokemonInfo 如上所见在方法前增加了用 suspend 进行了修饰，只有被 suspend 修饰的方法，才可以在协程中调用。 按照如上配置，在数据源的工作就完成了，相比于 RxJava 的 Observable 、 Flowable 、 Single 、 Completable 、 Maybe 使用场景要简单太多了，我们来看一下在 Repositories 中是如何使用的。 Kotlin Flow 在 Repositories 中的使用如果我们想在 Flow 中使用 Retrofit 或者 Room 进行网络请求或者查询数据库的操作，我们需要将使用 suspend 修饰符的操作放到 flow { ... } 中执行，最后使用 emit() 方法更新数据，将数据发送给 ViewModel，代码如下所示：PokemonGo/app/src/main/java/com/hi/dhl/pokemon/data/repository/PokemonRepositoryImpl.kt flow { val pokemonDao = db.pokemonInfoDao() // 查询数据库是否存在，如果不存在请求网络 var infoModel = pokemonDao.getPokemon(name) if (infoModel == null) { // 网络请求 val netWorkPokemonInfo = api.fetchPokemonInfo(name) // 将网路请求的数据，换转成的数据库的 model，之后插入数据库 infoModel = netWorkPokemonInfo.let { PokemonInfoEntity( name = it.name, height = it.height, weight = it.weight, experience = it.experience ) } // 插入更新数据库 pokemonDao.insertPokemon(infoModel) } // 将数据源的 model 转换成上层用到的 model， // ui 不能直接持有数据源，防止数据源的变化，影响上层的 ui val model = mapper2InfoModel.map(infoModel) // 更新数据，将数据发送给 ViewModel emit(model)}.flowOn(Dispatchers.IO) // 通过 flowOn 切换到 IO 线程 将上面的代码简化如下所示： flow { // 进行网络或者数据库操作 emit(model)}.flowOn(Dispatchers.IO) // 通过 flowOn 切换到 IO 线程 正如你所见，将耗时操作放到 flow { ... } 里面，通过 flowOn(Dispatchers.IO) 切换到 IO 线程，最后通过 emit() 方法将数据发送给 ViewModel，接下来我们来看一下如何在 ViewModel 中接受 Flow 发送的数据。 Kotlin Flow 在 ViewModel 中的使用在 ViewModel 中使用 Flow 之前在 Jetpack 成员 Paging3 实践以及源码分析（一） 文章也有提到， 这里我们在深入分析一下，在 ViewModel 中接受 Flow 发送的数据有三种方法，根据实际情况去调用。PokemonGo/app/src/main/java/com/hi/dhl/pokemon/ui/detail/DetailViewModel.kt 方法一 在 LifeCycle 2.2.0 之前使用的方法，使用两个 LiveData，一个是可变的，一个是不可变的，如下所示： // 私有的 MutableLiveData 可变的，对内访问private val _pokemon = MutableLiveData&lt;PokemonInfoModel&gt;()// 对外暴露不可变的 LiveData，只能查询val pokemon: LiveData&lt;PokemonInfoModel&gt; = _pokemonviewModelScope.launch { polemonRepository.featchPokemonInfo(name) .onStart { // 在调用 flow 请求数据之前，做一些准备工作，例如显示正在加载数据的进度条 } .catch { // 捕获上游出现的异常 } .onCompletion { // 请求完成 } .collectLatest { // 将数据提供给 Activity 或者 Fragment _pokemon.postValue(it) }} 准备一私有的 MutableLiveData，只对内访问 对外暴露不可变的 LiveData 在 viewModelScope.launch 方法中执行协程代码块 collectLatest 是末端操作符，收集 Flow 在 Repositories 层发射出来的数据，在一段时间内发送多次数据，只会接受最新的一次发射过来的数据 调用 _pokemon.postValue 方法将数据提供给 Activity 或者 Fragment 方法二 在 LifeCycle 2.2.0 之后，可以用更精简的方法来完成，使用 LiveData 协程构造方法 (coroutine builder)，这个方法也是在 PokemonGo 项目中用到的方法。 @OptIn(ExperimentalCoroutinesApi::class)fun fectchPokemonInfo(name: String) = liveData&lt;PokemonInfoModel&gt; { polemonRepository.featchPokemonInfo(name) .onStart { // 在调用 flow 请求数据之前，做一些准备工作，例如显示正在加载数据的进度条 } .catch { // 捕获上游出现的异常 } .onCompletion { // 请求完成 } .collectLatest { // 更新 LiveData 的数据 emit(it) }} liveData{ ... } 协程构造方法提供了一个协程代码块，产生的是一个不可变的 LiveData，emit() 方法则用来更新 LiveData 的数据 collectLatest 是末端操作符，收集 Flow 在 Repositories 层发射出来的数据，在一段时间内发送多次数据，只会接受最新的一次发射过来的数据 PS：需要注意的是 flow { ... } 和 liveData{ ... } 内部都有一个 emit() 方法。 方法三： 调用 Flow 的扩展方法 asLiveData() 返回一个不可变的 LiveData，供 Activity 或者 Fragment 调用。 @OptIn(ExperimentalCoroutinesApi::class)suspend fun fectchPokemonInfo3(name: String) = polemonRepository.featchPokemonInfo(name) .onStart { // 在调用 flow 请求数据之前，做一些准备工作，例如显示正在加载数据的按钮 } .catch { // 捕获上游出现的异常 } .onCompletion { // 请求完成 }.asLiveData() 因为 polemonRepository.featchPokemonInfo(name) 是一个用 suspend 修饰的方法，所以在 ViewModel 中调用也需要使用 suspend 来修饰。 为什么说调用 asLiveData() 方法会返回一个不可变的 LiveData，我们来看一下源码： fun &lt;T&gt; Flow&lt;T&gt;.asLiveData( context: CoroutineContext = EmptyCoroutineContext, timeoutInMs: Long = DEFAULT_TIMEOUT): LiveData&lt;T&gt; = liveData(context, timeoutInMs) { collect { emit(it) }} asLiveData() 方法其实就是对 方法二 中的 liveData{ ... } 的封装 asLiveData 是 Flow 的扩展函数，返回值是一个 LiveData liveData{ ... } 协程构造方法提供了一个协程代码块，在 liveData{ ... } 中执行协程代码 collect 是末端操作符，收集 Flow 在 Repositories 层发射出来的数据 最后调用 LiveData 中的 emit() 方法更新 LiveData 的数据 DataBinding（数据绑定）在 PokemonGo 项目中使用了 DataBinding 进行的数据绑定。 DataBinding（数据绑定）实际上是 XML 布局中的另一个视图结构层次，视图 (XML) 通过数据绑定层不断地与 ViewModel 交互，如下所示：PokemonGo/app/src/main/res/layout/activity_details.xml &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.hi.dhl.pokemon.ui.detail.DetailViewModel&quot; /&gt; &lt;/data&gt; ...... &lt;androidx.appcompat.widget.AppCompatTextView android:id=&quot;@+id/weight&quot; android:text=&quot;@{viewModel.pokemon.getWeightString}&quot;/&gt; ...... &lt;/layout&gt; 这是获取神奇宝贝的详细信息，通过 DataBinding 以声明方式将数据（神奇宝贝的体重）绑定到界面上，更多使用参考项目中的代码。 如何处理 ViewModel 的三种方式如果不使用数据绑定，在 Activity 或者 Fragment 中如何处理 ViewModel 的三种方式。PokemonGo/app/src/main/java/com/hi/dhl/pokemon/ui/detail/DetailsFragment.kt 方式一： 使用两个 LiveData，一个是可变的，一个是不可变的，在 Activity 或者 Fragment 中调用对外暴露不可变的 LiveData 即可，如下所示： // 方法一mViewModel.pokemon.observe(this, Observer { // 将数据显示在页面上}) 方式二： 使用 LiveData 协程构造方法 (coroutine builder) 提供的协程代码块，产生的是一个不可变的 LiveData，处理方式 同方法一，在 Activity 或者 Fragment 中调用这个不可变的 LiveData 即可，如下所示： // 方法二mViewModel.fectchPokemonInfo2(mPokemonModel.name).observe(this, Observer { // 将数据显示在页面上}) 方式三： 调用 Flow 的扩展方法 asLiveData() 返回一个不可变的 LiveData，在 Activity 或者 Fragment 调用这个不可变的 LiveData 即可，如下所示： // 方法三lifecycleScope.launch { mViewModel.apply { fectchPokemonInfo3(mPokemonModel.name).observe(this@DetailsFragment, Observer { // 将数据显示在页面上 }) }} 到这里关于 Kotlin Flow 在 MVVM 当中每层的实践就分析完了，如果使用过 RxJava 的小伙伴们应该会非常熟悉，对于没有使用过 RxJava 的小伙伴们，入门的门槛也是非常低的，强烈建议至少体验一次，体验过之后，我认为你会跟我一样爱上它的。 神奇宝贝 (PokemonGo) 基于 Jetpack + MVVM + Repository + Data Mapper + Kotlin Flow 的实战项目，我也正在为 PokemonGo 项目设计更多的场景，也会加入更多的 Jetpack 成员，可以点击下方链接前往查看。 PokemonGo GitHub 地址：https://github.com/hi-dhl/PokemonGo 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请在仓库右上角帮我点个赞，后面我会陆续完成更多 Jetpack 新成员的项目实践","link":"/2020/08/22/jetpack/09-kotlin-flow/"},{"title":"神奇宝贝  眼前一亮的 Jetpack + MVVM 极简实战","text":"前言Jetpack 实战项目 PokemonGo（神奇宝贝）基于 MVVM 架构和 Repository 设计模式，PokemonGo 项目中用到的技术，都是之前写过的一系列文章里面涉及到的知识点：Paging3（network + db），Dagger-Hilt，App Startup，DataBinding，Room，Motionlayout，Kotlin Flow，Coil，JProgressView 等等。 项目 PokemonGo 已经上传到 GitHub: https://github.com/hi-dhl/PokemonGo，欢迎前去查看，动态效果图如下所示，如果动图无法查看，请点击这里查看 动态效果图 | 静态图 Jetpack 实战项目 PokemonGo 包含了以下功能： 自定义 RemoteMediator 实现 network + db 的混合使用 ( RemoteMediator 是 Paging3 当中重要成员 ) 使用 Data Mapper 分离数据源 和 UI Kotlin Flow 结合 Retrofit2 + Room 的混合使用 Kotlin Flow 与 LiveData 的使用 使用 Coil 加载图片 使用 ViewModel、LiveData、DataBinding 协同工作 使用 Motionlayout 做动画 App Startup 与 Hilt 的使用 PokemonGo 涉及的技术： Gradle Versions Plugin：检查依赖库是否存在最新版本 Kotlin + Coroutines + Flow：flow 是对 Kotlin 协程的扩展，让我们可以像运行同步代码一样运行异步代码 JetPack Paging3（network + db）：用到了 Paging3 中的 RemoteMediator 用来实现 network + db Dagger-Hilt (2.28-alpha)：依赖注入框架 App Startup：设置组件初始化顺序 DataBinding：以声明方式将可观察数据绑定到界面上 Room：在 SQLite 上提供了一个抽象层，流畅地访问 SQLite 数据库 LiveData：在底层数据库更改时通知视图 ViewModel：以注重生命周期的方式管理界面相关的数据 Andriod KTX：编写更简洁、惯用的 Kotlin 代码 项目架构 MVVM 架构 Repository 设计模式 Data Mapper 数据映射 Retrofit2 &amp; OkHttp3：用于请求网路数据 Coil：基于 Kotlin 开发的首个图片加载库 material-components-android：模块化和可定制的材料设计 UI 组件 Motionlayout ：MotionLayout 是一种布局类型，可帮助您管理应用中的动画 Timber: 日志打印 JProgressView ：一个小巧灵活可定制的进度条，支持图形：圆形、圆角矩形、矩形等等 以上技术栈对应之前写的技术文章： Jetpack 最新成员 AndroidX App Startup 实践以及原理分析 Jetpack 成员 Paging3 实践以及源码分析（一） Jetpack 新成员 Paging3 网络实践及原理分析（二） Jetpack 新成员 Hilt 实践（一）启程过坑记 Jetpack 新成员 Hilt 实践之 App Startup（二）进阶篇 Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇 全方面分析 Hilt 和 Koin 性能 [译][2.4K Star] 放弃 Dagger 拥抱 Koin 项目中封装 Kotlin + Android Databinding 为数不多的人知道的 Kotlin 技巧以及 原理解析(一) 为数不多的人知道的 Kotlin 技巧以及 原理解析(二) 如果之前对这些技术没有接触过，或者只是听说，对阅读本文没有什么影响，本文会对这些技术结合着项目 PokemonGo 来分析，为了文章的简洁性，本文不会细究技术细节，因为每个技术都需要花好几篇文章才能分析清楚，我会在后续的文章去详细分析。 如何检查依赖库最新版本在之前的文章 再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度 分析过，到目前为止大概管理 Gradle 依赖提供了 4 种不同方法： 手动管理 ：在每个 module 中定义插件依赖库，每次升级依赖库时都需要手动更改（不建议使用） 使用 ext 的方式管理插件依赖库 ：这是 Google 推荐管理依赖的方法 Android官方文档 Kotlin + buildSrc：自动补全和单击跳转，依赖更新时 将重新 构建整个项目 Composing builds：自动补全和单击跳转，依赖更新时 不会重新 构建整个项目 新版的 AndroidStudio 只支持 ext 的方式 和 手动方式管理 检查依赖库是否存在最新版本，不支持 buildSrc、gradle-wrapper 版本的检查。 满足不了 PokemonGo 项目的需求，在 PokemonGo 项目中采用 buildSrc 方式去管理所有依赖库，因为 PokemonGo 项目采用单模块结构，而且支持 自动补全 和 单击跳转 很方便，所这里用到了 Gradle Versions Plugin 插件去检查依赖库的最新版本，检查结果如下所示： The following dependencies have later release versions: - androidx.swiperefreshlayout:swiperefreshlayout [1.0.0 -&gt; 1.1.0] https://developer.android.com/jetpack/androidx - com.squareup.okhttp3:logging-interceptor [3.9.0 -&gt; 4.7.2] https://square.github.io/okhttp/ - junit:junit [4.12 -&gt; 4.13] http://junit.org - org.koin:koin-android [2.1.5 -&gt; 2.1.6] - org.koin:koin-androidx-viewmodel [2.1.5 -&gt; 2.1.6] - org.koin:koin-core [2.1.5 -&gt; 2.1.6]Gradle release-candidate updates: - Gradle: [6.1.1 -&gt; 6.5.1] 会列出所有需要更新的依赖库的最新版本，并且 Gradle Versions Plugin 比 AndroidStudio 所支持的更加全面： 支持手动方式管理依赖库最新版本检查 支持 ext 的方式管理依赖库最新版本检查 支持 buildSrc 方式管理依赖库最新版本检查 支持 gradle-wrapper 最新版本检查 支持多模块的依赖库最新版本检查 那么如何使用呢？只需要三步 1.将 PokemonGo 项目根目录 checkVersions.gradle 文件拷贝到你的项目根目录下面 2.在项目的根目录 build.gradle 文件夹内添加以下代码 apply from: './checkVersions.gradle'buildscript { repositories { google() jcenter() } dependencies { classpath &quot;com.github.ben-manes:gradle-versions-plugin:0.28.0&quot; }} 3.添加完成之后，在根目录下执行以下命令。 ./gradlew dependencyUpdates 会在当前目录下生成 build/dependencyUpdates/report.txt 文件。 MVVM 架构Jetpack 实战项目 PokemonGo 基于 MVVM 架构和 Repository 设计模式，如今几乎所有的 Android 开发者至少都听过 MVVM 架构，在谷歌 Android 团队宣布了 Jetpack 的视图模型之后，它已经成为了现代 Android 开发模式最流行的架构之一，如下图所示： MVVM 有助于将应用程序的业务逻辑与 UI 完全分开。 如果业务逻辑与 UI 逻辑之间的联系非常紧密，那么维护将很困难，由于很难重用业务逻辑，因此编写单元测试代码非常困难，一堆重复的代码和复杂的逻辑。 Jetpack 的视图模型的 MVVM 架构由 View + DataBinding + ViewModel + Model 组成。 DataBindingDataBinding（数据绑定）实际上是 XML 布局中的另一个视图结构层次，视图 (XML) 通过数据绑定层不断地与 ViewModel 交互。 我们来看一个例子，首页上有个 RecyclerView 用来展示神奇宝贝数据（名字、图片、点击事件等等），每一个 item 对应一个 ViewHolder，来看一下 ViewHolder 的实现。 class PokemonViewModel(view: View) : DataBindingViewHolder&lt;PokemonListModel&gt;(view) { private val mBinding: RecycleItemPokemonBinding by viewHolderBinding(view) override fun bindData(data: PokemonListModel, position: Int) { mBinding.apply { pokemon = data executePendingBindings() } }} 正如你所看到的，由于使用了数据绑定，ViewHolder 里面的代码变的非常简单，可能这个例子不够明显，我们来看一个劲爆的，点击首页每一个 item 会跳转到详情页面，详情页面如下图所示： 详情页面（DetailActivity）展示了神奇宝贝的详细数据，先查询数据库，如果没有找到，读取网路数据然后保存到数据库，由于使用了数据绑定，代码变得非常简单，如下所示： class DetailActivity : DataBindingAppCompatActivity() { private val mBindingActivity: ActivityDetailsBinding by binding(R.layout.activity_details) private val mViewModel: DetailViewModel by viewModels() lateinit var mPokemonModel: PokemonListModel override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) mBindingActivity.apply { mPokemonModel = requireNotNull(intent.getParcelableExtra(KEY_LIST_MODEL)) pokemonListModel = mPokemonModel lifecycleOwner = this@DetailActivity viewModel = mViewModel.apply { fectchPokemonInfo(mPokemonModel.name) .observe(this@DetailActivity, Observer {}) } } }} 正如你所见 DetailActivity 代码变得非常简单，如果以后我们想要改变网络的 URL、Model、获取或保存数据的方式等等，我们不需要改变 DetailActivity 中的任何代码。 更多关于 DataBinding 的使用请参考我另外一个仓库 JDataBinding：目前已经封装了一系列的组件包含 DataBindingActivity、DataBindingAppCompatActivity、DataBindingFragmentActivity、DataBindingFragment、DataBindingDialog、DataBindingListAdapter、DataBindingViewHolder 等等。 ViewModelViewModel 是 MVVM 架构中非常重要的设计，它在 activities 或 fragments 和业务逻辑中起到了非常重要的作用，它不依赖于 UI 组件，使得单元测试更加容易，ViewModel 以生命周期的方式管理界面相关的数据，直到 Activity 被销毁。 LiveData 与 ViewModel 具有很好的协同作用，LiveData 持有从数据源获取到的数据，并且它可以被 DataBinding 组件观察，当 Activity 被销毁时，它将被取消订阅。 而详情页面（DetailActivity) 代码之所以能这么简单得益于 ViewModel、LiveData、DataBinding 协同工作, 我们来看一下 ViewModel 代码。 class DetailViewModel @ViewModelInject constructor( val polemonRepository: Repository) : ViewModel() { private val _pokemon = MutableLiveData&lt;PokemonInfoModel&gt;() val pokemon: LiveData&lt;PokemonInfoModel&gt; = _pokemon @OptIn(ExperimentalCoroutinesApi::class) fun fectchPokemonInfo(name: String) = liveData&lt;PokemonInfoModel&gt; { polemonRepository.featchPokemonInfo(name) .collectLatest { _pokemon.postValue(it) emit(it) } ....... // 省略部分代码， }} activity_details.xml 代码 &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.hi.dhl.pokemon.ui.detail.DetailViewModel&quot; /&gt; &lt;/data&gt; ...... &lt;androidx.appcompat.widget.AppCompatTextView android:id=&quot;@+id/weight&quot; android:text=&quot;@{viewModel.pokemon.getWeightString}&quot;/&gt; ...... &lt;/layout&gt; 这是获取神奇宝贝的详细信息，通过 DataBinding 以声明方式将数据（神奇宝贝的体重）绑定到界面上，更多使用参考项目中的代码。 RepositoryRepository 设计模式是最流行、应用最广泛的设计模式之一，在 Repository 层获取网络数据，并将数据存储到数据库中，在这一层中有两个非常重要的成员 Paging3 库中的 RemoteMediator 和 Data Mappers。 RemoteMediator在之前的文章 Jetpack 成员 Paging3 实践以及源码分析（一） 和 Jetpack 新成员 Paging3 网络实践及原理分析（二） 分别分析了使用 Paging3 访问 数据库 和 网络，但是遗漏了 RemoteMediator 类的使用，RemoteMediator 是 Paging3 当中一个非常重要的成员，用于实现 数据库 和 网络 访问，所以这里是对之前的文章一个补充。 RemoteMediator 很重要，需要单独花一篇文章去分析，为了节省篇幅，在这里不会详细的去分析它，如果对 RemoteMediator 不太理解没有关系，我会在后续的文章里面详细的分析它。 项目中网络访问用的是 Retrofit2 &amp; OkHttp3 用来请求网络数据，使用 Room 作为数据库存储，将获得的数据保存到数据库中，Room 在 SQLite 上提供了一个抽象层，流畅地访问 SQLite 数据库，同时拥有了 SQLite 全部功能，在编译的时候进行错误检查。 @OptIn(ExperimentalPagingApi::class)class PokemonRemoteMediator( val api: PokemonService, val db: AppDataBase) : RemoteMediator&lt;Int, PokemonEntity&gt;() { val mPageKey = 0 override suspend fun load( loadType: LoadType, state: PagingState&lt;Int, PokemonEntity&gt; ): MediatorResult { try { ...... val pageKey = when (loadType) { // 首次访问 或者调用 PagingDataAdapter.refresh() LoadType.REFRESH -&gt; null // 在当前加载的数据集的开头加载数据时 LoadType.PREPEND -&gt; return MediatorResult.Success(endOfPaginationReached = true) // 在当前数据集末尾添加数据 LoadType.APPEND -&gt; { ...... if (remoteKey == null || remoteKey.nextKey == null) { return MediatorResult.Success(endOfPaginationReached = true) } remoteKey.nextKey } } ...... // 使用 Retrofit2 获取网络数据 val page = pageKey ?: 0 val result = api.fetchPokemonList( state.config.pageSize, page * state.config.pageSize ).results ....... db.withTransaction { if (loadType == LoadType.REFRESH) { // 当首次加载，或者下拉刷新的时候，清空当前数据 } ...... // 存储获取到的数据 remoteKeysDao.insertAll(entity) pokemonDao.insertPokemon(item) } return MediatorResult.Success(endOfPaginationReached = endOfPaginationReached) } catch (e: IOException) { return MediatorResult.Error(e) } catch (e: HttpException) { return MediatorResult.Error(e) } }} 注意：使用了 @OptIn(ExperimentalPagingApi::class) 需要在 App 模块 build.gradle 文件内添加以下代码。 android { kotlinOptions { freeCompilerArgs += [&quot;-Xopt-in=kotlin.RequiresOptIn&quot;] }} 在 RemoteMediator 的实现类 PokemonRemoteMediator 中的核心部分是关于参数 LoadType 的判断。 LoadType.REFRESH：首次访问 或者调用 PagingDataAdapter.refresh() 触发，这里不需要做任何操作，返回 null 就可以 LoadType.PREPEND：在当前列表头部添加数据的时候时触发，实际在项目中基本很少会用到直接返回 MediatorResult.Success(endOfPaginationReached = true) ，参数 endOfPaginationReached 表示没有数据了不在加载 LoadType.APPEND：下拉加载更多时触发，这里获取下一页的 key, 如果 key 不存在，表示已经没有更多数据，直接返回 MediatorResult.Success(endOfPaginationReached = true) 不会在进行网络和数据库的访问 接下来的逻辑和之前请求网络数据的逻辑没有什么区别了，使用 Retrofit2 获取网络数据，然后使用 Room 将数据保存到数据库中。 接下来聊一下 Repository 中另外一个重要的成员 Data Mapper，在项目中起到了非常的重要，在一个快速开发的项目中，为了越快完成第一个版本交付，下意识的将数据源和 UI 绑定到一起，当业务逐渐增多，数据源变化了，上层也要一起变化，导致后期的重构工作量很大，核心的原因耦合性太强了。 Data Mapper（个人建议）Data Mapper 的意识非常重要，在项目中起到了非常的重要，关于 Data Mappers 在 Repository 中的重要性可以看一下国外大神写的这篇文章 The “Real” Repository Pattern in Android 在 Medium 上获得了 4.9K 的赞。 使用 Data Mapper 分离数据源的 Model 和 页面显示的 Model，不要因为数据源的增加、修改或者删除，导致上层页面也要跟着一起修改，换句话说使用 Data Mapper 做一个中间转换，如下图所示，来源于网络： 使用 Data Mapper（数据映射）优点如下： 数据源的更改不会影响上层的业务 糟糕的后端实现不会影响上层的业务 ( 想象一下，如果你被迫执行2个网络请求，因为后端不能在一个请求中提供你需要的所有信息，你会让这个问题影响你的整个代码吗? ) Data Mapper 便于做单元测试，确保不会因为数据源的变化，而影响上层的业务 如果在一个大型项目中直接使用 Data Mapper 会有适得其反的效果，所以需要结合设计模式来完善，这不在本文讨论范围之内，其实在这里我想表达是，不要因为快速实现某个功能，下意识的将数据源的 model 和 UI 绑定在一起。 Data Mappe 实现方式有很多种，可以手动实现，也可以通过引入第三方框架，其中有名框架 modelmapper，在 PokemonGo 项目中是手动实现的。 Koltin Flow停止使用 RxJava，尝试一下 Flow，不仅简单而且功能很强大，Retrofit2 和 Room 也都提供了对应的支持。 Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库，也叫做异步流，类似 RxJava 的 Observable，在 PokemonGo 项目中也用到了 Flow。 override suspend fun featchPokemonInfo(name: String): Flow&lt;PokemonInfoModel&gt; { return flow { val pokemonDao = db.pokemonInfoDao() var infoModel = pokemonDao.getPokemon(name) // 查询数据库是否存在，如果不存在请求网络 if (infoModel == null) { // 网络请求 val netWorkPokemonInfo = api.fetchPokemonInfo(name) ...... pokemonDao.insertPokemon(infoModel) // 插入更新数据库 } val model = mapper2InfoModel.map(infoModel) // 数据转换 emit(model) }.flowOn(Dispatchers.IO)} 在这里做了三件事： 查询数据库是否存在，如果不存在请求网络 请求网络获取数据，更新数据库 将数据源的 Model 转换为页面显示的 Model 依赖注入Hilt、Dagger、Koin 等等都是依赖注入库，使用依赖注入库有以下优点： 依赖注入库会自动释放不再使用的对象，减少资源的过度使用。 在配置 scopes 范围内，可重用依赖项和创建的实例，提高代码的可重用性，减少了很多模板代码。 代码变得更具可读性。 易于构建对象。 编写低耦合代码，更容易测试。 在 PokemonGo 项目中使用的是 Hilt，Hilt 是在 Dagger 基础上进行开发的，减少了在项目中进行手动依赖，Hilt 集成了 Jetpack 库和 Android 框架类，并删除了大部分模板代码，让开发者只需要关注如何进行绑定，同时 Hilt 也继承了 Dagger 优点，编译时正确性、运行时性能、并且得到了 Android Studio 的支持，来看一下 Hilt 与 Room 在一起使用的例子。 @Module@InstallIn(ApplicationComponent::class)object RoomModule { /** * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。 * @Singleton 提供单例 */ @Provides @Singleton fun provideAppDataBase(application: Application): AppDataBase { return Room .databaseBuilder(application, AppDataBase::class.java, &quot;dhl.db&quot;) .fallbackToDestructiveMigration() .allowMainThreadQueries() .build() } @Singleton @Provides fun provideTasksRepository( db: AppDataBase ): Repository { return PokemonFactory.makePokemonRepository(db) }} 这里需要用到 @Module 注解，使用 @Module 注解的普通类，在其内部提供 Room 的实例，更多使用可以查看 PokemonGo 项目。 小巧灵活的进度条神奇宝贝详情页的进度条使用的是 JProgressView ：一个小巧灵活可定制的进度条，支持图形：圆形、圆角矩形、矩形等等，效果如下图所示： 起源于当时想用一个现成的库，但是在网上找了很多，没有一个合适自己的，要不大而全，要不作者好久没更新了，要不不兼容 DataBinding，于是乎就自己封装了一个小巧灵活的进度条，项目长期维护并持续更新，如果有更好的建议欢迎告知我，JProgressView 使用非常的简单，根据自己的需求去配置即可。 &lt;com.hi.dhl.jprogressview.JProgressView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;18dp&quot; android:layout_below=&quot;@+id/exp&quot; android:translationZ=&quot;100dp&quot; app:maxProgressValue=&quot;@{viewModel.pokemon.maxExp}&quot; app:progressValue=&quot;@{viewModel.pokemon.exp}&quot; app:progress_animate_duration=&quot;@integer/progress_animate_duration&quot; app:progress_color=&quot;@color/color_progress_4&quot; app:progress_color_background=&quot;@color/color_progress_bg&quot; app:progress_paint_bg_width=&quot;@dimen/circle_stroke_width&quot; app:progress_paint_value_width=&quot;@dimen/circle_stroke_width&quot; app:progress_text_color=&quot;@android:color/black&quot; app:progress_text_size=&quot;@dimen/text_size_12sp&quot; app:progress_type=&quot;@integer/porgress_tpye_round_rect&quot; /&gt; 名称 值类型 默认值 备注 progress_type integer 圆形：1 矩形：0；矩形：0；矩形：0 progress_animate_duration integer 2000 动画运行时间 progress_color color Color.GRAY 当前进度颜色 progress_color_background color Color.GRAY 进度条背景颜色 progress_paint_bg_width dimen 10 进度条背景画笔的宽度 progress_paint_value_width dimen 10 当前进度画笔的宽度 progress_text_color color Color.BLUE 进度条上的文字的颜色 progress_text_size dimen sp2Px(20f) 进度条上的文字的大小 progress_text_visible boolean 默认不显示：false 是否显示文字 progress_value integer 0 当前进度 progress_value_max integer 100 当前进度条的最大值 更多关于进度条的使用，查看 JProgressView 仓库，全文到这里就结束了，为了节省篇幅，很多在之前系列文章里面分析过的，这里不在详细分析了，更多技术细节会在后续的系列文章中分析。 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请在仓库右上角帮我点个赞，后面我会陆续完成更多 Jetpack 新成员的项目实践","link":"/2020/08/22/jetpack/08-PokemonGo/"},{"title":"全方面分析 Hilt 和 Koin 性能","text":"前言Hilt 系列文章 Jetpack 成员 Hilt 实践（一）启程过坑记 Jetpack 成员 Hilt 结合 App Startup（二）进阶篇 Jetpack 成员 Hilt 与 Dagger 区别 (三) 落地篇 Koin、Dagger、Hilt 目前都是非常流行的库，面对这么多层出不穷的新技术，我们该做如何选择，是一直困扰我们的一个问题，之前我分析过 Koin 和 Dagger 的性能对比，Hilt 与 Dagger 的不同之处，可以点击下方链接前往查看。 放弃 Dagger 拥抱 Koin Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇 这是 Hilt 系列的第四篇，主要来分析 Hilt 和 Koin 的性能，如果你之前对 Hilt 和 Koin 不了解也没有关系，对阅读本文没有什么影响，接下来将会从以下几个方面来分析 Hilt 和 Koin 不同之处。 依赖注入的优点？ Koin 为什么可以做到无代码生成、无反射？ AndroidStudio 支持 Hilt 和 Koin 在关联代码间进行导航吗？ Hilt 和 Koin 谁的编译速度更快？以及为什么？ 比较 Hilt 和 Koin 代码行数？ Hilt 和 Koin 在使用上的区别，谁上手最快？ 依赖注入的优点Koin 是为 Kotlin 开发者提供的一个实用型轻量级依赖注入框架，采用纯 Kotlin 语言编写而成，仅使用功能解析，无代理、无代码生成、无反射。 Hilt 是在 Dagger 基础上进行开发的，减少了在项目中进行手动依赖，Hilt 集成了 Jetpack 库和 Android 框架类，并删除了大部分模板代码，让开发者只需要关注如何进行绑定，同时 Hilt 也继承了 Dagger 优点，编译时正确性、运行时性能、并且得到了 Android Studio 的支持。 Hilt、Dagger、Koin 等等都是依赖注入库，依赖注入是面向对象设计中最好的架构模式之一，使用依赖注入库有以下优点： 依赖注入库会自动释放不再使用的对象，减少资源的过度使用。 在指定范围内，可重用依赖项和创建的实例，提高代码的可重用性，减少了很多模板代码。 代码变得更具可读性。 易于构建对象。 编写低耦合代码，更容易测试。 Hilt VS Koin接下来将从 AndroidStudio 基础支持、项目结构、代码行数、编译时间、使用上的不同，这几个方面对 Hilt 和 Koin 进行全方面的分析。 Android Studio 强大的基础支持Android Studio &gt;= 4.1 的版本，在编辑器和代码行号之间，增加了一个新的 “间距图标”，可以在 Dagger 的关联代码间进行导航，包括依赖项的生产者、消费者、组件、子组件以及模块。 Hilt 是在 Dagger 基础上进行开发的，所以 Hilt 自然也拥有了 Dagger 的优点，在 Android Studio &gt;= 4.1 版本上也支持在 Hilt 的关联代码间进行导航，如下图所示。 PS： 我用的版本是 Android Studio 4.1 Canary 10，命名和图标在不同版本上会有差异。 有了 Android Studio 支持，在 Android 应用中 Dagger 和 Hilt 在关联代码间进行导航是如此简单。 这两个图标的意思如下： 左边(向上箭头)的图标: 提供类型的地方 (即依赖项来自何处) 右边的图标: 类型被当作依赖项使用的地方 遗憾的是 Koin 不支持，其实 Koin 并不需要这个功能，Koin 并不像 Hilt 注入代码那么分散，而且 Koin 注入关系很明确，可以很方便的定位到与它相关联的代码，并且 Koin 提供的 Debug 工具，可以打印出其构建过程，帮助我们分析。 而 Hilt 不一样的是 Hilt 采用注解的方式，在使用 Hilt 的项目中，如果想要弄清楚其依赖项来自 @Inject 修饰的构造器、@Binds 或者 @Provides 修饰的方法？还是限定符？不是一件容易的事，尤其在一个大型复杂的的项目中，想要弄清楚它们之间的依赖关系是非常困难的，而 Android Studio &gt;= 4.1 的版本，增加的 “间距图标”，帮助我们解决了这个问题。 比较 Hilt 和 Koin 项目结构为了能够正确比较这两种方式，新建了两个项目 Project-Hilt 和 Project-Koin， 分别用 Hilt 和 Koin 去实现，Project-Hilt 和 Project-Koin 两个项目的依赖库版本管理统一用 Composing builds 的方式（关于 Composing builds 请参考这篇文章 再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度），除了它们本身的依赖库，其他的依赖库都是相同的，如下图所示： 项目 Project-Hilt 和 Project-Koin 都分别实现了 Room 和 Retrofit 进行数据库和网络访问，统一在 Repository 里面进行处理，它们的依赖注入都放在了 di 下面，这应该是一个小型 App 基础架构，如下图所示： 如上图所示，这里需要关注 di 包下的类，Project-Hilt 和 Project-Koin 分别注入了 Room、Retrofit 和 Repository，以 Hilt 注入的方式至少需要三个文件才能完成，但是如果使用 Koin 的方式只需要一个文件就可以完成，后面我会进行详细的分析。 比较 Koin 和 Hilt 代码行数项目 Project-Hilt 和 Project-Koin 除了它们本身的依赖之外，其他的依赖都是相同的。 我使用 Statistic 工具来进行代码行数的统计，反复对比了项目编译前和编译后，它们的结果如下所示： 代码行数 Hilt Koin 编译之前 2414 2414 编译之后 149608 138405 正如你所见 Hilt 生成的代码多于 Koin，随着项目越来越复杂，生成的代码量会越来越多。 比较 Koin 和 Hilt 编译时间为了保证测试的准确性，每次编译之前我都会先 clean 然后才会 rebuild，反复的进行了三次这样的操作，它们的结果如下所示。 第一次编译结果： Hilt:BUILD SUCCESSFUL in 28s27 actionable tasks: 27 executedKoin:BUILD SUCCESSFUL in 17s27 actionable tasks: 27 executed 第二次编译结果： Hilt:BUILD SUCCESSFUL in 22s27 actionable tasks: 27 executedKoin:BUILD SUCCESSFUL in 15s27 actionable tasks: 27 executed 第三编译结果： Hilt:BUILD SUCCESSFUL in 35s27 actionable tasks: 27 executedKoin:BUILD SUCCESSFUL in 18s27 actionable tasks: 27 executed 每次的编译时间肯定是不一样的，速度取决于你的电脑的环境，不管执行多少次，结果如上所示 Hilt 编译时间总是大于 Koin，这个结果告诉我们，如果在一个非常大型的项目，这个代价是非常昂贵。 为什么 Hilt 编译时间总是大于 Koin 因为在 Koin 中不需要使用注解，也不需要用 kapt，这意味着没有额外的代码生成，所有的代码都是 Kotlin 原始代码，所以说 Hilt 编译时间总是大于 Koin，从这个角度上同时也解释了，为什么会说 Koin 仅使用功能解析，无额外代码生成。 Koin 和 Hilt 使用上的不同为了节省篇幅，这里只会列出部分代码，具体详细使用参考我之前写的 Hilt 入门三部曲，包含了 Hilt 所有的用法以及实战案例。 Jetpack 新成员 Hilt 实践（一）启程过坑记：介绍了 Hilt 的常用注解、以及在实践过程中遇到的一些坑，Hilt 如何与 Android 框架类进行绑定，以及他们的生命周期。 Jetpack 新成员 Hilt 实践之 App Startup（二）进阶篇：分析注解的区别、限定符和作用域注解的使用，以及如何在 ViewModel、App Startup、ContentProvider 中使用等等。 Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇：Hilt 与 Dagger 不同之处，以及在多模块中局限性以及使用。 在项目中使用 Hilt 如果我们需要在项目中使用 Hilt，我们需要添加 Hilt 插件和依赖库，首先在 project 的 build.gradle 添加以下依赖。 buildscript { ... dependencies { ... classpath 'com.google.dagger:hilt-android-gradle-plugin:2.28-alpha' }} 然后在 App 模块中的 build.gradle 文件中添加以下代码。 ...apply plugin: 'kotlin-kapt'apply plugin: 'dagger.hilt.android.plugin'android { compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } // For Kotlin projects kotlinOptions { jvmTarget = JavaVersion.VERSION_1_8.toString() }}dependencies { implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot; kapt &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;} 注意： 这里有一个坑，对于 Kotlin 项目，需要添加 kotlinOptions，这是 Google 文档 Dependency injection with Hilt 中没有提到的，否则使用 ViewModel 会编译不过。 完成以上步骤就可以在项目中使用 Hilt 了，所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application，这是依赖注入容器的入口。 @HiltAndroidAppclass HiltApplication : Application() { /** * 1. 所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application * 2. @HiltAndroidApp 将会触发 Hilt 代码的生成，包括用作应用程序依赖项容器的基类 * 3. 生成的 Hilt 组件依附于 Application 的生命周期，它也是 App 的父组件，提供其他组件访问的依赖 * 4. 在 Application 中设置好 @HiltAndroidApp 之后，就可以使用 Hilt 提供的组件了， * Hilt 提供的 @AndroidEntryPoint 注解用于提供 Android 类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）等等 * Application 使用 @HiltAndroidApp 注解 */} @HiltAndroidApp 注解将会触发 Hilt 代码的生成，用作应用程序依赖项容器的基类，这下我们就可以在 di 包下注入 Room、Retrofit 和 Repository，其中 Room 和 Retrofit 比较简单，这里我们看一下 如何注入 Repository， Repository 有一个子类 TasksRepository，代码如下所示。 class TasksRepository @Inject constructor( private val localDataSource: DataSource, private val remoteDataSource: DataSource) : Repository TasksRepository 的构造函数包含了 localDataSource 和 remoteDataSource，需要构建这两个 DataSource 才能完成 TasksRepository 注入，代码如下所示： @Module@InstallIn(ApplicationComponent::class)object QualifierModule { // 为每个声明的限定符，提供对应的类型实例，和 @Binds 或者 @Provides 一起使用 @Qualifier // @Retention 定义了注解的生命周期，对应三个值（SOURCE、BINARY、RUNTIME） // AnnotationRetention.SOURCE：仅编译期，不存储在二进制输出中。 // AnnotationRetention.BINARY：存储在二进制输出中，但对反射不可见。 // AnnotationRetention.RUNTIME：存储在二进制输出中，对反射可见。 @Retention(AnnotationRetention.RUNTIME) annotation class RemoteTasksDataSource // 注解的名字，后面直接使用它 @Qualifier @Retention(AnnotationRetention.RUNTIME) annotation class LocalTasksDataSource @Singleton @RemoteTasksDataSource @Provides fun provideTasksRemoteDataSource(): DataSource { // 返回值相同 return RemoteDataSource() // 不同的实现 } @Singleton @LocalTasksDataSource @Provides fun provideTaskLocalDataSource(appDatabase: AppDataBase): DataSource { // 返回值相同 return LocalDataSource(appDatabase.personDao()) // 不同的实现 } @Singleton @Provides fun provideTasksRepository( @LocalTasksDataSource localDataSource: DataSource, @RemoteTasksDataSource remoteDataSource: DataSource ): Repository { return TasksRepository( localDataSource, remoteDataSource ) }} 这只是 Repository 注入代码，当然这并不是全部，还有 Room、Retrofit、Activity、Fragment、ViewModel 等等需要注入，随着项目越来越复杂，多模块化的拆分，还有更多的事情需要去做。 Hilt 和 Dagger 比起来虽然简单很多，但是 Hilt 相比于 Koin，其入门的门槛还是很高的，尤其是 Hilt 的注解，需要了解其每个注解的含义才能正确的使用，避免资源的浪费，但是对于注解的爱好者来说，可能更偏向于使用 Hilt，接下来我们来看一下如何在项目中使用 Koin。 在项目中使用 Koin 如果要在项目中使用 Koin，需要在项目中添加 Koin 的依赖，我们只需要在 App 模块中的 build.gradle 文件中添加以下代码。 implementation “org.koin:koin-core:2.1.5”implementation “org.koin:koin-androidx-viewmodel:2.1.5” 如果需要在项目中使用 Koin 进行依赖注入，需要在 Application 或者其他的地方进行初始化。 class KoinApplication : Application() { override fun onCreate() { super.onCreate() startKoin { AndroidLogger(Level.DEBUG) androidContext(this@KoinApplication) modules(appModule) } }} 当初始化完成之后，就可以在项目中使用 Koin 了，首先我们来看一下如何在项目中注入 Repository， Repository 有一个子类 TasksRepository，代码和上文介绍的一样，需要在其构造函数构造 localDataSource 和 remoteDataSource 两个 DataSource。 class TasksRepository @Inject constructor( private val localDataSource: DataSource, private val remoteDataSource: DataSource) : Repository 那么在 Koin 中如何注入呢，很简单，只需要几行代码就可以完成。 val repoModule = module { single { LocalDataSource(get()) } single { RemoteDataSource() } single { TasksRepository(get(), get()) }}// 添加所有需要在 Application 中进行初始化的 moduleval appModule = listOf(repoModule) 和上面 Hilt 长长的代码比起来，Koin 是不是简单很多，那么 Room、Retrofit、ViewModel 如何注入呢，也很简单，代码如下所示。 // 注入 ViewModelval viewModele = module { viewModel { MainViewModel(get()) }}// 注入 Roomval localModule = module { single { AppDataBase.initDataBase(androidApplication()) } single { get&lt;AppDataBase&gt;().personDao() }}// 注入 Retrofitval remodeModule = module { single { GitHubService.createRetrofit() } single { get&lt;Retrofit&gt;().create(GitHubService::class.java) }}// 添加所有需要在 Application 中进行初始化的 moduleval appModule = listOf(viewModele, localModule, remodeModule) 上面 Koin 的代码严格意义上讲，其实不太规范，在这里只是为了和 Hilt 进行更好的对比。 到这里是不是感觉 Hilt 相比于 Koin 是不是简单很多，在阅读 Hilt 文档的时候花了好几天时间才消化，而 Koin 只需要花很短的时间。 我们在看一下使用 Hilt 和 Koin 完成 Room、Retrofit、Repository 和 ViewModel 等等全部的依赖注入需要多少行代码。 依赖注入框架 Hilt Koin 代码行数 122 42 正如你所见依赖注入部分的代码 Hilt 多于 Koin，示例中只是一个基本的项目架构，实际的项目往往比这要复杂的很多，所需要的代码也更多，也越来越复杂。 不仅仅如此而已，根据 Koin 文档介绍，Koin 不需要用到反射，那么无反射 Koin 是如何实现的呢，因为 Koin 基于 kotlin 基础上进行开发的，使用了 kotlin 强大的语法糖（例如 Inline、Reified 等等）和函数式编程，来看一个简单的例子。 inline fun &lt;reified T : ViewModel&gt; Module.viewModel( qualifier: Qualifier? = null, override: Boolean = false, noinline definition: Definition&lt;T&gt;): BeanDefinition&lt;T&gt; { val beanDefinition = factory(qualifier, override, definition) beanDefinition.setIsViewModel() return beanDefinition} 内联函数支持具体化的类型参数，使用 reified 修饰符来限定类型参数，可以在函数内部访问它，由于函数是内联的，所以不需要反射。 但是在另一方面 Koin 相比于 Hilt 错误提示不够友好，Hilt 是基于 Dagger 基础上进行开发的，所以 Hilt 自然也拥有了 Dagger 的优点，编译时正确性，对于一个大型项目来说，这是一个非常严重的问题，因为我们更喜欢编译错误而不是运行时错误。 总结我们总共从以下几个方面对 Hilt 和 Koin 进行全方面的分析： AndroidStudio 支持 Hilt 在关联代码间进行导航，支持在 @Inject 修饰的构造器、@Binds 或者 @Provides 修饰的方法、限定符之间进行跳转。 项目结构：完成 Hilt 的依赖注入需要的文件往往多于 Koin。 代码行数：使用 Statistic 工具来进行代码统计，反复对比了项目编译前和编译后，Hilt 生成的代码多于 Koin，随着项目越来越复杂，生成的代码量会越来越多。 代码行数 Hilt Koin 编译之前 2414 2414 编译之后 149608 138405 编译时间：Hilt 编译时间总是大于 Koin，这个结果告诉我们，如果是在一个非常大型的项目，这个代价是非常昂贵。 Hilt:BUILD SUCCESSFUL in 35s27 actionable tasks: 27 executedKoin:BUILD SUCCESSFUL in 18s27 actionable tasks: 27 executed 使用上对比：Hilt 使用起来要比 Koin 麻烦很多，其入门门槛高于 Koin，在阅读 Hilt 文档的时候花了好几天时间才消化，而 Koin 只需要花很短的时间，依赖注入部分的代码 Hilt 多于 Koin，在一个更大更复杂的项目中所需要的代码也更多，也越来越复杂。 依赖注入框架 Hilt Koin 代码行数 122 42 为什么 Hilt 编译时间总是大于 Koin？ 因为在 Koin 中不需要使用注解，也不需要 kapt，这意味着没有额外的代码生成，所有的代码都是 Kotlin 原始代码，所以说 Hilt 编译时间总是大于 Koin，从这个角度上同时也解释了，为什么会说 Koin 仅使用功能解析，无额外代码生成。 为什么 Koin 不需要用到反射？ 因为 Koin 基于 kotlin 基础上进行开发的，使用了 kotlin 强大的语法糖（例如 Inline、Reified 等等）和函数式编程，来看一个简单的例子。 inline fun &lt;reified T : ViewModel&gt; Module.viewModel( qualifier: Qualifier? = null, override: Boolean = false, noinline definition: Definition&lt;T&gt;): BeanDefinition&lt;T&gt; { val beanDefinition = factory(qualifier, override, definition) beanDefinition.setIsViewModel() return beanDefinition} 内联函数支持具体化的类型参数，使用 reified 修饰符来限定类型参数，可以在函数内部访问它，由于函数是内联的，所以不需要反射。 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请在仓库右上角帮我点个赞，后面我会陆续完成更多 Jetpack 新成员的项目实践","link":"/2020/08/22/jetpack/07-hilt-koin/"},{"title":"Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇","text":"在 Google 的 Hilt 文档中 Dependency injection with Hilt 只是简单的告诉我们 Hilt 是 Android 的依赖注入库，它减少了在项目中进行手动依赖，Hilt 是基于 Dagger 基础上进行开发的，为常见的 Android 类提供容器并自动管理它们的生命周期等等。 文档中的概念过于模糊，那么 Hilt 与 Dagger 在使用上有那些区别，并没有一个直观感受，而本文的目的就是详细的分析一下 Hilt 与 Dagger 到底有那些不同之处。 在之前的两篇文章中已经详细的介绍了 Hilt 注解的含义以及用法，并附上详细的案例，在代码中都有详细的注释，为了节省篇幅，本文不会在详细介绍 Hilt 注解的含义，可以点击下方链接前往查看。 Jetpack 新成员 Hilt 实践（一）启程过坑记：介绍了 Hilt 的常用注解、以及在实践过程中遇到的一些坑，Hilt 如何与 Android 框架类进行绑定，以及他们的生命周期。 Jetpack 新成员 Hilt 实践之 App Startup（二）进阶篇：分析注解的区别、限定符和作用域注解的使用，以及如何在 ViewModel、App Startup、ContentProvider 中使用等等。 代码已经上传到了 GitHub：AndroidX-Jetpack-Practice 如果对你有帮助，请在仓库右上角帮我点个赞，感谢。 在之前的文章中 放弃 Dagger 拥抱 Koin 分析了 Dagger 和 Koin 编译时间和使用上的不同等等，这篇文章主要从以下几个方面分析 Hilt 与 Dagger 的不同之处。 初始化对比？ 与 Android 框架类对比？ 与 Room、WorkManager 对比？ 与 ViewModule 对比？ Hilt 在多模块中的局限性？ 初始化对比无论使用 Hilt 还是使用 Dagger，使用它们之前都需要在 Application 里面进行初始化，这是依赖注入容器的入口。 Dagger在 Dagger 中我们必须通过 @Module 和 @Component 注解，创建对应的文件，并注入 Application // Component 声明了所有的 modules// ActivityAllModule 配置了所有的 activity@Singleton@Component(modules = arrayOf( AndroidInjectionModule::class, ActivitylModule::class))interface AppCompoment { fun inject(app: App) @Component.Builder interface Builder { @BindsInstance fun bindApplication(app: Application): Builder fun build(): AppCompoment }} 然后创建完 modules 和 components 文件之后，需要在 Application 中 初始化 Dagger, 需要实现 HasActivityInjector 接口，用来自动管理 Activity。 class App : Application(), HasActivityInjector { @Inject lateinit var dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Activity&gt; override fun attachBaseContext(base: Context?) { super.attachBaseContext(base) } override fun onCreate() { super.onCreate() DaggerAppCompoment.builder() .bindApplication(this) .build() .inject(this) } override fun activityInjector(): AndroidInjector&lt;Activity&gt; { return dispatchingAndroidInjector }} Hilt在 Hilt 中我们不需要手动指定包含每个模块，在 Application 中添加 @HiltAndroidApp 注解将会触发 Hilt 代码的生成，用作应用程序依赖项容器的基类。 @HiltAndroidAppclass HiltApplication : Application() { /** * 1. 所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application * 2. @HiltAndroidApp 将会触发 Hilt 代码的生成，包括用作应用程序依赖项容器的基类 * 3. 生成的 Hilt 组件依附于 Application 的生命周期，它也是 App 的父组件，提供其他组件访问的依赖 * 4. 在 Application 中设置好 @HiltAndroidApp 之后，就可以使用 Hilt 提供的组件了， * Hilt 提供的 @AndroidEntryPoint 注解用于提供 Android 类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）等等 * Application 使用 @HiltAndroidApp 注解 */} 所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application，这是依赖注入容器的入口。 Hilt 提供了 @ApplicationContext 和 @ActivityContext 两种预定义限定符，我们可以直接使用，不需要开发人员自己注入 Application。 与 Android 框架类对比我们来看一下 Dagger 和 Hilt 对于最常见的 Android 类 Application、Activity、Fragment、View、Service、BroadcastReceiver 的支持，我们以 Activity 和 Fragment 为例。 Dagger在 Dagger 中对于每一个 Activity 和 Fragment 都需要告诉 Dagger 如何注入它们，所以我们需要创建对应的 ActivityModule、FragmentModule。 每次有新增的 Fragment 和 Activity 必须添加在对应的 Module 文件中，每次添加 Activity 时都需要添加 @ContributesAndroidInjector 注解，用于自动生成子组件相关代码，帮我们减少重复的模板代码，编译的时候会自动创建的一个类 ActivitylModule_ContributeXXXXActivity，帮我们生成注入的代码。 // 把所有的 Activity 放到 ActivitylModule 进行统一管理@Moduleabstract class ActivitylModule(){ // ContributesAndroidInjector 用于自动生成子组件相关代码，帮我们减少重复的模板代码 // modules 指定子组件(当前 MainActivity 包含了 2 个 fragment，所以我们需要指定包含的 fragment) // 每次新建的 activity 都需要在这里手动添加 // 通过注解 @ActivityScope 指定 Activity 的 生命周期 @ActivityScope @ContributesAndroidInjector(modules = arrayOf(FragmentModule::class)) abstract fun contributeMainActivity():MainActivity}// 管理所有的 Fragment@Moduleabstract class FragmentModule { // 如果当前有新增的 Fragment 需要添加到这个模块中 @ContributesAndroidInjector abstract fun contributeHomeFragment(): HomeFragment @ContributesAndroidInjector abstract fun contributeAboutFragment(): AboutFragment} Dagger 提供了 HasSupportFragmentInjector 接口去自动管理 Fragment，所有的 Activity 继承 BaseActivity，我们需要实现 HasSupportFragmentInjector，并且需要在 Activity 和 Fragment 中添加 AndroidInjection.inject(this)。 abstract class BaseActivity : AppCompatActivity(),HasSupportFragmentInjector { @Inject lateinit var dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Fragment&gt; override fun onCreate(savedInstanceState: Bundle?) { AndroidInjection.inject(this) super.onCreate(savedInstanceState) } override fun supportFragmentInjector(): AndroidInjector&lt;Fragment&gt; { return dispatchingAndroidInjector }}abstract class BaseFragment : Fragment() { override fun onAttach(context: Context?) { super.onAttach(context) AndroidSupportInjection.inject(this) }} Hilt在 Hilt 中 Android 框架类完全由 Hilt 帮我管理，我们只要在 Activiyt 和 Fragmetn 中添加 @AndroidEntryPoint 即可。 @AndroidEntryPointclass HitAppCompatActivity : AppCompatActivity() {}@AndroidEntryPointclass HiltFragment : Fragment() {} Hilt 真做了很多优化工作，相比于 Dagger 而言，删除很多模板代码，不需要开发者手动管理，开发者只需要关注如何进行绑定即可。 与 Room、WorkManager 对比接下来我们来看一下 Dagger 和 Hilt 对于 Room、WorkManager 在使用上有什么区别，这里以 Room 为例。 Dagger在 Dagger 中使用 Room 需要使用 @Module 注解创建 RoomModule 文件，然后在 Component 中添加 RoomModule。 @Moduleclass RoomModule(val app: Application) { @Provides @Singleton fun providerAppDataBase(): AppDataBase = Room .databaseBuilder(app, AppDataBase::class.java, &quot;dhl.db&quot;) .fallbackToDestructiveMigration() .allowMainThreadQueries() .build()}// Component 声明了所有的 modules// ActivityAllModule 配置了所有的 activity// RoomModule 和数据库相关的@Singleton@Component(modules = arrayOf( AndroidInjectionModule::class, RoomModule::class, ActivitylModule::class))interface AppCompoment { fun inject(app: App) @Component.Builder interface Builder { @BindsInstance fun bindApplication(app: Application): Builder fun build(): AppCompoment }} 在 Dagger 中需要在对应的模块中添加组件对应的生命周期 @Singleton、@ActivityScope 等等。 @Singleton 对应的 Application。 @ActivityScope 对应的 Activity。 Hilt在 Hilt 中我们只需要使用注解 @Module 创建 RoomModule 文件即可，不需要自己手动去添加 Module。 使用 @InstallIn 注解指定 module 的生命周期，例如使用 @InstallIn(ApplicationComponent::class) 注解 module 会绑定到 Application 的生命周期上。 @Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 RoomModule 绑定到 Application 的生命周期。object RoomModule { /** * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。 * @Singleton 提供单例 */ @Provides @Singleton fun provideAppDataBase(application: Application): AppDataBase { return Room .databaseBuilder(application, AppDataBase::class.java, &quot;dhl.db&quot;) .fallbackToDestructiveMigration() .allowMainThreadQueries() .build() }} Hilt 提供了以下组件来绑定依赖与对应的 Android 类。 Hilt 提供的组件 对应的 Android 类 ApplicationComponent Application ActivityRetainedComponent ViewModel ActivityComponent Activity FragmentComponent Fragment ViewComponent View ViewWithFragmentComponent View annotated with @WithFragmentBindings ServiceComponent Service 与 ViewModule 对比？我们在 Android 组件中注入一个 ViewModels 实例，需要通过 ViewModelFactory 来绑定 ViewModels 实例，传统的调用方式如下所示： ViewModelProviders.of(this).get(DetailViewModel::class.java) 接下来我们来看一下在 Dagger 和 Hilt 中如何使用 ViewModule。 Dagger在 Dagger 中，对于每一个 ViewModel，需要告诉 Dagger 如何注入它们，所以我们需要创建 ViewModelModule 文件，在 ViewModelModule 中管理所有的 ViewModel。 @Moduleabstract class ViewModelModule { @Binds @IntoMap @ViewModelKey(DetailViewModel::class) abstract fun bindDetailViewModel(viewModel: DetailViewModel): ViewModel @Binds abstract fun bindViewModelFactory(factory: ViewModelFactory): ViewModelProvider.Factory} 创建完 ViewModelModule 文件之后，需要在 Component 中添加 ViewModelModule // Component 声明了所有的 modules// RoomModule 和数据库相关的// ActivityAllModule 配置了所有的 activity// ViewModelModule 配置所有的 ViewModel @Singleton@Component(modules = arrayOf( AndroidInjectionModule::class, RoomModule::class, ViewModelModule::class, ActivitylModule::class))interface AppCompoment { fun inject(app: App) @Component.Builder interface Builder { @BindsInstance fun bindApplication(app: Application): Builder fun build(): AppCompoment }} HiltHilt 为我们提供了 @ViewModelInject 注解来注入 ViewModel 实例，另外 Hilt 为 SavedStateHandle 类提供了 @Assisted 注解来注入 SavedStateHandle 实例。 class HiltViewModel @ViewModelInject constructor( private val tasksRepository: Repository, //SavedStateHandle 用于进程被终止时，存储和恢复数据 @Assisted private val savedStateHandle: SavedStateHandle) : ViewModel() Hilt 的局限性 Hilt 不支持 ContentProvider，如果你在想在 ContentProvider 中获取 Hilt 提供的依赖，需要使用 @EntryPoint 注解。具体如何使用，可以看之前的内容 在 Hilt 不支持的类中执行依赖注入 Hilt 在多模块项目中的局限性，多模块项目大概分为两种类型： 分级模块组成的应用程序。 动态功能模块（dynamic feature modules）组成的应用程序。 分级模块组成的应用程序如果多模块项目是由分级模块组成的应用程序，那么可以使用 Hilt 来完成依赖注入，分级模块依赖如下图所示。图来自 Google。 从上到下层层依赖，这种情况下可以直接使用 Hilt 进行依赖注入，和在单个 App 模块中使用是一样的，这里不再详述了，Hilt 在多模块中的使用的项目示例 HiltWithMultiModuleSimple 已经上传到 GitHub 上了，代码中有详细的注释。 动态功能模块应用程序如果是模块项目是 dynamic feature modules （动态功能模块）组成的应用程序，那么使用 Hilt 就有些局限性了，dynamic feature modules 简称 DFMs。 在 DFMs 中，模块之间相互依赖的方式是颠倒的，因此 Hilt 无法在动态功能模块中使用，所以在 DFMs 中只能使用 Dagger 完成依赖注入，在 DFMs 中模块依赖如下图所示。图来自 Google。 一个 App 被分割成一个 Base APK 和多个模块 APK。 Base APK: 这个 APK 包含了基本的代码和资源（services, content providers, permissions）等等，其他被分割的模块 APK 都可以访问，当一个用户请求下载你的应用，这个 APK 首先下载和安装。 Configuration APK：每个 APK 包含特定的资源。当用户下载你的应用程序时，他们的设备只下载和安装针对他们设备的 Configuration APK。 Dynamic Feature APK：每个 APK 包含应用程序的某个功能的代码和资源，这些功能在首次安装应用程序时是不需要的。用户可以按需安装 Feature APK，从而为用户提供额外的功能。每个 Feature APK 都依赖于 Base APK。 例如 dynamic-feature1 依赖于 Base APK，所以在 DFMs 中，模块之间相互依赖的方式是颠倒的。 如何解决 Hilt 在 DFMs 中组件依赖问题？ 在 app module 中或者任何其它可以被 Hilt 处理的模块中，定义一个接口并添加 @EntryPoint 注解，然后添加 @InstallIn 注解指定 module 的范围。 // LoginModuleDependencies.kt - File in the app module.@EntryPoint@InstallIn(ApplicationComponent::class)interface LoginModuleDependencies { @AuthInterceptorOkHttpClient fun okHttpClient(): OkHttpClient} 在 dynamic-feature1 模块中，使用 Dagger 中的 @Component 注解，创建 Component 文件，并在 dependencies 中指定通过 @EntryPoint 注解声明的接口。 @Component(dependencies = [LoginModuleDependencies::class])interface LoginComponent { fun inject(activity: LoginActivity) @Component.Builder interface Builder { fun context(@BindsInstance context: Context): Builder fun appDependencies(loginModuleDependencies: LoginModuleDependencies): Builder fun build(): LoginComponent }} 上面步骤完成之后，就可以在 DFMs 中使用 Dagger 完成依赖注入，就跟我们之前介绍的使用 Dagger 方式一样。 在 Application 中 初始化 Dagger，并实现 HasActivityInjector 接口。 对于每一个 ViewModel、Fragment 和 Activity 我们需要告诉 Dagger 如何注入它们。 在每个 modules 中添加 Fragments、Activities 和 ViewModels。 所有的 Activity 继承 BaseActivity，我们需要实现 HasSupportFragmentInjector。 总结关于 Hilt 在多模块中的使用的项目示例 HiltWithMultiModuleSimple 已经上传的 GitHub 可以前去查看。 到这里 Hilt 入门三部曲终于完结了，从入门、进阶、到落地，所有注解的含义以及项目示例、以及和 Jetpack 组件的使用，Hilt 与 Dagger 不同之处，以及在多模块中局限性以及使用，全部都介绍完了。 Jetpack 新成员 Hilt 实践（一）启程过坑记：介绍了 Hilt 的常用注解、以及在实践过程中遇到的一些坑，Hilt 如何与 Android 框架类进行绑定，以及他们的生命周期。 Jetpack 新成员 Hilt 实践之 App Startup（二）进阶篇：分析注解的区别、限定符和作用域注解的使用，以及如何在 ViewModel、App Startup、ContentProvider 中使用等等。 Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇：Hilt 与 Dagger 不同之处，以及在多模块中局限性以及使用。 对于使用 Dagger 小伙伴们，应该能够感受到从入门到放弃是什么感觉，Dagger 学习的成本是非常高的，如果项目中引入了 Dagger 意味着团队每个人都要学习 Dagger，无疑这个成本是巨大的，而且使用起来非常的复杂。对于每一个 ViewModel、Fragment 和 Activity 我们需要告诉 Dagger 如何注入它们。 而 Hilt 的学习成本相对于 Dagger 而言成本非常低，Hilt 集成了 Jetpack 库和 Android 框架类，并自动管理它们的生命周期，让开发者只需要关注如何进行绑定，而不需要管理所有 Dagger 配置的问题。 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请在仓库右上角帮我点个赞，后面我会陆续完成更多 Jetpack 新成员的项目实践","link":"/2020/08/22/jetpack/06-hilt-dagger/"},{"title":"Jetpack 新成员 Hilt 实践之 App Startup（二）进阶篇","text":"在上一篇文章 Jetpack 新成员 Hilt 实践（一）启程过坑记 分别介绍了 Hilt 的常用注解、以及在实践过程中遇到的一些坑，Hilt 如何 Android 框架类进行绑定，以及他们的生命周期，这篇文章继续讲解 Hilt 的用法，代码已经全部上传到 GitHub：HiltWithAppStartupSimple 如果对你有帮助，请在仓库右上角帮我点个赞。 Hilt 涉及的知识点有点多而且比较难理解，在看本篇文章之前一定要先看一下之前的文章 Jetpack 新成员 Hilt 实践（一），为了节省篇幅，这篇文章将会忽略 Hilt 环境配置的过程等等之前文章已经介绍过的内容。 另外如果想了解 Google 新推出的另外两个 Jetpack 新成员 App Startup 和 Paging3 的实践与原理，可以点击下方链接前去查看。 Jetpack 成员 AndroidX App Startup 实践以及原理分析 Jetpack 成员 Paging3 数据实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack 成员 Paging3 使用 RemoteMediator 实现加载网络分页数据并更新到数据库中（三） 代码地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 通过这篇文章你将学习到以下内容： 什么是注解？ @assist 注解和 SavedStateHandle 如何使用？ 如何使用 @Binds 注解实现接口注入？ @Binds 和 @Provides 的区别？ 限定符 @Qualifier 的使用？ 自定义限定符 @qualifers 预定义的限定符 @qualifers 组件作用域 @scopes 如何使用？ 如何在 Hilt 不支持的类中执行依赖注入？ Hilt 如何和 ContentProvider 一起使用？ Hilt 如何和 App Startup 一起使用？ Hilt 是基于 Dagger 基础上进行开发的，如果了解 Dagger 朋友们，应该会感觉它们很像，但是与 Dagger 不同的是， Hilt 集成了 Jetpack 库和 Android 框架类，并删除了大部分模板代码，让开发者只需要关注如何进行绑定，而不需要管理所有 Dagger 配置的问题。 在上篇文章已经介绍过， Hilt 如何 Android 框架类进行绑定，以及他们的生命周期，这篇文章将介绍 Hilt 如何和 Jetpack 组件（ViewModel、App Startup）一起绑定，在开始介绍之前我们先来了解一下什么是注解。 什么是注解之前有小伙伴在 WX 上问过我，对注解不太了解，所以想在这里想简单的提一下。 注解是放在 Java 源码的类、方法、字段、参数前的一种特殊“注释”，注解则可以被编译器打包进入 class 文件，可以在编译，类加载，运行时被读取。 常见的三个注解 @Override、@Deprecated、@SuppressWarnings @Override： 确保子类重写了父类的方法，编译器会检查该方法是否正确地实现。 @Deprecated：表示某个类、方法已经过时，编译器会检查，如果使用了过时的方法，会给出提示。 @SuppressWarnings：编译器会忽略产生的警告。 Hilt 如何和 ViewModel 一起使用？在上一篇文章只是简单的介绍了 Hilt 如何和 ViewModel 一起使用，我们继续介绍 ViewModel 的另外一个重要的参数 SavedStateHandle，首先需要添加依赖。 在 App 模块中的 build.gradle 文件中添加以下代码。 implementation 'androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha01'kapt 'androidx.hilt:hilt-compiler:1.0.0-alpha01' koltin 使用 kapt, Java 使用 annotationProcessor。 注意： 这个是在 Google 文档上没有提到的，如果使用的是 kotlin 的话需要额外在 App 模块中的 build.gradle 文件中添加以下代码，否则调用 by viewModels() 会编译不过。 // For Kotlin projectskotlinOptions { jvmTarget = &quot;1.8&quot;} 在 ViewModel 的构造函数中使用 @ViewModelInject 注解提供一个 ViewModel，如果需要用到 SavedStateHandle，需要使用 @assist 注解添加 SavedStateHandle 依赖项，代码如下所示。 class HiltViewModel @ViewModelInject constructor( private val tasksRepository: Repository, //SavedStateHandle 用于进程被终止时，保存和恢复数据 @Assisted private val savedStateHandle: SavedStateHandle) : ViewModel() { // getLiveData 方法会取得一个与 key 相关联的 MutableLiveData // 当与 key 相对应的 value 改变时 MutableLiveData 也会更新。 private val _userId: MutableLiveData&lt;String&gt; = savedStateHandle.getLiveData(USER_KEY) // 对外暴露不可变的 LiveData val userId: LiveData&lt;String&gt; = _userId companion object { private val USER_KEY = &quot;userId&quot; }} 将用户的 userId 存储在 SavedStateHandle 中，当进程被终止时保存和恢复对应的数据。 SavedStateHandle 是什么？SavedStateHandle 为了解决什么问题？ Activity 和 Fragment 通常会在下面三种情况下被销毁（以下内容来自 Google）： 从当前界面永久离开： 用户导航至其他界面或直接关闭 Activity (通过点击返回按钮或执行的操作调用了 finish() 方法)。对应 Activity 实例被永久关闭。 Activity 配置 (configuration) 被改变： 例如旋转屏幕等操作，会使 Activity 需要立即重建。 应用在后台时，其进程被系统杀死： 这种情况发生在设备剩余运行内存不足，系统又需要释放一些内存的时候，当进程在后台被杀死后，用户又返回该应用时 Activity 需要被重建。 ViewModel 会帮您处理第二种情况，因为在这种情况下 ViewModel 没有被销毁，而在第三种情况下，ViewModel 被销毁了, 当进程在后台被杀死后，则需要使用 onSaveInstanceState() 作为备用保存数据的方式。 SavedStateHandle 的出现就是为了解决 App 进程终止保存和恢复数据问题，ViewModel 不需要向 Activity 发送和接收状态。相反的，现在可以在 ViewModel 中处理保存和恢复数据。 SavedStateHandle 类似于一个 Bundle，它是数据的键-值映射，这个 SavedStateHandle 包含在 ViewModel 中，它在后台进程终止时仍然存在，以前保存在 onSaveInstanceState() 中的任何数据现在都可以保存在 SavedStateHandle 中。 使用 @Binds 注解实现接口注入？注入接口实例有两种方式分别使用注解 @Binds 和 @Provides，@Provides 的方式在上一篇文章 Jetpack 新成员 Hilt 实践（一）启程过坑记 Hilt 如何和 Room 一起使用 和 Hilt 如何和第三方组件一起使用 都有介绍，这里我们来介绍如何使用注解 @Binds。 interface WorkService { fun init()}/** * 注入构造函数，因为 Hilt 需要知道如何提供 WorkServiceImpl 的实例 */class WorkServiceImpl @Inject constructor() : WorkService { override fun init() { Log.e(TAG, &quot; I am an WorkServiceImpl&quot;) } }@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ActivityComponent，因此 WorkServiceModule 绑定到 ActivityComponent 的生命周期。abstract class WorkServiceModule { /** * @Binds 注解告诉 Hilt 需要提供接口实例时使用哪个实现 * * bindAnalyticsService 函数需要为 Hilt 提供了以下信息 * 1. 函数返回类型告诉 Hilt 提供了哪个接口的实例 * 2. 函数参数告诉 Hilt 提供哪个实现 */ @Binds abstract fun bindAnalyticsService( workServiceImpl: WorkServiceImpl ): WorkService} 使用注解 @Binds 时，需要提供以下两个信息： 函数参数告诉 Hilt 接口的实现类，例如参数 WorkServiceImpl 是接口 WorkService 的实现类。 函数返回类型告诉 Hilt 提供了哪个接口的实例。 注解 @Binds 和 注解 @Provides 的区别？ @Binds：需要在方法参数里面明确指明接口的实现类。 @Provides：不需要在方法参数里面明确指明接口的实现类，由第三方框架实现，通常用于和第三方框架进行绑定(Retrofit、Room 等等) // 有自己的接口实现@Bindsabstract fun bindAnalyticsService( workServiceImpl: WorkServiceImpl): WorkService// 没有自己的接口实现@Providesfun providePersonDao(application: Application): PersonDao { return Room .databaseBuilder(application, AppDataBase::class.java, &quot;dhl.db&quot;) .fallbackToDestructiveMigration() .allowMainThreadQueries() .build().personDao()} @Providesfun provideGitHubService(): GitHubService { return Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build().create(GitHubService::class.java)} 限定符 @Qualifier 注解的使用来自 Google：@Qualifier 是一种注解，当类型定义了多个绑定时，使用它来标识该类型的特定绑定。 换句话说 @Qualifier 声明同一个类型，可以在多处进行绑定，我将限定符分为两种。 自定义限定符 预定义限定符 自定义限定符的使用我们先用注解 @Qualifier 声明两个不同的实现。 // 为每个声明的限定符，提供对应的类型实例，和 @Binds 或者 @Provides 一起使用@Qualifier// @Retention 定义了注解的生命周期，对应三个值（SOURCE、BINARY、RUNTIME）@Retention(AnnotationRetention.BINARY)annotation class RemoteTasksDataSource // 注解的名字，后面直接使用它@Qualifier@Retention(AnnotationRetention.RUNTIME)annotation class LocalTasksDataSource @Qualifier ：为每个声明的限定符，提供对应的类型实例，和 @Binds 或者 @Provides 一起使用 @Retention：定义了注解的生命周期，对应三个值（SOURCE、BINARY、RUNTIME） AnnotationRetention.SOURCE：仅编译期，不存储在二进制输出中。 AnnotationRetention.BINARY：存储在二进制输出中，但对反射不可见。 AnnotationRetention.RUNTIME：存储在二进制输出中，对反射可见。 通常我们自定义的注解都是 RUNTIME，所以务必要加上@Retention(RetentionPolicy.RUNTIME) 这个注解 来看一下 @Qualifier 和 @Provides 一起使用的例子，定义了两个方法，具有相同的返回类型，但是实现不同，限定符将它们标记为两个不同的绑定。 @Singleton@RemoteTasksDataSource@Providesfun provideTasksRemoteDataSource(): DataSource { // 返回值相同 return RemoteDataSource() // 不同的实现}@Singleton@LocalTasksDataSource@Providesfun provideTaskLocalDataSource(appDatabase: AppDataBase): DataSource { // 返回值相同 return LocalDataSource(appDatabase.personDao()) // 不同的实现} 当我们声明完 @Qualifier 注解之后，就可以使用声明的两个 @Qualifier，来看个例子，定义一个 Repository 构造方法里面传入用 @Qualifier 注解声明的两个不同实现。 @Singleton@Providesfun provideTasksRepository( @LocalTasksDataSource localDataSource: DataSource, @RemoteTasksDataSource remoteDataSource: DataSource): Repository { return TasksRepository( localDataSource, remoteDataSource )} provideTasksRepository 方法内，传入的参数都是 DataSource，但是前面用 @Qualifier 注解声明了它们不同的实现。 预定义限定符Hilt 提供了一些预定义限定符，例如你可能在不同的情况下需要不同的 Context（Appliction、Activity）Hilt 提供了 @ApplicationContext 和 @ActivityContext 两种限定符。 class HiltViewModel @ViewModelInject constructor( @ApplicationContext appContext: Context, @ActivityContext actContext: Context, private val tasksRepository: Repository, @Assisted private val savedStateHandle: SavedStateHandle) 组件作用域 @scopes 的使用默认情况下，Hilt 中的所有绑定都是无作用域的，这意味着每次应用程序请求绑定时，Hilt 都会创建一个所需类型的新实例。 @scopes 的作用在指定作用域范围内(Application、Activity 等等) 提供相同的实例。 Hilt 还允许将绑定的作用域限定到特定组件，Hilt 只为绑定作用域到的组件的每个实例创建一次范围绑定，所有绑定请求共享同一个实例，我们来看一例子。 @Singletonclass HiltSimple @Inject constructor() {} HiltSimple 用 @Singleton 声明了其作用域，那么在 Application 范围内提供相同的实例，代码如下所示，大家可以运行 Demo 看一下输出结果。 MainActivity: com.hi.dhl.hilt.appstartup.di.HiltSimple@8f75417HitAppCompatActivity: com.hi.dhl.hilt.appstartup.di.HiltSimple@8f75417 注意：绑定组件范围可能非常的昂贵，因为提供的对象会保留在内存中，直到该组件被销毁，应该尽量减少在应用程序中使用绑定组件范围，对于要求在一定范围内使用同一实例的绑定，或者对于创建成本高昂的绑定，使用组件范围的绑定是合适的。 下表列出了每个生成组件的 scope 注解对应的范围。 Android class Generated component Scope Application ApplicationComponent @Singleton View Model ActivityRetainedComponent @ActivityRetainedScope Activity ActivityComponent @ActivityScoped Fragment FragmentComponent @FragmentScoped View ViewComponent @ViewScoped View annotated with @WithFragmentBindings ViewWithFragmentComponent @ViewScoped Service ServiceComponent @ServiceScoped 在 Hilt 不支持的类中执行依赖注入Hilt 支持最常见的 Android 类 Application、Activity、Fragment、View、Service、BroadcastReceiver 等等，但是您可能需要在 Hilt 不支持的类中执行依赖注入，在这种情况下可以使用 @EntryPoint 注解进行创建，Hilt 会提供相应的依赖。 @EntryPoint：可以使用 @EntryPoint 注解创建入口点，@EntryPoint 允许 Hilt 使用 Hilt 无法在依赖中提供依赖的对象。 例如 Hilt 不支持 ContentProvider，如果你在想在 ContentProvider 中获取 Hilt 提供的依赖，你可以定义一个接口，并添加 @EntryPoint 注解，然后添加 @InstallIn 注解指定 module 的范围，代码如下所示。 @EntryPoint@InstallIn(ApplicationComponent::class)interface InitializerEntryPoint { fun injectWorkService(): WorkService companion object { fun resolve(context: Context): InitializerEntryPoint { val appContext = context.applicationContext ?: throw IllegalStateException() return EntryPointAccessors.fromApplication( appContext, InitializerEntryPoint::class.java ) } }} 使用 EntryPointAccessors 提供四个静态方法进行访问，分别是 fromActivity、fromApplication、fromFragment、fromView 等等 EntryPointAccessors 提供四个静态方法，第一个参数是 @EntryPoint 接口上 @InstallIn 注解指定 module 的范围，我们在接口 InitializerEntryPoint 用 @InstallIn 注解指定 module 的范围是 ApplicationComponent，所以我们应该使用 EntryPointAccessors 提供的静态方法 fromApplication。 class WorkContentProvider : ContentProvider() { override fun onCreate(): Boolean { context?.run { val service = InitializerEntryPoint.resolve(this).injectWorkService() Log.e(TAG, &quot;WorkContentProvider ${service.init()}&quot;) } return true } ......} 在 ContentProvider 中调用 EntryPointAccessors 类中的 fromApplication 方法就可以获取到 Hit 提供的依赖。 Hilt 如何和 App Startup 一起使用App Startup 会默认提供一个 InitializationProvider，InitializationProvider 继承 ContentProvider，那么 Hilt 在 App Startup 中使用的方式和 ContentProvider 一样。 class AppInitializer : Initializer&lt;Unit&gt; { override fun create(context: Context): Unit { val service = InitializerEntryPoint.resolve(context).injectWorkService() Log.e(TAG, &quot;AppInitializer ${service.init()}&quot;) return Unit } override fun dependencies(): MutableList&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; = mutableListOf()} 通过调用 EntryPointAccessors 的静态方法，获取到 Hit 提供的依赖，关于 App Startup 如何使用可以查看这篇文章 Jetpack 最新成员 AndroidX App Startup 实践以及原理分析 总结到这里关于 Hilt 的注解使用都介绍完了，代码已经全部上传到了 GitHub：HiltWithAppStartupSimple。 HiltWithAppStartupSimple 包含了本篇文章和 Jetpack 新成员 Hilt 实践（一）启程过坑记 文章中使用的案例，如果之前没有看过可以先去了解一下，之后看代码会更加的清楚。 Hilt 是基于 Dagger 基础上进行开发的，入门要比 Dagger 简单很多，不需要去管理所有的 Dagger 的配置问题，但是其入门的门槛还是很高的，尤其是 Hilt 的注解，需要了解其每个注解的含义才能正确的使用，避免资源的浪费。 这篇文章和之前 Jetpack 新成员 Hilt 实践（一）启程过坑记 的文章其中很多案例都重新去设计了，因为 Google 的提供的案例，确实很难让人理解，希望这两篇文章可以帮助小伙伴们快速入门 Hilt，后面还会有更多实战案例。 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请在仓库右上角帮我点个赞，后面我会陆续完成更多 Jetpack 新成员的项目实践","link":"/2020/08/22/jetpack/05-hilt-app-startup/"},{"title":"Jetpack 新成员 Hilt 实践（一）启程过坑记","text":"前言在之前的文章里面分别分析 Jetpack 新成员 App Startup 实践以及原理分析 和 Jetpack 新成员 Paging3 实践以及源码分析（一） 以及 Jetpack 新成员 Paging3 网络实践及原理分析（二） 如果没有看过可以点击下方地址前去查看： Jetpack 最新成员 AndroidX App Startup 实践以及原理分析 Jetpack 成员 Paging3 数据实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack 成员 Paging3 使用 RemoteMediator 实现加载网络分页数据并更新到数据库中（三） 代码地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 这篇文章主要来分析一下 Hilt，花了好几天时间梳理了一下 官方 Hilt 文档，Hilt 的知识点有点多，将会分为三篇文章结合实际案例来完成，每篇文章都会有详细的使用的案例。本篇文章的案例已经上传到了 GitHub： HiltSimple。 通过这篇文章你将学习到以下内容： 为什么需要使用依赖注入库？ Hilt 是什么？ Hilt 常用注解含义？ 使用 Hilt 都有那些坑需要注意？ Hilt 如何和 Android 组件一起使用？ Hilt 如何和第三方组件一起使用？ Hilt 如何和 Jetpack 组件 ViewModule 一起使用？ Hilt 如何和 Jetpack 组件 Room 一起使用？ 研究 Hilt 时遇到一些坑，有些坑在 Goggle 文档上也没有提到，我会在文中特别强调，并在 文末总结部分 进行汇总。 为什么需要使用依赖注入库Hilt、Dagger、Koin 等等都是依赖注入库，Google 也在努力不断的完善依赖注入库从 Dagger 到 Dagger2 在到现在的 Hilt，因为依赖注入是面向对象设计中最好的架构模式之一，使用依赖注入库有以下优点： 依赖注入库会自动释放不再使用的对象，减少资源的过度使用。 在配置 scopes 范围内，可重用依赖项和创建的实例，提高代码的可重用性，减少了很多模板代码。 代码变得更具可读性。 易于构建对象。 编写低耦合代码，更容易测试。 Hilt 是什么？Hilt 是 Android 的依赖注入库，它减少了在项目中进行手动依赖，进行手动依赖注入需要您手动构造每个类及其依赖，依赖注入库的出现节省了 Android 开发者大量的时间。 Hilt 通过为项目中的每个 Android 类提供容器并自动管理它们的生命周期，提供了在应用程序中使用 DI 的标准方法。Hilt 是在 Dagger 的基础上进行构建，因为 Dagger 提供的编译时正确性、运行时性能、可伸缩性并且从 Android Studio 支持 Dagger 中获益。 Hilt 的实现要比 Dagger 简单得多，使用 Dagger 实现依赖注入，需要去编写 modules、components 等等。每次创建一个新的 android 组件，比如 Activity、Fragment 或Service，我们都需要手动将它们添加到各自的 modules 中，以便在需要的时候注入它们。 接下来我们开始从分析 Hilt 注解的含义出发，来了解如何在应用程序中使用 Hilt。 Hilt 常用注解的含义Hilt 常用注解包含 @HiltAndroidApp、@AndroidEntryPoint、@Inject、@Module、@InstallIn、@Provides、@EntryPoint 等等。 @HiltAndroidApp 所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application。 @HiltAndroidApp 注解将会触发 Hilt 代码的生成，作为应用程序依赖项容器的基类。 生成的 Hilt 组件依附于 Application 的生命周期，它也是 App 的父组件，提供其他组件访问的依赖。 在 Application 中设置好 @HiltAndroidApp 之后，就可以使用 Hilt 提供的组件了，组件包含Application、Activity、Fragment、View、Service、BroadcastReceiver 等等。 @AndroidEntryPointHilt 提供的 @AndroidEntryPoint 注解用于提供 Android 类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）特殊的 Application 使用 @HiltAndroidApp 注解。 Activity：仅仅支持 ComponentActivity 的子类例如 FragmentActivity、AppCompatActivity 等等。 Fragment：仅仅支持继承 androidx.Fragment 的 Fragment View Service BroadcastReceiver 坑： 如果使用 @AndroidEntryPoint 在非 ComponentActivity 子类上注解，例如 Activity 则会抛出以下异常。 Activities annotated with @AndroidEntryPoint must be a subclass of androidx.activity.ComponentActivity. (e.g. FragmentActivity, AppCompatActivity, etc.) 如果使用 @AndroidEntryPoint 注解 Android 类，必须在它依赖的 Android 类添加同样的注解，例如在 Fragment 中添加 @AndroidEntryPoint 注解，必须在 Fragment 依赖的 Activity 上也添加 @AndroidEntryPoint 注解 , 否则会抛出以下异常。 java.lang.IllegalStateException: Hilt Fragments must be attached to an @AndroidEntryPoint Activity. Found: class com.hi.dhl.hilt.MainActivity @Inject Hilt 需要知道如何从相应的组件中提供必要依赖的实例。使用 @Inject 注解来告诉 Hilt 如何提供该类的实例，它常用于构造函数、非私有字段、方法中。 注意：在构建时，Hilt 为 Android 类生成 Dagger 组件。然后 Dagger 遍历您的代码并执行以下步骤： 构建并验证依赖关系，确保没有未满足的依赖关系。 生成它在运行时用于创建实际对象及其依赖项的类。 @Module常用于创建依赖类的对象(例如第三方库 OkHttp、Retrofit等等)，使用 @Module 注解的类，需要使用 @InstallIn 注解指定 module 的范围。 @Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {} @InstallIn使用 @Module 注入的类，需要使用 @InstallIn 注解指定 module 的范围，例如使用 @InstallIn(ActivityComponent::class) 注解的 module 会绑定到 activity 的生命周期上。 Hilt 提供了以下组件来绑定依赖与 对应的 Android 类的活动范围。 Hilt 提供的组件 对应的 Android 类的活动范围 ApplicationComponent Application ActivityRetainedComponent ViewModel ActivityComponent Activity FragmentComponent Fragment ViewComponent View ViewWithFragmentComponent View annotated with @WithFragmentBindings ServiceComponent Service 注意：Hilt 没有为 broadcast receivers 提供组件，因为 Hilt 直接从 ApplicationComponent 注入 broadcast receivers。 Hilt 会根据相应的 Android 类生命周期自动创建和销毁生成的组件类的实例，它们的对应关系如下表格所示。 Hilt 提供的组件 创建对应的生命周期 销毁对应的生命周期 ApplicationComponent Application#onCreate() Application#onDestroy() ActivityRetainedComponent Activity#onCreate() Activity#onDestroy() ActivityComponent Activity#onCreate() Activity#onDestroy() FragmentComponent Fragment#onAttach() Fragment#onDestroy() ViewComponent View#super() View destroyed ViewWithFragmentComponent View#super() View destroyed ServiceComponent Service#onCreate() Service#onDestroy() @Provides它常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。 @Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule { /** * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。 * @Singleton 提供单例 */ @Provides @Singleton fun provideOkHttpClient(): OkHttpClient { return OkHttpClient.Builder() .build() }} @EntryPointHilt 支持最常见的 Android 类 Application、Activity、Fragment、View、Service、BroadcastReceiver 等等，但是您可能需要在Hilt 不支持的类中执行依赖注入，在这种情况下可以使用 @EntryPoint 注解进行创建，Hilt 会提供相应的依赖。 基本概念介绍完了之后，我们正式在项目中使用 Hilt。 如何使用 Hilt首先需要添加 Hilt 依赖，Hilt 依赖添加方式相比于 Koin 太麻烦了，首先在 project 的 build.gradle 添加以下依赖。 buildscript { ... dependencies { ... classpath 'com.google.dagger:hilt-android-gradle-plugin:2.28-alpha' }} 然后在 App 模块中的 build.gradle 文件中添加以下代码。 ...apply plugin: 'kotlin-kapt'apply plugin: 'dagger.hilt.android.plugin'android { ...}dependencies { implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot; kapt &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;} 坑：需要注意的是如果同时使用 hilt 和 data binding，Android Studio 的版本必须 &gt;= 4.0 所以还没有升级的朋友们，尽快升级吧，升级到 Android Studio 4.0 也会遇到一些坑，不过好在这些坑现在都有相应的解决方案了。 Hilt 使用 Java 8 的功能，所以要在项目中启用 Java 8，需要在 App 模块的 build.gradle 文件中，添加以下代码。 android { ... compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } // For Kotlin projects kotlinOptions { jvmTarget = &quot;1.8&quot; }} 注意： 这里有一个坑，对于 Kotlin 项目，需要添加 kotlinOptions，这是 Google 文档 Dependency injection with Hilt 中没有提到的，否则使用 ViewModel 会编译不过，下文会有详细的讲解。 Hilt 依赖添加方式相比于 Koin 太麻烦了，使用 koin 只需要添加相应的依赖就可以使用了。 Application 是 App 的入口，所以所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application @HiltAndroidAppclass HiltApplication : Application() { /** * 1. 所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application * 2. @HiltAndroidApp 将会触发 Hilt 代码的生成，包括用作应用程序依赖项容器的基类 * 3. 生成的 Hilt 组件依附于 Application 的生命周期，它也是 App 的父组件，提供其他组件访问的依赖 * 4. 在 Application 中设置好 @HiltAndroidApp 之后，就可以使用 Hilt 提供的组件了， * Hilt 提供的 @AndroidEntryPoint 注解用于提供 Android 类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）等等 * Application 使用 @HiltAndroidApp 注解 */} @HiltAndroidApp 将会触发 Hilt 代码的生成，包括用作应用程序依赖容器的基类 生成的 Hilt 组件依附于 Application 的生命周期，它也是 App 的父组件，提供其他组件访问的依赖 准备工作都做完了，接下来我们来看几个例子，如何使用 Hilt 进行依赖注入。 如何使用 Hilt 进行依赖注入我们先来看一个简单的例子，注入 HiltSimple 并在 Application 中调用它的 doSomething 方法。 class HiltSimple @Inject constructor() { fun doSomething() { Log.e(TAG, &quot;----doSomething----&quot;) }}@HiltAndroidAppclass HiltApplication : Application() { @Inject lateinit var mHiltSimple: HiltSimple override fun onCreate() { super.onCreate() mHiltSimple.doSomething() }} Hilt 需要知道如何从相应的组件中提供必要依赖的实例。使用 @Inject 注解来告诉 Hilt 如何提供该类的实例，@Inject 常用于构造函数、非私有字段、方法中。 Hilt 如何和 Android 组件一起使用如果是 Hilt 支持的 Android 组件，直接使用 @AndroidEntryPoint 注解即可。 /** * * 为项目中的每个 Android 类生成一个 Hilt 组件，这些组件可以从它们各自的父类接收依赖项， * 如果是抽象类则不能使用 @AndroidEntryPoint 注解 * * 如果使用 @AndroidEntryPoint 注解 Android 类，还必须注解依赖于它的 Android 类， * 例如 如果 注解 fragment 然后还必须注解 fragment 依赖的 Activity, 否则会抛出以下异常 * java.lang.IllegalStateException: Hilt Fragments must be attached to an @AndroidEntryPoint Activity. Found: class com.hi.dhl.hilt.MainActivity */@AndroidEntryPointclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // 用到了 Fragment 1.2.0 中重要的更新 // 可以查看之前写的这篇文章 @see https://juejin.im/post/5ecb16f1f265da76fb0c3967 supportFragmentManager.beginTransaction() .add(R.id.container, HiltFragment::class.java, null) .commit() }}/** * 如果 注解 fragment 然后还必须注解 fragment 依赖的 Activity, 否则会抛出以下异常 * java.lang.IllegalStateException: Hilt Fragments must be attached to an @AndroidEntryPoint Activity. Found: class com.hi.dhl.hilt.MainActivity */@AndroidEntryPointclass HiltFragment : Fragment() { // 使用 @Inject 注解从组件中获取依赖 @Inject lateinit var mHiltSimple: HiltSimple override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_hilt, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) mHiltSimple.doSomething() }} 如果是抽象类则不需要使用 @AndroidEntryPoint 注解。 @AndroidEntryPoint 注解 仅仅支持 ComponentActivity 的子类例如 FragmentActivity、AppCompatActivity 等等。 如果使用 @AndroidEntryPoint 注解 Android 类，必须在它依赖的 Android 类添加同样的注解，例如在 Fragment 中添加 @AndroidEntryPoint 注解，必须在 Fragment 依赖的 Activity 上也添加 @AndroidEntryPoint 注解。 注意： 在 Activity 中添加 Fragment，用到了 Fragment 1.2.0 中重要的更新，可以查看之前写的这篇文章 [译][Google工程师] 详解 FragmentFactory 如何优雅使用 Koin 以及部分源码分析。 Hilt 如何和第三方组件一起使用如果要在项目中注入第三方依赖，我们需要使用 @Module 注解，使用 @Module注解的普通类，在其中创建第三方依赖的对象。 @Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule { /** * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。 * @Singleton 提供单例 */ @Provides @Singleton fun provideOkHttpClient(): OkHttpClient { return OkHttpClient.Builder() .build() } @Provides @Singleton fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit { return Retrofit.Builder() .client(okHttpClient) .baseUrl(&quot;https://api.github.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build() } @Provides @Singleton fun provideGitHubService(retrofit: Retrofit): GitHubService { return retrofit.create(GitHubService::class.java) }} @Module 常用于创建依赖类的对象(例如第三方库 OkHttp、Retrofit等等)。 使用 @Module 注入的类，需要使用 @InstallIn 注解指定 module 的范围，会绑定到 Android 类对应的生命周期上。 @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。 Hilt 如何和 ViewModel 一起使用在 App 模块中的 build.gradle 文件中添加以下代码。 implementation 'androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha01'kapt 'androidx.hilt:hilt-compiler:1.0.0-alpha01' 注意： 这个是在 Google 文档上没有提到的，如果使用的是 kotlin 的话需要额外在 App 模块中的 build.gradle 文件中添加以下代码，否则调用 by viewModels() 会编译不过。 // For Kotlin projectskotlinOptions { jvmTarget = &quot;1.8&quot;} 在 ViewModel 对象的构造函数中使用 @ViewModelInject 注解提供一个 ViewModel。 class HiltViewModel @ViewModelInject constructor() : ViewModel() { /** * 在 LifeCycle 2.2.0 之后，可以用更精简的方法来完成，使用 LiveData 协程构造方法 (coroutine builder)。 * liveData 协程构造方法提供了一个协程代码块，产生的是一个不可变的 LiveData，emit() 方法则用来更新 LiveData 的数据。 * * 具体可以查看之前写的这篇文章 [https://juejin.im/post/5ee998e8e51d4573d65df02b#heading-10] 有详细介绍 */ val mHitLiveData = liveData { emit(&quot; i am a ViewModelInject&quot;) }}@AndroidEntryPointclass MainActivity : AppCompatActivity() { private val mHitViewModule: HiltViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) mHitViewModule.mHitLiveData.observe(this, Observer { tvResult.setText(it) }) }} 在 HiltViewModel 里面使用了 LifeCycle 2.2.0 之后新增的方法，LiveData 协程构造方法提供了一个协程代码块，产生的是一个不可变的 LiveData，emit() 方法则用来更新 LiveData 的数据，具体可以查看之前写的这篇文章 Jetpack 成员 Paging3 实践以及源码分析（一） 里面有详细介绍。 Hilt 如何和 Room 一起使用这里需要用到 @Module 注解，使用 @Module 注解的普通类，在其中提供 Room 的实例。 @Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object RoomModule { /** * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。 * @Singleton 提供单例 */ @Provides @Singleton fun provideAppDataBase(application: Application): AppDataBase { return Room .databaseBuilder(application, AppDataBase::class.java, &quot;dhl.db&quot;) .fallbackToDestructiveMigration() .allowMainThreadQueries() .build() } @Provides @Singleton fun providePersonDao(appDatabase: AppDataBase): PersonDao { return appDatabase.personDao() }} 总结全文到这里就结束了，本篇文章的案例已经全部上传到了 GitHub：HiltSimple。 这篇文章里面分别介绍了 @HiltAndroidApp、@AndroidEntryPoint、@Inject、@Module、@InstallIn、@Provides 的含义以及实战案例，下篇文章我们一起来分析一下 @EntryPoint，以及和其他 Jetpack 组件如何一起使用。 需要注意的是使用 Hilt 有三个需要注意的地方 如果注解非 ComponentActivity 子类，例如 Activity 则会抛出以下异常。 Activities annotated with @AndroidEntryPoint must be a subclass of androidx.activity.ComponentActivity. (e.g. FragmentActivity, AppCompatActivity, etc.) 如果使用 @AndroidEntryPoint 注解 Android 类，必须在它依赖的 Android 类添加同样的注解，例如在 Fragment 中添加 @AndroidEntryPoint 注解，必须在 Fragment 依赖的 Activity 上也添加 @AndroidEntryPoint 注解 , 否则会抛出以下异常。 java.lang.IllegalStateException: Hilt Fragments must be attached to an @AndroidEntryPoint Activity. Found: class com.hi.dhl.hilt.MainActivity 需要注意的是如果同时使用 hilt 和 data binding，Android Studio 的版本必须 &gt;= 4.0 所以还没有升级的朋友们，尽快升级吧，升级到 Android Studio 4.0 也会遇到一些坑，不过好在这些坑现在都有相应的解决方案了。 Hilt 如果和 ViewModel 一起使用有点需要注意 这个是在 Google 文档上没有提到的，如果使用的是 kotlin 语言的话，需要额外在 App 模块中的 build.gradle 文件中添加以下代码，否则调用 by viewModels() 会编译不过。 kotlinOptions { jvmTarget = &quot;1.8&quot;} 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请在仓库右上角帮我点个赞，后面我会陆续完成更多 Jetpack 新成员的项目实践","link":"/2020/08/22/jetpack/04-hilt/"},{"title":"Jetpack 新成员 Paging3 网络实践及原理分析（二）","text":"前言Google 最近更新了几个 Jetpack 新成员 Hilt、Paging 3、App Startup 等等。 在之前的文章里面分别分析 App Startup 实践以及原理 和 Paging3 加载本地数据（一）实践以及原理，如果没有看过可以点击下方地址前去查看： Jetpack 最新成员 AndroidX App Startup 实践以及原理分析 Jetpack 成员 Paging3 数据实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack 成员 Paging3 使用 RemoteMediator 实现加载网络分页数据并更新到数据库中（三） 代码地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 今天这边文章主要来分析 Paging3 加载网络数据及其原理，利用周末的时间参考 Google 文档实现了 Paging3 期间也遇到一些坑，会在文中详细分析，代码已经上传到了 GitHub：Paging3SimpleWithNetWork 通过这篇文章你将学习到以下内容： Paging3 是什么？ Paging3 相对之前版本 (Paging1、Paging2) 核心的变化？ 关于 Paging 支持的分页策略？ 在项目中如何使用 Paging3 去加载网络数据？ Paging3 网络异常如何处理？ Paging3 如何监听网络请求状态？ Paging3 如何进行刷新和重试？ 在项目 Paging3SimpleWithNetWork 中用到了 Coil（Kotlin 图片加载库）、Databinding（数据绑定）、Anko（主要用来替换替代 XML 使用的方式）、Koin（Kotlin 依赖注入库）、JDatabinding（基于 Databinding 封装的组件）、Data Mapper（数据映射）、使用 Composing builds 作为依赖库的版本管理、Repository 设计模式、MVVM 架构等等，关于这里一些技术之前没有了解过，可以点击下面连接前往查看。 [译][1.4K+ Star] Kotlin 新秀 Coil VS Glide and Picasso [译][2.4K Star] 放弃 Dagger 拥抱 Koin 再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度 项目中封装 Kotlin + Android Databinding 为数不多的人知道的 Kotlin 技巧以及 原理解析 Paging3 是什么？Paging 是一个分页库，它可以帮助您从本地存储或通过网络加载显示数据。这种方法使你的 App 更有效地使用网络带宽和系统资源。 Google 推荐使用 Paging 作为 App 架构的一部分，它可以很方便的和 Jetpack 组件集成，Paging3 包含了以下功能： 在内存中缓存分页数据，确保您的 App 在使用分页数据时有效地使用系统资源。 内置删除重复数据的请求，确保您的 App 有效地使用网络带宽和系统资源。 可配置 RecyclerView 的 adapters，当用户滚动到加载数据的末尾时自动请求数据。 支持 Kotlin 协程和 Flow, 以及 LiveData 和 RxJava。 内置的错误处理支持，包括刷新和重试等功能。 Paging3 相对于之前类的职能变化在 Paging3 之前提供了 ItemKeyedDataSource、PageKeyedDataSource、PositionalDataSource 这三个类，在这三个类中进行数据获取的操作。 PositionalDataSource：主要用于加载数据有限的数据（加载本地数据库） ItemKeyedDataSource：主要用来请求网络数据，它适用于通过当前页面最后一条数据的 id，作为下一页的数据的开始的位置，例如 Github 的 API。 例如地址 https://api.github.com/users?since=0?per_page=30 当 since = 0 时获取第一页数据，当前页面最后一条数据的 ID 是 46。 将 46 作为开始位置，此时 since = 46，地址变成：https://api.github.com/users?since=46?per_page=30。 PageKeyedDataSource：也是用来请求网络数据，它适用于通过页码分页来请求数据。 在 Paging3 之后 ItemKeyedDataSource、PageKeyedDataSource、PositionalDataSource 合并为一个 PagingSource，所有旧 API 加载方法被合并到 PagingSource 中的单个 load() 方法中。 abstract suspend fun load(params: LoadParams&lt;Key&gt;): LoadResult&lt;Key, Value&gt; 这是一个挂起函数，实现这个方法来触发异步加载，具体实现见下文，另外在 Paging3 中还有以下变化 LivePagedListBuilder 和 RxPagedListBuilder 合并为了 Pager。 使用 PagedList.Config 替换 PagingConfig。 使用 RemoteMediator 替换了 PagedList.BoundaryCallback 去加载网络和本地数据库的数据。 四步实现 Paging3 加载网络数据Google 推荐我们使用 Paging3 时，在应用程序的三层中操作，以及它们如何协同工作加载和显示分页数据，如下图所示： 我们接下来按照 Google 推荐的方式开始实现，只需要四步即可实现 Paging3 加载网络数据，文中只贴出核心代码，具体实现可以看 GitHub 上的 Paging3SimpleWithNetWork 项目，先在 App 模块中的 build.gradle 文件中添加以下代码： dependencies { def paging_version = &quot;3.0.0-alpha01&quot; implementation &quot;androidx.paging:paging-runtime:$paging_version&quot;} 1. 网络请求部分这里选择使用的是 GitHub API interface GitHubService { @GET(&quot;users&quot;) suspend fun getGithubAccount(@Query(&quot;since&quot;) id: Int, @Query(&quot;per_page&quot;) perPage: Int): List&lt;GithubAccountModel&gt; companion object { fun create(): GitHubService { val client = OkHttpClient.Builder() .build() val retrofit = Retrofit.Builder() .client(client) .baseUrl(&quot;https://api.github.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build() return retrofit.create(GitHubService::class.java) } }} 注意： 这里需要在 getGithubAccount 方法前添加 suspend 关键字，否则调用的时候，会抛出以下异常。 Unable to create call adapter for XXXXX 2. 在 Repository 层创建 PagingSource 数据源class GitHubItemPagingSource( private val api: GitHubService) : PagingSource&lt;Int, GithubAccountModel&gt;(), AnkoLogger { override suspend fun load(params: LoadParams&lt;Int&gt;): LoadResult&lt;Int, GithubAccountModel&gt; { return try { // key 相当于 id val key = params.key ?: 0 // 获取网络数据 val items = api.getGithubAccount(key, params.loadSize) // 请求失败或者出现异常，会跳转到 case 语句返回 LoadResult.Error(e) // 请求成功，构造一个 LoadResult.Page 返回 LoadResult.Page( data = items, // 返回获取到的数据 prevKey = null, // 上一页，设置为空就没有上一页的效果，这需要注意的是，如果是第一页需要返回 null，否则会出现多次请求 nextKey = items.lastOrNull()?.id// 下一页，设置为空就没有加载更多效果，如果后面没有更多数据设置为空，即滑动到最后不会在加载数据 ) } catch (e: Exception) { e.printStackTrace() LoadResult.Error(e) } }} PagingSource 是一个抽象类，主要用来向 Paging 提供源数据，需要重写 load 方法，在这个方法进行网络请求的处理。需要注意的是 LoadResult.Page 里面的两个参数 prevKey 和 nextKey，这里有个坑。 prevKey：上一页，设置为空就没有上一页的效果，这需要注意的是，如果是第一页需要返回 null，否则会出现多次请求，我刚开始忽略了，导致首次加载的时候，出现了两次请求。 nextKey：下一页，设置为空就没有加载更多效果，如果后面没有更多数据设置为空，即滑动到最后不会在加载数据。 load 方法的参数 LoadParams，它是一个密封类，里面有三个内部类 Refresh、Append、Prepend。 类名 作用 Refresh 在初始化刷新的使用 Append 在加载更多的时候使用 Prepend 在当前列表头部添加数据的时候使用 3. 在 Repository 层创建 Pager 和 PagingData Pager：是主要的入口页面，在其构造方法中接受 PagingConfig、initialKey、remoteMediator、pagingSourceFactory。 PagingData：是分页数据的容器，它查询一个 PagingSource 对象并存储结果。 class GitHubRepositoryImpl( val pageConfig: PagingConfig, val gitHubApi: GitHubService, val mapper2Person: Mapper&lt;GithubAccountModel, GitHubAccount&gt;) : Repository { override fun postOfData(id: Int): Flow&lt;PagingData&lt;GitHubAccount&gt;&gt; { return Pager(pageConfig) { // 加载数据库的数据 GitHubItemPagingSource(gitHubApi, 0) }.flow.map { pagingData -&gt; // 数据映射，数据源 GithubAccountModel ——&gt; 上层用到的 GitHubAccount pagingData.map { mapper2Person.map(it) } } }} 在 postOfData 方法中构建了一个 Pager， 其构造方法中接受 PagingConfig、initialKey、remoteMediator、pagingSourceFactory，其中 initialKey、remoteMediator 是可选的，pageConfig 和 pagingSourceFactory 必填的。 pagingSourceFactory 是一个 lambda 表达式，在 Kotlin 中可以直接用花括号表示，在花括号内，执行执行网络请求 GitHubItemPagingSource(gitHubApi, 0)。 最后调用 flow 返回 Flow&lt;PagingData&lt;Value&gt;&gt;，然后通过 Flow 的 map 方法将数据源 GithubAccountModel 转换成上层用到的 GithubAccount。 关于 flow 在上一篇 Jetpack 成员 Paging3 实践以及源码分析（一） 已经分析过了. 4. 最后一步，接受数据，并绑定 UI在 ViewModel 接受数据，并传递给 Adapter. val gitHubLiveData: LiveData&lt;PagingData&lt;GitHubAccount&gt;&gt; = repository.postOfData(0).asLiveData() LiveData 有三种使用方式，这里演示的是其中一种，其余的在之前的文章Jetpack 成员 Paging3 实践以及源码分析（一） 已经分析过了。 mMainViewModel.gitHubLiveData.observe(this, Observer { data -&gt; mAdapter.submitData(lifecycle, data) }) 到这里请求网络数据并显示的在 UI 上就结束了，最后我们来分析一下 Paging3 内置的错误处理支持，包括刷新和重试等功能。 5. 网络状态异常的处理Paging3 提供了内置的错误处理支持，包括刷新和重试等功能，说到这里 Google 对于 Paging3 的设计相比于之前的设计真的好，基本上进行网络请求地方用 RecyclerView 去展示数据，都需要用到刷新、重试、错误处理等等功能。 1. 错误处理 Paging3 的组件 PagingDataAdapter，PagingDataAdapter 是一个处理分页数据的可回收视图适配器，PagingDataAdapter 提供了三个方法，如下图所示： 方法名 作用 withLoadStateFooter 添加列表底部（类似于加载更多） withLoadStateHeader 添加列表的头部 withLoadStateHeaderAndFooter 添加头部和底部 Paging3 提供了 LoadStateAdapter 用于实现列表底部和头部样式，只需要继承 LoadStateAdapter 做对应的网络状态处理即可，例如这里实现的 FooterAdapter 加载更多样式。 class FooterAdapter(val adapter: GitHubAdapter) : LoadStateAdapter&lt;NetworkStateItemViewHolder&gt;() { override fun onBindViewHolder(holder: NetworkStateItemViewHolder, loadState: LoadState) { holder.bindData(loadState, 0) } override fun onCreateViewHolder( parent: ViewGroup, loadState: LoadState ): NetworkStateItemViewHolder { val view = inflateView(parent, R.layout.recycie_item_network_state) return NetworkStateItemViewHolder(view) { adapter.retry() } } private fun inflateView(viewGroup: ViewGroup, @LayoutRes viewType: Int): View { val layoutInflater = LayoutInflater.from(viewGroup.context) return layoutInflater.inflate(viewType, viewGroup, false) }}class NetworkStateItemViewHolder(view: View, private val retryCallback: () -&gt; Unit) : DataBindingViewHolder&lt;LoadState&gt;(view) { val mBinding: RecycieItemNetworkStateBinding by viewHolderBinding(view) override fun bindData(data: LoadState, position: Int) { mBinding.apply { // 正在加载，显示进度条 progressBar.isVisible = data is LoadState.Loading // 加载失败，显示并点击重试按钮 retryButton.isVisible = data is LoadState.Error retryButton.setOnClickListener { retryCallback() } // 加载失败显示错误原因 errorMsg.isVisible = !(data as? LoadState.Error)?.error?.message.isNullOrBlank() errorMsg.text = (data as? LoadState.Error)?.error?.message executePendingBindings() } }} 在上面分别处理了，正在加载、加载失败并提供重试按钮等等状态。 2. Paging3 同时提供了刷新、重试等等方法，如下图所示： refresh：常用用于下拉更新数据。 retry：常用于底部更多样式，当请求网络失败的时候，显示重试按钮，点击调用 retry。 3. Paging3 还帮我处理了如果出现多次网络请求，只会处理最后一次请求，例如由于网络慢，用户频繁的刷新数据等等 6. 监听网路请求状态刚才分析过 PagingDataAdapter 是一个处理分页数据的可回收视图适配器，并且还提供了两个监听数据状态的方法。 这两个方法的区别是： addDataRefreshListener：当一个新的 PagingData 提交并显示的时候调用。 addLoadStateListener：这个方法同 addDataRefreshListener 方法，它们之间的区别是 addLoadStateListener 方法返回了一个 CombinedLoadStates 的对象，如上图所示。 CombinedLoadStates 是一个数据类，里面有三个成员变量 refresh、prepend 和 append。 val refresh: LoadState = (mediator ?: source).refreshval prepend: LoadState = (mediator ?: source).prependval append: LoadState = (mediator ?: source).append 变量 作用 refresh 在初始化刷新的使用 append 在加载更多的时候使用 prepend 在当前列表头部添加数据的时候使用 refresh、prepend 和 append 都是 LoadState 的对象，LoadState 也是一个密封类，每一个 refresh、prepend 和 append 都对应着三种状态。 变量 作用 Error 表示加载失败 Loading 表示正在加载 NotLoading 表示当前未加载 到这里不得不佩服 Google 什么都替我们想好了，这里需要结合自己的项目实际情况，去定制不同的状态处理。 到这里 Paging3 算是完结了，最后贴一下本文案例 Paging3SimpleWithNetWork 已经上传到 GitHub，最后祝大家周末愉快呀。 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请在仓库右上角帮我点个赞，后面我会陆续完成更多 Jetpack 新成员的项目实践","link":"/2020/08/22/jetpack/03-Paging3/"},{"title":"Jetpack 成员 Paging3 数据库实践以及源码分析（一）","text":"前言前几天 Google 更新了几个 Jetpack 新成员 Hilt、Paging 3、App Startup 等等，在之前的文章里面分了 App Startup 是什么、App Startup 为我们解决了什么问题，如果之前没有看过可以点击下面连接前往查看文章和代码。 Jetpack 最新成员 AndroidX App Startup 实践以及原理分析 AppStartup 代码地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 今天这边文章主要来分析 Paging3，Paging3 会分为三篇文章，详细的分析其原理，每篇文章都有完整的项目示例。 Jetpack 成员 Paging3 数据库实践以及源码分析（一） Jetpack 成员 Paging3 网络实践及原理分析（二） Jetpack 成员 Paging3 使用 RemoteMediator 实现加载网络分页数据并更新到数据库中（三） 通过这篇文章你将学习到以下内容： Paging3 是什么？ Paging3 在项目中的架构以及类的职能源码分析？ 如何在项目中正确使用 Paging3？ 数据映射（Data Mapper）是什么？ Kotlin Flow 是什么？ 在分析之前我们先来了解一下本文实战项目中用到的技术： 使用 Koin 作为依赖注入，可以看我之前写的篇文章：[译][2.4K Star] 放弃 Dagger 拥抱 Koin。 使用 Composing builds 作为依赖库的版本管理，可以看我之前写篇文章：再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度。 JDataBinding 是我基于 DataBinding 封装的库，可以看我之前写篇文章：项目中封装 Kotlin + Android Databinding。 数据映射（Data Mapper）： 将数据源的实体，转换为上层用到的 model，在项目中起到了很大重要，我看了很多项目的，这个概念很少被提及到，看国外的大牛的写的文章时，它们提及到了这个概念，后面会对它详细的分析。 项目中用到了一些 Kotlin 技巧，可以查看我另外一篇文章：为数不多的人知道的 Kotlin 技巧以及 原理解析。 还有 Paging 3、Room、Anko、Repository 设计模式、MVVM 架构等等。 Paging3 是什么？Paging 是一个分页库，它可以帮助您从本地存储或通过网络加载显示数据。这种方法使你的 App 更有效地使用网络带宽和系统资源。 Paging3 是使用 Kotlin 协程完全重写的库，经历了从 Paging1x 到 Paging2x 在到现在的 Paging3，深刻领悟到 Paging3 比 Paging1 和 Paging2 真的方便了很多。 Google 推荐使用 Paging 作为 App 架构的一部分，它可以很方便的和 Jetpack 组件集成，Paging3 包含了以下功能： 在内存中缓存分页数据，确保您的 App 在使用分页数据时有效地使用系统资源。 内置删除重复数据的请求，确保您的 App 有效地使用网络带宽和系统资源。 可配置 RecyclerView 的 adapters，当用户滚动到加载数据的末尾时自动请求数据。 支持 Kotlin 协程和 Flow, 以及 LiveData 和 RxJava。 内置的错误处理支持，包括刷新和重试等功能。 Paging3 的架构以及类的职能源码分析Google 推荐我们使用 Paging3 时，在应用程序的三层中操作，以及它们如何协同工作加载和显示分页数据，如下图所示： 但是我个人认为应该在增加一层 Data Mapper (下面会有详细的介绍)，如下图所示： 数据映射（Data Mapper）将数据源的实体，转换为上层用到的 model，往往会被我们忽略掉，但是在项目中起到了很大重要，我看了很多项目的，这个概念很少被提及到，我只在国外的大牛的写的文章中，它们提及到了这个概念。关于数据映射（Data Mapper） 后面会单独写一篇文章，配合 Demo 去验证，这里只是简单提及一下。 Data Mapper在一个快速开发的项目中，为了越快完成第一个版本交付，下意识的将数据源和 UI 绑定到一起，当业务逐渐增多，数据源变化了，上层也要一起变化，导致后期的重构工作量很大，核心的原因耦合性太强了。 使用数据映射（Data Mapper）优点如下： 数据源的更改不会影响上层的业务。 糟糕的后端实现不会影响上层的业务 (想象一下，如果你被迫执行2个网络请求，因为后端不能在一个请求中提供你需要的所有信息，你会让这个问题影响你的整个代码吗)。 Data Mapper 便于做单元测试，确保不会因为数据源的变化，而影响上层的业务。 在本文案例项目 Paging3Simple 中会用到 Data Mapper 作为数据映射，在代码中有详细的注释。 Repository layer在 Repository layer 中的主要使用 Paging3 组件中的 PagingSource，每个 PagingSource 对象定义一个数据源以及如何从该数据源查找数据， PagingSource 对象可以从任何一个数据源加载数据，包括网络数据和本地数据。 PagingSource 是一个抽象类，其中有两个重要的方法 load 和 和 getRefreshKey，load 方法如下所示： abstract suspend fun load(params: LoadParams&lt;Key&gt;): LoadResult&lt;Key, Value&gt; 这是一个挂起函数，实现这个方法来触发异步加载，另外一个 getRefreshKey 方法 open fun getRefreshKey(state: PagingState&lt;Key, Value&gt;): Key? = null 该方法只在初始加载成功且加载页面的列表不为空的情况下被调用。 在这一层中还有另外一个 Paging3 的组件 RemoteMediator，RemoteMediator 对象处理来自分层数据源的分页，例如具有本地数据库缓存的网络数据源。 ViewModel layer在 ViewModel layer 层主要用到了 Paging3 的组件 Pager，Pager 是主要的入口页面，在其构造方法中接受 PagingConfig、initialKey、remoteMediator、pagingSourceFactory，代码如下所示： class Pager&lt;Key : Any, Value : Any&gt;@JvmOverloads constructor( config: PagingConfig, initialKey: Key? = null, @OptIn(ExperimentalPagingApi::class) remoteMediator: RemoteMediator&lt;Key, Value&gt;? = null, pagingSourceFactory: () -&gt; PagingSource&lt;Key, Value&gt;) 今天这篇文章和项目主要用到了 PagingConfig 和 PagingSource，PagingSource 上面已经说过了，所以我们主要来分一下 PagingConfig。 val pagingConfig = PagingConfig( // 每页显示的数据的大小 pageSize = 60, // 开启占位符 enablePlaceholders = true, // 预刷新的距离，距离最后一个 item 多远时加载数据 prefetchDistance = 3, /** * 初始化加载数量，默认为 pageSize * 3 * * internal const val DEFAULT_INITIAL_PAGE_MULTIPLIER = 3 * val initialLoadSize: Int = pageSize * DEFAULT_INITIAL_PAGE_MULTIPLIER */ initialLoadSize = 60, /** * 一次应在内存中保存的最大数据 * 这个数字将会触发，滑动加载更多的数据 */ maxSize = 200) 将 ViewModel 层连接到 UI 层用到了 Paging3 的组件 PagingData，PagingData 对象是分页数据的容器，它查询一个 PagingSource 对象并存储结果。 Google 推荐我们将组件 Pager 放到 ViewModel layer，但是我更喜欢放到 Repository layer，详见下文。 UI layer在 UI layer 中的主要到了 Paging3 的组件 PagingDataAdapter，PagingDataAdapter 是一个处理分页数据的可回收视图适配器，您可以使用 AsyncPagingDataDiffer 组件来构建自己的自定义适配器，本文中用到是 PagingDataAdapter。 Paging 3 如何在项目中使用在 App 模块中的 build.gradle 文件中添加以下代码： dependencies { def paging_version = &quot;3.0.0-alpha01&quot; implementation &quot;androidx.paging:paging-runtime:$paging_version&quot;} 接下来我将按照上面说的每层去实现，首先我们先来看一下项目的结构。 bean: 存放上层需要的 model，会和 RecyclerView 的 Adapter 绑定在一起。 loca: 存放和本地数据库相关的操作。 mapper: 数据映射，主要将数据源的实体 转成上层的 model。 repository：主要来处理和数据源相关的操作（本地、网络、内存中缓存等等）。 di: 和依赖注入相关。 ui：数据的展示。 数据库部分@Daointerface PersonDao { @Query(&quot;SELECT * FROM PersonEntity order by updateTime desc&quot;) fun queryAllData(): PagingSource&lt;Int, PersonEntity&gt; @Insert fun insert(personEntity: List&lt;PersonEntity&gt;) @Delete fun delete(personEntity: PersonEntity)} 关于 Dao 这里需要解释一下, queryAllData 方法返回了一个 PagingSource，后面会通过 Pager 转换成 flow&lt;PagingData&lt;Value&gt;&gt;。 Repository 部分通过 Koin 注入 RepositoryFactory，通过 RepositoryFactory 管理相关的 Repository，RepositoryFactory 代码如下： class RepositoryFactory(val appDataBase: AppDataBase) { // 传递 PagingConfig 和 Data Mapper fun makeLocalRepository(): Repository = PersonRepositoryImpl(appDataBase, pagingConfig,Person2PersonEntityMapper(), PersonEntity2PersonMapper()) val pagingConfig = PagingConfig( // 每页显示的数据的大小 pageSize = 60, // 开启占位符 enablePlaceholders = true, // 预刷新的距离，距离最后一个 item 多远时加载数据 prefetchDistance = 3, /** * 初始化加载数量，默认为 pageSize * 3 * * internal const val DEFAULT_INITIAL_PAGE_MULTIPLIER = 3 * val initialLoadSize: Int = pageSize * DEFAULT_INITIAL_PAGE_MULTIPLIER */ initialLoadSize = 60, /** * 一次应在内存中保存的最大数据 * 这个数字将会触发，滑动加载更多的数据 */ maxSize = 200 )} 这里主要是生成 PagingConfig 和 Data Mapper 然后传递给 PersonRepositoryImpl，我们来看一下 PersonRepositoryImpl 相关代码。 class PersonRepositoryImpl( val db: AppDataBase, val pageConfig: PagingConfig, val mapper2PersonEntity: Mapper&lt;Person, PersonEntity&gt;, val mapper2Person: Mapper&lt;PersonEntity, Person&gt;) : Repository { private val mPersonDao by lazy { db.personDao() } override fun postOfData(): Flow&lt;PagingData&lt;Person&gt;&gt; { return Pager(pageConfig) { // 加载数据库的数据 mPersonDao.queryAllData() }.flow.map { pagingData -&gt; // 数据映射，数据库实体 PersonEntity ——&gt; 上层用到的实体 Person pagingData.map { mapper2Person.map(it) } } }} Pager 是主要的入口页面，在其构造方法中接受 PagingConfig、pagingSourceFactory。 pagingSourceFactory: () -&gt; PagingSource&lt;Key, Value&gt; pagingSourceFactory 是一个 lambda 表达式，在 Kotlin 中可以直接用花括号表示，在花括号内，执行加载数据库的数据的请求。 最后调用 flow 返回 Flow&lt;PagingData&lt;Value&gt;&gt;，然后通过 Flow 的 map 将数据库实体 PersonEntity 转换成上层用到的实体 Person。 Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库，也叫做异步流，类似 RxJava 的 Observable，本文主要用到了 Flow 当中的 map 方法进行数据转换，简单实例如下所示： flow{ for (i in 1..4) { emit(i) }}.map { it * it} 到这里我们在回过去看，项目中 pagingData.map { mapper2Person.map(it) } 这行代码，其中 mapper2Person 是我们自己实现的 Data Mapper，代码如下所示： class PersonEntity2PersonMapper : Mapper&lt;PersonEntity, Person&gt; { override fun map(input: PersonEntity): Person = Person(input.id, input.name, input.updateTime)} 数据库实体 PersonEntity 转换为 上层用到的实体 Person。 UI 部分通过 koin 依赖注入 MainViewModel，并传递参数 Repository。 class MainViewModel(val repository: Repository) : ViewModel() { // 调用 Flow 的 asLiveData 方法转为 LiveData val pageDataLiveData3: LiveData&lt;PagingData&lt;Person&gt;&gt; = repository.postOfData().asLiveData()} 在 Activity 当中注册 observe，并将数据绑定给 Adapter，如下所示： mMainViewModel.pageDataLiveData3.observe(this, Observer { data -&gt; mAdapter.submitData(lifecycle, data)}) 知识扩充刚才我们调用了 asLiveData 方法转为 LiveData，其实还有两种方法（作为了解即可）。 方法一 在 LifeCycle 2.2.0 之前使用的方法，使用两个 LiveData，一个是可变的，一个是不可变的，如下所示： // 私有的 MutableLiveData 可变的，对内访问private val _pageDataLiveData: MutableLiveData&lt;Flow&lt;PagingData&lt;Person&gt;&gt;&gt; by lazy { MutableLiveData&lt;Flow&lt;PagingData&lt;Person&gt;&gt;&gt;() }// 对外暴露不可变的 LiveData，只能查询val pageDataLiveData: LiveData&lt;Flow&lt;PagingData&lt;Person&gt;&gt;&gt; = _pageDataLiveData_pageDataLiveData.postValue(repository.postOfData()) 准备一私有的 MutableLiveData，只对内访问。 对外暴露不可变的 LiveData。 将值赋值给 _pageDataLiveData。 方法二 在 LifeCycle 2.2.0 之后，可以用更精简的方法来完成，使用 LiveData 协程构造方法 (coroutine builder)。 val pageDataLiveData2 = liveData { emit(repository.postOfData())} liveData 协程构造方法提供了一个协程代码块，产生的是一个不可变的 LiveData，emit() 方法则用来更新 LiveData 的数据。 最后添加左右滑动删除功能调用 recyclerview 封装好的 ItemTouchHelper 实现 左右滑动删除 item 功能。 private fun initSwipeToDelete() { /** * 位于 [androidx.recyclerview.widget] 包下，已经封装好的控件 */ ItemTouchHelper(object : ItemTouchHelper.Callback() { override fun getMovementFlags( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder ): Int = makeMovementFlags(0, ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT) override fun onMove( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder ): Boolean = false override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) { (viewHolder as PersonViewHolder).mBinding.person?.let { // 当 item 左滑 或者 右滑 的时候删除 item mMainViewModel.remove(it) } } }).attachToRecyclerView(rvList)} 关于 Paging 加载本地数据到这里就结束了，我们将在下一篇文章讲解如何加载网络数据，最后上一个效果图。 总结这篇文章主要介绍了以下内容： Paging3 是什么以及它的优点 Paging 是一个分页库，它可以帮助您从本地存储或通过网络加载和显示数据。这种方法使你的 App 更有效地使用网络带宽和系统资源，而 Paging3 是使用 Kotlin 协程完全重写的库： 在内存中缓存分页数据，确保您的 App 在使用分页数据时有效地使用系统资源。 内置删除重复数据的请求，确保您的 App 有效地使用网络带宽和系统资源。 可配置 RecyclerView 的 adapters，当用户滚动到加载数据的末尾时自动请求数据。 支持 Kotlin 协程和 Flow, 以及 LiveData 和 RxJava。 内置的错误处理支持，包括刷新和重试功能。 Paging3 的架构以及类的职能源码分析 PagingSource：每个 PagingSource 对象定义一个数据源以及如何从该数据源查找数据。 RemoteMediator：RemoteMediator 对象处理来自分层数据源的分页，例如具有本地数据库缓存的网络数据源。 Pager：是主要的入口页面，在其构造方法中接受 PagingConfig、initialKey、remoteMediator、pagingSourceFactory。 PagingDataAdapter：是一个处理分页数据的可回收视图适配器，您可以使用 AsyncPagingDataDiffer 组件来构建自己的自定义适配器。 数据映射（Data Mapper） 数据映射（Data Mapper）将数据源的实体，转换为上层用到的 model，往往会被我们忽略掉的，但是在项目中起到了很大重要，使用 数据映射（Data Mapper）优点如下： 数据源的更改不会影响上层的业务。 糟糕的后端实现不会影响上层的业务 (想象一下，如果你被迫执行2个网络请求，因为后端不能在一个请求中提供你需要的所有信息，你会让这个问题影响你的整个代码吗)。 Data Mapper 便于做单元测试，确保不会因为数据源的变化，而影响上层的业务。 在本文案例项目 Paging3Simple 中会用到 Data Mapper 作为数据映射。 Kotlin Flow Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库，也叫做异步流，类似 RxJava 的 Observable，本文主要用到了 flow 当中的 map 方法进行数据转换，如下面的例子所示： flow{ for (i in 1..4) { emit(i) }}.map { it * it} 到这里我相信应该理解了，项目中 pagingData.map { mapper2Person.map(it) } 这行代码的意思了。 GitHub 地址：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，正在逐渐增加 Jetpack 新成员，仓库持续更新，可以前去查看：AndroidX-Jetpack-Practice, 如果这个仓库对你有帮助，请在仓库右上角帮我点个赞，后面我会陆续完成更多 Jetpack 新成员的项目实践","link":"/2020/08/22/jetpack/02-Paging3/"},{"title":"Jetpack 新成员 AndroidX App Startup 实践以及原理分析","text":"前言前几天 Google 更新了几个 Jetpack 新成员 Hilt、Paging 3、App Startup 等等，周末空闲时间实践了一下 App Startup 可以前去查看 GitHub 上的项目 AndroidX-Jetpack-Practice ，接下来一起来分析一下 AndroidX App Startup。 通过这篇文章你将学习到以下内容： App Startup 是什么？ App Startup 为我们解决了什么问题？ 为什么无论是 Google 还是第三方库，初始化时都会在 ContentProvider 里面进行初始化？ 在 ContentProvider 里初始化会带来什么性能问题？ ContentProvider 启动顺序源码分析？ 如何正确使用 App Startup？ 自动初始化。 手动初始化（也是延迟初始化）。 App Startup 是什么？来自 Google 文档： App Startup 是 Android Jetpack 最新成员，提供了在 App 启动时初始化组件简单、高效的方法，无论是 library 开发人员还是 App 开发人员都可以使用 App Startup 显示的设置初始化顺序。 简单的说就是 App Startup 提供了一个 ContentProvider 来运行所有依赖项的初始化，避免每个第三方库单独使用 ContentProvider 进行初始化，从而提高了应用的程序的启动速度。 无论是 Google 提供的库还是第三方库，启动时运行一些初始化逻辑并不少见，例如 WorkManager 在应用启动时使用 ContentProvider 进行初始化，来看一下 Google 工程师 Husayn Hakeem 分享的一张的图。 上图表示现在我们有三个库分别 LibraryA、LibraryB、和 LibraryC 它们使用自己的 ContentProviders 进行初始化。 而 App Startup 提供了一个 ContentProvider 来运行所有依赖项的初始化（LibraryA、LibraryB、和 LibraryC），如下图所示。 AndroidX App Startup 为我们解决了什么问题？刚才我们说到无论是 Google 提供的库还是第三方库，App 启动运行时会初始化一些逻辑，它们为了方便开发者使用，避免开发者手动调用，使用 ContentProvider 进行初始化，例如 WorkManager 在应用启动时使用 ContentProvider 进行初始化，我们来看一下 WorkManager 的源码，先来看一下 AndroidManifest.xml 文件内容。 如上所见，我们可以看到在 AndroidManifest.xml 文件内定义了一个名为 WorkManagerInitializer 的 ContentProvider，我来看看 WorkManagerInitializer 里面都做了什么。 public class WorkManagerInitializer extends ContentProvider { @Override public boolean onCreate() { // Initialize WorkManager with the default configuration. WorkManager.initialize(getContext(), new Configuration.Builder().build()); return true; } ...... // 省略了没用的代码} 如上所见其实就是在 WorkManagerInitializer 的 onCreate() 方法里面，使用默认配置初始化 WorkManager。 我们也来模仿 WorkManager 写一个 Demo，这里只贴出部分代码，更多信息查看 GitHub 上的 AppStartupSimple 下面的 ContentProvider 模块。 定义一个 WorkContentProvider 并在 onCreate 方法中打印一行日志。 class WorkContentProvider : ContentProvider() { override fun onCreate(): Boolean { Log.d(TAG, &quot;WorkContentProvider create()&quot;) return true } .....} 在 AndroidManifest.xml 文件中注册 WorkContentProvider。 &lt;application&gt; &lt;provider android:name=&quot;.WorkContentProvider&quot; android:authorities=&quot;${applicationId}.provider&quot; android:exported=&quot;false&quot; /&gt;&lt;/application&gt; 运行 App 日志如下所示。 com.hi.dhl.startup.simple D/WorkContentProvider: WorkContentProvider create() 假设你的 App 有很多类似于 WorkManager 这样的库，都在 ContentProvider 里面进行一些初始化工作，在 App 启动时运行多个 ContentProvider，这样会带来一些问题： 多个 ContentProvider 会增加了 App 启动运行的时间。 ContentProvider 的 onCreate 方法会先于 Application 的 OnCreate 方法执行，这是在冷启动阶段自动运行初始化的，来看一下 Android 10 系统源码。 private void handleBindApplication(AppBindData data) { ...... if (!data.restrictedBackupMode) { if (!ArrayUtils.isEmpty(data.providers)) { // 创建ContentProvider installContentProviders(app, data.providers); } } ...... try { // 调用调用 Application 的 OnCreate 方法 mInstrumentation.callApplicationOnCreate(app); } catch (Exception e) { ...... } ...... } 这是在 App 冷启动时自动运行初始化的，这样只会增加 App 的加载时间，用户希望 App 加载得快，启动慢会带来糟糕的用户体验，AndroidX App Startup 正是为了解决这个问题而出现的。 如何正确使用 AndroidX App Startup？使用 AndroidX App Startup 来运行所有依赖项的初始化有两种方式： 自动初始化。 手动初始化（也是延迟初始化）。 具体可以查看 GitHub 上的 AppStartupSimple 下面的 Startup-Library 模块相关代码。 自动初始化 在 build.gradle 文件内添加依赖。 implementation &quot;androidx.startup:startup-runtime:1.0.0-alpha01&quot; 实现 Initializer 接口，并重写两个方法，来初始化组件。 class LibaryC : Initializer&lt;LibaryC.Dependency&gt; { override fun create(context: Context): Dependency { // 初始化工作 Log.e(TAG, &quot;init LibaryC &quot;) return Dependency() } override fun dependencies(): MutableList&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; { return mutableListOf(LibaryB::class.java) } ......} create(Context): 这里进行组件初始化工作。 dependencies(): 返回需要初始化的列表，同时设置 App 启动时依赖库运行的顺序，假设LibaryC 依赖于 LibaryB，LibaryB 依赖于 LibaryA，App 启动运行时，会先运行 LibaryA 然后运行 LibaryB 最后运行 LibaryC。 正如 GitHub 上的 AppStartupSimple 示例项目，它依赖结构就是 LibaryC 依赖于 LibaryB，LibaryB 依赖于 LibaryA，输出结果如下所示： com.hi.dhl.startup.simple E/LibaryA: init LibaryA com.hi.dhl.startup.simple E/LibaryB: init LibaryB com.hi.dhl.startup.simple E/LibaryC: init LibaryC 在 AndroidManifest.xml 文件中注册 InitializationProvider。 &lt;application&gt; &lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;${applicationId}.androidx-startup&quot; android:exported=&quot;false&quot; tools:node=&quot;merge&quot;&gt; &lt;!-- 自动初始化 --&gt; &lt;meta-data android:name=&quot;com.hi.dhl.startup.library.LibaryC&quot; android:value=&quot;androidx.startup&quot; /&gt; &lt;/provider&gt;&lt;/application&gt; App 启动的时 App Startup 会读取 AndroidManifest.xml 文件里面的 InitializationProvider 下面的 &lt;meta-data&gt; 声明要初始化的组件，完成自动初始化工作。 手动初始化（也是延迟初始化） 在 build.gradle 文件内添加依赖，和上文一样。 创建一个类 LibaryD 实现 Initializer 接口，并重写两个方法，来初始化组件，和上文一样。 在 AndroidManifest.xml 文件中注册 InitializationProvider。 &lt;application&gt; &lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;${applicationId}.androidx-startup&quot; android:exported=&quot;false&quot; tools:node=&quot;merge&quot;&gt; &lt;!-- 手动初始化（也是延迟初始化） 在 `&lt;meta-data&gt;` 标签内添加 `tools:node=&quot;remove&quot;` --&gt; &lt;meta-data android:name=&quot;com.hi.dhl.startup.library.LibaryD&quot; android:value=&quot;androidx.startup&quot; tools:node=&quot;remove&quot; /&gt; &lt;/provider&gt;&lt;/application&gt; 禁用单个组件的自动初始化，需要在 &lt;meta-data&gt; 标签内添加 tools:node=&quot;remove&quot; 清单合并工具会将它从清单文件中删除。 禁用所有组件初始化，需要在 provider 标签内添加 tools:node=&quot;remove&quot; 清单合并工具会将它从清单文件中删除。 &lt;!-- 禁用所有组件初始化 --&gt;&lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;${applicationId}.androidx-startup&quot; android:exported=&quot;false&quot; tools:node=&quot;remove&quot;&gt; ......&lt;/provider&gt; 在需要的地方进行初始化，调用以下代码进行初始化。 AppInitializer.getInstance(context).initializeComponent(MyInitializer::class.java) 如果组件初始化之后，再次调用 AppInitializer.initializeComponent() 方法不会再次初始化。 手动初始化（也是延迟初始化）是非常有用的，组件不需要在 App 启动时运行，只需要在需要它地方运行，可以减少 App 的启动时间，提高启动速度。 全文到这里就结束了，App Startup 和 ContentProvider 相关示例已经上传到 GitHub 上了 AndroidX-Jetpack-Practice：https://github.com/hi-dhl/AndroidX-Jetpack-Practice 正在建立一个最全、最新的 AndroidX Jetpack 相关组件的实战项目 以及 相关组件原理分析文章，仓库持续更新中，可以前去查看：AndroidX-Jetpack-Practice 总结这篇文章主要介绍了以下内容： ContentProvider 启动顺序源码分析。 App Startup 是 Jetpack 的新成员，是为了解决因 App 启动时运行多个 ContentProvider 会增加 App 的启动时间的问题。 使用了一个 InitializationProvider 管理多个依赖项，消除了每个库单独使用 ContentProvider 成本，减少初始化时间。 App Startup 允许你自定义组件初始化顺序。 App Startup 可以自动初始化 AndroidManifest.xml 文件中 InitializationProvider 下面的 &lt;meta-data&gt; 声明要初始化的组件。 App Startup 提供了一种延迟初始化组件的方法，减少 App 初始化时间。 在 AndroidManifest.xml 文件中声明 node=&quot;remove&quot; 打包的时候会删除？这样做的目的是什么？ 便于管理所有的初始化项 禁用组件自动初始化也将禁用该组件依赖项的自动初始化 确保合并工具从所有其他合并清单文件中删除 参考文献 https://developer.android.com/topic/libraries/app-startup https://proandroiddev.com/androidx……","link":"/2020/08/22/jetpack/01-app-startup/"},{"title":"为数不多的人知道的 Kotlin 技巧以及 原理解析（二）","text":"文章中没有奇淫技巧，都是一些在实际开发中常用，但很容易被我们忽略的一些常见问题，源于平时的总结，这篇文章主要对这些常见问题进行分析。 之前分享过一篇文章 为数不多的人知道的 Kotlin 技巧以及 原理解析 主要分析了一些让人傻傻分不清楚的操作符的原理。 这篇文章主要分析一些常见问题的解决方案，如果使用不当会对 性能 和 内存 造成的那些影响以及如何规避这些问题，文章中涉及的案例来自 Kotlin 官方、Stackoverflow、Medium 等等网站，都是平时看到，然后进行汇总和分析。 通过这篇文章你将学习到以下内容： 使用 toLowerCase 和 toUpperCase 等等方法会造成那些影响？ 如何优雅的处理空字符串？ 为什么解构声明和数据类不能在一起使用？ Kotlin 提供的高效的文件处理方法，以及原理解析？ Sequence 和 Iterator 有那些不同之处？ 便捷的 joinToString 方法的使用？ 如何用一行代码实现移除字符串的前缀和后缀？ 尽量少使用 toLowerCase 和 toUpperCase 方法当我们比较两个字符串，需要忽略大小写的时候，通常的写法是调用 toLowerCase() 方法或者 toUpperCase() 方法转换成大写或者小写，然后在进行比较，但是这样的话有一个不好的地方，每次调用 toLowerCase() 方法或者 toUpperCase() 方法会创建一个新的字符串，然后在进行比较。 调用 toLowerCase() 方法 fun main(args: Array&lt;String&gt;) {// use toLowerCase() val oldName = &quot;Hi dHL&quot; val newName = &quot;hi Dhl&quot; val result = oldName.toLowerCase() == newName.toLowerCase()// or use toUpperCase()// val result = oldName.toUpperCase() == newName.toUpperCase()} toLowerCase() 编译之后的 Java 代码 如上图所示首先会生成一个新的字符串，然后在进行字符串比较，那么 toUpperCase() 方法也是一样的如下图所示。 toUpperCase() 编译之后的 Java 代码 这里有一个更好的解决方案，使用 equals 方法来比较两个字符串，添加可选参数 ignoreCase 来忽略大小写，这样就不需要分配任何新的字符串来进行比较了。 fun main(args: Array&lt;String&gt;) { val oldName = &quot;hi DHL&quot; val newName = &quot;hi dhl&quot; val result = oldName.equals(newName, ignoreCase = true)} equals 编译之后的 Java 代码 使用 equals 方法并没有创建额外的对象，如果遇到需要比较字符串的时候，可以使用这种方法，减少额外的对象创建。 如何优雅的处理空字符串当字符串为空字符串的时候，返回一个默认值，常见的写法如下所示： val target = &quot;&quot;val name = if (target.isEmpty()) &quot;dhl&quot; else target 其实有一个更简洁的方法，可读性更强，使用 ifEmpty 方法，当字符串为空字符串时，返回一个默认值，如下所示。 val name = target.ifEmpty { &quot;dhl&quot; } 其原理跟我们使用 if 表达式是一样的，来分析一下源码。 public inline fun &lt;C, R&gt; C.ifEmpty(defaultValue: () -&gt; R): R where C : CharSequence, C : R = if (isEmpty()) defaultValue() else this ifEmpty 方法是一个扩展方法，接受一个 lambda 表达式 defaultValue ，如果是空字符串，返回 defaultValue，否则不为空，返回调用者本身。 除了 ifEmpty 方法，Kotlin 库中还封装很多其他非常有用的字符串，例如：将字符串转为数字。常见的写法如下所示： val input = &quot;123&quot;val number = input.toInt() 其实这种写法存在一定问题，假设输入字符串并不是纯数字，例如 123ddd 等等，调用 input.toInt() 就会报错，那么有没有更好的写法呢？如下所示。 val input = &quot;123&quot;// val input = &quot;123ddd&quot;// val input = &quot;&quot;val number = input.toIntOrNull() ?: 0 避免将解构声明和数据类一起使用这是 Kotlin 团队一个建议：避免将解构声明和数据类一起使用，如果以后往数据类添加新的属性，很容易破坏代码的结构。我们一起来思考一下，为什么 Kotlin 官方会这么说，我先来看一个例子：数据类和解构声明的使用。 // 数据类data class People( val name: String, val city: String)fun main(args: Array&lt;String&gt;) { // 编译测试 printlnPeople(People(&quot;dhl&quot;, &quot;beijing&quot;))}fun printlnPeople(people: People) { // 解构声明，获取 name 和 city 并将其输出 val (name, city) = people println(&quot;name: ${name}&quot;) println(&quot;city: ${city}&quot;)} 输出结果如下所示： name: dhlcity: beijing 随着需求的变更，需要给数据类 People 添加一个新的属性 age。 // 数据类，增加了 agedata class People( val name: String, val age: Int, val city: String)fun main(args: Array&lt;String&gt;) { // 编译测试 printlnPeople(People(&quot;dhl&quot;, 80, &quot;beijing&quot;))} 此时没有更改解构声明，也不会有任何错误，编译输出结果如下所示： name: dhlcity: 80 得到的结果并不是我们期望的，此时我们不得不更改解构声明的地方，如果代码中有多处用到了解构声明，因为增加了新的属性，就要去更改所有使用解构声明的地方，这明显是不合理的，很容易破坏代码的结构，所以一定要避免将解构声明和数据类一起使用。当我们使用不规范的时候，并且编译器也会给出警告，如下图所示。 文件的扩展方法Kotlin 提供了很多文件扩展方法 Extensions for java.io.Reade ：forEachLine 、 readLines 、 readText 、 useLines 等等方法，帮助我们简化文件的操作，而且使用完成之后，它们会自动关闭，例如 useLines 方法： File(&quot;dhl.txt&quot;).useLines { line -&gt; println(line)} useLines 是 File 的扩展方法，调用 useLines 会返回一个文件中所有行的 Sequence，当文件内容读取完毕之后，它会自动关闭，其源码如下。 public inline fun &lt;T&gt; File.useLines(charset: Charset = Charsets.UTF_8, block: (Sequence&lt;String&gt;) -&gt; T): T = bufferedReader(charset).use { block(it.lineSequence()) } useLines 是 File 的一个扩展方法 useLines 接受一个 lambda 表达式 block 调用了 BufferedReader 读取文件内容，之后调用 block 返回文件中所有行的 Sequence 给调用者 那它是如何在读取完毕自动关闭的呢，核心在 use 方法里面，在 useLines 方法内部调用了 use 方法，use 方法也是一个扩展方法，源码如下所示。 public inline fun &lt;T : Closeable?, R&gt; T.use(block: (T) -&gt; R): R { var exception: Throwable? = null try { return block(this) } catch (e: Throwable) { exception = e throw e } finally { when { apiVersionIsAtLeast(1, 1, 0) -&gt; this.closeFinally(exception) this == null -&gt; {} exception == null -&gt; close() else -&gt; try { close() } catch (closeException: Throwable) { // cause.addSuppressed(closeException) // ignored here } } }} 其实很简单，调用 try...catch...finally 最后在 finally 内部进行 close。其实我们也可以根据源码实现一个通用的异常捕获方法。 inline fun &lt;T, R&gt; T.dowithTry(block: (T) -&gt; R) { try { block(this) } catch (e: Throwable) { e.printStackTrace() }}// 使用方式dowithTry { // 添加会出现异常的代码, 例如 val result = 1 / 0} 当然这只是一个非常简单的异常捕获方法，在实际项目中还有很多需要去处理的，比如说异常信息需不需要返回给调用者等等。 在上文中提到了调用 useLines 方法返回一个文件中所有行的 Sequence，为什么 Kolin 会返回 Sequence，而不返回 Iterator？ Sequence 和 Iterator 不同之处为什么 Kolin 会返回 Sequence，而不返回 Iterator？其实这个核心原因由于 Sequence 和 Iterator 实现不同导致 内存 和 性能 有很大的差异。 接下来我们围绕这两个方面来分析它们的性能，Sequences(序列) 和 Iterator(迭代器) 都是一个比较大的概念，本文的目的不是去分析它们，所以在这里不会去详细分析 Sequence 和 Iterator，只会围绕着 内存 和 性能 两个方面去分析它们的区别，让我们有一个直观的印象。更多信息可以查看国外一位大神写的文章 Prefer Sequence for big collections with more than one processing step。 Sequence 和 Iterator 从代码结构上来看，它们非常的相似如下所示： interface Iterable&lt;out T&gt; { operator fun iterator(): Iterator&lt;T&gt;}interface Sequence&lt;out T&gt; { operator fun iterator(): Iterator&lt;T&gt;} 除了代码结构之外，Sequences(序列) 和 Iterator(迭代器) 它们的实现完全不一样。 Sequences(序列)Sequences 是属于懒加载操作类型，在 Sequences 处理过程中，每一个中间操作不会进行任何计算，它们只会返回一个新的 Sequence，经过一系列中间操作之后，会在末端操作 toList 或 count 等等方法中进行最终的求职运算，如下图所示。 在 Sequences 处理过程中，会对单个元素进行一系列操作，然后在对下一个元素进行一系列操作，直到所有元素处理完毕。 val data = (1..3).asSequence() .filter { print(&quot;F$it, &quot;); it % 2 == 1 } .map { print(&quot;M$it, &quot;); it * 2 } .forEach { print(&quot;E$it, &quot;) }println(data)// 输出 F1, M1, E2, F2, F3, M3, E6 如上所示：在 Sequences 处理过程中，对 1 进行一系列操作输出 F1, M1, E2, 然后对 2 进行一系列操作，依次类推，直到所有元素处理完毕，输出结果为 F1, M1, E2, F2, F3, M3, E6。 在 Sequences 处理过程中，每一个中间操作（ map、filter 等等 ）不进行任何计算，只有在末端操作（ toList、count、forEach 等等方法 ） 进行求值运算，如何区分是中间操作还是末端操作，看方法的返回类型，中间操作返回的是 Sequence，末端操作返回的是一个具体的类型（ List、int、Unit 等等 ）源码如下所示。 // 中间操作 map ，返回的是 Sequencepublic fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt; { return TransformingSequence(this, transform)}// 末端操作 toList 返回的是一个具体的类型（List）public fun &lt;T&gt; Sequence&lt;T&gt;.toList(): List&lt;T&gt; { return this.toMutableList().optimizeReadOnlyList()}// 末端操作 forEachIndexed 返回的是一个具体的类型（Unit）public inline fun &lt;T&gt; Sequence&lt;T&gt;.forEachIndexed(action: (index: Int, T) -&gt; Unit): Unit { var index = 0 for (item in this) action(checkIndexOverflow(index++), item)} 如果是中间操作 map、filter 等等，它们返回的是一个 Sequence，不会进行任何计算 如果是末端操作 toList、count、forEachIndexed 等等，返回的是一个具体的类型（ List、int、Unit 等等 ），会做求值运算 Iterator(迭代器)在 Iterator 处理过程中，每一次的操作都是对整个数据进行操作，需要开辟新的内存来存储中间结果，将结果传递给下一个操作，代码如下所示： val data = (1..3).asIterable() .filter { print(&quot;F$it, &quot;); it % 2 == 1 } .map { print(&quot;M$it, &quot;); it * 2 } .forEach { print(&quot;E$it, &quot;) }println(data)// 输出 F1, F2, F3, M1, M3, E2, E6 如上所示：在 Iterator 处理过程中，调用 filter 方法对整个数据进行操作输出 F1, F2, F3，将结果存储到 List 中, 然后将结果传递给下一个操作 （ map ） 输出 M1, M3 将新的结果在存储的 List 中, 直到所有操作处理完毕。 // 每次操作都会开辟一块新的空间，存储计算的结果public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt; { return filterTo(ArrayList&lt;T&gt;(), predicate)}// 每次操作都会开辟一块新的空间，存储计算的结果public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; { return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)} 对于每次操作都会开辟一块新的空间，存储计算的结果，这是对内存极大的浪费，我们往往只关心最后的结果，而不是中间的过程。 了解完 Sequences 和 Iterator 不同之处，接下里我们从 性能 和 内存 两个方面来分析 Sequences 和 Iterator。 Sequences 和 Iterator 性能对比分别使用 Sequences 和 Iterator 调用它们各自的 filter、map 方法，处理相同的数据的情况下，比较它们的执行时间。 使用 Sequences ： val time = measureTimeMillis { (1..10000000 * 10).asSequence() .filter { it % 2 == 1 } .map { it * 2 } .count()}println(time) // 1197 使用 Iterator ： val time2 = measureTimeMillis { (1..10000000 * 10).asIterable() .filter { it % 2 == 1 } .map { it * 2 } .count()}println(time2) // 23641 Sequences 和 Iterator 处理时间如下所示： Sequences Iterator 1197 23641 这个结果是很让人吃惊的，Sequences 比 Iterator 快 19 倍，如果数据量越大，它们的时间差距会越来越大，当我们在读取文件的时候，可能会进行一系列的数据操作 drop、filter 等等，所以 Kotlin 库函数 useLines 等等方法会返回 Sequences，因为它们更加的高效。 Sequences 和 Iterator 内存对比这里使用了 Prefer Sequence for big collections with more than one processing step 文章的一个例子。 有 1.53 GB 犯罪分子的数据存储在文件中，从文件中找出有多少犯罪分子携带大麻，分别使用 Sequences 和 Iterator，我们先来看一下如果使用 Iterator 处理会怎么样（这里调用 readLines 函返回 List&lt;String&gt;） File(&quot;ChicagoCrimes.csv&quot;).readLines() .drop(1) // Drop descriptions of the columns .mapNotNull { it.split(&quot;,&quot;).getOrNull(6) } // Find description .filter { &quot;CANNABIS&quot; in it } .count() .let(::println) 运行完之后，你将会得到一个意想不到的结果 OutOfMemoryError Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space 调用 readLines 函返回一个集合，有 3 个中间操作，每一个中间操作都需要一块空间存储 1.53 GB 的数据，它们需要占用超过 4.59 GB 的空间，每次操作都开辟了一块新的空间，这是对内存巨大浪费。如果我们使用序列 Sequences 会怎么样呢?（调用 useLines 方法返回的是一个 Sequences）。 File(&quot;ChicagoCrimes.csv&quot;).useLines { lines -&gt;// The type of `lines` is Sequence&lt;String&gt; lines .drop(1) // Drop descriptions of the columns .mapNotNull { it.split(&quot;,&quot;).getOrNull(6) } // Find description .filter { &quot;CANNABIS&quot; in it } .count() .let { println(it) } // 318185 没有出现 OutOfMemoryError 异常，共耗时 8.3 s，由此可见对于文件操作使用序列不仅能提高性能，还能减少内存的使用，从性能和内存这两面也解释了为什么 Kotlin 库的扩展方法 useLines 等等，读取文件的时候使用 Sequences 而不使用 Iterator。 便捷的 joinToString 方法的使用joinToString 方法提供了一组丰富的可选择项（ 分隔符，前缀，后缀，数量限制等等 ）可用于将可迭代对象转换为字符串。 val data = listOf(&quot;Java&quot;, &quot;Kotlin&quot;, &quot;C++&quot;, &quot;Python&quot;) .joinToString( separator = &quot; | &quot;, prefix = &quot;{&quot;, postfix = &quot;}&quot; ) { it.toUpperCase() }println(data) // {JAVA | KOTLIN | C++ | PYTHON} 这是很常见的用法，将集合转换成字符串，高效利用便捷的joinToString 方法，开发的时候事半功倍，既然可以添加前缀，后缀，那么可以移除它们吗? 可以的，Kotlin 库函数提供了一些方法，帮助我们实现，如下代码所示。 var data = &quot;**hi dhl**&quot;// 移除前缀println(data.removePrefix(&quot;**&quot;)) // hi dhl**// 移除后缀println(data.removeSuffix(&quot;**&quot;)) // **hi dhl// 移除前缀和后缀println(data.removeSurrounding(&quot;**&quot;)) // hi dhl// 返回第一次出现分隔符后的字符串println(data.substringAfter(&quot;**&quot;)) // hi dhl**// 如果没有找到，返回原始字符串println(data.substringAfter(&quot;--&quot;)) // **hi dhl**// 如果没有找到，返回默认字符串 &quot;no match&quot;println(data.substringAfter(&quot;--&quot;,&quot;no match&quot;)) // no matchdata = &quot;{JAVA | KOTLIN | C++ | PYTHON}&quot;// 移除前缀和后缀println(data.removeSurrounding(&quot;{&quot;, &quot;}&quot;)) // JAVA | KOTLIN | C++ | PYTHON 有了这些 Kotlin 库函数，我们就不需要在做 startsWith() 和 endsWith() 的检查了，如果让我们自己来实现上面的功能，我们需要花多少行代码去实现呢，一起来看一下 Kotlin 源码是如何实现的，上面的操作符最终都会调用以下代码，进行字符串的检查和截取。 public String substring(int beginIndex, int endIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } if (endIndex &gt; value.length) { throw new StringIndexOutOfBoundsException(endIndex); } int subLen = endIndex - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);} 参考源码的实现，如果以后遇到类似的需求，但是 Kotlin 库函数有无法满足我们，我们可以以源码为基础进行扩展。 全文到这里就结束了，Kotlin 的强大不止于此，后面还会分享更多的技巧，在 Kotlin 的道路上还有很多实用的技巧等着我们一起来探索。","link":"/2020/08/22/kotlin/02-kotlin/"},{"title":"为数不多的人知道的 Kotlin 技巧以及 原理解析（一）","text":"Google 引入 Kotlin 的目的就是为了让 Android 开发更加方便，自从官宣 Kotlin 成为了 Android 开发的首选语言之后，已经有越来越多的人开始使用 Kotlin。 结合着 Kotlin 的高级函数的特性可以让代码可读性更强，更加简洁，但是简洁的背后是有代价的，使用不当对性能可能会有损耗，这块往往很容易被我们忽略，这就需要我们去研究 kotlin 语法糖背后的魔法，当我们在开发的时候，选择合适的语法糖，尽量避免这些错误，关于 Kotlin 性能损失那些事，可以看一下我另外两篇文章。 [译][2.4K Start] 放弃 Dagger 拥抱 Koin [译][5k+] Kotlin 的性能优化那些事 这两篇文章都分析了 Kotlin 使用不当对性能的影响，不仅如此 Kotlin 当中还有很多让人傻傻分不清楚的语法糖例如 run, with, let, also, apply 等等，这篇文章将介绍一种简单的方法来区分它们以及如何选择使用。 通过这篇文章你将学习到以下内容，文中会给出相应的答案 如何使用 plus 操作符对集合进行操作？ 当获取 Map 值为空时，如何设置默认值？ require 或者 check 函数做什么用的？ 如何区分 run, with, let, also and apply 以及如何使用？ 如何巧妙的使用 in 和 when 关键字？ Kotlin 的单例有那种三种写法? 为什么 by lazy 声明的变量只能用 val？ plus 操作符在 Java 中算术运算符只能用于基本数据类型，+ 运算符可以与 String 值一起使用，但是不能在集合中使用，在 Kotlin 中可以应用在任何类型，我们来看一个例子，利用 plus (+) 和 minus (-) 对 Map 集合做运算，如下所示。 fun main() { val numbersMap = mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3) // plus (+) println(numbersMap + Pair(&quot;four&quot;, 4)) // {one=1, two=2, three=3, four=4} println(numbersMap + Pair(&quot;one&quot;, 10)) // {one=10, two=2, three=3} println(numbersMap + Pair(&quot;five&quot;, 5) + Pair(&quot;one&quot;, 11)) // {one=11, two=2, three=3, five=5} // minus (-) println(numbersMap - &quot;one&quot;) // {two=2, three=3} println(numbersMap - listOf(&quot;two&quot;, &quot;four&quot;)) // {one=1, three=3}} 其实这里用到了运算符重载，Kotlin 在 Maps.kt 文件里面，定义了一系列用关键字 operator 声明的 Map 的扩展函数。 用 operator 关键字声明 plus 函数，可以直接使用 + 号来做运算，使用 operator 修饰符声明 minus 函数，可以直接使用 - 号来做运算，其实我们也可以在自定义类里面实现 plus (+) 和 minus (-) 做运算。 data class Salary(var base: Int = 100){ override fun toString(): String = base.toString()}operator fun Salary.plus(other: Salary): Salary = Salary(base + other.base)operator fun Salary.minus(other: Salary): Salary = Salary(base - other.base)val s1 = Salary(10)val s2 = Salary(20)println(s1 + s2) // 30println(s1 - s2) // -10 Map 集合的默认值在 Map 集合中，可以使用 withDefault 设置一个默认值，当键不在 Map 集合中，通过 getValue 返回默认值。 val map = mapOf( &quot;java&quot; to 1, &quot;kotlin&quot; to 2, &quot;python&quot; to 3).withDefault { &quot;?&quot; }println(map.getValue(&quot;java&quot;)) // 1println(map.getValue(&quot;kotlin&quot;)) // 2println(map.getValue(&quot;c++&quot;)) // ? 源码实现也非常简单，当返回值为 null 时，返回设置的默认值。 internal inline fun &lt;K, V&gt; Map&lt;K, V&gt;.getOrElseNullable(key: K, defaultValue: () -&gt; V): V { val value = get(key) if (value == null &amp;&amp; !containsKey(key)) { return defaultValue() } else { @Suppress(&quot;UNCHECKED_CAST&quot;) return value as V }} 但是这种写法和 plus 操作符在一起用，有一个 bug ，看一下下面这个例子。 val newMap = map + mapOf(&quot;python&quot; to 3)println(newMap.getValue(&quot;c++&quot;)) // 调用 getValue 时抛出异常，异常信息：Key c++ is missing in the map. 这段代码的意思就是，通过 plus(+) 操作符合并两个 map，返回一个新的 map, 但是忽略了默认值，所以看到上面的错误信息，我们在开发的时候需要注意这点。 使用 require 或者 check 函数作为条件检查// 传统的做法val age = -1;if (age &lt;= 0) { throw IllegalArgumentException(&quot;age must not be negative&quot;)}// 使用 require 去检查require(age &gt; 0) { &quot;age must be negative&quot; }// 使用 checkNotNull 检查val name: String? = nullcheckNotNull(name){ &quot;name must not be null&quot;} 那么我们如何在项目中使用呢，具体的用法可以查看我 GitHub 上的项目 DataBindingDialog.kt 当中的用法。 如何区分和使用 run, with, let, also, apply感谢大神 Elye 的这篇文章提供的思路 Mastering Kotlin standard functions。 run, with, let, also, apply 都是作用域函数，这些作用域函数如何使用，以及如何区分呢，我们将从以下三个方面来区分它们。 是否是扩展函数。 作用域函数的参数（this、it）。 作用域函数的返回值（调用本身、其他类型即最后一行）。 是否是扩展函数首先我们来看一下 with 和 T.run，这两个函数非常的相似，他们的区别在于 with 是个普通函数，T.run 是个扩展函数，来看一下下面的例子。 val name: String? = nullwith(name){val subName = name!!.substring(1,2)}// 使用之前可以检查它的可空性name?.run { val subName = name.substring(1,2) }?:throw IllegalArgumentException(&quot;name must not be null&quot;) 在这个例子当中，name?.run 会更好一些，因为在使用之前可以检查它的可空性。 作用域函数的参数（this、it）我们在来看一下 T.run 和 T.let，它们都是扩展函数，但是他们的参数不一样，T.run 的参数是 this, T.let 的参数是 it。 val name: String? = &quot;hi-dhl.com&quot;// 参数是 this，可以省略不写name?.run {println(&quot;The length is ${this.length} this 是可以省略的 ${length}&quot;)}// 参数 itname?.let {println(&quot;The length is ${it.length}&quot;)}// 自定义参数名字name?.let { str -&gt;println(&quot;The length is ${str.length}&quot;)} 在上面的例子中看似 T.run 会更好，因为 this 可以省略，调用更加的简洁，但是 T.let 允许我们自定义参数名字，使可读性更强，如果倾向可读性可以选择 T.let。 作用域函数的返回值（调用本身、其他类型）接下里我们来看一下 T.let 和 T.also 它们接受的参数都是 it, 但是它们的返回值是不同的，T.let 返回最后一行，T.also 返回调用本身。 var name = &quot;hi-dhl&quot;// 返回调用本身name = name.also {val result = 1 * 1&quot;juejin&quot;}println(&quot;name = ${name}&quot;) // name = hi-dhl// 返回的最后一行name = name.let {val result = 1 * 1&quot;hi-dhl.com&quot;}println(&quot;name = ${name}&quot;) // name = hi-dhl.com 从上面的例子来看 T.also 似乎没有什么意义，细想一下其实是非常有意义的，在使用之前可以进行自我操作，结合其他的函数，功能会更强大。 fun makeDir(path: String) = path.let{ File(it) }.also{ it.mkdirs() } 当然 T.also 还可以做其他事情，比如利用 T.also 在使用之前可以进行自我操作特点，可以实现一行代码交换两个变量，在后面会有详细介绍 T.apply 函数通过上面三个方面，大致了解函数的行为，接下来看一下 T.apply 函数，T.apply 函数是一个扩展函数，返回值是它本身，并且接受的参数是 this。 // 普通方法fun createInstance(args: Bundle) : MyFragment {val fragment = MyFragment()fragment.arguments = argsreturn fragment}// 改进方法fun createInstance(args: Bundle) = MyFragment().apply { arguments = args } // 普通方法fun createIntent(intentData: String, intentAction: String): Intent {val intent = Intent()intent.action = intentActionintent.data=Uri.parse(intentData)return intent}// 改进方法，链式调用fun createIntent(intentData: String, intentAction: String) = Intent().apply { action = intentAction } .apply { data = Uri.parse(intentData) } 汇总以表格的形式汇总，更方便去理解 函数 是否是扩展函数 函数参数(this、it) 返回值(调用本身、最后一行) with 不是 this 最后一行 T.run 是 this 最后一行 T.let 是 it 最后一行 T.also 是 it 调用本身 T.apply 是 this 调用本身 使用 T.also 函数交换两个变量接下来演示的是使用 T.also 函数，实现一行代码交换两个变量？我们先来回顾一下 Java 的做法。 int a = 1;int b = 2;// Java - 中间变量int temp = a;a = b;b = temp;System.out.println(&quot;a = &quot;+a +&quot; b = &quot;+b); // a = 2 b = 1// Java - 加减运算a = a + b;b = a - b;a = a - b;System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b); // a = 2 b = 1 // Java - 位运算a = a ^ b;b = a ^ b;a = a ^ b;System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b); // a = 2 b = 1// Kotlina = b.also { b = a }println(&quot;a = ${a} b = ${b}&quot;) // a = 2 b = 1 来一起分析 T.also 是如何做到的，其实这里用到了 T.also 函数的两个特点。 调用 T.also 函数返回的是调用者本身。 在使用之前可以进行自我操作。 也就是说 b.also { b = a } 会先将 a 的值 (1) 赋值给 b，此时 b 的值为 1，然后将 b 原始的值（2）赋值给 a，此时 a 的值为 2，实现交换两个变量的目的。 in 和 when 关键字使用 in 和 when 关键字结合正则表达式，验证用户的输入，这是一个很酷的技巧。 // 使用扩展函数重写 contains 操作符operator fun Regex.contains(text: CharSequence) : Boolean { return this.containsMatchIn(text)}// 结合着 in 和 when 一起使用when (input) { in Regex(&quot;[0–9]&quot;) -&gt; println(&quot;contains a number&quot;) in Regex(&quot;[a-zA-Z]&quot;) -&gt; println(&quot;contains a letter&quot;)} in 关键字其实是 contains 操作符的简写，它不是一个接口，也不是一个类型，仅仅是一个操作符，也就是说任意一个类只要重写了 contains 操作符，都可以使用 in 关键字，如果我们想要在自定义类型中检查一个值是否在列表中，只需要重写 contains() 方法即可，Collections 集合也重写了 contains 操作符。 val input = &quot;kotlin&quot;when (input) { in listOf(&quot;java&quot;, &quot;kotlin&quot;) -&gt; println(&quot;found ${input}&quot;) in setOf(&quot;python&quot;, &quot;c++&quot;) -&gt; println(&quot;found ${input}&quot;) else -&gt; println(&quot; not found ${input}&quot;)} Kotlin 的单例三种写法我汇总了一下目前 Kotlin 单例总共有三种写法： 使用 Object 实现单例。 使用 by lazy 实现单例。 可接受参数的单例（来自大神 Christophe Beyls）。 使用 Object 实现单例代码： object WorkSingleton Kotlin 当中 Object 关键字就是一个单例，比 Java 的一坨代码看起来舒服了很多，来看一下编译后的 Java 文件。 public final class WorkSingleton { public static final WorkSingleton INSTANCE; static { WorkSingleton var0 = new WorkSingleton(); INSTANCE = var0; }} 通过 static 代码块实现的单例，优点：饿汉式且是线程安全的，缺点：类加载时就初始化，浪费内存。 使用 by lazy 实现单例利用伴生对象 和 by lazy 也可以实现单例，代码如下所示。 class WorkSingleton private constructor() { companion object { // 方式一 val INSTANCE1 by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) { WorkSingleton() } // 方式二 默认就是 LazyThreadSafetyMode.SYNCHRONIZED，可以省略不写，如下所示 val INSTANCE2 by lazy { WorkSingleton() } }} lazy 的延迟模式有三种： 上面代码所示 mode = LazyThreadSafetyMode.SYNCHRONIZED，lazy 默认的模式，可以省掉，这个模式的意思是：如果有多个线程访问，只有一条线程可以去初始化 lazy 对象。 当 mode = LazyThreadSafetyMode.PUBLICATION 表达的意思是：对于还没有被初始化的 lazy 对象，可以被不同的线程调用，如果 lazy 对象初始化完成，其他的线程使用的是初始化完成的值。 mode = LazyThreadSafetyMode.NONE 表达的意思是：只能在单线程下使用，不能在多线程下使用，不会有锁的限制，也就是说它不会有任何线程安全的保证以及相关的开销。 通过上面三种模式，这就可以理解为什么 by lazy 声明的变量只能用 val，因为初始化完成之后它的值是不会变的。 可接受参数的单例但是有的时候，希望在单例实例化的时候传递参数，例如： Singleton.getInstance(context).doSome() 上面这两种形式都不能满足，来看看大神 Christophe Beyls 在这篇文章给出的方法 Kotlin singletons with argument 代码如下。 class WorkSingleton private constructor(context: Context) { init { // Init using context argument } companion object : SingletonHolder&lt;WorkSingleton, Context&gt;(::WorkSingleton)}open class SingletonHolder&lt;out T : Any, in A&gt;(creator: (A) -&gt; T) { private var creator: ((A) -&gt; T)? = creator @Volatile private var instance: T? = null fun getInstance(arg: A): T { val i = instance if (i != null) { return i } return synchronized(this) { val i2 = instance if (i2 != null) { i2 } else { val created = creator!!(arg) instance = created creator = null created } } }} 有没有感觉这和 Java 中双重校验锁的机制很像，在 SingletonHolder 类中如果已经初始化了直接返回，如果没有初始化进入 synchronized 代码块创建对象，利用了 Kotlin 伴生对象提供的非常强大功能，它能够像其他任何对象一样从基类继承，从而实现了与静态继承相当的功能。 所以我们将 SingletonHolder 作为单例类伴随对象的基类，以便在单例类上重用并公开 getInstance（）函数。 参数传递给 SingletonHolder 构造函数的 creator，creator 是一个 lambda 表达式，将 WorkSingleton 传递给 SingletonHolder 类构造函数。 并且不限制传入参数的类型，凡是需要传递参数的单例模式，只需将单例类的伴随对象继承于 SingletonHolder，然后传入当前的单例类和参数类型即可，例如： class FileSingleton private constructor(path: String) { companion object : SingletonHolder&lt;FileSingleton, String&gt;(::FileSingleton)} 总结到这里就结束了，Kotlin 的强大不止于此，后面还会分享更多的技巧，在 Kotlin 的道路上还有很多实用的技巧等着我们一起来探索。 例如利用 Kotlin 的 inline、reified、DSL 等等语法, 结合着 DataBinding、LiveData 等等可以设计出更加简洁并利于维护的代码，更多技巧可以查看我 GitHub 上的项目 JDataBinding。 参考链接 Mastering Kotlin standard functions: run, with, let, also and apply Kotlin: fun with “in”","link":"/2020/08/22/kotlin/01-kotlin/"},{"title":"图解多平台 AndroidStudio 技巧(二)","text":"这篇文章将会继续分享一些实用的快捷键，好的 idea 能提高我们的工作效率，如果掌握一些快捷键，能帮我们从繁琐重复的工作中解放出来，写代码的效率就越高，接下来想分享一些实用的快捷键, 因为快捷键比较多，将会分为多篇文章。 图解多平台 AndroidStudio 技巧(一) 图解多平台 AndroidStudio 技巧(二) 软件环境: Mac/Win/Linux: 内置默认快捷键 AndroidStudio v4.1.1 不同的外接键盘使用下列快捷键，需要根据自己的键盘做相应的调整 显示当前类所有的方法当我们在阅读别人的代码，或者在阅读源码的时候，想查看当前类都有那些方法、常量、变量等等，下面这个快捷键将会给你一个大局观，非常的实用 MAC: Cmd + Fn + F12 MAC外接机械键盘: Cmd + F12 Win/Linux: Ctrl + F12 高亮当我们需要查看某个变量在那个地方调用了，这个快捷键会标识出所有使用这个变量的地方 Mac: Cmd + Shift + Fn + F7 MAC外接机械键盘: Cmd + Shift + F7 Win/Linux: Ctrl + Shift + F7 快速跳转到父类当我们正在阅读代码，这时如果想跳转到父类，通常的做法回到类的开头点击进去，如果代码很长，这样做效率很低，下面的快捷键可以帮助你快速跳转到父类 Mac: Cmd + U Win/Linux: Ctrl + U 快速跳转到实现一个接口有多个实现，当我们点击接口的一个方法，想查看他在子类的不同实现，这个快捷键可以帮助你快速跳转到子类的实现 Mac: Cmd + Option + B Win/Linux: Ctrl + Alt + B 覆写或者实现方法这个快捷键就很简单了，弹出一个框让你自己去选择要重写或者复写某个方法 Mac: Control + O Win/Linux: Ctrl + O 生成默认方法如果我们想要快速生成类默认方法如构造方法、toString()、Setter()、Gettter()等等，可以使用下面的快捷键 Mac: Cmd + N Win/Linux: Alt+Insert 汇总为了方便查看将这两篇文章的快捷键做了一个汇总 说明 快捷键 参数提示 Mac: Cmd + P win/Linux: Ctrl + P 自动提取方法 Mac: Cmd + Alt + M Win/Linux: Ctrl + Alt + M 自动提取参数 Mac: Cmd + Alt + P Win/Linux: Ctrl + Alt + P 自动生成变量 Mac: Cmd + Alt + V Win/Linux: Ctrl + Alt + V 搜索某个方法是否被调用 Mac/Win/Linux: Alt + F7 重构快捷键 Mac : Ctrl + T Win/Linux: Ctrl + Alt + Shift + T 包裹代码 Mac: Cmd + Alt + T Win/Linux: Ctrl + Alt + T 批量重命名 Mac/Win/Linux: shift + F6 查看方法调用层次结构 Mac: Control + Option + H Win/Linux: Ctrl + Alt + H 查看类的层次结构 Mac: Control + H Win/Linux: Ctrl + H 错误快捷提示 Mac/Win/Linux：Alt + Enter 快速跳转到父类 Mac: Cmd + U Win/Linux: Ctrl + U 快速跳转到实现 Mac: Cmd + Option + B Win/Linux: Ctrl + Alt + B 显示当前类所有的方法 MAC: Cmd + F12 Win/Linux: Ctrl + F12 删除行 Mac: Cmd + Delete Win/Linux: Ctrl + Y 自动补全 Mac/Win/Linux: Enter/Tab 覆写或者实现方法 Mac: Control + O Win/Linux: Ctrl + O 生成默认方法 Mac: Cmd + N Win/Linux: Alt+Insert 内联 Mac: Cmd + Alt + N Win/Linux: Ctrl + Alt + N","link":"/2020/08/22/AndroidStudio/03-androidstudio-2/"},{"title":"图解多平台 AndroidStudio 技巧(一)","text":"好的 idea 能提高我们的工作效率，如果掌握一些快捷键，能帮我们从繁琐重复的工作中解放出来，写代码的效率就越高，接下来想分享一些实用的快捷键, 因为快捷键比较多，将会分为多篇文章。 图解多平台 AndroidStudio 技巧(一) 图解多平台 AndroidStudio 技巧(二) 软件环境: Mac/Win/Linux: 内置默认快捷键 AndroidStudio v4.1.1 不同的外接键盘使用下列快捷键，需要根据自己的键盘做相应的调整 参数提示如果某个方法参数超级长，你不知道参数是什么怎么办？我们可以使用下面快捷键 Mac: Cmd + P win/Linux: Ctrl + P 自动提取方法我们在优化代码的时候，会看见有臭有长的代码，而我们传统的做法是新建一个函数，把代码复制过去，这个过程可以用使用下面快捷键完成 Mac: Cmd + Alt + M Win/Linux: Ctrl + Alt + M 自动提取参数我们在开发过程中，发现函数用到的变量最好是当作参数传递进来比较好，如果手动修改要在每个添加函数的地方修改繁琐至极，下面的快捷键可以解放你 Mac: Cmd + Alt + P Win/Linux: Ctrl + Alt + P 当然如果只是想进行方法重载，在弹出的那个对话框里面打勾 自动生成变量 Mac: Cmd + Alt + V Win/Linux: Ctrl + Alt + V 搜索某个方法是否被调用我们在重构、优化或者阅读别人的代码，要知道某个方法被谁调用, 可以使用下面命令 Mac/Win/Linux: Alt + F7 重构快捷键我们在重构的时候，很多操作都可以使用快捷键来完成，但是重构的快捷键太多了，我们没有办法全部记住，有一个快捷键可以帮助我们 Mac : Ctrl + T Win/Linux: Ctrl + Alt + Shift + T 包裹代码 Mac: Cmd + Alt + T Win/Linux: Ctrl + Alt + T 批量重命名如果在开发过程中或者优化过程中，发现变量名字取的不好，或者单词拼写错误，需要修改用到的所有变量，下面这个快捷键可以解放你的双手 Mac/Win/Linux: shift + F6 查看方法调用层次结构有时候我们在阅读代码的时候，想知道一个方法的调用结构是怎么样的，下面的一个快捷键会帮助到你 Mac: Control + Option + H Win/Linux: Ctrl + Alt + H 查看类的层次结构在阅读源码的时候，想知道某个类的调用结构是怎么样的，可以使用下面的快捷键 Mac: Control + H Win/Linux: Ctrl + H 错误快捷提示在写代码的时候，可能会遇到idea给出的警告，下面的快捷键可以帮助你有效的解决警告 Mac/Win/Linux：Alt + Enter 汇总为了方便查看将上面的快捷键做一个汇总 说明 快捷键 参数提示 Mac: Cmd + P win/Linux: Ctrl + P 自动提取方法 Mac: Cmd + Alt + M Win/Linux: Ctrl + Alt + M 自动提取参数 Mac: Cmd + Alt + P Win/Linux: Ctrl + Alt + P 自动生成变量 Mac: Cmd + Alt + V Win/Linux: Ctrl + Alt + V 搜索某个方法是否被调用 Mac/Win/Linux: Alt + F7 重构快捷键 Mac : Ctrl + T Win/Linux: Ctrl + Alt + Shift + T 包裹代码 Mac: Cmd + Alt + T Win/Linux: Ctrl + Alt + T 批量重命名 Mac/Win/Linux: shift + F6 查看方法调用层次结构 Mac: Control + Option + H Win/Linux: Ctrl + Alt + H 查看类的层次结构 Mac: Control + H Win/Linux: Ctrl + H 错误快捷提示 Mac/Win/Linux：Alt + Enter 快速跳转到父类 Mac: Cmd + U Win/Linux: Ctrl + U 快速跳转到实现 Mac: Cmd + Option + B Win/Linux: Ctrl + Alt + B 显示当前类所有的方法 MAC: Cmd + F12 Win/Linux: Ctrl + F12 删除行 Mac: Cmd + Delete Win/Linux: Ctrl + Y 自动补全 Mac/Win/Linux: Enter/Tab 覆写或者实现方法 Mac: Control + O Win/Linux: Ctrl + O 生成默认方法 Mac: Cmd + N Win/Linux: Alt+Insert 内联 Mac: Cmd + Alt + N Win/Linux: Ctrl + Alt + N","link":"/2020/08/22/AndroidStudio/03-androidstudio-1/"},{"title":"获取视频截图","text":"最近在搞一个视频截图的功能，自己在探索过程中，看到很多各种各样的解法，走了很多弯路，为了避免做相同功能的朋友们走很多弯路，我把自己解决方案，及探索过程遇到的Bug记录下来 screenVideo是一个通用的视频截图工具，目前已经适配大部分机型，对于个别机型不能使用的欢迎issuses，Demo中的视频的url不可用，视频的url可以从任意视频网站找一个可以播放的视频地址，用火狐获取一下播放的URL,替换demo中的url即可 Github下载 最开始想的是直接用View截图的方式截取当前的视频，结果截取的来的图片是黑屏，附上View截图代码 public Bitmap convertViewToBitmap(View view){ view.destroyDrawingCache();//销毁旧的cache销毁，获取cache通常会占用一定的内存，所以通常不需要的时候有必要对其进行清理 view.setDrawingCacheEnabled(true);//cache开启 view.buildDrawingCache();//创建新的缓存,获取cache通常会占用一定的内存，所以通常不需要的时候有必要对其进行清理,在每次获取新的,先销毁旧的缓存 view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));//测量view Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache());//将缓存的view转换为图片 return bitmap;} 上面的方式只能对静态的View进行截图，但是动态的比如说视频，那么截出来的图片就是黑屏。用SurfaceView显示在线视频，然后通过上面截图方式，得到图片是黑屏，（关于黑屏的原因大家可以去网上搜索，可以得到你想要的答案，这里就不在说了）于是我就去谷歌，各大博客上寻求解决方案，发现Android提供了MediaMetadataRetriever这个类来获取缩放图，于是按照这个思路去搜索，发现可以通过获取能够获取当前播放的帧数，来进行截图，以下是我的最终解决方案 /** * 视频截图代码 * @param url 播放的url * @param width 生成图片的宽度 * @param height 生成图片的高度 * @param currentVideoTime 当前播放的播放的秒数 * @return */@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)private Bitmap createVideoThumbnail(String url, int width, int height,String currentVideoTime) { Bitmap bitmap = null; MediaMetadataRetriever retriever = new MediaMetadataRetriever(); int kind = MediaStore.Video.Thumbnails.MINI_KIND; try { if (Build.VERSION.SDK_INT &gt;= 14) {//Android4.0以上的设备,必须使用这种方式来设置源播放视频的路径 retriever.setDataSource(url, new HashMap&lt;String, String&gt;()); } else { retriever.setDataSource(url); } int millis = mMdeiaPlayer.getDuration(); Log.e(TAG, &quot;-----millis----&quot; + millis); int pro = mMdeiaPlayer.getCurrentPosition(); Log.e(TAG,&quot;-----pro----&quot;+pro); String timeString = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION); long time = Long.parseLong(timeString) * 1000; //获取总长度,这一句也是必须的 long d = time*pro/millis;//计算当前播放的帧数,来截取当前的视频 Log.e(TAG,&quot;---------&quot;+d); bitmap = retriever.getFrameAtTime(d, MediaMetadataRetriever.OPTION_CLOSEST_SYNC); if (kind == MediaStore.Images.Thumbnails.MICRO_KIND &amp;&amp; bitmap != null) { bitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height, ThumbnailUtils.OPTIONS_RECYCLE_INPUT); } } catch (IllegalArgumentException ex) { // Assume this is a corrupt video file } catch (RuntimeException ex) { // Assume this is a corrupt video file. } finally { try { retriever.release(); mMdeiaPlayer.start(); } catch (RuntimeException ex) { // Ignore failures while cleaning up. } } return bitmap;} Github下载地址 : https://github.com/hi-dhl/screenVideo bug及解决方案start called in state 404-05 10:58:14.169 2237-2237/demo.dhl.con.onlinevideo E/MediaPlayer: start called in state 404-05 10:58:14.169 2237-2237/demo.dhl.con.onlinevideo E/MediaPlayer: error (-38, 0)04-05 10:58:14.169 2237-2237/demo.dhl.con.onlinevideo E/MediaPlayer: Error (-38,0)04-05 10:58:14.176 2237-2250/demo.dhl.con.onlinevideo E/MediaPlayer: error (261, -1003)04-05 10:58:14.176 2237-2237/demo.dhl.con.onlinevideo E/MediaPlayer: Error (261,-1003) 可能由于的播放的文件错误，或者给的url地址不能播放，可以在浏览器中试一下。 start called in state 104-05 11:50:27.346 2038-2038/demo.dhl.con.onlinevideo E/MediaPlayer: start called in state 104-05 11:50:27.347 2038-2038/demo.dhl.con.onlinevideo E/MediaPlayer: error (-38, 0)04-05 11:50:27.367 2038-2050/demo.dhl.con.onlinevideo E/MediaPlayer: error (261, -1003)04-05 11:50:27.367 2038-2038/demo.dhl.con.onlinevideo E/MediaPlayer: Error (261,-1003) 原因： Streaming is Not supported before Android 3.0Please test in device having above 3.0 version 解决方案： 这是Android官网关于，Android所支持的网络协议网络协议 音频和视频播放支持以下网络协议： RTSP协议（RTP，SDP的） HTTP / HTTPS的进步流 HTTP / HTTPS的现场直播议定书草案： MPEG-2 TS流媒体文件只 协议版本3（的Andr​​oid 4.0及以上） 议定书“第2版（Android的3.x版） 不支持之前的Andr​​oid 3.0 注： HTTPS不支持之前的Android 3.1，更换一台Android3.0以上的设备就好了 status=0x80000000java.io.IOException: setDataSource failed.: status=0x80000000 第一种解决方法 InputStream in = getResources().getAssets().open(&quot;GPSResp.dat&quot;); 第二种解决方案 将播放的视频或者音乐因为转换成Android所支持的格式下面是Android所支持的格式 static const char* kNoCompressExt[] = { &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.gif&quot;, &quot;.wav&quot;, &quot;.mp2&quot;, &quot;.mp3&quot;, &quot;.ogg&quot;, &quot;.aac&quot;, &quot;.mpg&quot;, &quot;.mpeg&quot;, &quot;.mid&quot;, &quot;.midi&quot;, &quot;.smf&quot;, &quot;.jet&quot;, &quot;.rtttl&quot;, &quot;.imy&quot;, &quot;.xmf&quot;, &quot;.mp4&quot;, &quot;.m4a&quot;, &quot;.m4v&quot;, &quot;.3gp&quot;, &quot;.3gpp&quot;, &quot;.3g2&quot;, &quot;.3gpp2&quot;, &quot;.amr&quot;, &quot;.awb&quot;, &quot;.wma&quot;, &quot;.wmv&quot;}; java.io.IOException: Prepare failed.: status=0x1MediaPlay播放视频的时候报下面的错 java.io.IOException: Prepare failed.: status=0x1 解决方案：把mediaPlayer.prepare;改成 mediaPlayer.prepareAsync(); getFrameAtTime: videoFrame is a NULL pointer播放视频的时候包下面的错误 getFrameAtTime: videoFrame is a NULL pointer 解决方案：视频地址错误，或者 视频损坏不能播放，检查视频是否正常 怎么样对播放的视频进行截图当我们使用SurfaceView的来显示播放的视频的时候，需要截取视频的时候，直接使用普通View获取截图的方式，会是黑屏，网上很多博客提到了解决方案mHolder.lockCanvas() 获取Canva来获取画布，实现截取视频，其实是错误的，我照着网上的贴子做了，报了下面的错，不知道是不是我的使用方法有错，请网友指正 12:58:24.690: E/BaseSurfaceHolder(719): Exception locking surface12:58:24.690: E/BaseSurfaceHolder(719): java.lang.IllegalArgumentException12:58:24.690: E/BaseSurfaceHolder(719): at android.view.Surface.nativeLockCanvas(Native Method)12:58:24.690: E/BaseSurfaceHolder(719): at android.view.Surface.lockCanvas(Surface.java:447)12:58:24.690: E/BaseSurfaceHolder(719): at com.android.internal.view.BaseSurfaceHolder.internalLockCanvas(BaseSurfaceHolder.java:184) 原因：SurfaceView 主要用来两种用法： 和MediaPlay配合使用播放视频， 或者和Canvas配合使用实现一些动画 但是不能这两种方法一起使用或者就会报上面的错。 解决方案：如果想要做视频截取的话，可以使用MediaMetadataRetriever这个类截取当前播放的帧画面，来是现实视频截图功能","link":"/2020/08/22/android/01-screenVideo/"},{"title":"再见吧 buildSrc, 拥抱 Composing builds 提升 Android 编译速度","text":"前言长期以来困扰我们的一个问题就是构建速度，AndroidStudio 的构建速度严重影响 Android 开发者的工作效率，尤其是更新一个版本号，导致整个项目重新构建，在网络慢的情况下，这是无法忍受的。 buildSrc 这种方式，在最近几年是非常流行的，因为它有以下优点： 共享 buildSrc 库工件的引用，全局只有一个地方可以修改它 支持 AndroidStudio 自动补全 支持 AndroidStudio 单击跳转 有优点的同时也有缺点，来看一下 Gradle 文档 A change in buildSrc causes the whole project to become out-of-date. Thus, when making small incremental changes, the –no-rebuild command-line option is often helpful to get faster feedback. Remember to run a full build regularly or at least when you’re done, though. buildSrc的更改会导致整个项目过时，因此，在进行小的增量更改时，– –no-rebuild命令行选项通常有助于获得更快的反馈。不过，请记住要定期或至少在完成后运行完整版本。 汇总一句话就是说，buildSrc 依赖更新将重新构建整个项目，那么有没有一种方法支持自动补全和单击跳转，有不用重新构建整个项目，Composing builds 就可以实现，接下来我们来演示一下 buildSrc 和 Composing builds 它们的 build 的时间，相关代码我已经上传到 GitHub 了：ComposingBuilds-vs-buildSrc 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 什么是 buildSrc？ 什么是 Composing builds？ 如何使用 Composing builds 和 buildSrc buildSrc 和 Composing builds 优势劣势对比？ Composing builds 编译速度怎么样？ buildSrc 如何迁移到 Composing builds？ 管理 Gradle 依赖都有那几种方式？以及效率怎么样？ 这篇文章涉及很多重要的知识点，请耐心读下去，我相信应该会给大家带来很多不一样的东西。 Composing builds 和 buildSrc 对比接下来我们来演示一下 buildSrc 和 Composing builds 它们的优势劣势对比，在分析之前，先来了解一下基本概念 什么是 buildSrc摘自 Gradle 文档：当运行 Gradle 时会检查项目中是否存在一个名为 buildSrc 的目录。然后 Gradle 会自动编译并测试这段代码，并将其放入构建脚本的类路径中, 对于多项目构建，只能有一个 buildSrc 目录，该目录必须位于根项目目录中, buildSrc 是 Gradle 项目根目录下的一个目录，它可以包含我们的构建逻辑，与脚本插件相比，buildSrc 应该是首选，因为它更易于维护、重构和测试代码 什么是 Composing builds摘自 Gradle 文档：复合构建只是包含其他构建的构建. 在许多方面，复合构建类似于 Gradle 多项目构建，不同之处在于，它包括完整的 builds ，而不是包含单个 projects 组合通常独立开发的构建，例如，在应用程序使用的库中尝试错误修复时 将大型的多项目构建分解为更小，更孤立的块，可以根据需要独立或一起工作 buildSrc vs Composing builds为了正确对比这两种方式，新建了两个空的项目分别是 Project-buildSrc 和 Project-ComposingBuild，这两个项目引用的依赖都是一样的，Project-buildSrc 包含 buildSrc，Project-ComposingBuild 包含 Composing builds。 Project-buildSrc 和 Project-ComposingBuild 它们的结构都差不多，接下来我们来看一下，编译速度 和 使用上有什么不同。 编译速度Project-buildSrc 和 Project-ComposingBuild 这两个项目，它们的 androidx.appcompat:appcompat 的版本是 1.0.2，现在我们从 1.0.2 升级到 1.1.0 来看一下它们 Build 的时间。 Project-buildSrc：修改了版本号 1.0.2 -&gt; 1.1.0 重新 Build 用时 37s Project-ComposingBuild：修改了版本号 1.0.2 -&gt; 1.1.0 重新 Build 用时 8s 当修改了版本号，Project-buildSrc 项目 Build 的时间几乎是 Project-ComposingBuild 项目的 4.6 倍（ PS: 每个人的环境不同，时间上会有差异，但是 Project-buildSrc 的时间总是大于 Project-ComposingBuild ） 在更大的项目中，网络慢的情况下，这种差异会更加明显，几分钟的构建都是常事，在 buildSrc 中做微小的更改，可能需要花很长时间构建，等待团队其他成员在他们提取更改之后，都将导致项目重新构建，这个代价是非常昂贵的。 它们在使用上有什么不同呢Project-buildSrc 在项目根目录下新建一个名为 buildSrc 的文件夹( 名字必须是 buildSrc，因为运行 Gradle 时会检查项目中是否存在一个名为 buildSrc 的目录 ) 在 buildSrc 文件夹里创建名为 build.gradle.kts 的文件，添加以下内容 plugins { `kotlin-dsl`}repositories{ jcenter()} 在 buildSrc/src/main/java/包名/ 目录下新建 Deps.kt 文件，添加以下内容 object Versions { ...... val appcompat = &quot;1.1.0&quot; ......}object Deps { ...... val appcompat = &quot;androidx.appcompat:appcompat:${Versions.appcompat}&quot; ......} 重启你的 Android Studio，项目里就会多出一个名为 buildSrc 的 module，实现上面演示的效果 Project-ComposingBuild 新建的 module 名称 VersionPlugin 需要注意 VersionPlugin 不能放在 Project 目录下，否则会抛出以下异常 Project directory '/Users/username/Downloads/ComposingBuilds-vs-buildSrc/Project-ComposingBuild/versionPlugin' is not part of the build defined by settings file '/Users/username/Downloads/ComposingBuilds-vs-buildSrc/Project-ComposingBuild/settings.gradle'. If this is an unrelated build, it must have its own settings file. 正确的应该将 VersionPlugin 放到和 Project 同级目录，或者 Project 以外的其他的地方，如下图所示 在 VersionPlugin 文件夹下的 build.gradle 文件内，添加以下内容 buildscript { repositories { jcenter() } dependencies { // 因为使用的 Kotlin 需要需要添加 Kotlin 插件 classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.72&quot; }}apply plugin: 'kotlin'apply plugin: 'java-gradle-plugin'repositories { // 需要添加 jcenter 否则会提示找不到 gradlePlugin jcenter()}gradlePlugin { plugins { version { // 在 app 模块需要通过 id 引用这个插件 id = 'com.hi.dhl.plugin' // 实现这个插件的类的路径 implementationClass = 'com.hi.dhl.plugin.Deps' } }} 在 VersionPlugin/src/main/java/包名/ 目录下新建 Deps.kt 文件，添加以下内容 class Deps : Plugin&lt;Project&gt; { override fun apply(project: Project) { } companion object { val appcompat = &quot;androidx.appcompat:appcompat:1.1.0&quot; }} 在 settings.gradle 文件内添加 includeBuild '../VersionPlugin' 重启你的 Android Studio 在 app 模块 build.gradle 文件内首行添加以下内容，就可以实现上面演示的效果 plugins{ // 这个 id 就是在 VersionPlugin 文件夹下 build.gradle 文件内定义的 id id &quot;com.hi.dhl.plugin&quot;} ps：plugins{} 需要放在 app 模块 build.gradle 文件内首行位置 Project-ComposingBuild 比 Project-buildSrc 多了两步操作需要在 settings.gradle 和 build.gradle 引入插件，两者在使用都是差不多的 如何快速使用 buildSrc 访问 ComposingBuilds-vs-buildSrc 拷贝 buildSrc 文件夹到你的项目的根目录 重启你的 Android Studio，项目里就会多出一个名为 buildSrc 的 module 如何快速使用 Composing builds 访问 ComposingBuilds-vs-buildSrc 拷贝 VersionPlugin 文件夹，放到和 Project 同级目录，或者 Project 以外的其他的地方 按照上面的配置方式，分配在 settings.gradle 和 app 模块的 build.gradle 引用插件即可 总结总共从以下几个方面对比了 Composing builds 和 buildSrc 目录结构：它们的基本目录结构是相同的，可以根据自己的项目进行不同的扩展 编译速度：当修改了版本号，Project-buildSrc 项目 Build 的时间几乎是 Project-ComposingBuild 项目的 4.6 倍（ PS: 每个人的环境不同，时间上会有差异，但是 Project-buildSrc 的时间总是大于 Project-ComposingBuild ） 使用上的区别：Composing builds 比 buildSrc 多了两步操作需要在 settings.gradle 和 build.gradle 引入插件 Project-buildSrc 和 Project-ComposingBuild 相关代码已经上传到 GitHub 了：ComposingBuilds-vs-buildSrc 到目前为止大概管理 Gradle 依赖提供了 4 种不同方法： 手动管理 ：在每个 module 中定义插件依赖库，每次升级依赖库时都需要手动更改（不建议使用） 使用 ext 的方式管理插件依赖库 ：这是 Google 推荐管理依赖的方法 Android官方文档 Kotlin + buildSrc：自动补全和单击跳转，依赖更新时 将重新 构建整个项目 Composing builds：自动补全和单击跳转，依赖更新时 不会重新 构建整个项目 buildSrc 如何迁移到 Composing builds？ 如果当前项目使用的是 buildSrc 方式，迁移到 Composing builds 很简单，需要将 buildSrc 内容拷贝的 Composing builds 中，然后删掉 buildSrc 文件夹就可以即可 参考文献 Organizing Gradle Projects Composing builds Android官方文档，使用 ext 的方式管理插件依赖库","link":"/2020/08/22/android/02-composing-builds/"},{"title":"「译」Kotlin 新秀 Coil、Glide 和 Picasso 大比拼","text":"前言 原标题: Coil vs Picasso vs Glide: Get Ready… Go! 原地址: https://proandroiddev.com/coil-vs-picasso… 原作者：Miguel Ángel Ruiz López 译者：hi-dhl 本文已收录于仓库 Technical-Article-Translation Coil 作为图片加载库的新秀，和 Glide、Picasso 这些老牌图片库相比，它们的优缺点是什么以及 Coil 未来的展望？先来了解一下什么是 Coil。 Coil 是基于 Kotlin 开发的首个图片加载库，来自 Instacart 团队，来看看官网对它的最新的介绍。 R8：Coil 下完全兼容 R8，所以不需要添加任何与 Coil 相关的混淆器规则。 Fast：Coil 进行了许多优化，包括内存和磁盘缓存，对内存中的图片进行采样，重新使用位图，自动暂停/取消请求等等。 Lightweight：Coil 为你的 APK 增加了 2000 个方法(对于已经使用了 OkHttp 和协程的应用程序)，这与 Picasso 相当，明显少于 Glide 和 Fresco。 Easy to use：Coil 利用了 Kotlin 的语言特性减少了样版代码。 Modern：使用了大量的高级特性，例如协程、OkHttp、和 androidX lifecycle 跟踪生命周期状态的，Coil 是目前唯一支持 androidX lifecycle 的库。 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 Kotlin 如何使用一行代码交换两个变量? Coil 和 Glide 和 Picasso 比较，它们优缺点是什么？ Kotlin 作为 Android 开发的首选语言，我们该如何进行选择 Coil、Glide 和 Picasso？ 如何在项目中使用 Coil？ Coil、Glide 和 Picasso 使用上大比拼？ Coil 的动态图片采样是什么？ 文章表格中出现的数字，可能很难理解，为了更好地理解，在最后的部分，会以柱状图清晰的展示每个库的性能的对比，全文分为 译文 和 译者思考 两个部分，在译者思考部分会更深入的分析这三个图片加载库的性能。 译文Coil 作为图片库的新秀，越来越受欢迎了，但是为什么会引起这么多人的关注？在当今主流的图片加载库环境中 Coil 是一股清流，它是轻量级的，因为它使用了许多 Android 开发者已经在他们的项目中包含的其他库（协程、Okhttp）。 当我第一次看到这个库时，我认为这些都是很好的改进，但是我很想知道和其他主流的图片加载库相比，这个库能带来哪些好处，这篇文章的主要目的是分析一下 Coil 的性能，接下来我们来对比一下 Coil、 Glide 和 Picasso。 我们如何测量为了弄清楚这些库的性能如何，我们分别用它们实现了一个应用程序，这是一个简单的应用程序，它下载 10 张图片并以网格布局显示它们，如下图所示。 所有图片都是在同一时间可见的，几乎是在同一时间被请求的，因此，可以认为它们是并行加载。 测试加载每张图片所需的时间：为了获得更准确的数据，图片被下载了十次将取平均值。 计算加载图片列表所需的时间：这个数字很重要，因为图片是并行加载的，所以不能从单个图片推断。这个测试也做了十次测试将取平均值。 另一个需要测试的重要点是第一次加载图片和从缓存中加载它们所花费的时间，已经进行了多次测试，覆盖了上面的场景。 从网络下载我们开始第一个场景，当缓存为空时，从网络中下载图片。 Glide 在下面的表中，您可以看到当缓存为空时，从网络中下载图片所用的时间。注意，这些时间是测试 10 次之后的平均值。 下表展示了加载完整的图片列表所需的时间，以及平均时间。 Picasso Picasso 的测试和 Glide 相同，当缓存为空时，从网络中下载图片，测试 10 次左右所用的时间的平均值。 以及加载完整的图片列表所需要的时间，以及平均时间。 Coil 现在来看一下今天主角 Coil ，和 Picasso、Glide 做相同的测试，当缓存为空时，从网络下载 10 次左右所用的时间的平均值。 以及加载完整的图片列表所需的时间，以及平均时间。 从缓存中加载现在开始另外一个场景测试，当缓存不为空时，加载图片所需要的时间。 Glide 从缓存中加载图片所用时间，如下表所示。 从缓存中加载完整的图片列表所需的时间，以及平均时间。 Picasso 测试用例和 Glide 相同，从缓存中加载图片所用时间，如下表所示。 以及从缓存中加载完整的图片列表所需的时间，以及平均时间。 Coil 最后我们来看一下 Coil 如何呢，从缓存中加载图片所用时间，如下表所示。 同样的从缓存中加载完整的图片列表所需的时间，以及平均时间。 结论为了更好地理解我们在测试中得到的结果，我们可以从下面图表中看到这些数字，反应了从网络下载每个图片时的结果。 Glide 最快 Picasso 和 Coil 几乎相同。 但是当我们从缓存中加载的时候，正如你在下面的图片中看到的，在大多数情况下，Glide 最快，Coil 其次，Picasso 最慢。 另一个重要的测试加载完整的图片列表所花费的时间，这些数字非常重要，因为这是用户等待看到整个图片列表的时间。当图片从网络加载时，Glide 是最快的，其次是Picasso，Coil是最慢的。 从缓存加载的结果是不同的。Glide 和 Coil 几乎相同，Picasso 是最慢的。 从这些数字中我们可以得出几个结论： 有许多场景需要测试，例如，下载大图片，调整图片大小以适应容器等等。因此，我不能说其他情况下的结果可能会有很大的不同。 正如您所看到的，统计数据是一门包含大量数据的科学，因此对每个场景进行 10 次测试不足以具体的说明那个库最好，但是我们可以粗略地了解性能。 Glide 似乎在大多数情况下更快，但数量一般不是很大情况。如果你需要很好地执行，或者你正在下载很多图片，这可能对你来说是非常有用。此外，如果我们使用大图片，这些测试的结果可能会改变。 Coil 作为图片加载库的新秀，未来它的性能可能会有很大提高，现在只是我们将它与成熟的图片加载库进行比较的结果。 译者思考作者从以下场景对 Coil、Glide、Picasso 做了全面的测试。 当缓存为空时，从网络中下载图片的平均时间。 从网络中下载图片所用的时间。结果：Glide 最快 Picasso 和 Coil 几乎相同。 加载完整的图片列表所用的时间，以及平均时间。结果：Glide 是最快的，其次是Picasso，Coil是最慢的。 当缓存不为空时，从缓存中加载图片的平均时间。 从缓存中加载图片所用的时间。结果：Glide 最快，Coil 其次，Picasso 最慢。 加载完整的图片列表所用的时间，以及平均时间。结果：Glide 和 Coil 几乎相同，Picasso 是最慢的。 图片加载库的选择是我们应用程序中最重要的部分之一，根据以上结果，如果你的应用程序中没有大量使用图片的时候，我认为使用 Coil 更好，原因有以下几点： 与 Glide 和 Fresco 类似，Coil 支持位图池，位图池是一种重新使用不再使用的位图对象的技术，这可以显著提高内存性能(特别是在oreo之前的设备上)，但是它会造成一些 API 限制。 Coil 是基于 Kotlin 开发的，为 Kotlin 使用而设计的，所以代码通常更简洁更干净。 Kotlin 作为 Android 首选语言，Coil 是为 Kotlin 而设计的，Coil 在未来肯定会大方光彩。 从 Glide、Picasso 迁移到 Coil 是非常的容易，API 非常的相似。 Coil 支持 androidX lifecycle 跟踪生命周期状态，也是是目前唯一支持 androidX lifecycle 的网络图片加载库。 Coil 支持动态图片采样，假设本地有一个 500x500 的图片，当从磁盘读取 500x500 的映像时，我们将使用 100x100 的映像作为占位符。 如果你的是图片类型的应用，应用程序中包含了大量的图片，图片加载的速度是整个应用的核心指标之一，那么现在还不适合使用 Coil。 Coil 涵盖了 Glide、Picasso 等等图片加载库所支持的功能，除此之外 Coil 还有一个功能 动态图片采样。 动态图片采样更多关于图片采样信息可以访问 Coil ，这里简单的说明一下，假设本地有一个 500x500 的图片，当从磁盘读取 500x500 的图片时，将使用 100x100 的映像作为占位符，等待加载完成之后才会完全显示，用官方的一张动图显示过程如下。 这种淡入动画效果，在视觉上体验非常舒适，占位符在主线程上设置，这样可以防止在 ImageView 为空的情况下出现白色闪烁，接下来让我们来看看如何使用 Coil？Coil、Glide 和 Picasso 使用上大比拼？ 如何使用 Coil添加 Coil 依赖 implementation &quot;io.coil-kt:coil:0.11.0&quot; 在 App moudule 下 build.gradle 文件中添加如下代码 kotlinOptions { jvmTarget = &quot;1.8&quot;} 在项目中调用你需要的代码，这里汇总了 Coil 所有使用方式 // 将图片加载到 ImageView 中, 并开启图片采样// 用到了 Kotlin 的高级特性扩展，调用更加简单imageView.load(&quot;https://www.example.com/image.jpg&quot;){ crossfade(true)}inline fun ImageView.load( uri: String?, imageLoader: ImageLoader = Coil.imageLoader(applicationContext), builder: LoadRequestBuilder.() -&gt; Unit = {}): RequestDisposable { return imageLoader.load(context, uri) { target(this@load) builder() }}// Coil 支持 Uri,File, String,HttpUrl, Bitmap, Drawable, DrawableIdimageView.load(R.drawable.ic_launcher_background)imageView.load(File(&quot;/path/to/image.jpg&quot;))imageView.load(&quot;content://com.android.externalstorage/image.jpg&quot;)// ......// Coil 提供了四种转换: 模糊，圆形剪裁，灰度和圆角imageView.load(&quot;https://www.example.com/image.jpg&quot;) { crossfade(true) placeholder(R.drawable.ic_launcher_background) transformations(CircleCropTransformation())}// Coil 是一个 object 单例val imageLoader1 = Coil.imageLoader(applicationContext)// 可以创建 或者 调用第三方库(Koin) 注入自己的实例。val imageLoader2 = ImageLoader(applicationContext)// 在某些情况下，需要远程下载然后进行回调var request = LoadRequest.Builder(applicationContext) .data(&quot;https://www.example.com/image.jpg&quot;) .target { drawable -&gt; // Handle the successful result. } .build()imageLoader2.execute(request) Coil、Glide 和 Picasso 使用上大比拼Coil 基于 Kotlin 而设计，自然也拥有了 Kotlin 的高级函数的特性，使用比 Glide 和 Picasso 要简单很多。 基本使用 // Coil - 用到了 Kotlin 的高级特性扩展，一行代码加载图片imageView.load(url)// GlideGlide.with(context) .load(url) .into(imageView)// PicassoPicasso.get() .load(url) .into(imageView) 后台线程 // Coil：无阻塞和线程安全val imageLoader = Coil.imageLoader(context)val request = GetRequest.Builder(context) .data(url) .size(width, height) .build()val drawable = imageLoader.execute(request).drawable// Glide：阻塞当前线程，一定不能从主线程调用val drawable = Glide.with(context) .load(url) .submit(width, height) .get()// Picasso：阻塞当前线程，一定不能从主线程调用val drawable = Picasso.get() .load(url) .resize(width, height) .get() 自动检测 scaleType imageView.scaleType = ImageView.ScaleType.FIT_CENTER// Coil：自动检测 scaleTypeimageView.load(url) { placeholder(placeholder)}// GlideGlide.with(context) .load(url) .placeholder(placeholder) .fitCenter() .into(imageView)// PicassoPicasso.get() .load(url) .placeholder(placeholder) .fit() .into(imageView) Coil 实战Jetpack 实战项目 PokemonGo（神奇宝贝）基于 MVVM 架构和 Repository 设计模式开发的一个小型的 App 项目，涉及到技术：Paging3（network + db），Dagger-Hilt，App Startup，DataBinding，Room，Motionlayout，Kotlin Flow，Coil 等等。 在这个项目中加载图片使用了 Coil ，可以去下载体验一下。 仓库地址：https://github.com/hi-dhl/PokemonGo Kotlin 小技巧如何实现一行代码交换两个变量？我们先来回顾一下 JAVA 的做法 int a = 1;int b = 2;// JAVA - 中间变量int temp = a;a = b;b = temp;System.out.println(&quot;a = &quot;+a +&quot; b = &quot;+b); // a = 2 b = 1// JAVA - 加减运算a = a + b;b = a - b;a = a - b;System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b); // a = 2 b = 1 // JAVA - 位运算a = a ^ b;b = a ^ b;a = a ^ b;System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b); // a = 2 b = 1// Kotlina = b.also { b = a }println(&quot;a = ${a} b = ${b}&quot;) // a = 2 b = 1 参考文献 https://proandroiddev.com/coil…… https://tech.instacart.com/introducing-coil…… 推荐文章 [译][Google工程师] 刚刚发布了 Fragment 的新特性 “Fragment 间传递数据的新方式” 以及源码分析 [译][Google工程师] 详解 FragmentFactory 如何优雅使用 Koin 以及部分源码分析 [译][2.4K Start] 放弃 Dagger 拥抱 Koin [译][5k+] Kotlin 的性能优化那些事 [译] 解密 RxJava 的异常处理机制 [译][1.4K+ Star] Kotlin 新秀 Coil VS Glide and Picasso 更多……","link":"/2020/08/17/translate/06-coil-vs-glide-vs-picasso/"},{"title":"「译」你中招了吗？ Kotlin 一个隐藏的坑","text":"前言 原标题: A decompiled story of Kotlin let and run 原地址: https://dev.to/vlazdra/a-decompiled…… 原作者：Vladimir Zdravkovic 译者：hi-dhl 本文已收录于仓库 Technical-Article-Translation 之前我发表过几篇关于 Kotlin 性能损耗和 Kotlin 技巧方面的文章，如果没有了解过，可以点击下方链接前去查看，可以避免在实际开发中遇到重复的问题。 [译][2.4K Start] 放弃 Dagger 拥抱 Koin [译][5k+] Kotlin 的性能优化那些事 为数不多的人知道的 Kotlin 技巧以及 原理解析(一) 为数不多的人知道的 Kotlin 技巧以及 原理解析(二) 这篇文章主要来分析 Kotlin 另外一个隐藏的问题，文章将会分为 译文 和 译者思考 两部分，本文不仅仅是翻译，在 译者思考 部分会对译文进行总结以及更加深入的思考和分析，也可以跳过译文直接看 译者思考 部分。 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 使用 T.let 会遇到什么问题？ 为什么会造成这个问题？ 如何解决这个问题？ 为什么使用 T.apply 可以解决这个问题？ T.apply 和 T.let 有什么区别？ 如何区分 run, with, let, also, apply？ Kotlin 如何交换两个变量？ 这篇文章涉及很多重要的知识点，请耐心读下去，应该可以从中学到很多技巧。 译文前段时间，我花了不少时间，为了弄清楚一个简单的 Kotlin 代码块 let 和 run，为什么不想做我想让它做的事，经过无数次重写我的代码之后，我认为这一定是我自己的错误，最后为了搞清楚 Kotlin 语法糖背后发生了什么，最后我决定花点时间深入研究生成的代码。 let 和 run 是 Kotlin 标准库当中的内联函数，我认为它们的工作的方式与经典的 if ... else ... 语句类似，所以我一直在项目中这么使用它们，直到我在一个项目中为了实现某个功能的时候，遇到了一个隐藏的问题，让我们看看问题是什么。 这是一个很简单的 Kotlin 代码，它有两个可空的变量，其中一个已经有值，如果我调用 doSomeAwesomePrinting() 方法，你认为控制台会输出什么？ 你可能会和我一样认为什么都不会输出，可是… 错了，最后会输出 “awesome output 1”。 为什么会这样？我们来看一下反编译后的代码，发生了什么。 正如你所见，当第二个变量 awesomeVar2 为空时，Kotlin 自动生成的变量 var10000 也为空，所以程序不会执行 return 语句，函数执行到最后会输出 ”awesome output 1“。 让我们来看看另外一个例子，在这个例子中，我们对上面 Kotlin 代码做一些更改，在第二个变量上添加 elvis 操作符，代码如下所示。 如果再次调用 doSomeAwesomePrinting() 方法则会输出 “awesome output 3”，这次的修改已完成了想要做的事情，与经典的 if ... else ... 语句类似，我们来看一下反编译后的代码。 正如你所见，反编译后的代码其实就是 if ... else ... 语句，当第二个变量为空时则输出 “awesome output 3”， 现在来分析一下如何解决文章开头提出来的问题。 解决方案 感谢 Danny 的建议，其实可以用 Kotlin 另外的一个内联函数 apply 来解决这个问题。 接下来按照 Danny 的建议，使用 Kotlin 另外一个内联函数 apply，看看会发生什么。 和我们所期望的一样，当第二个变量为空时，控制台什么都不会输出，你可以试一下，接下来我们来分析一下反编译后的代码。 正如你所看到的，Kotlin 自动生成的变量 var1 不为空，当第二个变量 awesomeVar2 为空时，直接 return 了。 最后我们对上面 Kotlin 代码，在 apply 的基础上，做一点一点修改，在第二个变量上添加 elvis 操作符如下所示。 运行代码之后，当第二个变量为空时，控制台将会输出 “awesome output 3” ，为了能够理解这里发生了什么，我们来看一下反编译后的代码。 生成的代码比之前多了很多，但是不影响我们正常分析，和我们预期的一样，控制台将输出 “awesome output 3” 译者思考接下来是译者思考部分，按照之前的风格，我们先对译文进行总结，然后在进行分析。 总结和分析使用 T.let 会遇到了什么问题？ Kotlin 标准库当中的内联函数 T.let 和 T.run 等等，它们的工作的方式与 if ... else ... 语句类似，从反编译后的代码可知其实就是 if ... else ... 语句，所以我们可能会认为运行下面的代码和 if ... else ... 语句一样不会有任何输出。 class ExampleClass { var awesomeVar1: String? = &quot;some awesome string value&quot; var awesomeVar2: String? = null fun doSomeAwesomePrinting() { awesomeVar1?.let { awesomeVar2?.let { println(&quot;awesome output 2&quot;) } } ?: run { println(&quot;awesome output 1&quot;) } }} 但是结果却出人意料，当第二个变量为空时，居然输出 “awesome output 1”，大家可以反编译上面的代码看一下，会更加清楚其内部逻辑。 为什么会造成这个问题？ 我们来看一下 Kotlin 内联函数 T.let 的源码实现。 public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block(this)} 正如你所看到的 T.let 接受的参数是 it, 它返回最后一行，接下来我们将源代码拆解一下，可能会更清楚发生了什么。 fun doSomeAwesomePrinting() { awesomeVar1?.let { // 将 awesomeVar2?.let{...} 的结果作为 awesomeVar1?.let{...} 的返回值 // 所以当 awesomeVar2 为空时，awesomeVar2?.let{...} 的结果为空 // 函数最后会输出 &quot;awesome output 1&quot; awesomeVar2?.let { println(&quot;awesome output 2&quot;) } } ?: run { println(&quot;awesome output 1&quot;) }} 将 awesomeVar2?.let{...} 的结果作为 awesomeVar1?.let{...} 的返回值 当 awesomeVar2 为空时，awesomeVar2?.let{...} 的结果为空 函数最后会输出 “awesome output 1” 如何解决这个问题？ 解决方案也很简单使用另外一个 Kotlin 内联函数 T.apply，代码如下所示。 class ExampleClass { var awesomeVar1: String? = &quot;some awesome string value&quot; var awesomeVar2: String? = null fun doSomeAwesomePrinting() { awesomeVar1?.apply { awesomeVar2?.apply { println(&quot;awesome output 2&quot;) } } ?: run { println(&quot;awesome output 1&quot;) } }} 使用 Kotlin 另外一个内联函数 T.apply 之后，结果和我们所预期的一样，这里什么都不会输出，那么为什么使用 T.apply 可以解决这个问题？T.apply 和 T.let 有什么区别呢？ 为什么使用 T.apply 可以解决这个问题？ 我们来看一下 Kotlin 内联函数 T.apply 的源码实现。 public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } block() return this} T.apply 函数是一个扩展函数，返回值是它本身，并且接受的参数是 this，接下来我们将源代码拆解进行分析。 fun doSomeAwesomePrinting() { awesomeVar1?.apply { // awesomeVar1?.apply{...} 的返回值是它本身，awesomeVar1 不为空 // 所以当 awesomeVar2 为空时，什么都不会输出 awesomeVar2?.apply { println(&quot;awesome output 2&quot;) } // awesomeVar2?.apply{...} 返回值是 awesomeVar2 } ?: run { println(&quot;awesome output 1&quot;) }} 根据 T.apply 函数特性，awesomeVar1?.apply{...} 的返回值是它本身，变量 awesomeVar1不为空 当 awesomeVar2 为空时，并不会影响到 awesomeVar1?.apply{...} 的结果，所这里什么都不会输出 T.apply 和 T.let 有什么区别？ 函数 是否是扩展函数 函数参数(this、it) 返回值(调用本身、最后一行) T.let 是 it 最后一行 T.apply 是 this 调用本身 除了 T.apply 和 T.let 之外，Kotlin 还有很多其他内联函数例如 T.run 、T.also、with 等等，虽然操作符不多，但是想要分清楚这些操作符确实有些困难，所以我将会介绍一种简单的方法来区分它们以及如何使用。 如何区分 run, with, let, also, apply感谢大神 Elye 的这篇文章提供的思路 Mastering Kotlin standard functions。 关于如何区分 run, with, let, also, apply 我在之前的文章 为数不多的人知道的 Kotlin 技巧以及 原理解析 中有介绍，这里我们在回顾一下。 run, with, let, also, apply 是 Kotlin 的内联函数，也是作用域函数，这些作用域函数如何使用，以及如何区分呢，我们将从以下三个维度来区分它们。 是否是扩展函数。 作用域函数的参数（this、it）。 作用域函数的返回值（调用本身、其他类型即最后一行）。 是否是扩展函数首先我们来看一下 with 和 T.run，这两个函数非常的相似，他们的区别在于 with 是个普通函数，T.run 是个扩展函数，来看一下下面的例子。 val name: String? = nullwith(name){ val subName = name!!.substring(1,2)}// 使用之前可以检查它的可空性name?.run { val subName = name.substring(1,2) }?:throw IllegalArgumentException(&quot;name must not be null&quot;) 在这个例子当中，name?.run 会更好一些，因为在使用之前可以检查它的可空性。 作用域函数的参数（this、it）我们在来看一下 T.run 和 T.let，它们都是扩展函数，但是他们的参数不一样，T.run 的参数是 this, T.let 的参数是 it。 val name: String? = &quot;hi-dhl.com&quot;// 参数是 this，可以省略不写name?.run { println(&quot;The length is ${this.length} this 是可以省略的 ${length}&quot;)}// 参数 itname?.let { println(&quot;The length is ${it.length}&quot;)}// 自定义参数名字name?.let { str -&gt; println(&quot;The length is ${str.length}&quot;)} 在上面的例子中似乎 T.run 会更好，因为 this 可以省略，调用更加的简洁，但是 T.let 允许我们自定义参数名字，使可读性更强，如果倾向可读性可以选择 T.let。 作用域函数的返回值（调用本身、其他类型即最后一行）接下里我们来看一下 T.let 和 T.also 它们接受的参数都是 it, 但是它们的返回值是不同的，T.let 返回的是最后一行，T.also 返回调用者本身。 var name = &quot;hi-dhl&quot;// 返回调用本身name = name.also { val result = 1 * 1 &quot;juejin&quot;}println(&quot;name = ${name}&quot;) // name = hi-dhl// 返回的最后一行name = name.let { val result = 1 * 1 &quot;hi-dhl.com&quot;}println(&quot;name = ${name}&quot;) // name = hi-dhl.com 从上面的例子来看 T.also 似乎没有什么意义，细想一下其实是非常有意义的，在使用之前可以进行自我操作，结合其他的函数，功能会更强大。 fun makeDir(path: String) = path.let{ File(it) }.also{ it.mkdirs() } 当然 T.also 还可以做其他事情，比如利用 T.also 在使用之前可以进行自我操作特点，可以实现一行代码交换两个变量，在后面会有详细介绍 T.apply 函数通过上面的分析，大致了解了函数的行为，接下来看一下 T.apply 函数，T.apply 函数是一个扩展函数，返回值是它本身，并且接受的参数是 this。 // 普通方法fun createInstance(args: Bundle) : MyFragment { val fragment = MyFragment() fragment.arguments = args return fragment}// 改进方法fun createInstance(args: Bundle) = MyFragment().apply { arguments = args } // 普通方法fun createIntent(intentData: String, intentAction: String): Intent { val intent = Intent() intent.action = intentAction intent.data=Uri.parse(intentData) return intent}// 改进方法，链式调用fun createIntent(intentData: String, intentAction: String) = Intent().apply { action = intentAction } .apply { data = Uri.parse(intentData) } 使用 T.also 函数交换两个变量接下来演示的是使用 T.also 函数，实现一行代码交换两个变量？我们先来回顾一下 Java 的做法。 int a = 1;int b = 2;// Java - 中间变量int temp = a;a = b;b = temp;System.out.println(&quot;a = &quot;+a +&quot; b = &quot;+b); // a = 2 b = 1// Java - 加减运算a = a + b;b = a - b;a = a - b;System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b); // a = 2 b = 1 // Java - 位运算a = a ^ b;b = a ^ b;a = a ^ b;System.out.println(&quot;a = &quot; + a + &quot; b = &quot; + b); // a = 2 b = 1// Kotlina = b.also { b = a }println(&quot;a = ${a} b = ${b}&quot;) // a = 2 b = 1 一起来分析 T.also 是如何做到的，其实这里用到了 T.also 函数的两个特点。 调用 T.also 函数返回的是调用者本身。 在使用之前可以进行自我操作。 也就是说 b.also { b = a } 会先将 a 的值 (1) 赋值给 b，此时 b 的值为 1，然后将 b 原始的值（2）赋值给 a，此时 a 的值为 2，实现交换两个变量的目的。 汇总为了更方便的理解和记忆，接下来我以表格的形式将上面的内容进行汇总，具体还需要有结合实际项目去使用。 函数 是否是扩展函数 函数参数(this、it) 返回值(调用本身、最后一行) with 不是 this 最后一行 T.run 是 this 最后一行 T.let 是 it 最后一行 T.also 是 it 调用本身 T.apply 是 this 调用本身 全文到这里就结束了，大家可以在项目中灵活的去运用，可以让代码的可读性更高，如果你在 Kotlin 中遇到了那些坑，欢迎在评论区分享，更多优秀的英文技术文章，点击这里 精选译文 更多关于 Kotlin 的内联函数 run, with, let, also, apply 在实际项目中的使用，可以看我另外一个项目 PokemonGo ，基于 Jetpack + MVVM + Repository + Data Mapper + Kotlin Flow + Kotlin 技巧的实战项目，可以点击下面链接前去查看。 PokemonGo 仓库地址：https://github.com/hi-dhl/PokemonGo 推荐文章 [译][Google工程师] 刚刚发布了 Fragment 的新特性 “Fragment 间传递数据的新方式” 以及源码分析 [译][Google工程师] 详解 FragmentFactory 如何优雅使用 Koin 以及部分源码分析 [译][2.4K Start] 放弃 Dagger 拥抱 Koin [译][5k+] Kotlin 的性能优化那些事 [译] 解密 RxJava 的异常处理机制 [译][1.4K+ Star] Kotlin 新秀 Coil VS Glide and Picasso 更多……","link":"/2020/08/17/translate/07-kotlin-let-run/"},{"title":"「译」解密 RxJava 的异常处理机制","text":"前言 原标题: Beyond Basic RxJava Error Handling 原地址: https://proandroiddev.com/beyond-basic…… 原作者：Elye 译者：hi-dhl 本文已收录于仓库 Technical-Article-Translation 今天看到一篇大神 Elye 关于 RxJava 异常的处理的文章，让我对 RxJava 异常的处理有了一个清晰的了解，用了 RxJava 很久了对里面的异常处理机制一直很懵懂。 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 just 和 fromCallable 区别？ 什么是 RxJavaPlugins.setErrorHandler？ Crashes 发生在 just() 中的处理方案？ Crashes 发生在 subscribe success 中的处理方案？ Crashes 发生在 subscribe error 中的处理方案？ Crashes 发生在 complete 中的处理方案？ Crashes 发生在 complete 之前的处理方案？ 这篇文章涉及很多重要的知识点，请耐心读下去，应该可以从中学到很多技巧。 译文大部分了解 RxJava 的人都会喜欢它，因为它能够封装 onError 回调上的错误处理，如下所示： Single.just(getSomeData()) .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; handleResult(result) }, { error -&gt; handleError(error) } // Expect all error capture ) 你可能会以为所有的 Crashes 都将调用 handleError 来处理，但其实并全都是这样的 Crashes 发生在 just() 中我先来看一个简单的例子，假设 crashes 发生在 getSomeData() 方法内部 Single.just(getSomeData() /**🔥Crash🔥**/ ) .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; handleResult(result) }, { error -&gt; handleError(error) } // Crash NOT caught ⛔️ 这个错误将不会在 handleError 中捕获，因为 just() 不是 RxJava 调用链的一部分，如果你想捕获它，你可能需要在最外层添加 try-catch 来处理，如下所示： try { Single.just(getSomeData() /**🔥Crash🔥**/ ) .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; handleResult(result) }, { error -&gt; handleError(error) } // Crash NOT caught ⛔️ )} catch (exception: Exception) { handleError(exception) // Crash caught ✅} 如果你不使用 just ，而是使用 RxJava 内部的一些东西，例如 fromCallable，错误将会被捕获 Single.fromCallable{ getSomeData() /**🔥Crash🔥**/ } .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; handleResult(result) }, { error -&gt; handleError(error) } // Crash caught ✅ ) Crashes 发生在 subscribe success 中让我们来假设一下 Crashes 出现在 subscribe success 中，如下所示 Single.just(getSomeData() ) .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; handleResult(result) /**🔥Crash🔥**/ }, { error -&gt; handleError(error) } // Crash NOT caught ⛔️ ) 这个错误将不会被 handleError 捕获，奇怪的是，如果我们将 Single 换成 Observable，异常就会被捕获，如下所示： Observable.just(getSomeData() ) .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; handleResult(result) /**🔥Crash🔥**/ }, { error -&gt; handleError(error) }, // Crash caught ✅ { handleCompletion() } ) 原因是在 Single 中成功的订阅被认为是一个完整的流。因此，错误不再能被捕获。而在 Observable 中，它认为 onNext 需要处理，因此 crash 仍然可以被捕获，那么我们应该如何解决这个问题呢 错误的处理方式，像之前一样，在最外层使用 try-catch 进行异常捕获 try { Single.just(getSomeData()) .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; handleResult(result)/**🔥Crash🔥**/ }, { error -&gt; handleError(error) } // Crash NOT caught ⛔️ )} catch (exception: Exception) { handleError(exception) // Crash NOT caught ⛔️} 但是这样做其实异常并没有被捕获，crash 依然在传递，因为 RxJava 在内部处理了 crash，并没有传递到外部 一种很奇怪的方式，在 subscribe successful 中，执行 try-catch Single.just(getSomeData() ) .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; try { handleResult(result) /**🔥Crash🔥**/ } catch (exception: Exception) { handleError(exception) // Crash caught ✅ } }, { error -&gt; handleError(error) }, // Crash NOT caught ⛔️ ) 这种方式虽然捕获住了这个异常，但是 RxJava 并不知道如何处理 一种比较好的方式 上文提到了使用 Single 在 subscribe successful 中不能捕获异常，因为被认为是一个完整的流，处理这个情况比较好的方式，可以使用 doOnSuccess 方法 Single.just(getSomeData() ) .map { item -&gt; handleMap(item) } .doOnSuccess { result -&gt; handleResult(result) /*🔥Crash🔥*/ }, } .subscribe( { /** REMOVE CODE **/ }, { error -&gt; handleError(error) } // Crash caught ✅ ) 当我们按照上面方式处理的时候，错误将会被 onError 捕获，如果想让代码更好看，可以使用 doOnError 方法，如下所示: Single.just(getSomeData() ) .map { item -&gt; handleMap(item) } .doOnSuccess { result -&gt; handleResult(result) /*🔥Crash🔥*/ }, } .doOnError { error -&gt; handleError(error) } // Crash NOT stop ⛔️ .subscribe() 但是这并没有完全解决 crash 问题，虽然已经捕获了但并没有停止，因此 crash 仍然发生。 更准确的解释，它实际上确实捕获了 crash，但是 doOnError 不是完整状态，因此错误仍应该在 onError 中处理，否则它会在里面 crash，所以我们至少应该提供一个空的 onError Single.just(getSomeData() ) .map { item -&gt; handleMap(item) } .doOnSuccess { result -&gt; handleResult(result) /*🔥Crash🔥*/ }, } .doOnError { error -&gt; handleError(error) } // Crash NOT stop ⛔️ .subscribe({} {}) // But crash stop here ✅ Crashes 发生在 subscribe error 中Single.just(getSomeData() ) .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; handleResult(result) }, { error -&gt; handleError(error) /**🔥Crash🔥**/ } ) 我们可以想到使用上文提到的方法来解决这个问题 Single.just(getSomeData() ) .map { item -&gt; handleMap(item) } .doOnSuccess { result -&gt; handleResult(result) }, } .doOnError { error -&gt; handleError(error) /*🔥Crash🔥*/ } .subscribe({} {}) // Crash stop here ✅ 尽管这样可以避免 crash ，但是仍然很奇怪，因为没有在 crash 时做任何事情，我们可以按照下面的方式，在 onError 中捕获异常，这是一种非常有趣的编程方式。 Single.just(getSomeData() ) .map { item -&gt; handleMap(item) } .doOnSuccess { result -&gt; handleResult(result) }, } .doOnError { error -&gt; handleError(error) /*🔥Crash🔥*/ } .subscribe({} { error -&gt; handleError(error) }) // Crash caught ✅ 不管怎么样这个方案是可行的，在这里只是展示如何处理，后面还会有很好的方式 Crashes 发生在 complete 中例如 Observable 除了 onError 和 onNext（还有类似于 Single 的 onSuccess）之外，还有onComplete 状态。 如果 crashes 发生在如下所示的 onComplete 中，它将不会被捕获。 Observable.just(getSomeData() ) .map { item -&gt; handleMap(item) } .subscribe( { result -&gt; handleResult(result) }, { error -&gt; handleError(error) }, // Crash NOT caught ⛔️ { handleCompletion()/**🔥Crash🔥**/ } ) 我们可以按照之前的方法在 doOnComplete 方法中进行处理，如下所示： Observable.just(getSomeData() ) .map { item -&gt; handleMap(item) } .doOnNext{ result -&gt; handleResult(result) } .doOnError{ error -&gt; handleError(error) } Crash NOT stop ⛔️ .doOnComplete { handleCompletion()/**🔥Crash🔥**/ } .subscribe({ }, { }, { }) // Crash STOP here ✅ 最终 crash 能够在 doOnError 中捕获，并在我们提供的最后一个空 onError 函数处停止，但是我们通过这种解决方法逃避了问题。 Crashes 发生在 complete 之前让我们看另一种有趣的情况，我们模拟一种情况，我们订阅的操作非常慢，无法轻易终止（如果终止，它将crash） val disposeMe = Observable.fromCallable { Thread.sleep(1000) } .doOnError{ error -&gt; handleError(error) } // Crash NOT caught ⛔️ .subscribe({}, {}, {}) // Crash NOT caught or stop ⛔️Handler().postDelayed({ disposeMe.dispose() }, 100) 我们在 fromCallable 中等待 1000 才能完成，但是在100毫秒，我们通过调用 disposeMe.dispose() 终止操作。 这将迫使 Thread.sleep（1000）在结束之前终止，从而使其崩溃，无法通过 doOnError 或者提供的 onError 函数捕获崩溃 即使我们在最外面使用 try-catch，也是没用的，也无法像其他所有 RxJava 内部 crash 一样起作用。 try { val disposeMe = Observable.fromCallable { Thread.sleep(1000) } .doOnError{} // Crash NOT caught ⛔️ .subscribe({}, {}, {}) // Crash NOT caught or stop ⛔️ Handler().postDelayed({ disposeMe.dispose() }, 100)} catch (exception: Exception) { handleError(exception) // Crash NOT caught too ⛔️} RxJava Crash 终极解决方案对于 RxJava 如果确实发生了 crash，但 crash 不在您的控制范围内，并且您希望采用一种全局的方式捕获它，可以用下面是解决方案。 RxJavaPlugins.setErrorHandler { e -&gt; handleError(e) } 注册 ErrorHandler 它将捕获上述任何情况下的所有 RxJava 未捕获的错误（ just() 除外，因为它不属于RxJava 调用链的一部分） 但是要注意用于调用错误处理的线程在 crash 发生的地方挂起，如果你想确保它总是发生在主UI线程上，用 runOnUiThread{ } 包括起来 RxJavaPlugins.setErrorHandler { e -&gt; runOnUiThread { handleError(e))}} 因此，对于上面的情况，由于在完成之前终止而导致 Crash，下面将对此进行处理。 RxJavaPlugins.setErrorHandler { e -&gt; handle(e) } // Crash caught ✅val disposeMe = Observable.fromCallable { Thread.sleep(1000) } .doOnError{ error -&gt; handleError(error) } // Crash NOT caught ⛔️ .subscribe({}, {}, {}) // Crash NOT caught or stop ⛔️Handler().postDelayed({ disposeMe.dispose() }, 100) 有了这个解决方案，并不意味着注册 ErrorHandler 就是正确的方式 RxJavaPlugins.setErrorHandler { e -&gt; handle(e) } 通过了解上面发生 Crash 处理方案，您就可以选择最有效的解决方案，多个方案配合一起使用，以更健壮地处理程序所发生的的 Crash。 译者思考作者大概总了 5 种 RxJava 可能出现的异常的位置 Crashes 发生在 just() 中 Crashes 发生在 subscribe success 中 Crashes 发生在 subscribe error 中 Crashes 发生在 complete 中 Crashes 发生在 complete 之前 总的来说 RxJava 无法判断这些超出生命周期的、不可交付的异常中哪些应该或不应该导致应用程序崩溃，最后作者给出了，RxJava Crash 终极解决方案，注册 ErrorHandler RxJavaPlugins.setErrorHandler { e -&gt; handleError(e) } 它将捕获上述任何情况下的所有 RxJava 未捕获的错误，just() 除外，接下来我们来了解一下 RxJavaPlugins.setErrorHandler 关于 RxJavaPlugins.setErrorHandler这是 RxJava2.x 的一个重要设计，以下几种类型的错误 RxJava 是无法捕获的： 由于下游的生命周期已经达到其终端状态导致的异常 下游取消了将要发出错误的序列而无法发出的错误 发生了 crash ，但是 crash 不在您的控制范围内 一些第三方库的代码在被取消 或者 调用中断时会抛出该异常，这通常会导致无法交付的异常。 RxJava 无法判断这些超出生命周期的、不可交付的异常中哪些应该或不应该导致应用程序崩溃。 这些无法捕获的错误，最后会发送到 RxJavaPlugins.onError 处理程序中。这个处理程序可以用方法RxJavaPlugins.setErrorHandler() 重写，RxJava 默认情况下会将 Throwable 的 stacktrace 打印到控制台，并调用当前线程的未捕获异常处理程序。 所以我们可以采用一种全局的处理方式，注册一个 RxJavaPlugins.setErrorHandler() ，添加一个非空的全局错误处理，下面的示例演示了上面列出来的几种无法交付的异常。 RxJavaPlugins.setErrorHandler(e -&gt; { if (e instanceof UndeliverableException) { e = e.getCause(); } if ((e instanceof IOException) || (e instanceof SocketException)) { // fine, irrelevant network problem or API that throws on cancellation return; } if (e instanceof InterruptedException) { // fine, some blocking code was interrupted by a dispose call return; } if ((e instanceof NullPointerException) || (e instanceof IllegalArgumentException)) { // that's likely a bug in the application Thread.currentThread().getUncaughtExceptionHandler() .handleException(Thread.currentThread(), e); return; } if (e instanceof IllegalStateException) { // that's a bug in RxJava or in a custom operator Thread.currentThread().getUncaughtExceptionHandler() .handleException(Thread.currentThread(), e); return; } Log.warning(&quot;Undeliverable exception received, not sure what to do&quot;, e);}); 我相信到这里关于 RxJava Crash 处理方案，应该了解的很清楚了，选择最有效的解决方案，多个方案配合一起使用，可以更健壮地处理程序所发生的的 Crash。 接下来我们来了解一下 just 和 fromCallable 区别 ，作者在另外一篇文章 just-vs-fromcallable 做了详细的介绍 just 和 fromCallable 区别1. 值获取来源不一样just 值从外部获取的，而 fromCallable 值来自于内部生成，为了更清楚的了解，我们来看一下下面的代码： println(&quot;From Just&quot;)val justSingle = Single.just(Random.nextInt())justSingle.subscribe{ it -&gt; println(it) }justSingle.subscribe{ it -&gt; println(it) }println(&quot;\\nFrom Callable&quot;)val callableSingle = Single.fromCallable { Random.nextInt() }callableSingle.subscribe{ it -&gt; println(it) }callableSingle.subscribe{ it -&gt; println(it) } 对于 Just 和 fromCallable 分别调用 2 次 subscribe 执行结果如下所示： From Just801570614801570614From Callable12516018492033593269 你会发现对于 just 无论 subscribe 多少次，生成的随机值都保持不变，因为该值是从 Observable 外部生成的，而 Observable 只是将其存储供以后使用。 但是对于 fromCallable 它是从 Observable 内部生成的，每次 subscribe 都会都会生成一个新的随机数。 2. 立即执行和延迟执行 just 在调用 subscribe 方法之前值已经生成了，属于立即执行。 而 fromCallable 是调用 subscribe 方法之后执行的，属于延迟执行。 为了更清楚的了解，我们来看一下下面的代码： fun main() { println(&quot;From Just&quot;) val justSingle = Single.just(getRandomMessage()) println(&quot;start subscribing&quot;) justSingle.subscribe{ it -&gt; println(it) } println(&quot;\\nFrom Callable&quot;) val callableSingle = Single.fromCallable { getRandomMessage() } println(&quot;start subscribing&quot;) callableSingle.subscribe{ it -&gt; println(it) }}fun getRandomMessage(): Int { println(&quot;-Generating-&quot;) return Random.nextInt()} 结果如下所示： From Just-Generating-start subscribing1778320787From Callablestart subscribing-Generating-1729786515 对于 just 在调用 subscribe 之前打印了 -Generating-，而 fromCallable 是在调用 subscribe 之后才打印 -Generating-。 到这里文章就结束了，我们来一起探讨一个问题， 在 Java 时代 RxJava 确实帮助我们解决了很多问题，但是相对而言不好的地方 RxJava 里面各种操作符，理解起来确实很费劲，随着 Google 将 Kotlin 作为 Android 首选语言，那么 RxKotlin，有能给我们带来哪些好处了，在 Kotlin 时代，还有必要使用 RxKotlin 吗？ 参考文献 Beyond Basic RxJava Error Handling RxJava 2 : Understanding Hot vs. Cold with just vs. fromCallable What’s different in 2.0 推荐文章 [译][Google工程师] 刚刚发布了 Fragment 的新特性 “Fragment 间传递数据的新方式” 以及源码分析 [译][Google工程师] 详解 FragmentFactory 如何优雅使用 Koin 以及部分源码分析 [译][2.4K Start] 放弃 Dagger 拥抱 Koin [译][5k+] Kotlin 的性能优化那些事 [译] 解密 RxJava 的异常处理机制 [译][1.4K+ Star] Kotlin 新秀 Coil VS Glide and Picasso 更多……","link":"/2020/08/17/translate/05-rxJava-error/"},{"title":"「译」Kotlin 的性能优化那些事","text":"前言 原标题: Item: Consider aggregating elements to a map 原地址: https://blog.kotlin-academy.com/item…… 原作者：Marcin Moskala 译者：hi-dhl 本文已收录于仓库 Technical-Article-Translation 这篇文章应该可以说是 [译][2.4K Start] 放弃 Dagger 拥抱 Koin 文章的续集，在 “放弃 Dagger 拥抱 Koin” 文章中介绍了过渡使用 Inline 修饰符所带来的后果，以及 Koin 团队在为修复 1x 版本所做的性能优化，这边文章将继续学习如何提升 Kotlin 的查询速度。 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 如何提升 Kotlin 的查询速度？ 性能和代码可读性该做如何选择？ Kotlin 内存泄露那些事, 消除过期的对象引用？ 如何提高 Kotlin 代码的可读性？ Kotlin 算法：一行代码实现杨辉三角？ 这篇文章涉及很多重要的知识点，带着自己理解，请耐心读下去，应该可以从中学到很多技巧 译文我们需要多次访问大量的数据情况，这其实并不少见，例如： cache：从服务上下载的数据，然后保存在本地内存中以更快地访问它们 repository：从一些文件中加载数据 in-memory repository：用于不同类型的内存测试 这些数据可能表示一些用户、id、配置等等，它们通常以 list 形式返给我们，它们可能以相同的方式存储在内存中： class NetworkUserRepo(val userService: UserService): UserRepo { private var users: List&lt;User&gt;? = null override fun getUser(id: UserId): User? { if(users == null) { users = userService.getUsers() } return users?.firstOrNull { it.id == id } }}class ConfigurationsRepository( val configurations: List&lt;Configuration&gt;) { fun getByName(name: String) = configurations .firstOrNull { it.name == name }}class InMemoryUserRepo: UserRepo { private val users: MutableList&lt;User&gt; = mutableListOf() override fun getUser(id: UserId): User? = users.firstOrNull { it.id == id } fun addUser(user: User) { user.add(user) }} 这可能是存储这些元素的最好方式，注意我们是如何加载数据如何使用的，我们通过某个标识符或者名字访问这些元素（它们与我们设计数据库时唯一值有关），当 n 等于 list 的大小时，在 list 中查找元素的复杂度为 O(n)，更准确的说，平均需要 n / 2 次比较才能找到一个元素，如果是一个比较的大的 list，查找效率极其低效，解决这个问题的一个好办法是使用 Map 代替 list, Kotlin 默认使用的是 hash map, 更具体的说是 LinkedHashMap，当我们使用 hash map 查找元素的性能要好得多, 实际上 JVM 使用的 hash map 的大小根据映射本身的大小进行了调整, 如果实现 hashCode 方式正确，查找一个元素只需要进行一次比较。 这是 InMemoryRepo 中使用 map 代替 list class InMemoryUserRepo: UserRepo { private val users: MutableMap&lt;UserId, User&gt; = mutableMapOf() override fun getUser(id: UserId): User? = users[id] fun addUser(user: User) { user.put(user.id, user) }} 大多是其他操作，比如修改或者迭代这些数据（可能使用集合方法 filter, map, flatMap, sorted, sum 等等）对于 list 和 map 性能差不多的。 那么我们如何从 list 转换到 map，或者从 map 转换到 list，使用 associate 方法来完成 list 转换到 map，最常见的方法是 associateBy，它构建一个映射，其中的值是列表中的元素，键是通过一个 lambda 表达式提供。 data class User(val id: Int, val name: String)val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Marek&quot;))val byId = users.associateBy { it.id }byId == mapOf(1 to User(1, &quot;Michal&quot;), 2 to User(2, &quot;Marek&quot;)) val byName = users.associateBy { it.name }byName == mapOf(&quot;Michal&quot; to User(1, &quot;Michal&quot;), &quot;Marek&quot; to User(2, &quot;Marek&quot;)) 注意，映射中的键必须是唯一的，否则相同键值的元素会被删掉，这就是为什么我们应该根据唯一标识符进行关联（对于键值不是唯一的，应该使用 groupBy 方法） val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Michal&quot;))val byName = users.associateBy { it.name }byName == mapOf(&quot;Michal&quot; to User(2, &quot;Michal&quot;)) 从 map 转换到 list 使用 values 方法 val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Michal&quot;))val byId = users.associateBy { it.id }users == byId.values 如何在 repositories 中用 Map 提高元素访问的性能 class NetworkUserRepo(val userService: UserService): UserRepo { private var users: Map&lt;UserId, User&gt;? = null override fun getUser(id: UserId): User? { if(users == null) { users = userService.getUsers().associateBy { it.id } } return users?.get(id) }}class ConfigurationsRepository( configurations: List&lt;Configuration&gt;) { val configurations: Map&lt;String, Configuration&gt; = configurations.associateBy { it.name } fun getByName(name: String) = configurations[name]} 这个技巧是非常重要的，但是并不适合所有的 cases，当我们需要访问比较大的 list 的时候是非常有用的，这在后台访问是非常重要的，这些 list 可能在后台每秒被访问很多次，但是在前台并不重要（这里说的是 Android 或者 iOS）用户最多只会访问几次 repository，需要注意的是从 list 转换到 map 是需要时间的，如果过渡使用，可能会对性能有不好的影响。 译者思考作者总共从三个方面 Network、Configurations、InMemory 告诉我们应该如何从 list 转 map, 或者从 map 转 list, 以及应该在后台需要多次访问很大的数据集合中使用 map，过渡的使用只会对性能产生负面的影响。 list 转 map 调用用 associateBy 方法，接受一个 lambda 表达式 val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Michal&quot;))val byName = users.associateBy { it.name }byName == mapOf(&quot;Michal&quot; to User(2, &quot;Michal&quot;)) 从 map 转 list 调用 values 方法 val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Michal&quot;))val byId = users.associateBy { it.id }users == byId.values 这是一个非常重要的优化的手段（使用空间换取时间），在 [译][2.4K Start] 放弃 Dagger 拥抱 Koin 文章中介绍了当我们引入 Koin 1x 的时候冷启动时间变长了，而且在有大量依赖的时候，查找的时间会有点长，用过这个版本的朋友，应该都会有这个感觉，Koin 团队的解决方案中用到了 HashMap，使用空间换取时间，查找一个 Definition 时间复杂度变成了 O(1)，从提高的访问速度。 其实我们应该在头脑中，保持内存管理的意识，在每次优化、修改代码之前，不要急于写代码，先整理一下思路，在头脑中过一遍自己的方案，我们应该为项目找到一个折衷方案，不仅要考虑内存和性能，还要考虑代码的可读性。当我们做一个应用程序，在大多数情况下可读性更重要。当我们开发一个库时，通常性能和内存更重要。 性能和代码可读性该做如何选择如果用 Java 和 Kotlin 语言刷过 LeetCode，使用相同的思路实现同一个算法，在正常的 Case 中，Kotlin 和 Java 执行时间差值很小，数据量越大的情况下 Kotlin 和 Java 差距会越来越大，Kotlin 执行时间会越来越慢，但是为什么 Kotlin 语言还会成为 Android 开发的首选语言呢？来看一下作者 Marcin Moskala 另外一篇文章 My favorite examples of functional programming in Kotlin 展示的快排算法。 在之前的文章中分享了过这个算法，现在我们来分析一下这个算法。 fun &lt;T : Comparable&lt;T&gt;&gt; List&lt;T&gt;.quickSort(): List&lt;T&gt; = if(size &lt; 2) this else { val pivot = first() val (smaller, greater) = drop(1).partition { it &lt;= pivot} smaller.quickSort() + pivot + greater.quickSort() } // 使用 [2,5,1] -&gt; [1,2,5]listOf(2,5,1).quickSort() // [1,2,5] 这是一个非常酷的函数式编程的例子，当看到这个算法的第一感觉，它非常的简洁，可读性很强，其次我们来看一下这个算法执行时间，其实它根本没有针对性能进行优化。 如果你需要使用高性能的算法，你可以使用 Java 标准库当中的函数，Kotlin 扩展函数 sorted() 就是用 Java 标准库中的函数，Java 标准库中的函数效率会更高的，但是实际执行时间怎么样呢？生成一个随机数数组，使用使用 quickSort() 和 sorted() 方法进行排序，比较它们的执行时间，代码如下所示： val r = Random()listOf(100_000, 1_000_000, 10_000_000) .asSequence() .map { (1..it).map { r.nextInt(1000000000) } } .forEach { list: List&lt;Int&gt; -&gt; println(&quot;Java stdlib sorting of ${list.size} elements took ${measureTimeMillis { list.sorted() }}&quot;) println(&quot;quickSort sorting of ${list.size} elements took ${measureTimeMillis { list.quickSort() }}&quot;) } 执行结果如下所示： Java stdlib sorting of 100000 elements took 83quickSort sorting of 100000 elements took 163Java stdlib sorting of 1000000 elements took 558quickSort sorting of 1000000 elements took 859Java stdlib sorting of 10000000 elements took 6182quickSort sorting of 10000000 elements took 12133` 正如你所见，quickSort() 比 sorted() 排序算法要慢两倍，在正常情况下，差值通常在 0.1ms 和 0.2ms 之间，基本上可以忽略不计，但是它更简洁，可读性更强。这解释了在某些情况下，我们可以考虑使用一个优化程度稍低，但可读性强且简洁的函数，你同意作者这种观点吗？ Kotlin 内存泄露那些事, 消除过期的对象引用我看过很多文章都说 Kotlin 简洁和高效，Kotlin 确实很简洁，在 “如何提高 Kotlin 代码的可读性” 部分我会列举一些例子，但是高效的背后是有代价的，这块往往很容易被我们忽略，这就需要我们去研究 kotlin 语法糖背后的魔法，当我们在开发的时候，选择合适的语法糖，尽量避免这些错误，例如带有 lnmba 表达式高阶函数，不使用 Inline 修饰符，会被编译成匿名内部类等等，更详细的内容参考 [译][2.4K Start] 放弃 Dagger 拥抱 Koin Inline 修饰符带来的性能损失部分。 内存管理最重要的一条规则是，不使用的对象应该被释放 这篇文章 Effective Java in Kotlin, item 7: Eliminate obsolete object references 作者也列举了 Kotlin 的一些例子，例如我们需要使用 mutableLazy 属性委托，像 lazy 一样工作，我们来看一下实现代码： fun &lt;T&gt; mutableLazy(initializer: () -&gt; T): ReadWriteProperty&lt;Any?, T&gt; = MutableLazy(initializer)private class MutableLazy&lt;T&gt;( val initializer: () -&gt; T) : ReadWriteProperty&lt;Any?, T&gt; { private var value: T? = null private var initialized = false override fun getValue( thisRef: Any?, property: KProperty&lt;*&gt; ): T { synchronized(this) { if (!initialized) { value = initializer() initialized = true } return value as T } } override fun setValue( thisRef: Any?, property: KProperty&lt;*&gt;, value: T ) { synchronized(this) { this.value = value initialized = true } }} 如何使用： var game: Game? by mutableLazy { readGameFromSave() }fun setUpActions() { startNewGameButton.setOnClickListener { game = makeNewGame() startGame() } resumeGameButton.setOnClickListener { startGame() }} 思考一下 mutableLazy 实现正确吗？ 它有一个地方不对，lnmba 表达式 initializer 在使用后没有被删除。这意味着只要对 MutableLazy 实例的引用存在，它就会被保持，即使它不再有用，如何改进 MutableLazy 实现的方法，优化代码如下所示： fun &lt;T&gt; mutableLazy(initializer: () -&gt; T): ReadWriteProperty&lt;Any?, T&gt; = MutableLazy(initializer)private class MutableLazy&lt;T&gt;( var initializer: (() -&gt; T)?) : ReadWriteProperty&lt;Any?, T&gt; { private var value: T? = null override fun getValue( thisRef: Any?, property: KProperty&lt;*&gt; ): T { synchronized(this) { val initializer = initializer if (initializer != null) { value = initializer() this.initializer = null } return value as T } } override fun setValue( thisRef: Any?, property: KProperty&lt;*&gt;, value: T ) { synchronized(this) { this.value = value this.initializer = null } }} 在使用完之后将 initializer 设置为 null，它将会被 GC 回收。特别要注意当一个高阶函数会被编译成匿名类时或者它是一个未知类（任何或泛型类型）时，这个优化显得非常重要，我们来看一下 Kotlin stdlib 库中的类 SynchronizedLazyImpl 代码如下所示：kotlin-stdlib……/kotlin/util/LazyJVM.kt private class SynchronizedLazyImpl&lt;out T&gt;( initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable { private var initializer: (() -&gt; T)? = initializer private var _value: Any? = UNINITIALIZED_VALUE private val lock = lock ?: this override val value: T get() { val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) { @Suppress(&quot;UNCHECKED_CAST&quot;) return _v1 as T } return synchronized(lock) { val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) { @Suppress(&quot;UNCHECKED_CAST&quot;) (_v2 as T) } else { val typedValue = initializer!!() _value = typedValue initializer = null typedValue } } } ......} 请注意，在使用完之后 initializers 设置为 null，将会被 GC 回收 如何提高 Kotlin 代码的可读性上文提到了 Kotlin 简洁可读性很强，但是呢通过 AndroidStudio 提供了 convert our Java code to Kotlin 插件，将 Java 代码转换为 Kotlin 代码，Java-Style Kotlin 的代码明显很难看，那么如何提升 Kotlin 代码的可读性，我想分享几个很酷的例子 Improve Java to Kotlin code review，用到了 Elvis 表达式、run, with 等等函数 消除!! myList!!.length change to myList?.length 空检查 if (callback != null) { callback!!.response()} change to callback?.response() 使用 Elvis 表达式 if (toolbar != null) { if (arguments != null) { toolbar!!.title = arguments!!.getString(TITLE) } else { toolbar!!.title = &quot;&quot; }} change to toolbar?.title = arguments?.getString(TITLE) ?: “” 使用 scope 函数 val intent = intentUtil.createIntent(activity!!.applicationContext) activity!!.startActivity(intent)dismiss() change to activity?.run { val intent = intentUtil.createIntent(this) startActivity(intent) dismiss() } ps: scope 函数还有 run, with, let, also and apply，它们的区别是什么，如何正确使用它们，后面的文章会详细的介绍。 使用 takeIf if 函数 if (something != null &amp;&amp; something == preference) { something.doThing() change to something?.takeIf { it == preference }?.let { something.doThing() } Android TextUtil if (TextUtils.isEmpty(someString)) {...}val joinedString = TextUtils.join(COMMA, separateList) change to if (someString.isEmpty()) {...}val joinedString = separateList.joinToString(separator = COMMA) Java Util val strList = Arrays.asList(&quot;someString&quot;) change to val strList = listOf(&quot;someString&quot;) Empty and null if (myList == null || myList.isEmpty()) {...} change to if (myList.isNullOrEmpty() {...} 避免对对象进行重复操作 recyclerView.setLayoutManager(layoutManager)recyclerView.setAdapter(adapter) recyclerView.setItemAnimator(animator) change to with(recyclerView) { setLayoutManager(layoutManager) setAdapter(adapter) setItemAnimator(animator)} 避免列表循环 for (str in stringList) { println(str)} change to stringList.forEach { println(it) } 避免使用 mutable 集合 val stringList: List&lt;String&gt; = mutableListOf()for (other in otherList) { stringList.add(dosSomething(other))} change to val stringList = otherList.map { dosSomething(it) } 使用 when 代替 if if (requestCode == REQUEST_1) { doThis()} else if (requestCode == REQUEST_2) { doThat()} else { doSomething()} change to when (requestCode) { REQUEST_1 -&gt; doThis() REQUEST_1 -&gt; doThat() else -&gt; doSomething()} 使用 const companion object { val EXTRA_STRING = &quot;EXTRA_EMAIL&quot; val EXTRA_NUMBER = 12345} change to companion object { const val EXTRA_STRING = &quot;EXTRA_EMAIL&quot; const val EXTRA_NUMBER = 12345} 如果有更好的例子，欢迎留言 Kotlin 算法：一行代码实现杨辉三角我想分享一个很酷的算法，用一行代码实现杨辉三角，代码来自 Marcin Moskala 大神的 Twitter fun pascal() = generateSequence(listOf(1)) { prev -&gt; listOf(1) + (1..prev.lastIndex).map { prev[it - 1] + prev[it] } + listOf(1)}fun main() { pascal().take(10).forEach(::println)} 安利一个译者自己撸的导航网站基于 Python + Material Design 开发的 “为互联网人而设计 国内国外名站导航“ ，收集了国内外热门网址，涵括新闻、体育、生活、娱乐、设计、产品、运营、前端开发、Android开发等等导航网站 地址 参考文献 Item: Consider aggregating elements to a map Effective Java in Kotlin, item 7: Eliminate obsolete object references Improve Java to Kotlin code review 推荐文章 [译][Google工程师] 刚刚发布了 Fragment 的新特性 “Fragment 间传递数据的新方式” 以及源码分析 [译][Google工程师] 详解 FragmentFactory 如何优雅使用 Koin 以及部分源码分析 [译][2.4K Start] 放弃 Dagger 拥抱 Koin [译][5k+] Kotlin 的性能优化那些事 [译] 解密 RxJava 的异常处理机制 [译][1.4K+ Star] Kotlin 新秀 Coil VS Glide and Picasso 更多……","link":"/2020/08/05/translate/04-kotlin-performance/"},{"title":"「译」放弃 Dagger 拥抱 Koin","text":"前言 原标题: Koin vs Dagger, Say hello to Koin 原地址: https://blog.usejournal.com/android-koin… 原作者：Farshid ABZ 译者：hi-dhl 本文已收录于仓库 Technical-Article-Translation 在之前的文章中全面分析了 Dagger 与 Hit 和 Hit 与 Koin 的性能，点击下方链接前往查看 全方面分析 Hilt 和 Koin 性能 Jetpack 成员 Hilt 与 Dagger 区别 (三) 落地篇 在这篇文章中我们继续分析一下 Dagger 与 Koin 的性能，全文分为 译文 和 译者思考 两个部分。 我也正在结合最新的技术，开发一个新的项目，期间会用到 koin，在不久的将来，会与小伙伴们见面 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 Dagger 和 Koin 优势劣势对比？应该选择 Dagger 还是 Koin？ koin 语法特性？ Koin 为什么可以做到无代码生成、无反射？ Inline 修饰符做什么用的？如何正确使用？带来的性能损失？ 只是用 Inline 修饰符，为什么编译器会给我们一个警告？ 为什么编译器建议 inline 修饰符需要和 lambda 表达式一起使用呢？ 什么时候应该使用 inline 修饰符？ Reified 修饰符做什么用？如何使用？ Koin 带来性能损失的那些事？ Kotlin 用 5 行代码实现快排算法？ 这篇文章涉及很多重要的知识点，请耐心读下去，我相信应该会给大家带来很多不一样的东西。 译文当我正在反复学习 Dagger 的时候，我遇见了 Koin，Koin 不仅节省了我的时间，还提高了效率，将我从复杂 Dagger 给释放出来了。 这篇文章将会告诉你什么是 Koin，与 Dagger 对比有那些优势，以及如何使用 Koin。 是什么 KoinKoin 是为 Kotlin 开发者提供的一个实用型轻量级依赖注入框架，采用纯 Kotlin 语言编写而成，仅使用功能解析，无代理、无代码生成、无反射。 Dagger vs Koin为了正确比较这两种方式，我们用 Dagger 和 Koin 去实现了一个项目，项目的架构都是 MVVM，其中用到了 retrofit 和 LiveData，包含了 1 个Activity、4 个 fragments、5 个 view models、1 个 repository 和 1 个 web service 接口, 这应该是一个小型项目的基础架构了 先来看一下 DI 包下的结构，左边是 Dagger，右边是 Koin 如你所见配置 Dagger 需要很多文件 而 Koin 只需要 2 个文件，例如 用 Dagger 注入 1 个 view models 就需要 3 个文件（真的需要用这么多文件吗？） 比较 Dagger 和 Koin 代码行数我使用 Statistic 工具来统计的，反复对比了项目编译前和编译后，Dagger 和 Koin 生成的代码行数，结果是非常吃惊的 正如你看到的 Dagger 生成的代码行比 Koin 多两倍 Dagger 和 Koin 编译时间怎么样呢每次编译之前我都会先 clean 然后才会 rebuild，我得到下面这个结果 Koin:BUILD SUCCESSFUL in 17s88 actionable tasks: 83 executed, 5 up-to-dateDagger:BUILD SUCCESSFUL in 18s88 actionable tasks: 83 executed, 5 up-to-date 我认为这个结果证明了，如果是在一个更大、更真实的项目中，这个代价是非常昂贵。 Dagger 和 Koin 使用上怎么样呢如果你想在 MVVM 和 Android Support lib 中使用 Dagger 你必须这么做。 首先在 module gradle 中 添加 Dagger 依赖。 kapt &quot;com.google.dagger:dagger-compiler:$dagger_version&quot;kapt &quot;com.google.dagger:dagger-android-processor:$dagger_version&quot;implementation &quot;com.google.dagger:dagger:$dagger_version&quot; 然后创建完 modules 和 components 文件之后， 需要在 Application 中 初始化 Dagger（或者其他方式初始化 Dagger）。 Class MyApplication : Application(), HasActivityInjector { @Inject lateinit var dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Activity&gt; override fun activityInjector() = dispatchingAndroidInjector fun initDagger() { DaggerAppComponent .builder() .application(this) .build() .inject(this) }} 所有的 Activity 继承 BaseActivity，我们需要实现 HasSupportFragmentInjector 和 inject DispatchingAndroidInjector。 对于 view models，我们需要在 BaseFragment 中注入 ViewModelFactory，并实现 Injectable。 但这并不是全部。还有更多的事情要做。 对于每一个 ViewModel、Fragment 和 Activity 我们需要告诉 DI 如何注入它们，正如你所见我们有 ActivityModule、FragmentModule、和 ViewModelModule。 我们来看一下下面的代码 @Moduleabstract class ActivityModule { @ContributesAndroidInjector(modules = [FragmentModule::class]) abstract fun contributeMainActivity(): MainActivity //Add your other activities here} Fragments 如下所示： @Moduleabstract class FragmentModule { @ContributesAndroidInjector abstract fun contributeLoginFragment(): LoginFragment @ContributesAndroidInjector abstract fun contributeRegisterFragment(): RegisterFragment @ContributesAndroidInjector abstract fun contributeStartPageFragment(): StartPageFragment} ViewModels 如下所以： @Moduleabstract class ViewModelModule { @Binds abstract fun bindViewModelFactory(factory: ViewModelFactory): ViewModelProvider.Factory @Binds @IntoMap @ViewModelKey(loginViewModel::class) abstract fun bindLoginFragmentViewModel(loginViewModel: loginViewModel): ViewModel @Binds @IntoMap @ViewModelKey(StartPageViewModel::class) abstract fun bindStartPageViewModel(startPageViewModel: StartPageViewModel): ViewModel ......} 所以你必须在 DI modules 中添加这些 Fragments、Activities 和 ViewModels。 那么在 Koin 中如何做 你需要在 module gradle 中添加 Koin 依赖 implementation &quot;org.koin:koin-android-viewmodel:$koin_version&quot; 然后我们需要创建 module 文件，稍后我告诉你怎么做，实际上我们并不需要像 Dagger 那么多文件。 Dagger 还有其他问题 学习 Dagger 成本是很高的，如果有人加入你的项目或者团队，他/她不得不花很多时间学习 Dagger，我使用 Dagger 两年了，到现在还不是很了解，每次我开始学习 Andorid 新技术的时候，我不得不去搜索和学习如何用 Dagger 实现新技术。 来看一下 Koin 代码 首先我们需要添加 Koin 依赖，如下所示： implementation &quot;org.koin:koin-android-viewmodel:$koin_version&quot; 我们使用的是 koin-android-viewmodel 库，因为我们希望在 MVVM 中使用它，当然还有其他的依赖库。 添加完依赖之后，我们来实现第一个 module 文件，像 Dagger 一样，可以在一个单独的文件中实现每个模块，但是由于代码简单，我决定在一个文件中实现所有模块，你也可以把它们分开。 首先我们需要了解一下 koin 语法特性 get()： 解析 Koin 模块中的实例，调用 get() 函数解析所请求组件需要的实例，这个 get() 函数通常用于构造函数中，注入构造函数值 factory：声明这是一个工厂组件，每次请求都为您提供一个新实例 single：采用单例设计模式 name：用于命名定义，当您希望具有不同类型的同一个类的多个实例时，需要使用它 我们没有创建具有多个注释和多个组件的许多文件，而是为 DI 注入每个类的时候，提供一个简单、可读的文件。 了解完 koin 语法特性之后，我们来解释下面代码什么意思 private val retrofit: Retrofit = createNetworkClient() createNetworkClient 方法创建 Retrofit 实例，设置 baseUrl，添加 ConverterFactory 和 Interceptor private val generalApi: GeneralApi = retrofit.create(GeneralApi::class.java)private val authApi: AuthApi = retrofit.create(AuthApi::class.java) AuthApi 和 GeneralApi 是 retrofit 接口 val viewModelModule = module { viewModel { LoginFragmentViewModel(get()) } viewModel { StartPageViewModel() } } 在 module 文件中声明为 viewModel， Koin 将会向 ViewModelFactory 提供 viewModel，将其绑定到当前组件。 正如你所见，在 LoginFragmentViewModel 构造函数中有调用了 get() 方法，get() 会解析一个 LoginFragmentViewModel 需要的参数，然后传递给 LoginFragmentViewModel，这个参数就是 AuthRepo。 最后在 Application onCreate 方法中添加如下代码 startKoin(this, listOf(repositoryModule, networkModule, viewModelModule)) 这里只是调用 startKoin 方法，传入一个上下文和一个希望用来初始化 Koin 的模块列表。 现在使用 ViewModel 比使用纯 ViewModel 更容易，在 Fragment 和 Activity 视图中添加下面的代码 private val startPageViewModel: StartPageViewModel by viewModel() 通过这段代码，koin 为您创建了一个 StartPageViewModel 对象，现在你可以在 Fragment 和 Activity 中使用 view model 译者思考作者总共从以下 4 个方面对比了 Dagger 和 Kotlin： 文件数量：基于 mvvm 架构，分别使用了 Dagger 和 koltin 作为依赖注入框架，初始化 Dagger 时至少需要 9 个文件，而 koltin 只需要 2 个文件，Dagger 文件数量远超过 koltin 代码行数：作者使用了 Statistic 工具，反复对比了项目编译前和编译后，Dagger 和 Koin 生成的代码行数，如下图所示 反复的对比了 Dagger 和 Koin 编译时间，结果如下所示 koin 比 Dagger 快 Koin:BUILD SUCCESSFUL in 17s88 actionable tasks: 83 executed, 5 up-to-dateDagger:BUILD SUCCESSFUL in 18s88 actionable tasks: 83 executed, 5 up-to-date 学习成本巨大，如果使用了 Dagger 朋友，应该和作者的感觉是一样的，Dagger 学习的成本是非常高的，如果项目中引入了 Dagger 意味着团队每个人都要学习 Dagger，无疑这个成本是巨大的，而且使用起来非常的复杂 注意：作者在 Application 中调用 startKoin 方法初始化 Koin 的模块列表，是 Koin 1X 的方式，Koin 团队在 2x 的时候做了很多改动（下面会介绍），初始化 Koin 的模块列有所改动，代码如下所示： startKoin { // Use Koin Android Logger androidLogger() // declare Android context androidContext(this@MainApplication) // declare modules to use modules(module1, module2 ...)} Koin 为什么可以做到无代码生成、无反射Koin 作为一个轻量级依赖注入框架，为什么可以做到无代码生成、无反射？因为 kotlin 强大的语法糖（例如 Inline、Reified 等等）和函数式编程，我们先来看一段代码。koin-projects/koin-core/src/main/kotlin/org/koin/dsl/Module.kt 案例一 // typealias 是用来为已经存在的类型重新定义名字的typealias ModuleDeclaration = Module.() -&gt; Unitfun module(createdAtStart: Boolean = false, override: Boolean = false, moduleDeclaration: ModuleDeclaration): Module { // 创建 Module val module = Module(createdAtStart, override) // 执行匿扩展函数 moduleDeclaration(module) return module}// 如何使用val mModule: Module = module { single { ... } factory { ... }} Module 是一个 lambda 表达式，才可以在 “{}” 里面自由定义 single 和 factory，会等到你需要的时候才会执行。 案例二 inline fun &lt;reified T : ViewModel&gt; Module.viewModel( qualifier: Qualifier? = null, override: Boolean = false, noinline definition: Definition&lt;T&gt;): BeanDefinition&lt;T&gt; { val beanDefinition = factory(qualifier, override, definition) beanDefinition.setIsViewModel() return beanDefinition} 内联函数支持具体化的类型参数，使用 reified 修饰符来限定类型参数，以在函数内部访问它了，由于函数是内联的，不需要反射，通过上面两个案例，说明了为什么 Koin 可以做到无代码生成、无反射。建议大家都去看看 Koin 的源码，能够从中学到很多技巧，后面我会花好几篇文章分析 Koin 源码。 Inline 修饰符带来的性能损失Inline (内联函数) 的作用：提升运行效率，调用被 inline 修饰符的函数，会把里面的代码放到我调用的地方。 如果阅读过 Koin 源码的朋友，应该会发现 inline 都是和 lambda 表达式和 reified 修饰符配套在一起使用的，如果只使用 inline 修饰符标记函数会怎么样？ 只使用 inline 修饰符会有性能问题，在这篇文章 Consider inline modifier for higher-order functions 也分析了只使用 inline 修饰符为什么会带来性能问题，并且 Android Studio 也会给一个大大大的警告。 编译器建议我们在含有 lambda 表达式作为形参的函数中使用内联，既然 Inline 修饰符可以提升运行效率，为什么编译器会给我们一个警告？ 为什么编译器建议 inline 修饰符需要和 lambda 表达式一起使用呢？ 1. 既然 Inline 修饰符可以提升运行效率，为什么编译器会给我们一个警告？ 刚才我们说过调用被 inline 修饰符的函数，会把里面的代码放到我调用的地方，来看一下下面这段代码。 inline fun twoPrintTwo() { print(2) print(2)}inline fun twoTwoPrintTwo() { twoPrintTwo() twoPrintTwo()}inline fun twoTwoTwoPrintTwo() { twoTwoPrintTwo() twoTwoPrintTwo()}fun twoTwoTwoTwoPrintTwo() { twoTwoTwoPrintTwo() twoTwoTwoPrintTwo()} 执行完最后一个方法 twoTwoTwoTwoPrintTwo，反编译出来的结果是非常令人吃惊的，结果如下所示： public static final void twoTwoTwoTwoPrintTwo() { byte var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print();} 这显示了使用 Inline 修饰符的主要问题，当我们过度使用它们时，代码会快速增长。这就是为什么 IntelliJ 在我们使用它的时候会给出警告。 2. 为什么编译器建议 inline 修饰符需要和 lambda 表达式一起使用呢？ 因为 JVM 是不支持 lambda 表达式的，非内联函数中的 Lambda 表达式会被编译为匿名类，这对性能开销是非常巨大的，而且它们的创建和使用都较慢，当我们使用 inline 修饰符时，我们根本不需要创建任何其他类，来看一下下面代码。 fun main(args: Array&lt;String&gt;) { var a = 0 // 带 inline 的 Lambda 表达式 repeat(100_000_000) { a += 1 } var b = 0 // 不带 inline 的 Lambda 表达式 noinlineRepeat(100_000_000) { b += 1 }} 编译结果如下： // Java 代码public static final void main(@NotNull String[] args) { int a = 0; // 带 inline 的 Lambda 表达式, 会把里面的代码放到我调用的地方 int times$iv = 100000000; int var3 = 0; for(int var4 = times$iv; var3 &lt; var4; ++var3) { ++a; } // 不带 inline 的 Lambda 表达式，会被编译为匿名类 final IntRef b = new IntRef(); b.element = 0; noinlineRepeat(100000000, (Function1)(new Function1() { public Object invoke(Object var1) { ++b.element; return Unit.INSTANCE; } }));} 那么我们应该在什么时候使用 inline 修饰符呢？ 使用 inline 修饰符时最常见的场景就是把函数作为另一个函数的参数时(高阶函数)，例如 filter、map、joinToString 或者一些独立的函数 repeat。 如果没有函数类型作为参数，也没有 reified 实化类型参数时，不应该使用 inline 修饰符了。 从分析 Koin 源码，inline 应该 lambda 表达式或者 reified 修饰符配合在一起使用的，另外 Android Studio 越来越智能了，如果在不正确的地方使用，会有一个大大大的警告。 Reified 修饰符，具体化的类型参数reified （具体化的类型参数）：使用 reified 修饰符来限定类型参数，结合着 inline 修饰符具体化的类型参数，可以直接在函数内部访问它。 我想分享两个使用 Reified 修饰符很常见的例子 reified-type-parameters，使用 Java 是不可能实现的。 案例一： inline fun &lt;reified T&gt; Gson.fromJson(json: String) = fromJson(json, T::class.java) // 使用val user: User = Gson().fromJson(json)val user = Gson().fromJson&lt;User&gt;(json) 案例二： inline fun &lt;reified T: Activity&gt; Context.startActivity(vararg params: Pair&lt;String, Any?&gt;) = AnkoInternals.internalStartActivity(this, T::class.java, params) Koin 带来性能损失的那些事思考了很久需不需要写这部分内容，因为在 Koin 2x 的版本的时候已经修复了，这是官方的链接 News from the trenches — What’s next for Koin?，后来想想还是写写吧，作为自己的一个学习笔记。 这个源于有个人开了一个 Issue(Bad performance in some Android devices) 现在已经被关闭了，他指出了当 Dependency 数量越来越多的时候，Koin 效能会越来越差，而且还做了一个对比如下图所示： 如果使用过 Koin 1x 的朋友应该会感觉到，引入 Koin 1x 冷启动时间边长了，而且在有大量依赖的时候，查找的时间会有点长，后来 Koin 团队也发现确实存在这个问题，到底是怎么回事呢？ 他们在 BeanRegistry 类中维护了一个列表，用来存储了 BeanDefinition，然后使用 Kotlin 的 filter 函数找出对应的 BeanDefinition，所以找出一个 Definition 时间复杂度是 O(n)，如果平均有 M 层 Dependency，那么时间复杂度会变成 O(m*n)。 Koin 团队的解决方案是用了 HashMap，使用空间换取时间，查找一个 Definition 时间复杂度变成了 O(1)，优化之后的结果如下： Koin 2x 不仅在性能优化上有很大的提升，也拓展了很多新的特性，例如 FragmentFactory 能够依赖注入到 Fragments 中就像 ViewModels 一样，还有自动拆箱等等，在后面的文章会详细的分析一下。 Kotlin 用 5 行代码实现快排算法我想分享一个快速排序算法，这是一个很酷的函数编程的例子 share cool examples，当我看到这段代码的时候惊呆了，居然还可以这么写。 fun &lt;T : Comparable&lt;T&gt;&gt; List&lt;T&gt;.quickSort(): List&lt;T&gt; = if(size &lt; 2) this else { val pivot = first() val (smaller, greater) = drop(1).partition { it &lt;= pivot} smaller.quickSort() + pivot + greater.quickSort() } // 使用 [2,5,1] -&gt; [1,2,5]listOf(2,5,1).quickSort() // [1,2,5] 最后分享一个译者自己撸的导航网站基于 Python + Material Design 开发的 “为互联网人而设计 国内国外名站导航“ ，收集了国内外热门网址，涵括新闻、体育、生活、娱乐、设计、产品、运营、前端开发、Android开发等等导航网站 地址：https://site.51git.cn ps: 数据来源于网络，这里仅做分享，如有问题可以留言告诉我，我会立刻删除 国际资讯网址大全 Android 网址大全 参考文献 My favorite examples of functional programming in Kotlin koin 官网:https://insert-koin.io/ Effective Kotlin: Consider inline modifier for higher-order functions","link":"/2020/08/04/translate/03-dagger-koin/"},{"title":"「译」Google 建议使用这些 Fragment 的新特性","text":"前言 原标题: Android Fragments: FragmentFactory 原地址: https://proandroiddev.com/fragmentfactory…… 原作者：Husayn Hakeem 译者：hi-dhl 本文已收录于仓库 Technical-Article-Translation 在之前的文章 Fragment 新特性 : Fragment Result API 使用以及源码分析 中介绍了 Fragment Result API , 用来取代之前的 Fragment 之间通信方式的不足。 而这篇文章主要介绍 FragmentFactory 和 FragmentContainerView，分为 译文 和 译者思考 两个部分。 FragmentFactory 和 FragmentContainerView 是在 Fragment 1.2.0 上新增加的 API，目前稳定版本已经发布了，可以直接在项目中使用。 Google 建议使用的一些 Fragment 的新特性，它为我们解决了 Fragment 一些常见的问题。 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 FragmentFactory 是什么？ 什么情况下使用 FragmentFactory？ FragmentContainerView 是什么？ 为什么 Google 强烈建议使用 FragmentContainerView？ Koin 如何和 FragmentFactory 一起使用以及源码分析？ 如何处理嵌套 Fragment? 这篇文章涉及很多重要新的知识点，可以从中学到很多技巧。 译文现在我们可以使用 FragmentFactory 来完成 Fragment 构造函数的注入，但是这不是开发人员必须使用的 API, 在某些情况下，它可以被认为是一种很好的设计方法，帮助我们测试带有外部依赖项的 Fragment。 这篇文章将会解释什么是 FragmentFactory，什么时候以及如何使用它，如何处理嵌套 Fragment。 什么是 FragmentFactory？之前 Fragment 的实例都是通过使用默认的空的构造函数进行实例化，这是因为系统需要在某些情况下重新初始化它，比如配置更改或者 App 的进程重建，如果没有默认构造函数的限制，系统不知道如何重新初始化 Fragment 实例。 FragmentFactory 出现就是为了解决这个限制，通过向其提供实例化 Fragment 所需的参数/依赖关系，FragmentFactory 可以帮助系统创建 Fragment 实例。 如何使用 FragmentFactory？如果你的 Fragment 没有空的构造函数，您需要创建一个 FragmentFactory 来处理初始化它，通过继承 FragmentFactory 并且覆盖 FragmentFactory#instantiate() 来完成。 class CustomFragmentFactory(private val dependency: Dependency) : FragmentFactory() { override fun instantiate(classLoader: ClassLoader, className: String): Fragment { if (className == CustomFragment::class.java.name) { return CustomFragment(dependency) } return super.instantiate(classLoader, className) }} Fragment 是由 FragmentManagers 来管理的，所以为了使用 FragmentFactory 需要关联 FragmentManager，更具体的说它必须分配给包含 Fragment 组件的 FragmentManager，它可以是 Activity 或者 Fragment。 什么时候 FragmentFactory 和 FragmentManager 做关联FragmentFactory 负责在 Activity 和 parent Fragment 初始化 Fragment，所以应该在创建 Fragment 之前设置它。 在创建 component’s View 之前：如果在 XML 中定义 Fragment，应该使用 Fragment 的 tag &lt;fragment&gt; 或者 FragmentContainerView。 在创建 Fragment 之前：如果 Fragment 是动态添加的应该使用 FragmentTransaction。 在系统恢复 Fragment 之前：如果是因为配置更改或者 App 的进程重建，导致 Fragment 重建。 有了这些限制，可以在 Activity#onCreate() 和 Fragment#onCreate() 之前关联 FragmentFactory 和 FragmentManager，在这两个调用处 view 创建之前会重新初始化 Fragment。 这也就意味着应该在 super#onCreate() 之前关联 FragmentFactory 和 FragmentManager。 在 Activity 关联 FragmentFactory 和 FragmentManager class HostActivity : AppCompatActivity() { private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) { supportFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) // ... }} 在 Fragment 关联 FragmentFactory 和 FragmentManager class ParentFragment : Fragment() { private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) { childFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) // ... }} 需要使用 FragmentFactory 吗？到目前为止，您可能已经使用它们的默认构造函数创建 Fragment，然后使用 Dagger 或 Koin 这样的库注入它们需要的依赖项，或者在它们被使用之前在 Fragment 中初始化它们。 如果你的 Fragment 有一个默认的空构造函数，那么就不需要使用 FragmentFactory，如果在 Fragment 构造函数中接受参数，必须使用 FragmentFactory，否者会抛出 Fragment.InstantiationException 异常 如何同时使用 Fragment 和 FragmentFactory？只需要在创建 Fragment 之前，设置 FragmentFactory，它就会被用来实例化，这意味着在添加 Fragments 之前使用自定义的 FragmentFactory。 静态添加： 使用 Fragment 的 tag &lt;fragment&gt; 和 FragmentContainerView。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.fragment.app.FragmentContainerView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/customFragment&quot; android:name=&quot;com.example.CustomFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:tag=&quot;custom_fragment&quot; /&gt; 设置 FragmentFactory 用于初始化在Fragment 声明的 FragmentContainerView class HostActivity : AppCompatActivity() { private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) { supportFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) setContentView(R.layout.activity_with_fragment_container_view) }} 动态添加： 使用 FragmentTransaction#add() 方法动态的添加 Fragment class HostActivity : AppCompatActivity() { private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) { supportFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) setContentView(R.layout.activity_with_empty_frame_layout) if (savedInstanceState == null) { supportFragmentManager.beginTransaction() .add(R.id.content, CustomFragment::class.java, arguments) .commit() } }} FragmentFactory 和嵌套的 Fragment如果 parent Fragment 包含嵌套的 Fragment 或者多层次嵌套的 Fragment，它们都会使用 parent Fragment 的相同 FragmentFactory，嵌套 Fragment 需要调用 Fragment#childFragmentManager.fragmentFactory class ParentFragment : Fragment() { override fun onCreate(savedInstanceState: Bundle?) { childFragmentManager.fragmentFactory = parentFragmentFactory super.onCreate(savedInstanceState) if (savedInstanceState == null) { // Add NestedFragment } }}class NestedFragment : Fragment() { override fun onCreate(savedInstanceState: Bundle?) { childFragmentManager.fragmentFactory = childFragmentFactory super.onCreate(savedInstanceState) if (savedInstanceState == null) { // Add NestedNestedFragment } }}class NestedNestedFragment : Fragment() 译者思考我们来总结一下 Fragment 几个重要的更新，以及在什么情况下使用： 之前 Fragment 的实例都是通过使用默认的空的构造函数进行实例化的，FragmentFactory 出现就是为了解决这个限制。 FragmentFactory 不是必须要使用的，如果在 Fragment 构造函数中接受参数，必须使用 FragmentFactory FragmentFactory 需要在 Activity 或者 Fragment 中使用，并且需要在 Activity#onCreate() 和 Fragment#onCreate() 之前和 FragmentManager 做关联 嵌套的 Fragment 或者多层次嵌套的 Fragment，使用的是相同 FragmentFactory 正因为 FragmentFactory 出现，可以在 Fragment 构造函数中传递参数，意味着可以使用 Koin 等框架，可以实现构造函数依赖注入，后面我会演示如何使用 接下来一起了解一下什么 FragmentContainerView，为什么 Google 强烈建议使用 FragmentContainerView 容器来存储动态添加的 Fragment。 FragmentContainerView 是什么？为什么 Google 强烈建议使用？我们先来看一下 Google 的更新说明： FragmentContainerView： FragmentContainerView 是一个自定义 View 继承 FrameLayout，与 ViewGroups 不同，它只接受 Fragment Views。 为什么 Google 强烈建议使用？ 之前在 Google issue 提了一个 fragment z-ordering 的问题，就是说 Fragment 进入和退出动画会导致一个问题，进入的 Fragment 会在退出的 Fragment下面，直到它完全退出屏幕，这会导致在 Fragment 之间切换时产生错误的动画。 使用 FragmentContainerView 带来的好处是改进了对 fragment z-ordering 的处理。这是 Google 演示的例子，优化了两个 Fragment 退出和进入过渡不会互相重叠，使用 FragmentContainerView 将先开启退出动画然后才是进入动画。 Koin 如何和 FragmentFactory 一起使用以及源码分析在之前的文章 [译][2.4K Start] 放弃 Dagger 拥抱 Koin 分析了 Koin 性能，如果没有看过，建议可以去了解一下。 Koin 团队在 2.1.0 版本开始支持 Fragment 的依赖注入，截图如下所示： 1. 添加 Koin Fragment 依赖 implementation &quot;org.koin:koin-androidx-fragment:2.1.5&quot; 2. 创建 Fragment 并传递 ViewModel class FragmentTest(val mainViewModel: MainViewModel) : Fragment(){ ......} 3. 创建 Fragment modules val viewModelsModule = module { viewModel { MainViewModel() }}val fragmentModules = module { fragment { FragmentTest(get()) }}val appModules = listOf(fragmentModules, viewModelsModule) 4. 在调用 startKoin 方法时设置 KoinFragmentFactory startKoin { AndroidLogger(Level.DEBUG) androidContext(this@App) fragmentFactory() loadKoinModules(appModules)} fragmentFactory 是 KoinApplication 的扩展函数，提供了 KoinFragmentFactory 代码如下所示： koin.loadModules(listOf(module { single&lt;FragmentFactory&gt; { KoinFragmentFactory() } }))} 一起来分析 KoinFragmentFactory 内部的源码： class KoinFragmentFactory(val scope: Scope? = null) : FragmentFactory(), KoinComponent { override fun instantiate(classLoader: ClassLoader, className: String): Fragment { val clazz = Class.forName(className).kotlin val instance = if (scope != null) { scope.getOrNull&lt;Fragment&gt;(clazz) }else{ getKoin().getOrNull&lt;Fragment&gt;(clazz) } return instance ?: super.instantiate(classLoader, className) }} 继承 FragmentFactory 并且重写了 FragmentFactory#instantiate() 方法，在这个函数中，我们使用 className 作为参数获取 Fragment，并尝试从 Koin 中检索 Fragment 实例 5. 在 onCreate 方法之前 调用 setupKoinFragmentFactory 绑定 FragmentFactory override fun onCreate(savedInstanceState: Bundle?) { setupKoinFragmentFactory() super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)} 6. 添加 Fragment 并传递 Bundle val arguments = Bundle().apply { putString(FragmentTest.KEY_NAME, &quot;来源于 MainActivity&quot;)}supportFragmentManager.beginTransaction() .replace(R.id.container, FragmentTest::class.java, arguments) .commit() 相关源码已经上传到 JDataBinding 中, 可以查看 App、MainActivity、AppModule 和 FragmentTest 这几个类 参考文献 https://github.com/InsertKoinIO/koin/issues/647 Android Fragments: FragmentFactory https://developer.android.com/jetpack/androidx/releases/fragment 推荐文章 [译][Google工程师] 刚刚发布了 Fragment 的新特性 “Fragment 间传递数据的新方式” 以及源码分析 [译][Google工程师] 详解 FragmentFactory 如何优雅使用 Koin 以及部分源码分析 [译][2.4K Start] 放弃 Dagger 拥抱 Koin [译][5k+] Kotlin 的性能优化那些事 [译] 解密 RxJava 的异常处理机制 [译][1.4K+ Star] Kotlin 新秀 Coil VS Glide and Picasso 更多……","link":"/2020/07/31/translate/02-fragment-data/"},{"title":"「译」Google 最新发布了 Fragment 的新特性 Fragment 间传递数据的新方式 以及源码分析","text":"前言 原标题: Android Fragments: Fragment Result 原地址: https://proandroiddev.com/android-fragments-fragment-result…… 原作者: Husayn Hakeem 译者：hi-dhl 本文已收录于仓库 Technical-Article-Translation 就在 2020/05/07 号 Now in Android #17 更新了，发布 Android 的新特性，其中就包括 Fragment 间通信的新方式，大家可以点击这里前往，看看都有那些更新 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 新 Fragment 间通信的方式的使用？ 新 Fragment 间通信的源码分析？ 汇总 Fragment 之间的通信的方式？ 译文Frrgament 间传递数据可以通过多种方式，包括使用 target Fragment APIs (Fragment.setTargetFragment() 和 Fragment.getTargetFragment())，ViewModel 或者 使用 Fragments’ 父容器 Activity，target Fragment APIs 已经过时了，现在鼓励使用新的 Fragment result APIs 完成 Frrgament 之间传递数据，其中传递数据由 FragmentManager 处理，并且在 Fragments 设置发送数据和接受数据 在 Frrgament 之间传递数据使用新的 Fragment APIs 在 两个 Frrgament 之间的传递，没有任何引用，可以使用它们公共的 FragmentManager，它充当 Frrgament 之间传递数据的中心存储。 接受数据如果想在 Fragment 中接受数据，可以在 FragmentManager 中注册一个 FragmentResultListener，参数 requestKey 可以过滤掉 FragmentManager 发送的数据 FragmentManager.setFragmentResultListener( requestKey, lifecycleOwner, FragmentResultListener { requestKey: String, result: Bundle -&gt; // Handle result }) 参数 lifecycleOwner 可以观察生命周期，当 Fragment 的生命周期处于 STARTED 时接受数据。如果监听 Fragment 的生命周期，您可以在接收到新数据时安全地更新 UI，因为 view 的创建(onViewCreated() 方法在 onStart() 之前被调用)。 当生命周期处于 LifecycleOwner STARTED 的状态之前，如果有多个数据传递，只会接收到最新的值 当生命周期处于 LifecycleOwner DESTROYED 时，它将自动移除 listener，如果想手动移除 listener，需要调用 FragmentManager.setFragmentResultListener() 方法，传递空的 FragmentResultListener 在 FragmentManager 中注册 listener，依赖于 Fragment 发送返回的数据 如果在 FragmentA 中接受 FragmentB 发送的数据，FragmentA 和 FragmentB 处于相同的层级，通过 parent FragmentManager 进行通信，FragmentA 必须使用 parent FragmentManager 注册 listener parentFragmentManager.setFragmentResultListener(...) 如果在 FragmentA 中接受 FragmentB 发送的数据，FragmentA 是 FragmentB 的父容器， 他们通过 child FragmentManager 进行通信 childFragmentManager.setFragmentResultListener(...) listener 必须设置的Fragment 相同的 FragmentManager 发送数据如果 FragmentB 发送数据给 FragmentA，需要在 FragmentA 中注册 listener，通过 parent FragmentManager 发送数据 parentFragmentManager.setFragmentResult( requestKey, // Same request key FragmentA used to register its listener bundleOf(key to value) // The data to be passed to FragmentA) 测试 Fragment Results测试 Fragment 是否成功接收或发送数据，可以使用 FragmentScenario API 接受数据如果在 FragmentA 中注册 FragmentResultListener 接受数据，你可以模拟 parent FragmentManager 发送数据，如果在 FragmentA 中正确注册了 listener，可以用来验证 FragmentA 是否能收到数据，例如，如果在 FragmentA 中接受数据并更新 UI, 可以使用 Espresso APIs 来验证是否期望的数据 @Testfun shouldReceiveData() { val scenario = FragmentScenario.launchInContainer(FragmentA::class.java) // Pass data using the parent fragment manager scenario.onFragment { fragment -&gt; val data = bundleOf(KEY_DATA to &quot;value&quot;) fragment.parentFragmentManager.setFragmentResult(&quot;aKey&quot;, data) } // Verify data is received, for example, by verifying it's been displayed on the UI onView(withId(R.id.textView)).check(matches(withText(&quot;value&quot;))) } 发送数据可以在 FragmentB 的 parent FragmentManager 上注册一个 FragmentResultListener 来测试 FragmentB 是否成功发送数据，当发送数据结束时，可以来验证这个 listener 是否能收到数据 @Testfun shouldSendData() { val scenario = FragmentScenario.launchInContainer(FragmentB::class.java) // Register result listener var receivedData = &quot;&quot; scenario.onFragment { fragment -&gt; fragment.parentFragmentManager.setFragmentResultListener( KEY, fragment, FragmentResultListener { key, result -&gt; receivedData = result.getString(KEY_DATA) }) } // Send data onView(withId(R.id.send_data)).perform(click()) // Verify data was successfully sent assertThat(receivedData).isEqualTo(&quot;value&quot;)} 示例项目下面的示例项目，展示了如何使用 Fragment 新的 API android-playground: https://github.com/husaynhakeem/android-playground… 总结虽然使用了 Fragment result APIs，替换了过时的 Fragment target APIs，但是新的 APIs 在Bundle 作为数据传传递方面有一些限制，只能传递简单数据类型、Serializable 和 Parcelable 数据，Fragment result APIs 允许程序从崩溃中恢复数据，而且不会持有对方的引用，避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 译者的思考这是译者的一些思考，总结一下 Fragment 1.3.0-alpha04 新增加的 Fragment 间通信的 API 数据接受 FragmentManager.setFragmentResultListener( requestKey, lifecycleOwner, FragmentResultListener { requestKey: String, result: Bundle -&gt; // Handle result }) 数据发送 parentFragmentManager.setFragmentResult( requestKey, // Same request key FragmentA used to register its listener bundleOf(key to value) // The data to be passed to FragmentA) 那么 Fragment 间通信的新 API 给我们带来哪些好处呢： 在 Fragment 之间传递数据，不会持有对方的引用 当生命周期处于 ON_START 时开始处理数据，避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 当生命周期处于 ON_DESTROY 时，移除监听 我们一起来从源码的角度分析一下 Google 是如何做的 源码分析按照惯例从调用的方法来分析，数据接受时，调用了 FragmentManager 的 setFragmentResultListener 方法androidx.fragment/fragment/1.3.0-alpha04……androidx/fragment/app/FragmentManager.java private final ConcurrentHashMap&lt;String, LifecycleAwareResultListener&gt; mResultListeners = new ConcurrentHashMap&lt;&gt;();@Overridepublic final void setFragmentResultListener(@NonNull final String requestKey, @NonNull final LifecycleOwner lifecycleOwner, @Nullable final FragmentResultListener listener) { // mResultListeners 是 ConcurrentHashMap 的实例，用来储存注册的 listener // 如果传递的参数 listener 为空时，移除 requestKey 对应的 listener if (listener == null) { mResultListeners.remove(requestKey); return; } // Lifecycle是一个生命周期感知组件，一般用来响应Activity、Fragment等组件的生命周期变化 final Lifecycle lifecycle = lifecycleOwner.getLifecycle(); // 当生命周期处于 DESTROYED 时，直接返回 // 避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 if (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) { return; } // 开始监听生命周期 LifecycleEventObserver observer = new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { // 当生命周期处于 ON_START 时开始处理数据 if (event == Lifecycle.Event.ON_START) { // 开始检查受到的数据 Bundle storedResult = mResults.get(requestKey); if (storedResult != null) { // 如果结果不为空，调用回调方法 listener.onFragmentResult(requestKey, storedResult); // 清除数据 setFragmentResult(requestKey, null); } } // 当生命周期处于 ON_DESTROY 时，移除监听 if (event == Lifecycle.Event.ON_DESTROY) { lifecycle.removeObserver(this); mResultListeners.remove(requestKey); } } }; lifecycle.addObserver(observer); mResultListeners.put(requestKey, new FragmentManager.LifecycleAwareResultListener(lifecycle, listener));} Lifecycle是一个生命周期感知组件，一般用来响应Activity、Fragment等组件的生命周期变化 获取 Lifecycle 去监听 Fragment 的生命周期的变化 当生命周期处于 ON_START 时开始处理数据，避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 当生命周期处于 ON_DESTROY 时，移除监听 接下来一起来看一下数据发送的方法，调用了 FragmentManager 的 setFragmentResult 方法androidx.fragment/fragment/1.3.0-alpha04……androidx/fragment/app/FragmentManager.java private final ConcurrentHashMap&lt;String, Bundle&gt; mResults = new ConcurrentHashMap&lt;&gt;();private final ConcurrentHashMap&lt;String, LifecycleAwareResultListener&gt; mResultListeners = new ConcurrentHashMap&lt;&gt;(); @Overridepublic final void setFragmentResult(@NonNull String requestKey, @Nullable Bundle result) { if (result == null) { // mResults 是 ConcurrentHashMap 的实例，用来存储数据传输的 Bundle // 如果传递的参数 result 为空，移除 requestKey 对应的 Bundle mResults.remove(requestKey); return; } // mResultListeners 是 ConcurrentHashMap 的实例，用来储存注册的 listener // 获取 requestKey 对应的 listener LifecycleAwareResultListener resultListener = mResultListeners.get(requestKey); if (resultListener != null &amp;&amp; resultListener.isAtLeast(Lifecycle.State.STARTED)) { // 如果 resultListener 不为空，并且生命周期处于 STARTED 状态时，调用回调 resultListener.onFragmentResult(requestKey, result); } else { // 否则保存当前传输的数据 mResults.put(requestKey, result); }} 获取 requestKey 注册的 listener 当生命周期处于 STARTED 状态时，开始发送数据 否则保存当前传输的数据 源码分析到这里结束了，我们一起来思考一下，在之前我们的都有那些数据传方式 汇总 Fragment 之间的通信的方式 通过共享 ViewModel 或者关联 Activity来完成，Fragment 之间不应该直接通信 参考 Google: ViewModel#sharing 通过接口，可以在 Fragment 定义接口，并在 Activity 实现它 参考 Google: 与其他 Fragment 通信 通过使用 findFragmentById 方法，获取 Fragment 的实例，然后调用 Fragment 的公共方法 参考 Google: 与其他 Fragment 通信 调用 Fragment.setTargetFragment() 和 Fragment.getTargetFragment() 方法，但是注意 target fragment 需要直接访问另一个 fragment 的实例，这是十分危险的，因为你不知道目标 fragment 处于什么状态 Fragment 新的 API, setFragmentResult() 和 setFragmentResultListener() 综合以上通信方式，那么你认为 Fragment 之间通信最好的方式是什么？ 参考文献 Now in Android #17: https://medium.com/androiddeve…… Pass data between fragments: https://developer.android.com/training/basi…… ViewModel#sharing: https://developer.android.com/topic/librari…… 与其他 Fragment 通信: https://developer.android.com/training/basic…… 推荐文章 [译][Google工程师] 刚刚发布了 Fragment 的新特性 “Fragment 间传递数据的新方式” 以及源码分析 [译][Google工程师] 详解 FragmentFactory 如何优雅使用 Koin 以及部分源码分析 [译][2.4K Start] 放弃 Dagger 拥抱 Koin [译][5k+] Kotlin 的性能优化那些事 [译] 解密 RxJava 的异常处理机制 [译][1.4K+ Star] Kotlin 新秀 Coil VS Glide and Picasso 更多……","link":"/2020/06/10/translate/01-fragment/"},{"title":"Android 10 源码分析：Window 的类型 以及 三维视图层级分析","text":"引言 这是 Android 10 源码分析系列的第 7 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 在之前的文章 0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构 介绍了 Activity、Window、PhoneWindow、WindowManager 之间的关系，以及 Activity 和 Dialog 的视图绑定过程，而这篇文章主要两个目的： 对上一篇文章 0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构 做深入的了解 为后面的篇文章「如何在 Andorid 系统里添加自定义 View」等等做好铺垫 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 Window 都有那些常用的参数? Window 都那些类型？每个类型的意思？以及作用？ Window 那些过时的 API 以及处理方案？ Window 视图层级顺序是如何确定的？ Window 都那些 flag？每个 flag 的意思？以及作用？ Window 的软键盘模式？每个模式的意思？以及如何使用？ Kotlin 小技巧？ 在开始分析之前，我们先来看一张图，熟悉一下几个基本概念，这些概念伴将随着整篇文章 我们在手机上看到的界面是二维的，但是实际上是一个三维，如上图所示 Window：是一个抽象类，它作为一个顶级视图添加到 WindowManager 中，View 是依附于 Window 而存在的，对 View 进行管理 WindowManager：它是一个接口，继承自接口 ViewManager，对 Window 进行管理 PhoneWindow：Window 唯一实现类，添加到 WindowManager 的根容器中 WindowManagerService：WindowManager 是 Window 的容器，管理着 Window，对 Window 进行添加和删除，最终具体的工作都是由 WindowManagerService 来处理的，WindowManager 和 WindowManagerService 通过 Binder 来进行跨进程通信，WindowManagerService 才是 Window 的最终管理者 这篇文章重要知识点是 Window 视图层级顺序是如何确定的，其他内容都是一些概念的东西，可以选择性的阅读，了解完基本概念之后，进入这篇文章的核心内容，我们先来了解一下 Window 都有那些常用的参数 Window 都有那些常用的参数Window 的参数都被定义在 WindowManager 的静态内部类 LayoutParams 中frameworks/base/core/java/android/view/WindowManager#LayoutParams.java public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable { // window 左上角的 x 坐标 public int x; // window 左上角的 y 坐标 public int y; // Window 的类型 public int type; // Window 的 flag 用于控制 Window 的显示 public int flags; // window 软键盘输入区域的显示模式 public int softInputMode; // window 的透明度，取值为0-1 public float alpha = 1.0f; // window 在屏幕中的位置 public int gravity; // window 的像素点格式，值定义在 PixelFormat 中 public int format;} 接下来我们我们主要来介绍一下 Window 的类型、Window 视图层级顺序、Window 的 flag、和 window 软键盘模式 Window 都那些类型以及作用Window 的类型大概可以分为三类： 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window）， Window 的类型通过 type 值来表示，每个大类型又包含多个小类型，它们都定义在 WindowManager 的静态内部类 LayoutParamsframeworks/base/core/java/android/view/WindowManager#LayoutParams.java public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable { public int type; // 应用程序 Window 的开始值 public static final int FIRST_APPLICATION_WINDOW = 1; // 应用程序 Window 的结束值 public static final int LAST_APPLICATION_WINDOW = 99; // 子 Window 类型的开始值 public static final int FIRST_SUB_WINDOW = 1000; // 子 Window 类型的结束值 public static final int LAST_SUB_WINDOW = 1999; // 系统 Window 类型的开始值 public static final int FIRST_SYSTEM_WINDOW = 2000; // 系统 Window 类型的结束值 public static final int LAST_SYSTEM_WINDOW = 2999;} 类型 值 备注 FIRST_APPLICATION_WINDOW 1 应用程序 Window 的开始值 LAST_APPLICATION_WINDOW 99 应用程序 Window 的结束值 FIRST_SUB_WINDOW 1000 子 Window 的开始值 LAST_SUB_WINDOW 1999 子 Window 的结束值 FIRST_SYSTEM_WINDOW 2000 系统 Window 的开始值 LAST_SYSTEM_WINDOW 2999 系统 Window 的结束值 小技巧：如果是层级在 2000（FIRST_SYSTEM_WINDOW）以下的是不需要申请弹窗权限的 应用程序 Window（Application Window）：它的区间范围 [1,99]，例如 Activityframeworks/base/core/java/android/view/WindowManager#LayoutParams.java // 应用程序 Window 的开始值public static final int FIRST_APPLICATION_WINDOW = 1;// 应用程序 Window 的基础值public static final int TYPE_BASE_APPLICATION = 1;// 普通的应用程序public static final int TYPE_APPLICATION = 2;// 特殊的应用程序窗口，当程序可以显示 Window 之前使用这个 Window 来显示一些东西public static final int TYPE_APPLICATION_STARTING = 3;// TYPE_APPLICATION 的变体，在应用程序显示之前，WindowManager 会等待这个 Window 绘制完毕public static final int TYPE_DRAWN_APPLICATION = 4;// 应用程序 Window 的结束值public static final int LAST_APPLICATION_WINDOW = 99; 类型 备注 FIRST_APPLICATION_WINDOW 应用程序 Window 的开始值 TYPE_BASE_APPLICATION 应用程序 Window 的基础值 TYPE_APPLICATION 普通的应用程序 TYPE_APPLICATION_STARTING 特殊的应用程序窗口，当程序可以显示 Window 之前使用这个 Window 来显示一些东西 TYPE_DRAWN_APPLICATION TYPE_APPLICATION 的变体 在应用程序显示之前，WindowManager 会等待这个 Window 绘制完毕 LAST_APPLICATION_WINDOW 应用程序 Window 的结束值 子 Window（Sub Windwow）：它的区间范围 [1000,1999]，这些 Window 按照 Z-order 顺序依附于父 Window 上（关于 Z-order 后文有介绍），并且他们的坐标空间相对于父 Window 的，例如：PopupWindowframeworks/base/core/java/android/view/WindowManager#LayoutParams.java // 子 Window 类型的开始值public static final int FIRST_SUB_WINDOW = 1000;// 应用程序 Window 顶部的面板。这些 Window 出现在其附加 Window 的顶部。public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;// 用于显示媒体(如视频)的 Window。这些 Window 出现在其附加 Window 的后面。public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1;// 应用程序 Window 顶部的子面板。这些 Window 出现在其附加 Window 和任何Window的顶部public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;// 当前Window的布局和顶级Window布局相同时，不能作为子代的容器public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3;// 用显示媒体 Window 覆盖顶部的 Window， 这是系统隐藏的 APIpublic static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4;// 子面板在应用程序Window的顶部，这些Window显示在其附加Window的顶部， 这是系统隐藏的 APIpublic static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5;// 子 Window 类型的结束值public static final int LAST_SUB_WINDOW = 1999; 类型 备注 FIRST_SUB_WINDOW 子 Window 的开始值 TYPE_APPLICATION_PANEL 应用程序 Window 顶部的面板，这些 Window 出现在其附加 Window 的顶部 TYPE_APPLICATION_MEDIA 用于显示媒体(如视频)的 Window，这些 Window 出现在其附加 Window 的后面 TYPE_APPLICATION_SUB_PANEL 应用程序 Window 顶部的子面板，这些 Window 出现在其附加 Window 和任何Window的顶部 TYPE_APPLICATION_ATTACHED_DIALOG 当前Window的布局和顶级Window布局相同时，不能作为子代的容器 TYPE_APPLICATION_MEDIA_OVERLAY 用显示媒体 Window 覆盖顶部的 Window， 这是系统隐藏的 API TYPE_APPLICATION_ABOVE_SUB_PANEL 子面板在应用程序Window的顶部，这些Window显示在其附加Window的顶部， 这是系统隐藏的 API LAST_SUB_WINDOW 子 Window 的结束值 系统 Window（System Window）: 它区间范围 [2000,2999]，例如：Toast，输入法窗口，系统音量条窗口，系统错误窗口frameworks/base/core/java/android/view/WindowManager#LayoutParams.java // 系统Window类型的开始值public static final int FIRST_SYSTEM_WINDOW = 2000;// 系统状态栏，只能有一个状态栏，它被放置在屏幕的顶部，所有其他窗口都向下移动public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW;// 系统搜索窗口，只能有一个搜索栏，它被放置在屏幕的顶部public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_SYSTEM_ALERT = FIRST_SYSTEM_WINDOW+3;// 已经从系统中被移除，可以使用 TYPE_KEYGUARD_DIALOG 代替public static final int TYPE_KEYGUARD = FIRST_SYSTEM_WINDOW+4;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_TOAST = FIRST_SYSTEM_WINDOW+5;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW+6;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_PRIORITY_PHONE = FIRST_SYSTEM_WINDOW+7;// 系统对话框窗口public static final int TYPE_SYSTEM_DIALOG = FIRST_SYSTEM_WINDOW+8;// 锁屏时显示的对话框public static final int TYPE_KEYGUARD_DIALOG = FIRST_SYSTEM_WINDOW+9;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_SYSTEM_ERROR = FIRST_SYSTEM_WINDOW+10;// 输入法窗口，位于普通 UI 之上，应用程序可重新布局以免被此窗口覆盖public static final int TYPE_INPUT_METHOD = FIRST_SYSTEM_WINDOW+11;// 输入法对话框，显示于当前输入法窗口之上public static final int TYPE_INPUT_METHOD_DIALOG= FIRST_SYSTEM_WINDOW+12;// 墙纸public static final int TYPE_WALLPAPER = FIRST_SYSTEM_WINDOW+13;// 状态栏的滑动面板public static final int TYPE_STATUS_BAR_PANEL = FIRST_SYSTEM_WINDOW+14;// 应用程序叠加窗口显示在所有窗口之上public static final int TYPE_APPLICATION_OVERLAY = FIRST_SYSTEM_WINDOW + 38;// 系统Window类型的结束值public static final int LAST_SYSTEM_WINDOW = 2999; 类型 备注 FIRST_SYSTEM_WINDOW 系统 Window 类型的开始值 TYPE_STATUS_BAR 系统状态栏，只能有一个状态栏，它被放置在屏幕的顶部，所有其他窗口都向下移动 TYPE_SEARCH_BAR 系统搜索窗口，只能有一个搜索栏，它被放置在屏幕的顶部 TYPE_PHONE API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_SYSTEM_ALERT API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_KEYGUARD 已经从系统中被移除，可以使用 TYPE_KEYGUARD_DIALOG 代替 TYPE_TOAST API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_SYSTEM_OVERLAY API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_PRIORITY_PHONE API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_SYSTEM_ERROR API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_APPLICATION_OVERLAY 应用程序叠加窗口显示在所有窗口之上 TYPE_SYSTEM_DIALOG 系统对话框窗口 TYPE_KEYGUARD_DIALOG 锁屏时显示的对话框 TYPE_INPUT_METHOD 输入法窗口，位于普通 UI 之上，应用程序可重新布局以免被此窗口覆盖 TYPE_INPUT_METHOD_DIALOG 输入法对话框，显示于当前输入法窗口之上 TYPE_WALLPAPER 墙纸 TYPE_STATUS_BAR_PANEL 状态栏的滑动面板 LAST_SYSTEM_WINDOW 系统 Window 类型的结束值 需要注意的是： TYPE_PHONE、TYPE_SYSTEM_ALERT、TYPE_TOAST、TYPE_SYSTEM_OVERLAY、TYPE_PRIORITY_PHONE、TYPE_SYSTEM_ERROR 这些 type 在 API 26 中均已经过时，使用 TYPE_APPLICATION_OVERLAY 代替，需要申请 Manifest.permission.SYSTEM_ALERT_WINDOW 权限 TYPE_KEYGUARD 已经被从系统中移除，可以使用 TYPE_KEYGUARD_DIALOG 来代替 Window 视图层级顺序我们在手机上看的是二维的，但是实际上是三维的显示，如下图所示 在文章开头介绍了参数类型包含了 Window 的 x 轴坐标、Window 的 y 轴坐标， 既然是一个三维坐标系，那么 z 轴坐标在哪里？ 接下来就是我们要分析的非常重要的一个类 WindowManagerService，当添加 Window 的时候已经确定好了 Window 的层级，显示的时候才会根据当前的层级确定 Window 应该在哪一层显示 WindowManager 是 Window 的容器，管理着 Window，对 Window 进行添加和删除，具体的工作都是由 WMS 来处理的，WindowManager 和 WMS 通过 Binder 来进行跨进程通信，WMS 才是 Window 的最终管理者，我先来看一下 WMS 的 addWindow 方法frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java public int addWindow(Session session, IWindow client, int seq, LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel, InsetsState outInsetsState) { final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow); ...... win.mToken.addWindow(win); ...... win.getParent().assignChildLayers(); ...... } WindowState 计算当前 Window 层级 win.mToken.addWindow 这个方法将当前的 win 放入 WindowList 中，WindowList 是一个 ArrayList displayContent.assignWindowLayers 方法 计算 z-order 值, z-order 值越大越靠前，就越靠近用户 Window 视图层级顺序 用 Z-order 来表示，Z-order 对应着 WindowManager.LayoutParams 的 type 值，Z-order 可以理解为 Android 视图的层级概念，值越大越靠前，就越靠近用户。 WindowState 就是 windowManager 中的窗口，一个 WindowState 表示一个 window 那么 Z-order 的值的计算逻辑在 WindowState 类中，WindowState 构造的时候初始化当前的 mBaseLayer 和 mSubLayer，这两个参数应该是决定 z-order 的两个因素frameworks/base/services/core/java/com/android/server/wm/WindowState.java static final int TYPE_LAYER_MULTIPLIER = 10000;static final int TYPE_LAYER_OFFSET = 1000; WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token, WindowState parentWindow, int appOp, int seq, WindowManager.LayoutParams a, int viewVisibility, int ownerId, boolean ownerCanAddInternalSystemWindow, PowerManagerWrapper powerManagerWrapper) { // 判断该是否在子 Window 的类型范围内[1000,1999] if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) { // 调用 getWindowLayerLw 方法返回值在[1,33]之间，根据不同类型的 Window 在屏幕上进行排序 mBaseLayer = mPolicy.getWindowLayerLw(parentWindow) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; // mSubLayer 子窗口的顺序 // 调用 getSubWindowLayerFromTypeLw 方法返回值在[-2.3]之间 ，返回子 Window 相对于父 Window 的位置 mSubLayer = mPolicy.getSubWindowLayerFromTypeLw(a.type); ...... } else { mBaseLayer = mPolicy.getWindowLayerLw(this) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; mSubLayer = 0; ...... } } mBaseLayer 是基础序，对应的区间范围 [1,33] mSubLayer 相同分组下的子 Window 的序，对应的区间范围 [-2.3] 判断该是否在子 Window 的类型范围内[1000,1999] 如果是子 Window，调用 getWindowLayerLw 方法，计算 mBaseLayer 的值，返回一个用来对 Window 进行排序的任意整数，调用 getSubWindowLayerFromTypeLw 方法，计算 mSubLayer 的值，返回子 Window 相对于父 Window 的位置 如果不是子 Window，调用 getWindowLayerLw 方法，计算 mBaseLayer 的值，返回一个用来对 Window 进行排序的任意整数，mSubLayer 值为 0 计算 mBaseLayer 的值调用 WindowManagerPolicy 的 getWindowLayerLw 方法，计算 mBaseLayer 的值frameworks/base/services/core/java/com/android/server/policy/WindowManagerPolicy.java int APPLICATION_LAYER = 2;int APPLICATION_MEDIA_SUBLAYER = -2;int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1;int APPLICATION_PANEL_SUBLAYER = 1;int APPLICATION_SUB_PANEL_SUBLAYER = 2;int APPLICATION_ABOVE_SUB_PANEL_SUBLAYER = 3; /*** 根据不同类型的 Window 在屏幕上进行排序* 返回一个用来对窗口进行排序的任意整数，数字越小，表示的值越小*/ default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) { // 判断是否在应用程序 Window 类型的取值范围内 [1,99] if (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) { return APPLICATION_LAYER; } switch (type) { case TYPE_WALLPAPER: // 壁纸，通过 window manager 删除它 return 1; case TYPE_PHONE: // 电话 return 3; case TYPE_SEARCH_BAR: // 搜索栏 return 6; case TYPE_SYSTEM_DIALOG: // 系统的 dialog return 7; case TYPE_TOAST: // 系统 toast return 8; case TYPE_INPUT_METHOD: // 输入法 return 15; case TYPE_STATUS_BAR: // 状态栏 return 17; case TYPE_KEYGUARD_DIALOG: //锁屏 return 20; ...... case TYPE_POINTER: // the (mouse) pointer layer return 33; default: return APPLICATION_LAYER; }} 根据不同类型的 Window 在屏幕上进行排序，返回一个用来对 Window 进行排序的任意整数，数字越小，表示的值越小，通过以下公式来计算它的基础序 ，基础序越大，Z-order 值越大越靠前，就越靠近用户，我们以 Activity 为例： Activity 属于应用层 Window，它的取值范围在 [1,99] 内，调用 getWindowLayerLw 方法返回 APPLICATION_LAYER，APPLICATION_LAYER 值为 2，通过下面方法进行计算 static final int TYPE_LAYER_MULTIPLIER = 10000;static final int TYPE_LAYER_OFFSET = 1000;mBaseLayer = mPolicy.getWindowLayerLw(parentWindow) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; 那么最终 Activity 的 mBaseLayer 值是 21000 计算 mSubLayer 的值调用 getSubWindowLayerFromTypeLw 方法 ，传入 WindowManager.LayoutParams 的实例 a 的 type 值，计算 mSubLayer 的值frameworks/base/services/core/java/com/android/server/policy/WindowManagerPolicy.java int APPLICATION_LAYER = 2;int APPLICATION_MEDIA_SUBLAYER = -2;int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1;int APPLICATION_PANEL_SUBLAYER = 1;int APPLICATION_SUB_PANEL_SUBLAYER = 2;int APPLICATION_ABOVE_SUB_PANEL_SUBLAYER = 3;/*** 计算 Window 相对于父 Window 的位置* 返回 一个整数，正值在前面，表示在父 Window 上面，负值在后面，表示在父 Window 的下面*/default int getSubWindowLayerFromTypeLw(int type) { switch (type) { case TYPE_APPLICATION_PANEL: // 1000 case TYPE_APPLICATION_ATTACHED_DIALOG: // 1003 return APPLICATION_PANEL_SUBLAYER; // return 1 case TYPE_APPLICATION_MEDIA:// 1001 return APPLICATION_MEDIA_SUBLAYER;// return -2 case TYPE_APPLICATION_MEDIA_OVERLAY: return APPLICATION_MEDIA_OVERLAY_SUBLAYER; // return -1 case TYPE_APPLICATION_SUB_PANEL:// 1002 return APPLICATION_SUB_PANEL_SUBLAYER;// return 2 case TYPE_APPLICATION_ABOVE_SUB_PANEL: return APPLICATION_ABOVE_SUB_PANEL_SUBLAYER;// return 3 } return 0;} 计算子 Window 相对于父 Window 的位置，返回一个整数，正值表示在父 Window 上面，负值表示在父 Window 的下面 Window 的 flagWindow 的 flag 用于控制 Window 的显示，它们的值也是定义在 WindowManager 的内部类 LayoutParams 中frameworks/base/core/java/android/view/WindowManager#LayoutParams.java // 当 Window 可见时允许锁屏public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = 0x00000001;// Window 后面的内容都变暗public static final int FLAG_DIM_BEHIND = 0x00000002;@Deprecated// API 已经过时，Window 后面的内容都变模糊public static final int FLAG_BLUR_BEHIND = 0x00000004;// Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的// Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODALpublic static final int FLAG_NOT_FOCUSABLE = 0x00000008;// 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件// Window 之外的 view 也是可以响应 touch 事件。public static final int FLAG_NOT_TOUCH_MODAL = 0x00000020;// 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口。public static final int FLAG_NOT_TOUCHABLE = 0x00000010;// 只要 Window 可见时屏幕就会一直亮着public static final int FLAG_KEEP_SCREEN_ON = 0x00000080;// 允许 Window 占满整个屏幕public static final int FLAG_LAYOUT_IN_SCREEN = 0x00000100;// 允许 Window 超过屏幕之外public static final int FLAG_LAYOUT_NO_LIMITS = 0x00000200;// 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示public static final int FLAG_FULLSCREEN = 0x00000400;// 表示比FLAG_FULLSCREEN低一级，会显示状态栏public static final int FLAG_FORCE_NOT_FULLSCREEN = 0x00000800;// 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件public static final int FLAG_IGNORE_CHEEK_PRESSES = 0x00008000;// 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件。public static final int FLAG_WATCH_OUTSIDE_TOUCH = 0x00040000;@Deprecated// 窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;// 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制，// 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色。public static final int FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS = 0x80000000;// 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸public static final int FLAG_SHOW_WALLPAPER = 0x00100000; flag 备注 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON 当 Window 可见时允许锁屏 FLAG_DIM_BEHIND Window 后面的内容都变暗 FLAG_BLUR_BEHIND API 已经过时，Window 后面的内容都变模糊 FLAG_NOT_FOCUSABLE Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的，Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL FLAG_NOT_TOUCH_MODAL 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件，Window 之外的 view 也是可以响应 touch 事件 FLAG_NOT_TOUCHABLE 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口 FLAG_KEEP_SCREEN_ON 只要 Window 可见时屏幕就会一直亮着 FLAG_LAYOUT_IN_SCREEN 允许 Window 占满整个屏幕 FLAG_LAYOUT_NO_LIMITS 允许 Window 超过屏幕之外 FLAG_FULLSCREEN 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示 FLAG_FORCE_NOT_FULLSCREEN 表示比FLAG_FULLSCREEN低一级，会显示状态栏 FLAG_IGNORE_CHEEK_PRESSES 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件 FLAG_WATCH_OUTSIDE_TOUCH 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件 FLAG_SHOW_WHEN_LOCKED 已经过时，窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制， 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色 FLAG_SHOW_WALLPAPER 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸 window 软键盘模式表示 window 软键盘输入区域的显示模式，常见的情况 Window 的软键盘打开会占据整个屏幕，遮挡了后面的视图，例如看直播的时候底部有个输入框点击的时候，输入框随着键盘一起上来，而有的时候，希望键盘覆盖在所有的 View 之上，界面保持不动等等 软键盘模式(SoftInputMode) 值，与 AndroidManifest 中 Activity 的属性 android:windowSoftInputMode 是对应的，因此可以在 AndroidManifest 文件中为 Activity 设置android:windowSoftInputMode &lt;activity android:windowSoftInputMode=&quot;adjustNothing&quot; /&gt; 也可以在 Java 代码中为 Window 设置 SoftInputMode getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING); SoftInputMode 常用的有以下几个值 // 不会改变软键盘的状态public static final int SOFT_INPUT_STATE_UNCHANGED = 1;// 当用户进入该窗口时，隐藏软键盘public static final int SOFT_INPUT_STATE_HIDDEN = 2;// 当窗口获取焦点时，隐藏软键盘public static final int SOFT_INPUT_STATE_ALWAYS_HIDDEN = 3;// 当用户进入窗口时，显示软键盘public static final int SOFT_INPUT_STATE_VISIBLE = 4;// 当窗口获取焦点时，显示软键盘public static final int SOFT_INPUT_STATE_ALWAYS_VISIBLE = 5;// window会调整大小以适应软键盘窗口public static final int SOFT_INPUT_MASK_ADJUST = 0xf0;// 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置public static final int SOFT_INPUT_ADJUST_UNSPECIFIED = 0x00;// 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方// 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用；// 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏。public static final int SOFT_INPUT_ADJUST_RESIZE = 0x10;// 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的,// 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方// 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用public static final int SOFT_INPUT_ADJUST_PAN = 0x20;// 将不会调整大小，直接覆盖在window上public static final int SOFT_INPUT_ADJUST_NOTHING = 0x30; model 备注 SOFT_INPUT_STATE_UNCHANGED 不会改变软键盘的状态 SOFT_INPUT_STATE_VISIBLE 当用户进入窗口时，显示软键盘 SOFT_INPUT_STATE_HIDDEN 当用户进入该窗口时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_HIDDEN 当窗口获取焦点时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_VISIBLE 当窗口获取焦点时，显示软键盘 SOFT_INPUT_MASK_ADJUST window 会调整大小以适应软键盘窗口 SOFT_INPUT_ADJUST_UNSPECIFIED 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置 SOFT_INPUT_ADJUST_RESIZE 1. 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方 2. 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用 3. 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏 SOFT_INPUT_ADJUST_PAN 1. 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的 2. 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方 3. 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用 SOFT_INPUT_ADJUST_NOTHING 将不会调整大小，直接覆盖在window上 Kotlin 小技巧利用 plus (+) 和 plus (-) 对 Map 集合做运算，如下所示： fun main() { val numbersMap = mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3) // plus (+) println(numbersMap + Pair(&quot;four&quot;, 4)) // {one=1, two=2, three=3, four=4} println(numbersMap + Pair(&quot;one&quot;, 10)) // {one=10, two=2, three=3} println(numbersMap + Pair(&quot;five&quot;, 5) + Pair(&quot;one&quot;, 11)) // {one=11, two=2, three=3, five=5} // plus (-) println(numbersMap - &quot;one&quot;) // {two=2, three=3} println(numbersMap - listOf(&quot;two&quot;, &quot;four&quot;)) // {one=1, three=3}} 总结到这里就结束了，这篇文章主要介绍了 Window 的类型大概可以分为三类： 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window）。 分别介绍了 Window 的类型、Window 视图层级顺序、Window 的 flag、和 window 软键盘模式为后面的内容做铺垫 Window 都有那些常用的参数? 参数 备注 x window 左上角的 x 坐标 y window 左上角的 y 坐标 type Window 的类型 flag Window 的 flag 用于控制 Window 的显示 softInputMode window 软键盘输入区域的显示模式 alpha Window 的透明度，取值为0-1 gravity Window 在屏幕中的位置 alpha Window 的透明度，取值为0-1 format Window 的像素点格式，值定义在 PixelFormat 中 Window 都有那些类型？ 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window），子 Window 依附于父 Window 上，并且他们的坐标空间相对于父 Window 的，每个大类型又包含多个小类型，每个类型在上文的表格中已经列出来了， Window 那些过时的 API 以及处理方案？ TYPE_PHONE、TYPE_SYSTEM_ALERT、TYPE_TOAST、TYPE_SYSTEM_OVERLAY、TYPE_PRIORITY_PHONE、TYPE_SYSTEM_ERROR 这些 type 在 API 26 中均已经过时，使用 TYPE_APPLICATION_OVERLAY 代替，需要申请 Manifest.permission.SYSTEM_ALERT_WINDOW 权限 TYPE_KEYGUARD 已经被从系统中移除，可以使用 TYPE_KEYGUARD_DIALOG 来代替 Window 视图层级顺序是如何确定的？ Window 的参数 x、y，分别表示 Window 左上角的 x 坐标，Window 左上角的 y 坐标，Window 视图层级顺序 用 Z-order 来表示，Z-order 对应着 WindowManager.LayoutParams 的 type 值，Z-order 可以理解为 Android 视图的层级概念，值越大越靠前，就越靠近用户。而 mBaseLayer 和 mSubLayer 决定 z-order 的两个因素 Window 都那些 flag？ Window 的 flag 用于控制 Window 的显示，flag 的参数如下所示： flag 备注 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON 当 Window 可见时允许锁屏 FLAG_DIM_BEHIND Window 后面的内容都变暗 FLAG_BLUR_BEHIND API 已经过时，Window 后面的内容都变模糊 FLAG_NOT_FOCUSABLE Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的，Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL FLAG_NOT_TOUCH_MODAL 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件，Window 之外的 view 也是可以响应 touch 事件 FLAG_NOT_TOUCHABLE 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口 FLAG_KEEP_SCREEN_ON 只要 Window 可见时屏幕就会一直亮着 FLAG_LAYOUT_IN_SCREEN 允许 Window 占满整个屏幕 FLAG_LAYOUT_NO_LIMITS 允许 Window 超过屏幕之外 FLAG_FULLSCREEN 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示 FLAG_FORCE_NOT_FULLSCREEN 表示比FLAG_FULLSCREEN低一级，会显示状态栏 FLAG_IGNORE_CHEEK_PRESSES 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件 FLAG_WATCH_OUTSIDE_TOUCH 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件 FLAG_SHOW_WHEN_LOCKED 已经过时，窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制， 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色 FLAG_SHOW_WALLPAPER 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸 Window 软键盘模式？ Window 的软键盘模式表示 Window 软键盘输入区域的显示模式 model 备注 SOFT_INPUT_STATE_UNCHANGED 不会改变软键盘的状态 SOFT_INPUT_STATE_VISIBLE 当用户进入窗口时，显示软键盘 SOFT_INPUT_STATE_HIDDEN 当用户进入该窗口时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_HIDDEN 当窗口获取焦点时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_VISIBLE 当窗口获取焦点时，显示软键盘 SOFT_INPUT_MASK_ADJUST window 会调整大小以适应软键盘窗口 SOFT_INPUT_ADJUST_UNSPECIFIED 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置 SOFT_INPUT_ADJUST_RESIZE 1. 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方 2. 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用 3. 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏 SOFT_INPUT_ADJUST_PAN 1. 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的 2. 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方 3. 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用 SOFT_INPUT_ADJUST_NOTHING 将不会调整大小，直接覆盖在window上 参考文献 https://developer.android.google.cn/…/WindowManager.LayoutParams https://www.jianshu.com/p/3528255475a2","link":"/2020/06/07/android10/window-manager/07-WindowManagerService/"},{"title":"Android 10 源码分析：WindowManager 视图绑定以及体系结构","text":"引言 这是 Android 10 源码分析系列的第 6 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 Acivity 和 Dialog 视图解析绑定过程？ Activity 的视图如何与 Window 关联的？ Window 如何与 WindowManager 关联？ Dialog 的视图如何与 Window 关联？ 本文主要分析 Activity、Window、PhoneWindow、WindowManager 之间的关系，为我们后面的文章 「如何在 Andorid 系统里添加自定义View」 等等文章奠定基础，先来了解一下它们的基本概念 Activity：应用视图的容器。 WindowManager：它是一个接口类，继承自接口 ViewManager，对 Window 进行管理 Window：它是一个抽象类，它作为一个顶级视图添加到 WindowManager 中，对 View 进行管理 PhoneWindow：Window唯一实现类，Window是一个抽象概念，添加到WindowManager的根容器 DecorView: 它是 PhoneWindow 内部的一个成员变量，继承自 FrameLayout，FrameLayout 继承自 ViewGroup 在分析他们之前的关系之前，我们先来回顾一下 Acivity 和 Dialog 视图解析绑定的过程 Acivity 和 Dialog 视图解析绑定的过程Acivity 和 Dialog 相关的文章： 0xA03 Android 10 源码分析：APK 加载流程之资源加载 0xA04 Android 10 源码分析：APK 加载流程之资源加载（二） 0xA05 Android 10 源码分析：Dialog 加载绘制流程以及在 Kotlin、DataBinding 中的使用 在之前的文章 分别介绍了 Acivity 和 自定义 Dialog 视图的解析和绑定，总的来说分为三步 调用 LayoutInflater 的 inflate 方法，深度优先遍历解析 View 调用 ViewGroup 的 addView 方法将子 View 添加到根布局中 调用 WindowManager 的 addView 方法添加根布局 LayoutInflater 的 inflate 方法有多个重载的方法，常用的是下面三个参数的方法frameworks/base/core/java/android/view/LayoutInflater.java public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null);} resource：要解析的 xml 布局文件 Id root：表示根布局 attachToRoot：是否要添加到父布局 root 中 resource 其实很好理解就是资源 Id，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 当 View 解析完成之后，最后会调用 WindowManager 的 addView 方法，WindowManager 是一个接口类，继承自接口 ViewManager，用来管理 Window，它的实现类为 WindowManagerImpl，所以调用 WindowManager 的 addView 方法，实际上调用的是 WindowManagerImpl 的 addView 方法frameworks/base/core/java/android/view/WindowManagerImpl.java public final class WindowManagerImpl implements WindowManager { @UnsupportedAppUsage // 单例的设计模式 private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; private final Window mParentWindow; ...... public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); // mGlobal 是 WindowManagerGlobal 的实例 mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); } ...... } mGlobal 是 WindowManagerGlobal 的实例，使用的单例设计模式，参数 mParentWindow 是 Window 的实例，实际上是委托给 WindowManagerGlobal 去实现的 到这里我们关于 Acivity 和 Dialog 视图的解析和添加过程大概介绍完了，关于 Dialog 的视图如何与 Window 绑定在 0xA05 Android 10 源码分析：Dialog 加载绘制流程以及在 Kotlin、DataBinding 中的使用 文章中介绍了，接下来分析一下 Activity、Window、WindowManager 的关系 Activity、Window、WindowManager 的关系在 Activity 内部维护着一个 Window 的实例变量 mWindowframeworks/base/core/java/android/app/Activity.java public class Activity extends ContextThemeWrappe{ private Window mWindow;} Window 是一个抽象类，它的具体实现类为 PhoneWindow，在 Activity 的 attach 方法中给 Window 的实例变量 mWindow 赋值 frameworks/base/core/java/android/app/Activity.java final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); } 创建了 PhoneWindow 并赋值给 mWindow 调用 PhoneWindow 的 setWindowManager 方法，这个方法的具体实现发生在 Window 中，最终调用的是 Window 的 setWindowManager 方法 frameworks/base/core/java/android/view/Window.java public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { ...... // mWindowManager 是 WindowManagerImpl的实例变量 mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);} 将 WindowManager 转换为 WindowManagerImpl，之后调用 createLocalWindowManager 方法，并传递当前的 Window 对象，构建 WindowManagerImpl 对象，之后赋值给 mWindowManagerframeworks/base/core/java/android/view/WindowManagerImpl.java public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mContext, parentWindow);} 其实在 createLocalWindowManager 方法中，就做了一件事，将 Window 作为参数构建了一个 WindowManagerImpl 对象返还给调用处 总的来说，其实就是在 Activity 的 attach 方法中，通过调用 Window 的 setWindowManager 方法将 Window 和 WindowManager 关联在了一起 PhoneWindow 是 Window 的实现类，它是一个窗口，本身并不具备 View 相关的能力，实际上在 PhoneWindow 内部维护这一个变量 mDecorframeworks/base/core/java/com/android/internal/policy/PhoneWindow.java public class PhoneWindow extends Window{ // This is the top-level view of the window, containing the window decor. private DecorView mDecor; private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { // 完成DecorView的实例化 mDecor = generateDecor(-1); ...... } if (mContentParent == null) { // 调用 generateLayout 方法 要负责了DecorView的初始设置，诸如主题相关的feature、DecorView的背景 mContentParent = generateLayout(mDecor); } ...... } // 完成DecorView的实例化 protected DecorView generateDecor(int featureId) { ...... return new DecorView(context, featureId, this, getAttributes()); } // 调用 generateLayout 方法 要负责了DecorView的初始设置， // 诸如主题相关的feature、DecorView的背景，同时也初始化 contentParent protected ViewGroup generateLayout(DecorView decor) { ...... ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ...... }} mDecor 是 window 的顶级视图，它继承自 FrameLayout，它的创建过程由 installDecor 完成，然后在 installDecor 方法中通过 generateDecor 方法来完成DecorView的实例化 调用 generateLayout 方法 要负责了DecorView的初始设置，诸如主题相关的feature、DecorView的背景，同时也初始化 contentParent mDecor 它实际上是一个 ViewGroup，当在 Activity 中调用 setContentView 方法，通过调用 inflater 方法把布局资源转换为一个 View，然后添加到 DecorView 的 mContenParnent 中 当 View 初始化完成之后，最后会进入 ActivityThread 的 handlerResumeActivity 方法，执行了r.activity.makeVisible()方法frameworks/base/core/java/android/app/ActivityThread.java public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { ...... if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } ...... } 最终调用 Activity 的 makeVisible 方法，把 decorView 添加到 WindowManage 中frameworks/base/core/java/android/app/Activity.java void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE);} 到这里他们之间的关系明确了： 一个 Activity 持有一个 PhoneWindow 的对象，而一个 PhoneWindow 对象持有一个 DecorView 的实例 PhoneWindow 继承自 Window，一个 Window 对象内部持有 mWindowManager 的实例，通过调用 setWindowManager 方法与 WindowManager 关联在一起 WindowManager 继承自 ViewManager，WindowManagerImpl 是 WindowManager 接口的实现类，但是具体的功能都会委托给 WindowManagerGlobal 来实现 调用 WindowManager 的 addView 方法，实际上调用的是 WindowManagerImpl 的 addView 方法 总结Acivity 和 Dialog 视图解析绑定过程？ 调用 LayoutInflater 的 inflate 方法，深度优先遍历解析 View 调用 ViewGroup 的 addView 方法将子 View 添加到根布局中 调用 WindowManager 的 addView 方法添加根布局 Activity 的视图如何与 Window 关联的？在 Activity 内部维护着一个 Window 的实例变量 mWindowframeworks/base/core/java/android/app/Activity.java public class Activity extends ContextThemeWrappe{ private Window mWindow;} 最后调用 Activity 的 makeVisible 方法，把 decorView 添加到 WindowManage 中frameworks/base/core/java/android/app/Activity.java void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE);} Window 如何与 WindowManager 关联？在 Activity 的 attach 方法中，调用 PhoneWindow 的 setWindowManager 方法，这个方法的具体实现发生在 Window 中，最终调用的是 Window 的 setWindowManager 方法，将 Window 和 WindowManager 关联在了一起frameworks/base/core/java/android/view/Window.java public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { ...... // mWindowManager 是 WindowManagerImpl的实例变量 mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);} Dialog 的视图如何与 Window 关联？在 Dialog 的构造方法中初始化了 Window 对象frameworks/base/core/java/android/app/Dialog.java Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { ... // 获取WindowManager对象 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 构建PhoneWindow final Window w = new PhoneWindow(mContext); // mWindow 是PhoneWindow实例 mWindow = w; ...} 调用 Dialog 的 show 方法，完成 view 的绘制和 Dialog 的显示frameworks/base/core/java/android/app/Dialog.java public void show() { // 获取DecorView mDecor = mWindow.getDecorView(); // 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); // 将DecorView和布局参数添加到WindowManager中 mWindowManager.addView(mDecor, l);} 参考文献 http://liuwangshu.cn/framework/wm/1-windowmanager.html https://gudong.site/2017/05/08/activity-windown-decorview.html","link":"/2020/06/07/android10/window-manager/06-Window-WindowManager/"},{"title":"Android 10 源码分析：Dialog加载绘制流程以及在Kotlin、DataBinding中的使用","text":"引言 这是 Android 10 源码分析系列的第 5 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 Dialog的的创建流程？ Dialog的视图怎么与Window做关联了？ 自定义CustomDialog的view的是如何绑定的? 如何使用Kotlin具名可选参数构造类，实现构建者模式？ 相比于Java的构建者模式，通过具名可选参数构造类具有以下优点? 如何在Dialog中使用DataBinding？ 阅读本文之前，如果之前没有看过 Apk加载流程之资源加载一 和 Apk加载流程之资源加载二 点击下方链接前去查看，这几篇文章都是互相关联的 0xA03 Android 10 源码分析：Apk加载流程之资源加载（一） 0xA04 Android 10 源码分析：Apk加载流程之资源加载（二） 本文主要来主要围绕以下几个方面来分析: Dialog加载绘制流程 如何使用Kotlin具名可选参数构造类，实现构建者模式 如何在Dialog中使用DataBinding 源码分析在开始分析Dialog的源码之前，需要了解一下Dialog加载绘制流程，涉及到的数据结构与职能 在包 android.app 下： Dialog：Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑 AlertDialog：继承自Dialog，是具体的Dialog的操作实现类 AlertDialog.Builder：是AlertDialog的内部类，主要用于构造AlertDialog AlertController：是AlertDialog的控制类 AlertController.AlertParams：是AlertController的内部类，负责AlertDialog的初始化参数 了解完相关的数据结构与职能，接下来回顾一下Dialog的创建流程 AlertDialog.Builder builder = new AlertDialog.Builder(this);builder.setIcon(R.mipmap.ic_launcher);builder.setMessage(&quot;Message部分&quot;);builder.setTitle(&quot;Title部分&quot;);builder.setView(R.layout.activity_main);builder.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); }});builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); }});alertDialog = builder.create();alertDialog.show(); 上面代码都不会很陌生，主要使用了设计模式当中-构建者模式， 构建AlertDialog.Builder对象 builder.setXXX 系列方法完成Dialog的初始化 调用builder.create()方法创建AlertDialog 调用AlertDialog的show()完成View的绘制并显示AlertDialog 主要通过上面四步完成Dialog的创建和显示，接下来根据源码来分析每个方法的具体实现，以及Dialog的视图怎么与Window做关联 1 构建AlertDialog.Builder对象AlertDialog.Builder builder = new AlertDialog.Builder(this); AlertDialog.Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法frameworks/base/core/java/android/app/AlertDialog.java // AlertController.AlertParams类型的成员变量private final AlertController.AlertParams P;public Builder(Context context) { this(context, resolveDialogTheme(context, Resources.ID_NULL));}public Builder(Context context, int themeResId) { // 构造ContextThemeWrapper，ContextThemeWrapper 是 Context的子类，主要用来处理和主题相关的 // 初始化成为变量 P P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId)));} ContextThemeWrapper 继承自ContextWrapper，Application、Service继承自ContextWrapper，Activity继承自ContextThemeWrapper P是AlertDialog.Builder中的AlertController.AlertParams类型的成员变量 AlertParams中包含了与AlertDialog视图中对应的成员变量，调用builder.setXXX系列方法之后，我们传递的参数就保存在P中了 1.1 AlertParams封装了初始化参数AlertController.AlertParams 是AlertController的内部类，负责AlertDialog的初始化参数frameworks/base/core/java/com/android/internal/app/AlertController.java public AlertParams(Context context) {mContext = context;// mCancelable 用来控制点击外部是否可取消，默认可以取消mCancelable = true;// LayoutInflater 主要来解析layout.xml文件mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);} 主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量，LayoutInflater 主要来解析layout.xml文件，关于LayoutInflater可以参考之前的文章0xA04 Android 10 源码分析：Apk加载流程之资源加载（二） 初始化完成AlertParams之后，就完成了AlertDialog.Builder的构建 2 调用AlertDialog.Builder的setXXX系列方法AlertDialog.Builder初始化完成之后，调用它的builder.setXXX 系列方法完成Dialog的初始化frameworks/base/core/java/android/app/AlertDialog.java // ... 省略了很多builder.setXXX方法public Builder setTitle(@StringRes int titleId) { P.mTitle = P.mContext.getText(titleId); return this;}public Builder setMessage(@StringRes int messageId) { P.mMessage = P.mContext.getText(messageId); return this;}public Builder setPositiveButton(@StringRes int textId, final OnClickListener listener) { P.mPositiveButtonText = P.mContext.getText(textId); P.mPositiveButtonListener = listener; return this;}public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this;}// ... 省略了很多builder.setXXX方法 上面所有setXXX方法都是给Builder的成员变量P赋值，并且他们的返回值都是Builder类型，因此可以通过消息琏的方式调用 builder.setTitle().setMessage().setPositiveButton()... PS: 在Kotlin应该尽量避免使用构建者模式，使用Kotlin中的具名可选参数，实现构建者模式，代码更加简洁，为了不影响阅读的流畅性，将这部分内容放到了文末扩展阅读部分 3 builder.create方法builder.setXXX 系列方法之后调用builder.create方法完成AlertDialog构建，接下来看一下create方法frameworks/base/core/java/android/app/AlertDialog.java public AlertDialog create() { // P.mContext 是ContextWrappedTheme 的实例 final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); // Dialog的参数其实保存在P这个类里面 // mAler是AlertController的实例，通过这个方法把P中的变量传给AlertController.AlertParams P.apply(dialog.mAlert); // 用来控制点击外部是否可取消,mCancelable 默认为true dialog.setCancelable(P.mCancelable); // 如果可以取消设置回调监听 if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } // 设置一系列监听 dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } // 返回 AlertDialog 对象 return dialog;} 根据P.mContex 构建了一个AlertDialog mAler是AlertController的实例，调用apply方法把P中的变量传给AlertController.AlertParams 设置是否可以点击外部取消，默认可以取消，同时设置回调监听 最后返回AlertDialog对象 3.1 如何构建AlertDialog我们来分析一下AlertDialog是如何构建的，来看一下它的造方法具体实现frameworks/base/core/java/android/app/AlertDialog.java AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); // getContext() 返回的是ContextWrapperTheme // getWindow() 返回的是 PhoneWindow // mAlert 是AlertController的实例 mAlert = AlertController.create(getContext(), this, getWindow());} PhoneWindows是什么时候创建的？AlertDialog继承自Dialog，首先调用了super的构造方法，来看一下Dialog的构造方法frameworks/base/core/java/android/app/Dialog.java Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { ... // 获取WindowManager对象 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 构建PhoneWindow final Window w = new PhoneWindow(mContext); // mWindow 是PhoneWindow实例 mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setOnWindowSwipeDismissedCallback(() -&gt; { if (mCancelable) { cancel(); } }); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); // 继承 Handler mListenersHandler = new ListenersHandler(this);} 获取WindowManager对象，构建了PhoneWindow，到这里我们知道了PhoneWindow是在Dialog构造方法创建的 初始化了Dialog的成员变量mWindow，mWindow 是PhoneWindow的实例 初始化了Dialog的成员变量mListenersHandler，mListenersHandler继承Handler 我们回到AlertDialog构造方法，在AlertDialog构造方法内，调用了 AlertController.create方法，来看一下这个方法 public static final AlertController create(Context context, DialogInterface di, Window window) { final TypedArray a = context.obtainStyledAttributes( null, R.styleable.AlertDialog, R.attr.alertDialogStyle, R.style.Theme_DeviceDefault_Settings); int controllerType = a.getInt(R.styleable.AlertDialog_controllerType, 0); a.recycle(); // 根据controllerType 使用不同的AlertController switch (controllerType) { case MICRO: // MicroAlertController 是matrix风格 继承自AlertController return new MicroAlertController(context, di, window); default: return new AlertController(context, di, window); }} 根据controllerType 返回不同的AlertController，到这里分析完了AlertDialog是如何构建的 4 调用Dialog的show方法显示Dialog调用AlertDialog.Builder的create方法之后返回了AlertDialog的实例，最后调用了AlertDialog的show方法显示dialog，但是AlertDialog是继承自Dialog的，实际上调用的是Dialog的show方法frameworks/base/core/java/android/app/Dialog.java public void show() { // mShowing变量用于表示当前dialog是否正在显示 if (mShowing) { if (mDecor != null) { if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); } mDecor.setVisibility(View.VISIBLE); } return; } mCanceled = false; // mCreated这个变量控制dispatchOnCreate方法只被执行一次 if (!mCreated) { dispatchOnCreate(null); } else { // Fill the DecorView in on any configuration changes that // may have occured while it was removed from the WindowManager. final Configuration config = mContext.getResources().getConfiguration(); mWindow.getDecorView().dispatchConfigurationChanged(config); } // 用于设置ActionBar onStart(); // 获取DecorView mDecor = mWindow.getDecorView(); if (mActionBar == null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { final ApplicationInfo info = mContext.getApplicationInfo(); mWindow.setDefaultIcon(info.icon); mWindow.setDefaultLogo(info.logo); mActionBar = new WindowDecorActionBar(this); } // 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); boolean restoreSoftInputMode = false; if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) { l.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; restoreSoftInputMode = true; } // 将DecorView和布局参数添加到WindowManager中，完成view的绘制 mWindowManager.addView(mDecor, l); if (restoreSoftInputMode) { l.softInputMode &amp;= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; } mShowing = true; // 向Handler发送一个Dialog的消息，从而显示AlertDialog sendShowMessage();} 判断dialog是否已经显示，如果显示了直接返回 判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法 获取布局参数添加到WindowManager，调用addView方法完成view的绘制 向Handler发送一个Dialog的消息，从而显示AlertDialog 4.1 dispatchOnCreate在上面代码中，根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法frameworks/base/core/java/android/app/Dialog.java void dispatchOnCreate(Bundle savedInstanceState) { if (!mCreated) { // 调用 onCreate 方法 onCreate(savedInstanceState); mCreated = true; }} 在dispatchOnCreate方法中主要调用Dialog的onCreate方法, Dialog的onCreate方法是个空方法，由于我们创建的是AlertDialog对象，AlertDialog继承于Dialog，所以调用的是AlertDialog的onCreate方法frameworks/base/core/java/android/app/AlertDialog.java protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mAlert.installContent();} 在这方法里面调用了AlertController的installContent方法，来看一下具体的实现逻辑frameworks/base/core/java/com/android/internal/app/AlertController.java public void installContent() { // 获取相应的Dialog布局文件 int contentView = selectContentView(); // 调用setContentView方法解析布局文件 mWindow.setContentView(contentView); // 初始化布局文件中的组件 setupView();} 调用selectContentView方法获取布局文件，来看一下具体的实现 frameworks/base/core/java/com/android/internal/app/AlertController.java* private int selectContentView() { if (mButtonPanelSideLayout == 0) { return mAlertDialogLayout; } if (mButtonPanelLayoutHint == AlertDialog.LAYOUT_HINT_SIDE) { return mButtonPanelSideLayout; } return mAlertDialogLayout;} 返回的布局是mAlertDialogLayout，布局文件是在AlertController的构造方法初始化的frameworks/base/core/java/com/android/internal/app/AlertController.java mAlertDialogLayout = a.getResourceId( R.styleable.AlertDialog_layout, R.layout.alert_dialog); 调用Window.setContentView方法解析布局文件，Activity的setContentView最后也是调用了Window.setContentView这个方法，具体的解析流程，可以参考之前的文章Activity布局加载流程 0xA03 Android 10 源码分析：Apk加载流程之资源加载 调用setupView方法初始化布局文件中的组件, 到这里dispatchOnCreate方法分析结束 4.2 调用mWindowManager.addView完成View的绘制回到我们的Dialog的show方法，在执行了dispatchOnCreate方法之后，又调用了onStart方法，这个方法主要用于设置ActionBar，然后初始化WindowManager.LayoutParams对象，最后调用mWindowManager.addView()方法完成界面的绘制，绘制完成之后调用sendShowMessage方法frameworks/base/core/java/android/app/Dialog.java private void sendShowMessage() { if (mShowMessage != null) { // Obtain a new message so this dialog can be re-used Message.obtain(mShowMessage).sendToTarget(); }} 向Handler发送一个Dialog的消息，从而显示AlertDialog，该消息最终会在ListenersHandler中的handleMessage方法中被执行，ListenersHandler是Dialog的内部类，继承Handlerframeworks/base/core/java/android/app/Dialog.java public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; }} 如果msg.what = SHOW，会执行OnShowListener.onShow方法，msg.what的值和OnShowListener调用setOnShowListener方法赋值的frameworks/base/core/java/android/app/Dialog.java public void setOnShowListener(@Nullable OnShowListener listener) { if (listener != null) { mShowMessage = mListenersHandler.obtainMessage(SHOW, listener); } else { mShowMessage = null; }} mListenersHandler构造了Message对象，当我们在Dialog中发送showMessage的时候，被mListenersHandler所接收 4.3 自定义Dialog的view的是如何绑定的在上文分析中根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法，在dispatchOnCreate方法中主要调用Dialog的onCreate方法，由于创建的是AlertDialog对象，AlertDialog继承于Dialog，所以实际调用的是AlertDialog的onCreate方法，来完成布局文件的解析，和布局文件中控件的初始化 同理我们自定义CustomDialog继承自Dialog，所以调用的是自定义CustomDialog的onCreate方法，代码如下 public class CustomDialog extends Dialog { Context mContext; // ... 省略构造方法 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); LayoutInflater inflater = (LayoutInflater) mContext .getSystemService(Context.LAYOUT_INFLATER_SERVICE); View view = inflater.inflate(R.layout.custom_dialog, null); setContentView(view); }} 在onCreate方法中调用了 Dialog的setContentView 方法, 来分析setContentView方法frameworks/base/core/java/android/app/Dialog.java public void setContentView(@NonNull View view) { mWindow.setContentView(view);} mWindow是PhoneWindow的实例，最后调用的是PhoneWindow的setContentView解析布局文件，Activity的setContentView最后也是调用了PhoneWindow的setContentView方法，具体的解析流程，可以参考之前的文章Activity布局加载流程 0xA03 Android 10 源码分析：Apk加载流程之资源加载 总结Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑 Dialog的的创建流程？ 构建AlertDialog.Builder对象 builder.setXXX 系列方法完成Dialog的初始化 调用builder.create()方法创建AlertDialog 调用AlertDialog的show()初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，最终将Dialog显示出来 Dialog的视图怎么与Window做关联了？ 在Dialog的构造方法中初始化了Window对象 Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { ... // 获取WindowManager对象 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 构建PhoneWindow final Window w = new PhoneWindow(mContext); // mWindow 是PhoneWindow实例 mWindow = w; ...} 调用Dialog的show方法，完成view的绘制和Dialog的显示 public void show() { // 获取DecorView mDecor = mWindow.getDecorView(); // 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); // 将DecorView和布局参数添加到WindowManager中 mWindowManager.addView(mDecor, l);} 最终会通过WindowManager将DecorView添加到Window之中，用WIndow对象实现界面的加载与显示逻辑 自定义CustomDialog的view的是如何绑定的? 调用Dialog的show方法，在该方法内部会根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法，在dispatchOnCreate方法中主要调用Dialog的onCreate方法 自定义CustomDialog继承自Dialog，所以调用的是自定义CustomDialog的onCreate方法，在CustomDialog的onCreate方法中调用setContentView方法，最后调用的是PhoneWindow的setContentView解析布局文件，解析流程参考0xA03 Android 10 源码分析：Apk加载流程之资源加载 如何使用Kotlin具名可选参数构造类，实现构建者模式？ 这部分内容参考扩展阅读部分 相比于Java的构建者模式，通过具名可选参数构造类具有以下优点? 代码非常的简洁 每个参数名都可以显示的，声明对象时无须按照顺序书写，非常的灵活 构造函数中每个参数都是val声明的，在多线程并发业务场景中更加的安全 Kotlin的require方法，让我们在参数约束上更加的友好 如何在Dialog中使用DataBinding？ 这部分内容参考扩展阅读部分 扩展阅读1. Kotlin实现构建者模式刚才在上文中提到了，在Kotlin中应该尽量避免使用构建者模式，使用Kotlin的具名可选参数构造类，实现构建者模式，代码更加简洁 在 “Effective Java” 书中介绍构建者模式时，是这样子描述它的：本质上builder模式模拟了具名的可算参数，就像Ada和Python中的一样 关于Java用构建者模式实现自定义dialog，可以参考这边文章 Builder Pattern in Java，代码显得很长……..幸运的是，Kotlin是一门拥有具名可选参数的变成语言，Kotlin中的函数和构造器都支持这一特性，接下里我们使用具名可选参数构造类，实现构建者模式，点击JDataBinding前往查看，核心代码如下： class AppDialog( context: Context, val title: String? = null, val message: String? = null, val yes: AppDialog.() -&gt; Unit) : DataBindingDialog(context, R.style.AppDialog) { init { requireNotNull(message) { &quot;message must be not null&quot; } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) requestWindowFeature(Window.FEATURE_NO_TITLE) setContentView(root) display.text = message btnNo.setOnClickListener { dismiss() } btnYes.setOnClickListener { yes() } }} 调用方式也更加的简单 AppDialog( context = this@MainActivity, message = msg, yes = { // do something }).show() 相比于Java的构建者模式，通过具名可选参数构造类具有以下优点: 代码非常的简洁 每个参数名都可以显示的，声明对象时无须按照顺序书写，非常的灵活 构造函数中每个参数都是val声明的，在多线程并发业务场景中更加的安全 Kotlin的require方法，让我们在参数约束上更加的友好 2. 如何在Dialog中使用DataBindingDataBinding是什么？查看Google官网，会有更详细的介绍 DataBinding 是 Google 在 Jetpack 中推出的一款数据绑定的支持库，利用该库可以实现在页面组件中直接绑定应用程序的数据源 在使用Kotlin的具名可选参数构造类实现Dailog构建者模式的基础上，用DataBinding进行二次封装，加上DataBinding数据绑定的特性，使Dialog变得更加简洁、易用 Step1: 定义一个基类DataBindingDialog abstract class DataBindingDialog(@NonNull context: Context, @StyleRes themeResId: Int) : Dialog(context, themeResId) { protected inline fun &lt;reified T : ViewDataBinding&gt; binding(@LayoutRes resId: Int): Lazy&lt;T&gt; = lazy { requireNotNull( DataBindingUtil.bind&lt;T&gt;(LayoutInflater.from(context).inflate(resId, null)) ) { &quot;cannot find the matched view to layout.&quot; } }} Step2: 改造AppDialog class AppDialog( context: Context, val title: String? = null, val message: String? = null, val yes: AppDialog.() -&gt; Unit) : DataBindingDialog(context, R.style.AppDialog) { private val mBinding: DialogAppBinding by binding(R.layout.dialog_app) init { requireNotNull(message) { &quot;message must be not null&quot; } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) requestWindowFeature(Window.FEATURE_NO_TITLE) mBinding.apply { setContentView(root) display.text = message btnNo.setOnClickListener { dismiss() } btnYes.setOnClickListener { yes() } } }} 同理DataBinding在Activity、Fragment、Adapter中的使用也是一样的，利用Kotlin的inline、reified、DSL等等语法，可以设计出更加简洁并利于维护的代码 关于基于DataBinding封装的DataBindingActivity、DataBindingFragment、DataBindingDialog基础库相关代码，后续也会陆续完善基础库，点击JDataBinding前往查看，欢迎start","link":"/2020/06/07/android10/window-manager/05-Dialog/"},{"title":"Android 10 源码分析：Apk加载流程之资源加载（二）","text":"引言 这是 Android 10 源码分析系列的第 4 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 通过这篇文章你将学习到以下内容，将在文末会给出相应的答案 View 中的 INVISIBLE、VISIBLE、GONE 都有什么作用？ 为什么 ViewStub 是大小为0的视图 ViewStub 有什么作用？ ViewStub 是如何创建的？ 为什么 ViewStub 能做到延迟加载？ ViewStub 指定的 Layout 布局文件是什么时候被加载的？ LayoutInflater 是一个抽象类它如何被创建的？ 系统服务存储在哪里？如何获取和添加系统服务？ 在上一篇文章 0xA02 Android 10 源码分析：APK 加载流程之资源加载 中通过 LayoutInflater.inflate 方法解析 XML 文件，了解到了系统如何对 merge、include 标签是如何处理的，本文主要围绕以下两方面内容 系统对 ViewStub 如何处理？ LayoutInflater 是如何被创建的？ 系统对 merge、include 是如何处理的 使用 merge 标签必须有父布局，且依赖于父布局加载 merge 并不是一个 ViewGroup，也不是一个 View，它相当于声明了一些视图，等待被添加，解析过程中遇到 merge 标签会将 merge 标签下面的所有子 view 添加到根布局中 merge 标签在 XML 中必须是根元素 相反的 include 不能作为根元素，需要放在一个 ViewGroup 中 使用 include 标签必须指定有效的 layout 属性 使用 include 标签不写宽高是没有关系的，会去解析被 include 的 layout merge 标签为什么可以起到优化布局的效果？ 解析过程中遇到 merge 标签，会调用 rInflate 方法，部分代码如下 // 根据元素名解析，生成对应的viewfinal View view = createViewFromTag(parent, name, context, attrs);final ViewGroup viewGroup = (ViewGroup) parent;final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子viewrInflateChildren(parser, view, attrs, true);// 添加解析的viewviewGroup.addView(view, params); 解析 merge 标签下面的所有子 view，然后添加到根布局中更多信息查看0xA02 Android 10 源码分析：APK 加载流程之资源加载，接下来看一下系统对 ViewStub 如何处理 1. ViewStub是什么关于 ViewStub 的介绍，可以点击下方官网链接查看官网链接https://developer.android.google.cn/reference/android…ViewStub ViewStub 的继承结构 简单来说主要以下几点： ViewStub 控件是一个不可见， 大小为 0 的视图 当 ViewStub 控件设置可见，或者调用 inflate() 方法，ViewStub 所指定的 layout 资源就会被加载 ViewStub 也会从其父控件中移除，ViewStub 会被新加载的 layout 文件代替 为什么 ViewStub 是大小为 0 的视图frameworks/base/core/java/android/view/ViewStub.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // 设置视图大小为0 setMeasuredDimension(0, 0);} ViewStub 的作用 主要用来延迟布局的加载，例如：在 Android 中非常常见的布局，用 ListView 来展示列表信息，当没有数据或者网络加载失败时, 加载空的 ListView 会占用一些资源，如果用 ViewStub 包裹 ListView，当有数据时，才会调用 inflate() 方法显示 ListView，起到延迟加载了布局效果 1.1 ViewStub 是如何被创建的在上篇文章 0xA02 Android 10 源码分析：APK 加载流程之资源加载 中，介绍了 View 的创建是通过调用了 LayoutInflater.createView 方法根据完整的类的路径名利用反射机制构建 View 对象，因为 ViewStub 是继承 View，所以 ViewStub 的创建和 View 的创建是相同的，来看一下 LayoutInflater.createView 方法frameworks/base/core/java/android/view/LayoutInflater.java ...try { // 利用构造函数，创建View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // 如果是ViewStub，则设置LayoutInflater final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view;} finally { mConstructorArgs[0] = lastContext;}... 根据完整的类的路径名利用反射机制构建 View 对象，如果遇到 ViewStub 将当前 LayoutInflater 设置给 ViewStub，当 ViewStub 控件设置可见，或者调用 inflate()，会调用 LayoutInflater 的 inflate 方法完成布局加载，接下来分析 ViewStub 的构造方法 1.2 ViewStub 的构造方法在上面提到了根据完整的类的路径名利用反射机制构建 View 对象，当 View 对象被创建的时候，会调用它的构造函数，来看一下 ViewStub 的构造方法 public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); saveAttributeDataForStyleable(context, R.styleable.ViewStub, attrs, a, defStyleAttr, defStyleRes); // 解析xml中设置的 android:inflatedId 的属性 mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); // 解析xml中设置的 android:layout 属性 mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); // 解析xml中设置的 android:id 属性 mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); // view不可见 setVisibility(GONE); // 不会调用 onDraw 方法绘制内容 setWillNotDraw(true);} 获取 android:inflatedId、android:layout、android:id 的值 调用 setVisibility 方法，设置 View 不可见 调用 setWillNotDraw 方法，不会调用 onDraw 方法绘制内容 在上面提到了如果想要加载 ViewStub 所指定的 layout 资源，需要设置 ViewStub 控件设置可见，或者调用 inflate() 方法，来看一下 ViewStub 的 setVisibility 方法 1.3 ViewStub 的 setVisibility 方法setVisibility(int visibility) 方法，参数 visibility 对应三个值分别是 INVISIBLE、VISIBLE、GONE VISIBLE：视图可见 INVISIBLE：视图不可见的，它仍然占用布局的空间 GONE：视图不可见，它不占用布局的空间 接下里查看一下 ViewStub 的 setVisibility 方法frameworks/base/core/java/android/view/ViewStub.java @Overridepublic void setVisibility(int visibility) { if (mInflatedViewRef != null) { // mInflatedViewRef 是 WeakReference的实例，调用inflate方法时候初始化 View view = mInflatedViewRef.get(); if (view != null) { // 设置View可见 view.setVisibility(visibility); } else { throw new IllegalStateException(&quot;setVisibility called on un-referenced view&quot;); } } else { super.setVisibility(visibility); // 当View为空且设置视图可见(VISIBLE、INVISIBLE)，调用inflate方法 if (visibility == VISIBLE || visibility == INVISIBLE) { inflate(); } }} mInflatedViewRef 是 WeakReference 的实例，调用 inflate 方法时候初始化 从 mInflatedViewRef 缓存中获取 View，并且设置 View 可见 当 View 为空且设置视图可见(VISIBLE、INVISIBLE)，会调用 inflate方法 1.4 ViewStub.inflate 方法调用了 ViewStub 的 setVisibility 方法，最后都会调用 ViewStub.inflate 方法，来查看一下frameworks/base/core/java/android/view/ViewStub.java public View inflate() { final ViewParent viewParent = getParent(); if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) { if (mLayoutResource != 0) { final ViewGroup parent = (ViewGroup) viewParent; // 解析布局视图 // 返回的view是android:layout指定的布局文件最顶层的view final View view = inflateViewNoAdd(parent); // 移除ViewStub // 添加view到被移除的ViewStub的位置 replaceSelfWithView(view, parent); // 添加view到 mInflatedViewRef 中 mInflatedViewRef = new WeakReference&lt;&gt;(view); if (mInflateListener != null) { // 加载完成之后，回调onInflate 方法 mInflateListener.onInflate(this, view); } return view; } else { // 需要在xml中设置android:layout，不是layout，否则会抛出异常 throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); } } else { // ViewStub不能作为根布局，它需要放在ViewGroup中, 否则会抛出异常 throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); }} 调用 inflateViewNoAdd 方法返回 android:layout 指定的布局文件最顶层的 View 调用 replaceSelfWithView 方法, 移除 ViewStub, 添加 View 到被移除的 ViewStub 的位置 添加 View 到 mInflatedViewRef 中 加载完成之后，回调 onInflate 方法 需要注意以下两点： 使用 ViewStub 需要在 XML 中设置 android:layout，不是 layout，否则会抛出异常 ViewStub 不能作为根布局，它需要放在 ViewGroup 中, 否则会抛出异常 来查看一下 inflateViewNoAdd 方法和 replaceSelfWithView 方法 1.5 ViewStub.inflateViewNoAdd 方法调用 inflateViewNoAdd 方法返回 android:layout 指定的布局文件最顶层的 Viewframeworks/base/core/java/android/view/ViewStub.java private View inflateViewNoAdd(ViewGroup parent) { final LayoutInflater factory; // mInflater 是View被创建的时候，如果是ViewStub, 将LayoutInflater赋值给mInflater if (mInflater != null) { factory = mInflater; } else { // 如果mInflater为空，则创建LayoutInflater factory = LayoutInflater.from(mContext); } // 从指定的 mLayoutResource 资源中解析布局视图 // mLayoutResource 是在xml设置的 Android:layout 指定的布局文件 final View view = factory.inflate(mLayoutResource, parent, false); // mInflatedId 是在xml设置的 inflateId if (mInflatedId != NO_ID) { // 将id复制给view view.setId(mInflatedId); //注意：如果指定了mInflatedId , 被inflate的layoutView的id就是mInflatedId } return view;} mInflater 是 View 被创建的时候，如果是 ViewStub, 将 LayoutInflater 赋值给 mInflater 如果 mInflater 为空则通过 LayoutInflater.from(mContext) 构建 LayoutInflater 调用 LayoutInflater 的 inflate 方法解析布局视图 将 mInflatedId 设置 View 1.6 ViewStub.replaceSelfWithView 方法调用 replaceSelfWithView 方法, 移除 ViewStub, 添加 View 到被移除的 ViewStub 的位置frameworks/base/core/java/android/view/ViewStub.java private void replaceSelfWithView(View view, ViewGroup parent) { // 获取ViewStub在视图中的位置 final int index = parent.indexOfChild(this); // 移除ViewStub // 注意：调用removeViewInLayout方法之后，调用findViewById()是找不到该ViewStub对象 parent.removeViewInLayout(this); final ViewGroup.LayoutParams layoutParams = getLayoutParams(); // 将xml中指定的 android:layout 布局文件中最顶层的View，添加到被移除的 ViewStub的位置 if (layoutParams != null) { parent.addView(view, index, layoutParams); } else { parent.addView(view, index); }} 获取 ViewStub 在视图中的位置，然后移除 ViewStub 添加 android:layout 布局文件中最顶层的 View 到被移除的 ViewStub 的位置 1.7 ViewStub 的注意事项 使用 ViewStub 需要在 XML 中设置 android:layout，不是 layout，否则会抛出异常 throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); ViewStub 不能作为根布局，它需要放在 ViewGroup 中, 否则会抛出异常 throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); 一旦调用 setVisibility(View.VISIBLE) 或者 inflate() 方法之后，该 ViewStub 将会从试图中被移除（此时调用 findViewById() 是找不到该 ViewStub 对象). // 获取ViewStub在视图中的位置final int index = parent.indexOfChild(this);// 移除ViewStub// 注意：调用removeViewInLayout方法之后，调用findViewById()是找不到该ViewStub对象parent.removeViewInLayout(this); 如果指定了 mInflatedId , 被 inflate 的 layoutView 的 id 就是 mInflatedId // mInflatedId 是在xml设置的 inflateIdif (mInflatedId != NO_ID) { // 将id复制给view view.setId(mInflatedId); //注意：如果指定了mInflatedId , 被inflate的layoutView的id就是mInflatedId} 被 inflate 的 layoutView 的 layoutParams 与 ViewStub 的 layoutParams 相同. final ViewGroup.LayoutParams layoutParams = getLayoutParams();// 将xml中指定的 android:layout 布局文件中最顶层的View 也就是根view，// 添加到被移除的 ViewStub的位置if (layoutParams != null) { parent.addView(view, index, layoutParams);} else { parent.addView(view, index);} 到这里关于 ViewStub 的构建、布局的加载以及注意事项分析完了，接下来分析一下 LayoutInflater 是如何被创建的 2 关于LayoutInflater在 0xA02 Android 10 源码分析：APK 加载流程之资源加载 文章中，介绍了 Activity 启动的时候通过调用 LayoutInflater 的 inflater 的方法加载 layout 文件，那么 LayoutInflater 是如何被创建的呢，先来看一段代码，相信下面的代码都不会很陌生 public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) { return new AllVh(LayoutInflater .from(viewGroup.getContext()) .inflate(R.layout.list_item, viewGroup, false));} LayoutInflater的inflate方法的三个参数都代表什么意思？ resource：要解析的 XML 布局文件 Id root：表示根布局 attachToRoot：是否要添加到父布局 root中 resource 其实很好理解就是资源 Id，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该View中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 2.1 LayoutInflater 是如何被创建的LayoutInflater 是一个抽象类，通过调用了 from() 的静态函数，经由系统服务 LAYOUT_INFLATER_SERVICE，最终创建了一个 LayoutInflater 的子类对象 PhoneLayoutInflater，继承结构如下： LayoutInflater.from(ctx) 就是根据传递过来的 Context 对象，调用 getSystemService() 来获取对应的系统服务, 来看一下这个方法frameworks/base/core/java/android/view/LayoutInflater.java public static LayoutInflater from(Context context) { // 获取系统服务 LAYOUT_INFLATER_SERVICE ，并赋值给 LayoutInflater // Context 是一个抽象类，真正的实现类是ContextImpl LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) { throw new AssertionError(&quot;LayoutInflater not found.&quot;); } return LayoutInflater;} 而 Context 本身是一个抽象类，它真正的实例化对象是 ContextImplframeworks/base/core/java/android/app/ContextImpl.java public Object getSystemService(String name) { // SystemServiceRegistry 是管理系统服务的 // 调用getSystemService方法，通过服务名字查找对应的服务 return SystemServiceRegistry.getSystemService(this, name);} 2.2 SystemServiceRegistrySystemServiceRegistry 管理所有的系统服务，调用 getSystemService 方法，通过服务名字查找对应的服务frameworks/base/core/java/android/app/SystemServiceRegistry.java public static Object getSystemService(ContextImpl ctx, String name) { // SYSTEM_SERVICE_FETCHERS 是一个map集合 // 从 map 集合中取出系统服务 ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;} ServiceFetcher 为 SystemServiceRegistry 类的静态内部接口，定义了 getService 方法 ServiceFetcher 的实现类 CachedServiceFetcher 实现了 getService方法 所有的系统服务都存储在一个 map 集合 SYSTEM_SERVICE_FETCHERS当 中，调用 get 方法来获取对应的服务 如果有 getSystemService 方法来获取服务，那么相应的也会有添加服务的方法frameworks/base/core/java/android/app/SystemServiceRegistry.java private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass, ServiceFetcher&lt;T&gt; serviceFetcher) { SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);} 通过调用 SYSTEM_SERVICE_NAMES 的 put 方法，往 map 集合中添加数据，那么 registerService 是什么时候调用的，在 SystemServiceRegistry 类中搜索 registerService 方法，知道了在类加载的时候通过静态代码块中添加的，来看一下 static { // 初始化加载所有的系统服务 ... // 省略了很多系统服务 registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() { @Override public LayoutInflater createService(ContextImpl ctx) { return new PhoneLayoutInflater(ctx.getOuterContext()); }}); ... // 省略了很多系统服务} 最终是创建了一个 PhoneLayoutInflater 并返回的，到这里 LayoutInflater 的创建流程就分析完了 总结View 中的 INVISIBLE、VISIBLE、GONE 都有什么作用？ 如果想隐藏或者显示 View，可以通过调用 setVisibility(int visibility) 方法来实现，参数 visibility 对应三个值分别是INVISIBLE、VISIBLE、GONE VISIBLE：视图可见 INVISIBLE：视图不可见的，它仍然占用布局的空间 GONE：视图不可见，它不占用布局的空间 为什么 ViewStub 是大小为0的视图？frameworks/base/core/java/android/view/ViewStub.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // 设置视图大小为0 setMeasuredDimension(0, 0);} ViewStub 有什么作用？ ViewStub 的作用主要用来延迟布局的加载 ViewStub 是如何创建的？ 因为 ViewStub 是继承 View, 所以 ViewStub 的创建和 View 的创建是相同的，通过调用了 LayoutInflater.createView 方法根据完整的类的路径名利用反射机制构建 View 对象frameworks/base/core/java/android/view/LayoutInflater.java ...try { // 利用构造函数，创建View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // 如果是ViewStub，则设置LayoutInflater final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view;} finally { mConstructorArgs[0] = lastContext;}... 为什么 ViewStub 能做到延迟加载？ 因为在解析 layout 文件过程中遇到 ViewStub，只是构建 ViewStub 的对象和初始化 ViewStub 的属性，没有真正开始解析 View，所以可以做到延迟初始化 ViewStub 指定的 Layout 布局文件是什么时候被加载的？ 当ViewStub 控件设置可见，或者调用 inflate() 方法，ViewStub 所指定的 layout 资源就会被加载 LayoutInflater 是一个抽象类它如何被创建的？ LayoutInflater 是一个抽象类，通过调用了 from() 的静态函数，经由系统服务 LAYOUT_INFLATER_SERVICE，最终创建了一个 LayoutInflater的子类对象 PhoneLayoutInflater，继承结构如下： LayoutInflater.from(ctx) 就是根据传递过来的 Context 对象，调用 getSystemService() 来获取对应的系统服务 系统服务存储在哪里？如何获取和添加系统服务？ SystemServiceRegistry 管理所有的系统服务，所有的系统服务都存储在一 个map集合SYSTEM_SERVICE_FETCHERS 当中，调用 getSystemService 方法获取系统服务，调用 registerService 方法添加系统服务","link":"/2020/06/07/android10/resource-manager/04-APK-resource2/"},{"title":"Android 10 源码分析：APK 加载流程之资源加载","text":"引言 这是 Android 10 源码分析系列的第 3 篇 分支：android-10.0.0_r14 全文阅读大概 15 分钟 通过这篇文章你将学习到以下内容，文末会给出相应的答案 LayoutInflater的inflate 方法的三个参数都代表什么意思？ 系统对 merge、include 是如何处理的 merge 标签为什么可以起到优化布局的效果？ XML 中的 View 是如何被实例化的？ 为什么复杂布局会产生卡顿？在 Android 10 上做了那些优化？ BlinkLayout 是什么？ 前面两篇文章 0xA01 Android 10 源码分析：APK 是如何生成的 和 0xA02 Android 10 源码分析：APK 的安装流程 分析了 APK 大概可以分为代码和资源两部分，那么 APK 的加载也是分为代码和资源两部分，代码的加载涉及了进程的创建、启动、调度，本文主要来分析一下资源的加载，如果没有看过 APK 是如何生成的 和 APK 的安装流程 可以点击下方连接前往： 0xA01 Android 10 源码分析：APK 是如何生成的 0xA02 Android 10 源码分析：APK 的安装流程 1. Android 资源Android 资源大概分为两个部分：assets 和 res assets 资源 assets 资源放在 assets 目录下，它里面保存一些原始的文件，可以以任何方式来进行组织，这些文件最终会原封不动的被打包进 APK 文件中，通过AssetManager 来获取 asset 资源，代码如下 AssetManager assetManager = context.getAssets();InputStream is = assetManager.open(&quot;fileName&quot;); res资源 res 资源放在主工程的 res 目录下，这类资源一般都会在编译阶段生成一个资源 ID 供我们使用，res 目录包括 animator、anim、 color、drawable、layout、menu、raw、values、XML等，通过 getResource() 去获取 Resources 对象 Resources res = getContext().getResources(); APK 的生成过程中，会生成资源索引表 resources.arsc 文件和 R.java 文件，前者资源索引表 resources.arsc 记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息，后者定义了各个资源 ID 常量，运行时通过 Resources 和 AssetManger 共同完成资源的加载，如果资源是个文件，Resouces 先根据资源 ID 查找出文件名，AssetManger 再根据文件名查找出具体的资源，关于 resources.arsc，可以查看 0xA01 ASOP应用框架：APK 是如何生成的 2. 资源的加载和解析到 View 的生成下面代码一定不会很陌生，在 Activity 常见的几行代码 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.main_activity)} 一起来分析一下调用 setContentView 方法之后做了什么事情，接下来查看一下 Activity 中的 setContentView 方法frameworks/base/core/java/android/app/Activity.java public void setContentView(@LayoutRes int layoutResID) { // 实际上调用的是PhoneWindow.setContentView方法 getWindow().setContentView(layoutResID); initWindowDecorActionBar();} 调用 getWindow 方法返回的是 mWindow，mWindow 是 Windowd 对象，实际上是调用它的唯一实现类 PhoneWindow.setContentView 方法 2.1 Activity -&gt; PhoneWindowPhoneWindow 是 Window 的唯一实现类，它的结构如下： 当调用 Activity.setContentView 方法实际上调用的是 PhoneWindow.setContentView 方法frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java public void setContentView(int layoutResID) { // mContentParent是ID为ID_ANDROID_CONTENT的FrameLayout // 调用setContentView方法，就是给ID为ID_ANDROID_CONTENT的View添加子View if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { // FEATURE_CONTENT_TRANSITIONS，则是标记当前内容加载有没有使用过度动画 // 如果内容已经加载过，并且不需要动画，则会调用removeAllViews mContentParent.removeAllViews(); } // 检查是否设置了FEATURE_CONTENT_TRANSITIONS if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { // 解析指定的XML资源文件 mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } mContentParentExplicitlySet = true;} 先判断 mContentParent 是否为空，如果为空则调用 installDecor 方法，生成 mDecor，并将它赋值给 mContentParent 根据 FEATURE_CONTENT_TRANSITIONS 标记来判断是否加载过转场动画 如果设置了 FEATURE_CONTENT_TRANSITIONS 则添加 Scene 来过度启动，否则调用 mLayoutInflater.inflate(layoutResID, mContentParent)，解析资源文件，创建 View, 并添加到 mContentParent 视图中 2.2 PhoneWindow -&gt; LayoutInflater当调用 PhoneWindow.setContentView 方法，之后调用 LayoutInflater.inflate 方法，来解析 XML 资源文件frameworks/base/core/java/android/view/LayoutInflater.java public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null);} inflate 它有多个重载方法，最后调用的是 inflate(resource, root, root != null) 方法frameworks/base/core/java/android/view/LayoutInflater.java public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); // 根据XML预编译生成compiled_view.dex, 然后通过反射来生成对应的View，从而减少XmlPullParser解析Xml的时间 // 需要注意的是在目前的release版本中不支持使用 View view = tryInflatePrecompiled(resource, res, root, attachToRoot); if (view != null) { return view; } // 获取资源解析器 XmlResourceParser XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); }} 这个方法主要做了三件事： 根据 XML 预编译生成 compiled_view.dex, 然后通过反射来生成对应的 View 获取 XmlResourceParser 解析 View 注意：在目前的 release 版本中不支持使用 tryInflatePrecompiled 方法源码如下： private void initPrecompiledViews() { // Precompiled layouts are not supported in this release. // enabled 是否启动预编译布局，这里始终为false boolean enabled = false; initPrecompiledViews(enabled);}private void initPrecompiledViews(boolean enablePrecompiledViews) { mUseCompiledView = enablePrecompiledViews; if (!mUseCompiledView) { mPrecompiledClassLoader = null; return; } ...}View tryInflatePrecompiled(@LayoutRes int resource, Resources res, @Nullable ViewGroup root, boolean attachToRoot) { // mUseCompiledView始终为false if (!mUseCompiledView) { return null; } // 获取需要解析的资源文件的 pkg 和 layout String pkg = res.getResourcePackageName(resource); String layout = res.getResourceEntryName(resource); try { // 根据mPrecompiledClassLoader通过反射获取预编译生成的view对象的Class类 Class clazz = Class.forName(&quot;&quot; + pkg + &quot;.CompiledView&quot;, false, mPrecompiledClassLoader); Method inflater = clazz.getMethod(layout, Context.class, int.class); View view = (View) inflater.invoke(null, mContext, resource); if (view != null &amp;&amp; root != null) { // 将生成的view 添加根布局中 XmlResourceParser parser = res.getLayout(resource); try { AttributeSet attrs = Xml.asAttributeSet(parser); advanceToRootNode(parser); ViewGroup.LayoutParams params = root.generateLayoutParams(attrs); // 如果 attachToRoot=true添加到根布局中 if (attachToRoot) { root.addView(view, params); } else { // 否者将获取到的根布局的LayoutParams，设置到生成的view中 view.setLayoutParams(params); } } finally { parser.close(); } } return view; } catch (Throwable e) { } finally { } return null;} tryInflatePrecompiled 方法是 Android 10 新增的方法，这是一个在编译器运行的一个优化，因为布局文件越复杂 XmlPullParser 解析 XML 越耗时, tryInflatePrecompiled 方法根据 XML 预编译生成compiled_view.dex, 然后通过反射来生成对应的 View，从而减少 XmlPullParser 解析 XML 的时间，然后根据 attachToRoot 参数来判断是添加到根布局中，还是设置 LayoutParams 参数返回给调用者 用一个全局变量 mUseCompiledView 来控制是否启用 tryInflatePrecompiled 方法，根据源码分析，mUseCompiledView 始终为 false 了解了 tryInflatePrecompiled 方法之后，在来查看一下 inflate 方法中的三个参数都什么意思 resource：要解析的 XML 布局文件 ID root：表示根布局 attachToRoot：是否要添加到父布局 root 中 resource 其实很好理解就是资源 ID，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 根据源码知道调用 tryInflatePrecompiled 方法返回的 view 为空，继续往下执行调用 Resources 的 getLayout 方法获取资源解析器 XmlResourceParser 2.3 LayoutInflater -&gt; Resources上面说到 XmlResourceParser 是通过调用 Resources 的 getLayout 方法获取的，getLayout 方法又去调用了 Resources 的loadXmlResourceParser 方法frameworks/base/core/java/android/content/res/Resources.java public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException { return loadXmlResourceParser(id, &quot;layout&quot;);}XmlResourceParser loadXmlResourceParser(@AnyRes int id, @NonNull String type) throws NotFoundException { // TypedValue 主要用来存储资源 final TypedValue value = obtainTempTypedValue(); try { final ResourcesImpl impl = mResourcesImpl; // 获取XML资源，保存到 TypedValue impl.getValue(id, value, true); if (value.type == TypedValue.TYPE_STRING) { // 为指定的XML资源，加载解析器 return impl.loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type); } throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id) + &quot; type #0x&quot; + Integer.toHexString(value.type) + &quot; is not valid&quot;); } finally { releaseTempTypedValue(value); }} TypedValue 是动态的数据容器，主要用来存储 Resource 的资源，获取 XML 资源保存到 TypedValue，之后调用 ResourcesImpl 的 loadXmlResourceParser 方法加载对应的解析器 2.4 Resources -&gt; ResourcesImplResourcesImpl 实现了 Resource 的访问，它包含了 AssetManager 和所有的缓存，通过 Resource 的 getValue 方法获取 XML 资源保存到 TypedValue，之后就会调用 ResourcesImpl 的 loadXmlResourceParser 方法对该布局资源进行解析frameworks/base/core/java/android/content/res/ResourcesImpl.java XmlResourceParser loadXmlResourceParser(@NonNull String file, @AnyRes int id, int assetCookie, @NonNull String type) throws NotFoundException { if (id != 0) { try { synchronized (mCachedXmlBlocks) { final int[] cachedXmlBlockCookies = mCachedXmlBlockCookies; final String[] cachedXmlBlockFiles = mCachedXmlBlockFiles; final XmlBlock[] cachedXmlBlocks = mCachedXmlBlocks; // 首先从缓存中查找XML资源 final int num = cachedXmlBlockFiles.length; for (int i = 0; i &lt; num; i++) { if (cachedXmlBlockCookies[i] == assetCookie &amp;&amp; cachedXmlBlockFiles[i] != null &amp;&amp; cachedXmlBlockFiles[i].equals(file)) { // 调用newParser方法去构建一个XmlResourceParser对象，返回给调用者 return cachedXmlBlocks[i].newParser(id); } } // 如果缓存中没有，则创建XmlBlock，并将它放到缓存中 // XmlBlock是已编译的XML文件的一个包装类 final XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file); if (block != null) { final int pos = (mLastCachedXmlBlockIndex + 1) % num; mLastCachedXmlBlockIndex = pos; final XmlBlock oldBlock = cachedXmlBlocks[pos]; if (oldBlock != null) { oldBlock.close(); } cachedXmlBlockCookies[pos] = assetCookie; cachedXmlBlockFiles[pos] = file; cachedXmlBlocks[pos] = block; // 调用newParser方法去构建一个XmlResourceParser对象，返回给调用者 return block.newParser(id); } } } catch (Exception e) { final NotFoundException rnf = new NotFoundException(&quot;File &quot; + file + &quot; from xml type &quot; + type + &quot; resource ID #0x&quot; + Integer.toHexString(id)); rnf.initCause(e); throw rnf; } } throw new NotFoundException(&quot;File &quot; + file + &quot; from xml type &quot; + type + &quot; resource ID #0x&quot; + Integer.toHexString(id));} 首先从缓存中查找 XML 资源之后调用 newParser 方法，如果缓存中没有，则调用 AssetManger 的 openXmlBlockAsset 方法创建一个 XmlBlock，并将它放到缓存中，XmlBlock 是已编译的 XML 文件的一个包装类frameworks/base/core/java/android/content/res/AssetManager.java XmlBlock openXmlBlockAsset(int cookie, @NonNull String fileName) throws IOException { Preconditions.checkNotNull(fileName, &quot;fileName&quot;); synchronized (this) { ensureOpenLocked(); // 调用native方法nativeOpenXmlAsset, 加载指定的XML资源文件，得到ResXMLTree // xmlBlock是ResXMLTree对象的地址 final long xmlBlock = nativeOpenXmlAsset(mObject, cookie, fileName); if (xmlBlock == 0) { throw new FileNotFoundException(&quot;Asset XML file: &quot; + fileName); } // 创建XmlBlock，封装xmlBlock，返回给调用者 final XmlBlock block = new XmlBlock(this, xmlBlock); incRefsLocked(block.hashCode()); return block; }} 最终调用 native 方法 nativeOpenXmlAsset 去打开指定的 XML 文件，加载对应的资源，来查看一下 navtive 方法 NativeOpenXmlAssetframeworks/base/core/jni/android_util_AssetManager.cpp // java方法对应的native方法{&quot;nativeOpenXmlAsset&quot;, &quot;(JILjava/lang/String;)J&quot;, (void*)NativeOpenXmlAsset} static jlong NativeOpenXmlAsset(JNIEnv* env, jobject /*clazz*/, jlong ptr, jint jcookie, jstring asset_path) { ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie); ... const DynamicRefTable* dynamic_ref_table = assetmanager-&gt;GetDynamicRefTableForCookie(cookie); std::unique_ptr&lt;ResXMLTree&gt; xml_tree = util::make_unique&lt;ResXMLTree&gt;(dynamic_ref_table); status_t err = xml_tree-&gt;setTo(asset-&gt;getBuffer(true), asset-&gt;getLength(), true); asset.reset(); ... return reinterpret_cast&lt;jlong&gt;(xml_tree.release());} C++ 层的 NativeOpenXmlAsset 方法会创建 ResXMLTree 对象，返回的是 ResXMLTree 在 C++ 层的地址 Java 层 nativeOpenXmlAsse t方法的返回值 xmlBlock 是 C++ 层的 ResXMLTree 对象的地址，然后将 xmlBlock 封装进 XmlBlock 中返回给调用者 当 xmlBlock 创建之后，会调用 newParser 方法，构建一个 XmlResourceParser 对象，返回给调用者 2.5 ResourcesImpl -&gt; XmlBlockXmlBlock 是已编译的 XML 文件的一个包装类，XmlResourceParser 负责对 XML 的标签进行遍历解析的，它的真正的实现是 XmlBlock 的内部类 XmlBlock.Parser，而真正完成 XML 的遍历操作的函数都是由 XmlBlock 来实现的，为了提升效率都是通过 JNI 调用 native 的函数来做的，接下来查看一下 newParser 方法frameworks/base/core/java/android/content/res/XmlBlock.java public XmlResourceParser newParser(@AnyRes int resId) { synchronized (this) { // mNative是C++层的ResXMLTree对象的地址 if (mNative != 0) { // nativeCreateParseState方法根据 mNative 查找到ResXMLTree， // 在C++层构建一个ResXMLParser对象， // 构建Parser，封装ResXMLParser，返回给调用者 return new Parser(nativeCreateParseState(mNative, resId), this); } return null; }} 这个方法做两件事 mNative 是 C++ 层的 ResXMLTree 对象的地址，调用 native 方法 nativeCreateParseState，在 C++ 层构建一个 ResXMLParser 对象，返回 ResXMLParser 对象在 C++ 层的地址 Java 层拿到 ResXMLParser 在 C++ 层地址，构建 Parser，封装 ResXMLParser，返回给调用者 接下来查看一下 native 方法 nativeCreateParseStateframeworks/base/core/jni/android_util_XmlBlock.cpp // java方法对应的native方法{ &quot;nativeCreateParseState&quot;, &quot;(JI)J&quot;, (void*) android_content_XmlBlock_nativeCreateParseState } static jlong android_content_XmlBlock_nativeCreateParseState(JNIEnv* env, jobject clazz, jlong token, jint res_id){ ResXMLTree* osb = reinterpret_cast&lt;ResXMLTree*&gt;(token); if (osb == NULL) { jniThrowNullPointerException(env, NULL); return 0; } ResXMLParser* st = new ResXMLParser(*osb); if (st == NULL) { jniThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, NULL); return 0; } st-&gt;setSourceResourceId(res_id); st-&gt;restart(); return reinterpret_cast&lt;jlong&gt;(st);} token 对应 Java 层 mNative，是 C++ 层的 ResXMLTree 对象的地址 调用 C++ 层 android_content_XmlBlock_nativeCreateParseState 方法，根据 token找到 ResXMLTree 对象 在 C++ 层构建一个 ResXMLParser 对象，返给 Java 层对应 ResXMLParser 对象在 C++ 层的地址 Java 层拿到 ResXMLParser 在 C++ 层地址，封装到 Parser 中 2.6 再次回到 LayoutInflater经过一系列的跳转，最后调用 XmlBlock.newParser 方法获取资源解析器 XmlResourceParser，之后回到 LayoutInflater 调用处 inflate 方法，然后调用 rInflate 方法解析 Viewframeworks/base/core/java/android/view/LayoutInflater.java public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { // 获取context final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; // 存储根布局 View result = root; try { // 处理 START_TA G和 END_TAG advanceToRootNode(parser); final String name = parser.getName(); // 解析merge标签，rInflate方法会将merge标签下面的所有子view添加到根布局中 // 这也是为什么merge标签可以简化布局的效果 if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); } // 解析merge标签下的所有的View，添加到根布局中 rInflate(parser, root, inflaterContext, attrs, false); } else { // 如果不是merge标签，调用createViewFromTag方法解析布局视图，这里的temp其实是我们xml里的top view final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; // 如果根布局不为空的话，且attachToRoot为false，为View设置布局参数 if (root != null) { // 获取根布局的LayoutParams params = root.generateLayoutParams(attrs); // attachToRoot为false，为View设置LayoutParams if (!attachToRoot) { temp.setLayoutParams(params); } } // 解析当前View下面的所有子View rInflateChildren(parser, temp, attrs, true); // 如果 root 不为空且 attachToRoot 为false，将解析出来的View 添加到根布局 if (root != null &amp;&amp; attachToRoot) { root.addView(temp, params); } // 如果根布局为空 或者 attachToRoot 为false，返回当前的View if (root == null || !attachToRoot) { result = temp; } } } catch (XmlPullParserException e) { final InflateException ie = new InflateException(e.getMessage(), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; } catch (Exception e) { throw ie; } finally { } return result; }} 解析 merge 标签，使用 merge 标签必须有父布局，且依赖于父布局加载 rInflate 方法会将 merge 标签下面的所有 View 添加到根布局中 如果不是 merge 标签，调用 createViewFromTag 解析布局视图，返回 temp, 这里的 temp 其实是我们 XML 里的 Top View 调用 rInflateChildren 方法，传递参数 temp，在 rInflateChildren方 法里内部，会调用 rInflate 方法, 解析当前 View 下面的所有子 View 通过分析源码知道了attachToRoot 和 root的参数代表什么意思，这里总结一下： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的View生成 LayoutParams并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 无论是不是 merge 标签，最后都会调用 rInflate 方法进行 View 树的解析，他们的区别在于，如果是 merge 标签传递的参数 finishInflate 是 false，如果不是 merge 标签传递的参数 finishInflate 是 trueframeworks/base/core/java/android/view/LayoutInflater.java void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException { // 获取数的深度 final int depth = parser.getDepth(); int type; boolean pendingRequestFocus = false; // 逐个 View 解析 while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) { if (type != XmlPullParser.START_TAG) { continue; } final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) { // 解析android:focusable=&quot;true&quot;, 获取View的焦点 pendingRequestFocus = true; consumeChildElements(parser); } else if (TAG_TAG.equals(name)) { // 解析android:tag标签 parseViewTag(parser, parent, attrs); } else if (TAG_INCLUDE.equals(name)) { // 解析include标签，include标签不能作为根布局 if (parser.getDepth() == 0) { throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); } parseInclude(parser, context, parent, attrs); } else if (TAG_MERGE.equals(name)) { // merge标签必须作为根布局 throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); } else { // 根据元素名解析，生成View final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); // rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子View rInflateChildren(parser, view, attrs, true); // 添加解析的View viewGroup.addView(view, params); } } if (pendingRequestFocus) { parent.restoreDefaultFocus(); } // 如果finishInflate为true，则调用onFinishInflate方法 if (finishInflate) { parent.onFinishInflate(); }} 整个 View 树的解析过程如下： 获取 View 树的深度 逐个 View 解析 解析 android:focusable=”true”, 获取 View 的焦点 解析 android:tag 标签 解析 include 标签，并且 include 标签不能作为根布局 解析 merge 标签，并且 merge 标签必须作为根布局 根据元素名解析，生成对应的 View rInflateChildren 方法内部调用的 rInflate 方法，深度优先遍历解析所有的子 View 添加解析的 View 注意：通过分析源码, 以下几点需要特别注意 include 标签不能作为根元素，需要放在 ViewGroup中 merge 标签必须为根元素，使用 merge 标签必须有父布局，且依赖于父布局加载 当 XmlResourseParser 对 XML 的遍历，随着布局越复杂，层级嵌套越多，所花费的时间也越长，所以对布局的优化，可以使用 meger 标签减少层级的嵌套 在解析过程中调用 createViewFromTag 方法，根据元素名解析，生成对应的 View，接下来查看一下 createViewFromTag 方法frameworks/base/core/java/android/view/LayoutInflater.java private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) { return createViewFromTag(parent, name, context, attrs, false);}View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) { if (name.equals(&quot;view&quot;)) { name = attrs.getAttributeValue(null, &quot;class&quot;); } // 如果设置了theme, 构建一个ContextThemeWrapper if (!ignoreThemeAttr) { final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) { context = new ContextThemeWrapper(context, themeResId); } ta.recycle(); } try {\b\b // 如果name是blink，则创建BlinkLayout // 如果设置factory，根据factory进行解析, 这是系统留给我们的Hook入口 View view = tryCreateView(parent, name, context, attrs); // 如果 tryCreateView方法返回的View为空，则判断是内置View还是自定义View // 如果是内置的View则调用onCreateView方法，如果是自定义View 则调用createView方法 if (view == null) { final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try { // 如果使用自定义View，需要在XML指定全路径的， // 例如：com.hi.dhl.CustomView，那么这里就有个.了 // 可以利用这一点判定是内置的View，还是自定义View if (-1 == name.indexOf('.')) { // 解析内置View view = onCreateView(context, parent, name, attrs); } else { // 解析自定义View view = createView(context, name, null, attrs); } /** * onCreateView方法与createView方法的区别 * onCreateView方法：会给内置的View前面加一个前缀，例如：android.widget，最终会调用createView方法 * createView方法: 据完整的类的路径名利用反射机制构建View对象 */ } finally { mConstructorArgs[0] = lastContext; } } return view; } catch (InflateException e) { throw e; } catch (ClassNotFoundException e) { throw ie; } catch (Exception e) { throw ie; }} 解析 View 标签，如果设置了 theme, 构建一个 ContextThemeWrapper 调用 tryCreateView 方法，如果 name 是 blink，则创建 BlinkLayout，如果设置 factory，根据 factory 进行解析，这是系统留给我们的 Hook 入口，我们可以人为的干涉系统创建 View，添加更多的功能 如果 tryCreateView 方法返回的 View 为空，则分别调用 onCreateView 方法和 createView 方法，onCreateView 方法解析内置 View，createView 方法解析自定义 View 在解析过程中，会先调用 tryCreateView 方法，来看一下 tryCreateView 方法内部做了什么frameworks/base/core/java/android/view/LayoutInflater.java public final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) { // BlinkLayout它是FrameLayout的子类，是LayoutInflater中的一个内部类, // 如果当前标签为TAG_1995，则创建一个隔500毫秒闪烁一次的BlinkLayout来承载它的布局内容 if (name.equals(TAG_1995)) { // Let's party like it's 1995! // 源码注释也很有意思，写了Let's party like it's 1995!, 据说是为了庆祝1995年的复活节 return new BlinkLayout(context, attrs); } // 如果设置factory，根据factory进行解析, 这是系统留给我们的Hook入口，我们可以人为的干涉系统创建View，添加更多的功能 if (mFactory2 != null) { view = mFactory2.onCreateView(parent, name, context, attrs); } else if (mFactory != null) { view = mFactory.onCreateView(name, context, attrs); } else { view = null; } if (view == null &amp;&amp; mPrivateFactory != null) { view = mPrivateFactory.onCreateView(parent, name, context, attrs); } return view;} 如果 name 是 blink，则创建 BlinkLayout，返给调用者 如果设置 factory，根据 factory 进行解析, 这是系统留给我们的 Hook 入口，我们可以人为的干涉系统创建 View，添加更多的功能，例如夜间模式，将 View 返给调用者 根据刚才的分析，会先调用 tryCreateView 方法，如果这个方法返回的 View 为空，然后会调用 onCreateView 方法对内置 View 进行解析，createView 方法对自定义 View 进行解析 onCreateView 方法与 createView 方法的有什么区别 onCreateView 方法：会给内置的 View 前面加一个前缀，例如： android.widget，最终会调用 createView 方法 createView 方法: 根据完整的类的路径名利用反射机制构建 View 对象 来看一下这两个方法的实现，LayoutInflater 是一个抽象类，我们实际使用的是 PhoneLayoutInflater，它的结构如下 PhoneLayoutInflater 重写了 LayoutInflater 的 onCreatView 方法，这个方法就是给内置的 View 前面加一个前缀frameworks/base/core/java/com/android/internal/policy/PhoneLayoutInflater.java private static final String[] sClassPrefixList = { &quot;android.widget.&quot;, &quot;android.webkit.&quot;, &quot;android.app.&quot;}; protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException { for (String prefix : sClassPrefixList) { try { View view = createView(name, prefix, attrs); if (view != null) { return view; } } catch (ClassNotFoundException e) { } } return super.onCreateView(name, attrs);} onCreateView 方法会给内置的 View 前面加一个前缀，之后调用 createView 方法，真正的 View 构建还是在 LayoutInflater 的 createView 方法里完成的，createView 方法根据完整的类的路径名利用反射机制构建 View 对象frameworks/base/core/java/android/view/LayoutInflater.java public final View createView(@NonNull Context viewContext, @NonNull String name, @Nullable String prefix, @Nullable AttributeSet attrs) throws ClassNotFoundException, InflateException { ... try { if (constructor == null) { // 如果在缓存中没有找到构造函数，则根据完整的类的路径名利用反射机制构建View对象 clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); if (mFilter != null &amp;&amp; clazz != null) { boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) { failNotAllowed(name, prefix, viewContext, attrs); } } // 利用反射机制构建clazz, 将它的构造函数存入sConstructorMap中，下次可以直接从缓存中查找 constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); } else { // 如果从缓存中找到了缓存的构造函数 if (mFilter != null) { Boolean allowedState = mFilterMap.get(name); if (allowedState == null) { // 根据完整的类的路径名利用反射机制构建View对象 clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); ... } else if (allowedState.equals(Boolean.FALSE)) { failNotAllowed(name, prefix, viewContext, attrs); } } } ... try { // 利用构造函数，创建View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // 如果是ViewStub，则设置LayoutInflater final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view; } finally { mConstructorArgs[0] = lastContext; } } catch (NoSuchMethodException e) { throw ie; } catch (ClassCastException e) { throw ie; } catch (ClassNotFoundException e) { throw e; } catch (Exception e) { throw ie; } finally { } } 先从缓存中寻找构造函数，如果存在直接使用 如果没有找到根据完整的类的路径名利用反射机制构建 View 对象 到了这里关于 APK 的布局 XML 资源文件的查找和解析 -&gt; View 的生成流程到这里就结束了 总结那我们就来依次来回答上面提出的几个问题 LayoutInflater 的 inflate 的三个参数都代表什么意思？ resource：要解析的 XML 布局文件 ID root：表示根布局 attachToRoot：是否要添加到父布局 root 中 resource 其实很好理解就是资源 ID，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 系统对 merge、include 是如何处理的 使用 merge 标签必须有父布局，且依赖于父布局加载 merge 并不是一个 ViewGroup，也不是一个 View，它相当于声明了一些视图，等待被添加，解析过程中遇到 merge 标签会将 merge 标签下面的所有子 view 添加到根布局中 merge 标签在 XML 中必须是根元素 相反的 include 不能作为根元素，需要放在一个 ViewGroup 中 使用 include 标签必须指定有效的 layout 属性 使用 include 标签不写宽高是没有关系的，会去解析被 include 的 layout merge 标签为什么可以起到优化布局的效果？ 解析过程中遇到 merge 标签，会调用 rInflate 方法，解析 merge 标签下面的所有子 View，然后添加到根布局中 View 是如何被实例化的？ View 分为系统 View 和自定义 View, 通过调用 onCreateView 与createView 方法进行不同的处理 onCreateView 方法：会给内置的 View 前面加一个前缀，例如：android.widget，最终会调用 createView 方法 createView 方法：根据完整的类的路径名利用反射机制构建 View 对象 为什么复杂布局会产生卡顿？在 Android 10 上做了那些优化？ XmlResourseParser 对 XML 的遍历，随着布局越复杂，层级嵌套越多，所花费的时间也越长 调用 onCreateView 与 createView 方法是通过反射创建 View 对象导致的耗时 在 Android 10上，新增 tryInflatePrecompiled 方法是为了减少 XmlPullParser 解析 XML 的时间，但是用一个全局变量 mUseCompiledView 来控制是否启用 tryInflatePrecompiled 方法，根据源码分析，mUseCompiledView 始终为 false，所以 tryInflatePrecompiled 方法目前在 release 版本中不可使用 BlinkLayout 是什么？ BlinkLayout 继承 FrameLayout，是一种会闪烁的布局，被包裹的内容会一直闪烁，根据源码注释 Let’s party like it’s 1995!，BlinkLayout 是为了庆祝 1995 年的复活节, 有兴趣可以看看 reddit 上的讨论。BlinkLayout 通过 Handler 每隔 500ms 发送消息，在 handleMessage 中循环调用 invalidate 方法，通过调用 invalidate 方法，来触发 dispatchDraw 方法，做到一闪一闪的效果 参考 https://www.reddit.com/r/androiddev/comments/3sekn8/lets_party_like_its_1995_from_the_layoutinflater/ https://github.com/RTFSC-Android/RTFSC/blob/master/LayoutInflater.md https://www.yuque.com/beesx/beesandroid/gd7w9o","link":"/2020/06/07/android10/resource-manager/03-APK-resource/"},{"title":"Android 10 源码分析：APK 的安装流程","text":"前言 这是 Android 10 源码分析系列的第 2 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 上一篇文章介绍了 0xA01 Android 10 源码分析：APK 是如何生成的，这篇文章接着介绍如何安装 APK，需要说一下 Android 10 及更高版本中, 安装器 PackageInstaller 源码位置有所变动 PackageInstaller 源码所在位置PackageInstaller 是系统内置的应用程序，用于安装和卸载应用 在 Android 9 及更低版本中，软件包安装和权限控制功能包含在 PackageInstaller 软件包 (//packages/apps/PackageInstaller) 中。在 Android 10 及更高版本中，权限控制功能位于单独的软件包 PermissionController (//packages/apps/PermissionController)，这两个软件包在 Android 10 中的位置如下图所示，更多信息点击这里前往 Android 权限 Android 9 及更低版本中 ： 软件包安装和权限控制功能源码路径：packages/apps/PackageInstaller Android 10 及更高版本： 权限控制功能 PermissionController 源码路径：packages/apps/PermissionController/ 安装器 PackageInstaller 源码路径：frameworks/base/packages/PackageInstaller/ 在 Android 系统不同的目录存放不同类型的应用 /system/framwork：保存的是资源型的应用程序，它们用来打包资源文件 /system/app：保存系统自带的应用程序 /data/app：保存用户安装的应用程序 /data/data：应用数据目录 /data/app-private：保存受DRM保护的私有应用程序 /vendor/app：保存设备厂商提供的应用程序 查看 PackageInstaller 源码方式 AOSP-PackageInstaller: 包含了安装器 PackageInstaller(7.1.2、8.1.0、9.0.0、10.0.0) 的源码，可以切换分之查看，跟随 Android 版本更新，你永远可以看到最新的源代码 aospxref：这是一个在线查看 Android 源码网站，服务器在阿里云访问速度很快，文末有关这个网站的介绍 googlesource-PackageInstaller：这是安装器 PackageInstaller 在 googlesource 上的地址 1. APK 的安装方式安装 APK 主要分为以下三种场景 安装系统应用：系统启动后调用 PackageManagerService.main() 初始化注册解析安装工作 public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { // Self-check for initial settings. PackageManagerServiceCompilerMapping.checkProperties(); PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); m.enableSystemUserPackages(); ServiceManager.addService(&quot;package&quot;, m); final PackageManagerNative pmn = m.new PackageManagerNative(); ServiceManager.addService(&quot;package_native&quot;, pmn); return m;} 通过 adb 安装：通过 pm 参数，调用 PM 的 runInstall 方法，进入 PackageManagerService 安装安装工作 通过系统安装器 PackageInstaller 进行安装：先调用 InstallStart 进行权限检查之后启动 PackageInstallActivity，调用 PackageInstallActivity 的 startInstall 方法，点击 OK 按钮后进入 PackageManagerService 完成拷贝解析安装工作 所有安装方式大致相同，最终就是回到 PackageManagerService 中，安装一个 APK 的大致流程如下： 拷贝到 APK 文件到指定目录 解压缩 APK，拷贝文件，创建应用的数据目录 解析 APK 的 AndroidManifest.xml 文件 向 Launcher 应用申请添加创建快捷方式 本文主要来分析通过安装器 PackageInstaller 安装 APK，这是用户最常用的一种方式 2. PackageInstaller 的入口下面代码一定不会很陌生，这就是我们常用的安装 APK 的代码（PS: 关于静默安装我会后续分享在逆向开发相关的文章） Intent intent = new Intent(Intent.ACTION_VIEW);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);/** 自Android N开始，是通过FileProvider共享相关文件，但是Android Q对公* 有目录 File API进行了限制，只能通过Uri来操作*/if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q){ // filePath是通过ContentResolver得到的 intent.setDataAndType(Uri.parse(filePath) ,&quot;application/vnd.android.package-archive&quot;); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);}else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(mContext, &quot;com.dhl.file.fileProvider&quot;, file); intent.setDataAndType(contentUri, &quot;application/vnd.android.package-archive&quot;);} else { intent.setDataAndType(Uri.fromFile(file), &quot;application/vnd.android.package-archive&quot;);}startActivity(intent);// 需要在AndroidManifest添加权限&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt; 通过 intent.setDataAndType 方法指定 Intent 的数据类型为 application/vnd.android.package-archive，隐式匹配的 Activity 为 InstallStart：frameworks/base/packages/PackageInstaller/AndroidManifest.xml &lt;activity android:name=&quot;.InstallStart&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot; android:exported=&quot;true&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;content&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;data android:scheme=&quot;content&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_INSTALL&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 本文分析的是 10.0 的源码，在 8.0、9.0、10.0 等等版本中隐式匹配的 Activity 是 InstallStart，7.0 隐式匹配的 Activity 是 PackageInstallerActivity 安装器 PackageInstaller 的入口 Activity 是 InstallStart，定义了两个 scheme：content 和 package 3. APK 的安装流程通过上面方式找到了入口 Activity，下面我们来查看一下 APK 是如何安装的 3.1 InstallStart主要工作： 判断是否勾选“未知来源”选项，若未勾选跳转到设置安装未知来源界面 对于大于等于 Android 8.0 版本，会先检查是否申请安装权限，若没有则中断安装 判断 Uri 的 Scheme 协议，若是 content 则调用 InstallStaging, 若是 package 则调用 PackageInstallerActivity 当我们调用上面安装代码来安装 APK 时。会跳转到 InstallStart, 并调用它的 onCreate 方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallStart.java @Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ... final boolean isSessionInstall = PackageInstaller.ACTION_CONFIRM_INSTALL.equals(intent.getAction()); ... final ApplicationInfo sourceInfo = getSourceInfo(callingPackage); final int originatingUid = getOriginatingUid(sourceInfo); boolean isTrustedSource = false; // 判断是否勾选“未知来源”选项 if (sourceInfo != null &amp;&amp; (sourceInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) { isTrustedSource = intent.getBooleanExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, false); } if (!isTrustedSource &amp;&amp; originatingUid != PackageInstaller.SessionParams.UID_UNKNOWN) { final int targetSdkVersion = getMaxTargetSdkVersionForUid(this, originatingUid); // 如果targetSdkVerison小于0中止安装 if (targetSdkVersion &lt; 0) { Log.w(LOG_TAG, &quot;Cannot get target sdk version for uid &quot; + originatingUid); mAbortInstall = true; // 如果targetSdkVersion大于等于26（8.0）, 且获取不到REQUEST_INSTALL_PACKAGES权限中止安装 } else if (targetSdkVersion &gt;= Build.VERSION_CODES.O &amp;&amp; !declaresAppOpPermission( originatingUid, Manifest.permission.REQUEST_INSTALL_PACKAGES)) { Log.e(LOG_TAG, &quot;Requesting uid &quot; + originatingUid + &quot; needs to declare permission &quot; + Manifest.permission.REQUEST_INSTALL_PACKAGES); mAbortInstall = true; } } ... // 如果设置了ACTION_CONFIRM_PERMISSIONS，则调用PackageInstallerActivity。 if (isSessionInstall) { nextActivity.setClass(this, PackageInstallerActivity.class); } else { Uri packageUri = intent.getData(); // 判断Uri的Scheme协议是否是content if (packageUri != null &amp;&amp; packageUri.getScheme().equals( ContentResolver.SCHEME_CONTENT)) { // [IMPORTANT] This path is deprecated, but should still work. // 这个路径已经被起用了，但是仍然可以工作 // 调用InstallStaging来拷贝file/content，防止被修改 nextActivity.setClass(this, InstallStaging.class); } else if (packageUri != null &amp;&amp; packageUri.getScheme().equals( PackageInstallerActivity.SCHEME_PACKAGE)) { // 如果Uri中包含package，则调用PackageInstallerActivity nextActivity.setClass(this, PackageInstallerActivity.class); } else { // Uri不合法 Intent result = new Intent(); result.putExtra(Intent.EXTRA_INSTALL_RESULT, PackageManager.INSTALL_FAILED_INVALID_URI); setResult(RESULT_FIRST_USER, result); nextActivity = null; } } if (nextActivity != null) { startActivity(nextActivity); } finish();} 根据 Uri 的 Scheme 协议，若是 content 则调用 InstallStaging，查看 InstallStaging 的 onResume方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallStaging.java @Overrideprotected void onResume() { super.onResume(); if (mStagingTask == null) { if (mStagedFile == null) { // 创建临时文件 mStagedFile 用来存储数据 try { mStagedFile = TemporaryFileManager.getStagedFile(this); } catch (IOException e) { showError(); return; } } // 启动 StagingAsyncTask，并传入了content协议的Uri mStagingTask = new StagingAsyncTask(); mStagingTask.execute(getIntent().getData()); }} 创建临时文件 mStagedFile 用来存储数据 启动 StagingAsyncTask，并传入了 content 协议的 Uri private final class StagingAsyncTask extends AsyncTask&lt;Uri, Void, Boolean&gt; { @Override protected Boolean doInBackground(Uri... params) { ... Uri packageUri = params[0]; try (InputStream in = getContentResolver().openInputStream(packageUri)) { ... // 将packageUri（content协议的Uri）的内容写入到mStagedFile中 try (OutputStream out = new FileOutputStream(mStagedFile)) { byte[] buffer = new byte[1024 * 1024]; int bytesRead; while ((bytesRead = in.read(buffer)) &gt;= 0) { // Be nice and respond to a cancellation if (isCancelled()) { return false; } out.write(buffer, 0, bytesRead); } } } catch (IOException | SecurityException | IllegalStateException e) { Log.w(LOG_TAG, &quot;Error staging apk from content URI&quot;, e); return false; } return true; } @Override protected void onPostExecute(Boolean success) { if (success) { // 如果写入成功，调用DeleteStagedFileOnResult Intent installIntent = new Intent(getIntent()); installIntent.setClass(InstallStaging.this, DeleteStagedFileOnResult.class); installIntent.setData(Uri.fromFile(mStagedFile)); ... startActivity(installIntent); InstallStaging.this.finish(); } else { showError(); } }} doInBackground 方法中将 packageUri（content 协议的 Uri）的内容写入到 mStagedFile 中 如果写入成功，调用 DeleteStagedFileOnResult 的 OnCreate 方法： frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/DeleteStagedFileOnResult.java protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (savedInstanceState == null) { // 启动PackageInstallerActivity Intent installIntent = new Intent(getIntent()); installIntent.setClass(this, PackageInstallerActivity.class); installIntent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION); startActivityForResult(installIntent, 0); }} 经过分析 InstallStaging 主要起了中转作用，将 content 协议的 Uri 转换为 File 协议，最后跳转到 PackageInstallerActivity 3.2 PackageInstallerActivity主要工作： 显示安装界面 初始化安装需要用的各种对象，比如 PackageManager、IPackageManager、AppOpsManager、UserManager、PackageInstaller 等等 根据传递过来的 Scheme 协议做不同的处理 检查是否允许、初始化安装 在准备安装的之前，检查应用列表判断该应用是否已安装，若已安装则提示该应用已安装，由用户决定是否替换 在安装界面，提取出 APK 中权限信息并展示出来 点击 OK 按钮确认安装后，会调用 startInstall 开始安装工作 PackageInstallerActivity 才是应用安装器 PackageInstaller 真正的入口 Activity，查看它的 onCreate 方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java protected void onCreate(Bundle icicle) { getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS); super.onCreate(null); // 初始化安装需要用到的对象 mPm = getPackageManager(); mIpm = AppGlobals.getPackageManager(); mAppOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); // 根据Uri的Scheme做不同的处理 boolean wasSetUp = processPackageUri(packageUri); if (!wasSetUp) { return; } // 显示安装界面 bindUi(); // 检查是否允许安装包，如果允许则启动安装。如果不允许显示适当的对话框 checkIfAllowedAndInitiateInstall();} 主要做了对象的初始化，解析 Uri 的 Scheme，初始化界面，安装包检查等等工作，接着查看一下 processPackageUri 方法 private boolean processPackageUri(final Uri packageUri) { mPackageURI = packageUri; final String scheme = packageUri.getScheme(); // 根据这个Scheme协议分别对package协议和file协议进行处理 switch (scheme) { case SCHEME_PACKAGE: { try { // 通过PackageManager对象获取指定包名的包信息 mPkgInfo = mPm.getPackageInfo(packageUri.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.MATCH_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + packageUri.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); return false; } mAppSnippet = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } break; case ContentResolver.SCHEME_FILE: { // 根据packageUri创建一个新的File File sourceFile = new File(packageUri.getPath()); // 解析APK得到APK的信息，PackageParser.Package存储了APK的所有信息 PackageParser.Package parsed = PackageUtil.getPackageInfo(this, sourceFile); if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); return false; } // 根据PackageParser.Package得到的APK信息，生成PackageInfo mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mAppSnippet = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } break; default: { throw new IllegalArgumentException(&quot;Unexpected URI scheme &quot; + packageUri); } } return true;} 主要对 Scheme 协议分别对 package 协议和 file 协议进行处理 SCHEME_PACKAGE： 在 package 协议中调用了 PackageManager.getPackageInfo 方法生成 PackageInfo，PackageInfo 是跨进程传递的包数据（activities、receivers、services、providers、permissions等等）包含 APK 的所有信息 SCHEME_FILE： 在 file 协议的处理中调用了 PackageUtil.getPackageInfo 方法，方法内部调用了 PackageParser.parsePackage() 把 APK 文件的 manifest 和签名信息都解析完成并保存在了 Package，Package 包含了该 APK 的所有信息 调用 PackageParser.generatePackageInfo 生成 PackageInfo 接着往下走，都解析完成之后，回到 onCreate 方法，继续调用 checkIfAllowedAndInitiateInstall 方法 private void checkIfAllowedAndInitiateInstall() { // 首先检查安装应用程序的用户限制，如果有限制并弹出弹出提示Dialog或者跳转到设置界面 final int installAppsRestrictionSource = mUserManager.getUserRestrictionSource( UserManager.DISALLOW_INSTALL_APPS, Process.myUserHandle()); if ((installAppsRestrictionSource &amp; UserManager.RESTRICTION_SOURCE_SYSTEM) != 0) { showDialogInner(DLG_INSTALL_APPS_RESTRICTED_FOR_USER); return; } else if (installAppsRestrictionSource != UserManager.RESTRICTION_NOT_SET) { startActivity(new Intent(Settings.ACTION_SHOW_ADMIN_SUPPORT_DETAILS)); finish(); return; } // 判断如果允许安装未知来源或者根据Intent判断得出该APK不是未知来源 if (mAllowUnknownSources || !isInstallRequestFromUnknownSource(getIntent())) { initiateInstall(); } else { // 检查未知安装源限制,如果有限制弹出Dialog,显示相应的信息 final int unknownSourcesRestrictionSource = mUserManager.getUserRestrictionSource( UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, Process.myUserHandle()); final int unknownSourcesGlobalRestrictionSource = mUserManager.getUserRestrictionSource( UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, Process.myUserHandle()); final int systemRestriction = UserManager.RESTRICTION_SOURCE_SYSTEM &amp; (unknownSourcesRestrictionSource | unknownSourcesGlobalRestrictionSource); if (systemRestriction != 0) { showDialogInner(DLG_UNKNOWN_SOURCES_RESTRICTED_FOR_USER); } else if (unknownSourcesRestrictionSource != UserManager.RESTRICTION_NOT_SET) { startAdminSupportDetailsActivity(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES); } else if (unknownSourcesGlobalRestrictionSource != UserManager.RESTRICTION_NOT_SET) { startAdminSupportDetailsActivity( UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY); } else { // 处理未知来源的APK handleUnknownSources(); } }} 主要检查安装应用程序的用户限制，当 APK 文件不对或者安装有限制则调用 showDialogInner 方法，弹出 dialog 提示用户，显示相应的错误信息，来看一下都有那些错误信息 // Dialog identifiers used in showDialogprivate static final int DLG_BASE = 0;// package信息错误private static final int DLG_PACKAGE_ERROR = DLG_BASE + 2;// 存储空间不够private static final int DLG_OUT_OF_SPACE = DLG_BASE + 3;// 安装错误private static final int DLG_INSTALL_ERROR = DLG_BASE + 4;// 用户限制的未知来源private static final int DLG_UNKNOWN_SOURCES_RESTRICTED_FOR_USER = DLG_BASE + 5;private static final int DLG_ANONYMOUS_SOURCE = DLG_BASE + 6;// 在wear上不支持private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7;private static final int DLG_EXTERNAL_SOURCE_BLOCKED = DLG_BASE + 8;// 安装限制用户使用的应用程序private static final int DLG_INSTALL_APPS_RESTRICTED_FOR_USER = DLG_BASE + 9; 如果用户允许安装未知来源，会调用 initiateInstall 方法 private void initiateInstall() { String pkgName = mPkgInfo.packageName; // 检查设备上是否存在相同包名的APK String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] { pkgName }); if (oldName != null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] != null) { pkgName = oldName[0]; mPkgInfo.packageName = pkgName; mPkgInfo.applicationInfo.packageName = pkgName; } // 检查package是否已安装, 如果已经安装则显示对话框提示用户是否替换。 try { mAppInfo = mPm.getApplicationInfo(pkgName, PackageManager.MATCH_UNINSTALLED_PACKAGES); if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) == 0) { mAppInfo = null; } } catch (NameNotFoundException e) { mAppInfo = null; } // 初始化确认安装界面 startInstallConfirm();} 根据包名获取应用程序的信息，调用 startInstallConfirm 方法初始化安装确认界面后，当用户点击确认按钮之后发生了什么，接着查看确认按钮点击事件 private void bindUi() { ... // 点击确认按钮，安装APK mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install), (ignored, ignored2) -&gt; { if (mOk.isEnabled()) { if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, true); finish(); } else { // 启动Activity来完成应用的安装 startInstall(); } } }, null); // 点击取消按钮，取消此次安装 mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel), (ignored, ignored2) -&gt; { // Cancel and finish setResult(RESULT_CANCELED); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, false); } finish(); }, null); setupAlert(); mOk = mAlert.getButton(DialogInterface.BUTTON_POSITIVE); mOk.setEnabled(false);} 当用户点击确认按钮调用了 startInstall 方法，启动子 Activity 完成 APK 的安装 private void startInstall() { // 启动子Activity来完成应用的安 Intent newIntent = new Intent(); newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mPkgInfo.applicationInfo); newIntent.setData(mPackageURI); newIntent.setClass(this, InstallInstalling.class); ... if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI); startActivity(newIntent); finish();} startInstall 方法用来跳转到 InstallInstalling，并关闭掉当前的 PackageInstallerActivity 3.3 InstallInstalling主要工作： 向包管理器发送包的信息，然后等待包管理器处理结果 注册一个观察者 InstallEventReceiver，并接受安装成功和失败的回调 在方法 onResume 中创建同步栈，打开安装 session，设置安装进度条 InstallInstalling 首先向包管理器发送包的信息，然后等待包管理器处理结果，并在方法 InstallSuccess 和方法 InstallFailed 进行成功和失败的处理，查看 InstallInstalling 的 onCreate 方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallInstalling.java protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ... // 判断安装的应用是否已经存在 if (&quot;package&quot;.equals(mPackageURI.getScheme())) { try { getPackageManager().installExistingPackage(appInfo.packageName); launchSuccess(); } catch (PackageManager.NameNotFoundException e) { launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); } } else { final File sourceFile = new File(mPackageURI.getPath()); PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, appInfo, sourceFile); ... if (savedInstanceState != null) { // 如果savedInstanceState 不为空，获取已经存在mSessionId 和mInstallId 重新注册 mSessionId = savedInstanceState.getInt(SESSION_ID); mInstallId = savedInstanceState.getInt(INSTALL_ID); try { // 根据mInstallId向InstallEventReceiver注册一个观察者，launchFinishBasedOnResult会接收到安装事件的回调 InstallEventReceiver.addObserver(this, mInstallId, this::launchFinishBasedOnResult); } catch (EventResultPersister.OutOfIdsException e) { } } else { // 如果为空创建SessionParams，代表安装会话的参数 // 解析APK, 并将解析的参数赋值给SessionParams PackageInstaller.SessionParams params = new PackageInstaller.SessionParams( PackageInstaller.SessionParams.MODE_FULL_INSTALL); ... try { // 注册InstallEventReceiver，并在launchFinishBasedOnResult会接收到安装事件的回调 mInstallId = InstallEventReceiver .addObserver(this, EventResultPersister.GENERATE_NEW_ID, this::launchFinishBasedOnResult); } catch (EventResultPersister.OutOfIdsException e) { launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); } try { // createSession 内部通过IPackageInstaller与PackageInstallerService进行进程间通信， // 最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId mSessionId = getPackageManager().getPackageInstaller().createSession(params); } catch (IOException e) { launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); } } ... }} 最终都会注册一个观察者 InstallEventReceiver，并在 launchFinishBasedOnResult 会接收到安装事件的回调，其中 InstallEventReceiver 继承自 BroadcastReceiver，用于接收安装事件并回调给 EventResultPersister createSession 内部通过 IPackageInstaller 与 PackageInstallerService 进行进程间通信，最终调用的是 PackageInstallerService的createSession 方法来创建并返回 mSessionId 接下来在 onResume 方法创建 InstallingAsyncTask 用来执行 APK 的安装，接着查看 onResume 方法 protected void onResume() { super.onResume(); if (mInstallingTask == null) { PackageInstaller installer = getPackageManager().getPackageInstaller(); // 根据mSessionId 获取SessionInfo, 代表安装会话的详细信息 PackageInstaller.SessionInfo sessionInfo = installer.getSessionInfo(mSessionId); if (sessionInfo != null &amp;&amp; !sessionInfo.isActive()) { mInstallingTask = new InstallingAsyncTask(); mInstallingTask.execute(); } else { // 安装完成后会收到广播 mCancelButton.setEnabled(false); setFinishOnTouchOutside(false); } }} 得到 SessionInfo 创建并创建 InstallingAsyncTask，InstallingAsyncTask 的 doInBackground 方法设置安装进度条，并将 APK 信息写入 PackageInstaller.Session，写入完成之后，在 InstallingAsyncTask 的 onPostExecute 进行成功与失败的处理，接着查看 onPostExecute 方法 protected void onPostExecute(PackageInstaller.Session session) { if (session != null) { Intent broadcastIntent = new Intent(BROADCAST_ACTION); broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND); broadcastIntent.setPackage(getPackageName()); broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId); PendingIntent pendingIntent = PendingIntent.getBroadcast( InstallInstalling.this, mInstallId, broadcastIntent, PendingIntent.FLAG_UPDATE_CURRENT); session.commit(pendingIntent.getIntentSender()); mCancelButton.setEnabled(false); setFinishOnTouchOutside(false); } else { getPackageManager().getPackageInstaller().abandonSession(mSessionId); if (!isCancelled()) { launchFailure(PackageManager.INSTALL_FAILED_INVALID_APK, null); } }} 创建了 broadcastIntent，并通过 PackageInstaller.Session 的 commit 方法发送出去，通过 broadcastIntent 构造方法指定的 Intent 的 Action 为 BROADCAST_ACTION，而 BROADCAST_ACTION 是一个常量值 private static final String BROADCAST_ACTION = &quot;com.android.packageinstaller.ACTION_INSTALL_COMMIT&quot;; 回到 InstallInstalling.OnCreate 方法，在 OnCreate 方法注册 InstallEventReceiver，而 InstallEventReceiver 继承自 BroadcastReceiver，而使用 BroadcastReceiver 需要在 AndroidManifest.xml注册，接着查看 AndroidManifest.xml：/frameworks/base/packages/PackageInstaller/AndroidManifest.xml &lt;receiver android:name=&quot;.InstallEventReceiver&quot; android:permission=&quot;android.permission.INSTALL_PACKAGES&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;com.android.packageinstaller.ACTION_INSTALL_COMMIT&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 安装结束之后，会在观察者 InstallEventReceiver 注册的回调方法 launchFinishBasedOnResult 处理安装事件的结果，接着查看 launchFinishBasedOnResult private void launchFinishBasedOnResult(int statusCode, int legacyStatus, String statusMessage) { if (statusCode == PackageInstaller.STATUS_SUCCESS) { launchSuccess(); } else { launchFailure(legacyStatus, statusMessage); }}private void launchSuccess() { Intent successIntent = new Intent(getIntent()); successIntent.setClass(this, InstallSuccess.class); successIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); startActivity(successIntent); finish();} private void launchFailure(int legacyStatus, String statusMessage) { Intent failureIntent = new Intent(getIntent()); failureIntent.setClass(this, InstallFailed.class); failureIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); failureIntent.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, legacyStatus); failureIntent.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, statusMessage); startActivity(failureIntent); finish();} 安装成功和失败，都会启动一个新的 Activity（InstallSuccess、InstallFailed）将结果展示给用户，然后 finish 掉 InstallInstalling 4. 总结总结一下 PackageInstaller 安装APK的过程： 根据根据 Uri 的 Scheme 找到入口 InstallStart InstallStart 根据 Uri 的 Scheme 协议不同做不同的处理 都会调用 PackageInstallerActivity, 然后分别对package协议和 file 协议的 Uri 进行处理 PackageInstallerActivity 检查未知安装源限制,如果安装源限制弹出提示 Dialog 点击 OK 按钮确认安装后，会调用 startInstall 开始安装工作 如果用户允许安装，然后跳转到 InstallInstalling，进行 APK 的安装工作 在 InstallInstalling 中，向包管理器发送包的信息，然后注册一个观察者 InstallEventReceiver，并接受安装成功和失败的回调 5. 关于 packages.xml在 Andorid 系统目录 “/data/system” 下保存很多系统文件，主要介绍 packages.xml 文件 packages.xml：记录了系统中所有安装的应用信息，包括基本信息、签名和权限、APK 文件的路径、native 库的存储路径 系统启动的时候会通过 PackageManagerServcie 读取这个文件加载系统中所有安装的应用，这个文件在开发中也是非常有帮助的，不同厂商会对 Android 源码有不同的修改，如果我们需要分析系统 App 的源码，就通过这个 packages.xml 找到目标 APK，dump 出来分析源码 以下是 packages.xml 文件部分内容 &lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;packages&gt; &lt;version sdkVersion=&quot;27&quot; databaseVersion=&quot;3&quot; fingerprint=&quot;Meizu/meizu_M1822_CN/M1822:8.1.0/OPM1.171019.026/1539943691:user/release-keys&quot; /&gt; &lt;version volumeUuid=&quot;primary_physical&quot; sdkVersion=&quot;27&quot; databaseVersion=&quot;27&quot; fingerprint=&quot;Meizu/meizu_M1822_CN/M1822:8.1.0/OPM1.171019.026/1539943691:user/release-keys&quot; /&gt; &lt;meizu_version meizu_fingerprint=&quot;8.1.0-1541573178_stable&quot; /&gt; &lt;permission-trees /&gt; &lt;permissions&gt; &lt;item name=&quot;com.meizu.voiceassistant.push.permission.MESSAGE&quot; package=&quot;com.meizu.voiceassistant&quot; protection=&quot;2&quot; /&gt; &lt;item name=&quot;com.meizu.safe.alphame.permission.DATA&quot; package=&quot;com.meizu.safe&quot; protection=&quot;18&quot; /&gt; &lt;item name=&quot;android.permission.REAL_GET_TASKS&quot; package=&quot;android&quot; protection=&quot;18&quot; /&gt; ...... &lt;item name=&quot;android.permission.MODIFY_PHONE_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.WAKE_LOCK&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;1&quot; /&gt; &lt;/package&gt; &lt;package name=&quot;com.android.providers.telephony&quot; codePath=&quot;/system/priv-app/TelephonyProvider&quot; nativeLibraryPath=&quot;/system/priv-app/TelephonyProvider/lib&quot; primaryCpuAbi=&quot;arm64-v8a&quot; publicFlags=&quot;1007402501&quot; privateFlags=&quot;8&quot; ft=&quot;11e8dc5d800&quot; it=&quot;11e8dc5d800&quot; ut=&quot;11e8dc5d800&quot; version=&quot;27&quot; sharedUserId=&quot;1001&quot; isOrphaned=&quot;true&quot; forceFull=&quot;true&quot;&gt; &lt;sigs count=&quot;1&quot;&gt; &lt;cert index=&quot;0&quot; /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=&quot;android.permission.SEND_RECEIVE_STK_INTENT&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.BIND_INCALL_SERVICE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; ...... &lt;item name=&quot;android.permission.UPDATE_APP_OPS_STATS&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;1&quot; /&gt; &lt;/package&gt; 5.1. package 表示包信息 name 表示应用的包名 codePath 表示的是 APK 文件的路径 nativeLibraryPath 表示应用的 native 库的存储路径 it 表示应用安装的时间 ut 表示应用最后一次修改的时间 version 表示应用的版本号 userId 表示所属于的 id 5.2. sign 表示应用的签名 count 表示标签中包含有多少个证书 cert 表示具体的证书的值 5.3. perms 表示应用声明使用的权限，每一个子标签代表一项权限6. 安利一个在线查看 Android 源码网站aospxref 是 weishu 大神搭建一个在线查看在线查看 Android源码网站, 访问速度非常快 在这之前我常用的在线查看 Android 源码的网站 androidxref，访问速度不仅慢，而且更新也不及时，现在 Android 10 发布了，这个网站到现在提供的最新的代码还是 Andorid 9 aospxref 提供了与 androidxref 完全一样的源码浏览和交叉索引功能；除此之外，它还有一些别的优点： 跟随 Android 版本更新，你永远可以看到最新的源代码。 服务器在阿里云，国内访问速度贼快。 opengrok 版本较高，查阅代码时会有自动提示。 对页面做过部分优化，使用更便捷；比如可以在任意界面跳转到首页。 参考 Android包管理总结 安利一个看 Android 源代码的网站 Android 权限 Android包管理机制（一）PackageInstaller的初始化","link":"/2020/06/07/android10/package-manager/02-APK-install/"},{"title":"Android 10 源码分析：APK 是如何生成的","text":"前言 这是 Android 10 源码分析系列的第 1 篇 分支：android-10.0.0_r14 全文阅读大概 5 分钟 APK 的文件可以分为 代码 和 资源 两部分，接下来源码分析系列，会完全围绕着，这两部分内容来分析，而今天这篇文章是 Android 10 源码分析系列的第 1 篇。 本文预计会分为两篇文章来分析 APK 是如何生成的： 从原理的角度分析 APK 是如何生成的 如果不使用 AndroidStudio 如何生成 APK 我们很多时候都是直接点击 Android Studio 中直接点击 Run ‘app’，就可以在 build/outputs/apk 目录下生成 APK 文件，那么 Android Studio 是如何做到的呢？ 接下来我们一起来分析一下 APK 的构建过程，APK 的文件可以分为 代码 和 资源 两部分，那么构建 APK 的过程中，也会对 代码 和 资源 做分别的处理。 我们先来看看 Google提供的流程图 大概了解一下 APK 的构建过程 新版构建流程图 APK 打包的内容主要有： 应用模块用到的源代码、资源文件、aidl 接口文件等等 依赖模块即源代码即第三方依赖库如：aar、jar、so 文件等等 新版构建流程图只是描述了大概的过程，为了能够清楚的了解 APK 是如何生成的, 在来看一下老版构建流程图。 老版构建流程图 我们先来了解一下图中所示各个工具的作用。 名字 功能 AAPT/APT2 Android 资源打包工具 AIDL 将所有的 AIDL 接口转化为 Java 接口 Javac(Java Compiler) 将所有的 Java 代码编译成 Class文件 Dex 将 Class 文件编译成 Dex 文件 Apkbuilder 将处理后的资源和代码打包生成 APK 文件 Jarsigner/Apksigner 对未签名的 APK 文件进行签名 Zipalign 优化签名后的 APK，减少运行时所占用的内存 构建过程Apk 的构建过程大概分为如下几步： 使用 AAPT 工具生成 R.java 文件 所有的 AIDL 接口转化为 Java 接口 将 Java 代码编译成 Class 文件 将 Class 文件编译成 Dex 文件 打包生成 APK 文件 对 APK 文件签名 优化 APK 文件 1. 使用 AAPT 工具生成 R.java 文件AAPT（Android Asset Packaging Tool）android 资源打包工具，将资源文件（包括AndroidManifest.xml、布局文件、各种 xml 资源等）打包生成 R.java 文件，将 AndroidManifest.xml 生成二进制的 AndroidManifest.java 文件 aapt p -M AndroidManifest.xml -S output/res/ -I android.jar -J ./ -F input/out.apkp：打包-M：AndroidManifest.xml 文件路径-S：res 目录路径-A：assets 目录路径-I：android.jar 路径，会用到的一些系统库-J 指定生成的 R.java 的输出目录-F 具体指定 APK 文件的输出 但是从 Android Studio 3.0 开始，google 默认开启了 AAPT2 作为资源编译的编译器，AAPT2 的出现为资源的增量编译提供了支持，aapt2 主要分两步，compile 和 link compile aapt2 compile -o res.apk --dir output/res/-o：指定已编译资源的输出路径--dir：指定包含多个资源文件的资源目录 link aapt2 link -o input/out.apk -I tools/android.jar --manifest output/AndroidManifest.xml -A res.apk --java ./-o：指定链接的资源 APK 的输出路径-I：指定 android.jar 路径--manifest：指定 AndroidManifest.xml 路径--java ：指定要在其中生成 R.java 的目录 2. 所有的 AIDL 接口转化为 Java 接口使用 AIDL（Android Interface Denifition Language），位于 sdk\\build-tools 目录下的 aidl 工具，将源码文件、aidl 文件、framework.aidl 等所有的 AIDL 文件，生成相应的 Java 文件，命令如下： aidl -Iaidl -pAndroid/Sdk/platforms/android-29/framework.aidl -obuild aidl/com/android/vending/billing/IInAppBillingService.aidl-I 指定 import 语句的搜索路径，注意 -I 与目录之间一定不要有空格-p 指定系统类的 import 语句路径，如果是要用到 android.os.Bundle 系统的类，一定要设置 sdk 的 framework.aidl 路径-o 生成 java 文件的目录，注意 -o 与目录之间一定不要有空格，而且这设置项一定要在 aidl 文件路径之前设置 3. 将 Java 代码编译成 Class 文件使用 Javac（Java Compiler）把项目中所有的 Java 代码编译成 class 文件, 包括 Java 源文件、AAPT 生成的 R.java 文件 以及 aidl 生成的 Java 接口文件，命令如下： javac -target 1.8 -bootclasspath platforms/android-28/android.jar -d ./java/com/testjni/*.java 4. 将 Class 文件编译成 Dex 文件使用 DX 工具将所有的 Class 文件（包括第三方库中的 class 文件）转换成 Dex 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），该过程主要完成 Java 字节码转换成 Dalvik 字节码, 命令如下： java -jar dx.jar --dex --ouput=classes.dex ./java/com/testjni/*.class--dex：将 class 文件转成dex文件--output：指定生成 dex 文件到具体位置 5. 打包生成 APK 文件使用 Apkbuilder（主要用到的是 sdk/tools/lib/sdklib.jar 文件中的 ApkBuilderMain 类）将所有的 Dex 文件、Resource.arsc、Res 文件夹、Assets 文件夹、AndroidManifest.xml 打包生成 APK 文件（未签名） 6. 对 APK 文件签名使用 Apksigner（Android官方针对 APK 签名及验证工具）或 Jarsigner（JDK提供针对 jar 包签名工具）对未签名的 APK 文件进行签名 ps：如果使用 Apksigner 签名需要（7. 优化 APK 文件）放到（6. 对 APK 文件签名）签名前面，为什么？请查看关于 Apksigner 和 Jarsigner 的区别，请移步到文末 7. 优化 APK 文件使用 zipalign 对签名后的 APK 文件进行对齐处理，对齐的主要过程是将 APK 包中所有的资源文件距离文件起始偏移为 4 字节整数倍，这样通过内存映射访问 APK 文件时的速度会更快，减少其在设备上运行时所占用的内存 总结上述打包过程都是 AndroidStudio 编译时，调用各种编译命令自动完成的, 总结一下上述打包过程： 除了 assets 和 res/raw 资源被原装不动地打包进 APK 之外，其它的资源都会被编译或者处理 除了 assets 资源之外，其它的资源都会被赋予一个资源 ID 打包工具负责编译和打包资源，编译完成之后，会生成一个 resources.arsc 文件和一个 R.java，前者保存的是一个资源索引表，后者定义了各个资源 ID 常量 应用程序配置文件 AndroidManifest.xml 同样会被编译成二进制的 xml 文件，然后再打包到 APK 里面去 应用程序在运行时通过 AssetManager 来访问资源，或通过资源 ID 来访问，或通过文件名来访问 APK 文件大概可以分为两个部分：代码和资源, 代码部分通过 Javac 将 Java 代码编译成 Class 文件, 然后通过 DX 工具将 Class 文件编译成 Dex 文件，接下来我们主要来分析一下资源的编译和打包 资源的编译和打包在分析资源的编译和打包之前，我们需要了解一下 Android 都有哪些资源，其实 Android 资源大概分为两个部分：assets 和 res 当我们使用 AAPT 对资源进行编译的时候，会采用两种模式 Deflate(压缩模式)/Stored(存储模式)，而具体使用模式，取决于文件后缀类型，AAPT 会对以下文件后缀类型的资源采用存储模式（即不会被压缩） /* these formats are already compressed, or don't compress well */static const char* kNoCompressExt[] = { &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.gif&quot;, &quot;.wav&quot;, &quot;.mp2&quot;, &quot;.mp3&quot;, &quot;.ogg&quot;, &quot;.aac&quot;, &quot;.mpg&quot;, &quot;.mpeg&quot;, &quot;.mid&quot;, &quot;.midi&quot;, &quot;.smf&quot;, &quot;.jet&quot;, &quot;.rtttl&quot;, &quot;.imy&quot;, &quot;.xmf&quot;, &quot;.mp4&quot;, &quot;.m4a&quot;, &quot;.m4v&quot;, &quot;.3gp&quot;, &quot;.3gpp&quot;, &quot;.3g2&quot;, &quot;.3gpp2&quot;, &quot;.amr&quot;, &quot;.awb&quot;, &quot;.wma&quot;, &quot;.wmv&quot;, &quot;.webm&quot;, &quot;.mkv&quot;}; 通过 aapt l -v xxx.apk 或 unzip -l xxx.apk 来查看 APK 内文件使用的什么模式 1. assets 资源assets 资源放在 assets 目录下，它里面保存一些原始的文件，可以以任何方式来进行组织，AAPT 会对指定文件后缀类型的资源进行压缩，其余的文件最终会原封不动的被打包进 APK 文件中，通过 AssetManager 来获取 asset 资源，代码如下 AssetManager assetManager = context.getAssets();InputStream is = assetManager.open(&quot;fileName&quot;); 2. res 资源res 资源放在主工程的 res 目录下，这类资源一般都会在编译阶段生成一个资源ID供我们使用，res 目录包括 animator、anim、 color、drawable、layout、menu、raw、values、xml 等 上述资源文件除了 raw 类型资源，以及 drawable 文件夹下的 Bitmap 资源之外，其它的资源文件均会被编译成二进制格式的 XML 文件，生成的二进制格式的 XML 文件分别有一个字符串资源池，用来保存文件中引用到的每一个字符串 这样原来在文本格式的 XML 文件中的每一个放置字符串的地方在二进制格式的XML文件中都被替换成一个索引到字符串资源池的整数值，将整数值保存在 R.java 类中，R.java 会和其他源文件一起编译到 APK 中去 将资源编译成二进制文件，都是由 AAPT 工具来完成的，资源打包主要有以下几个流程： 解析 AndroidManifest.xml，获得应用程序的包名称，创建资源表 添加被引用资源包，被添加的资源会以一种资源 ID 的方式定义在 R.java 中 资源打包工具创建一个 AaptAssets 对象，收集当前需要编译的资源文件，收集到的资源保存在 AaptAssets 对象对象中 将上一步 AaptAssets 对象保存的资源，添加到资源表 ResourceTable 中去，用于最终生成资源描述文件 resources.arsc 编译 values 类资源，这类资源包括数组、颜色、尺寸、字符串等值 给 style、array 这类资源分配资源 ID 编译 XML 资源文件，编译的流程分为：① 解析 XML 文件 ② 赋予属性名称资源 ID ③ 解析属性值 ④ 将 XML 文件从文本格式转换为二进制格式 生成资源索引表 resources.arsc 2.1 资源 IDAAP 工具会所有的资源都会生成一个 R.java 文件，并且每个资源都对应 R.java 中的十六进制整数变量，其实这些十六进制的整数是由三部分组成：PackageId + TypeId + ItemValue，代码所示： public final class R { public static final class anim { public static final int abc_fade_in=0x7f010000; public static final int abc_fade_in=0x7f010001; //*** } public static final class string { public static final int a11y_no_data=0x7f100000; public static final int a11y_no_permission=0x7f100001; //*** }} 最高字节是 Package ID 表示命名空间，标明资源的来源，Android 系统自己定义了两个 Package ID，系统资源命名空间：0x01 和 应用资源命名空间：0x7f 正因为应用资源命名空间：0x7f，我们在做插件化的时候就会出现一个问题，宿主和插件包，合并资源后资源 ID 冲突。通过上面分析要解决这个问题，就要为不同的插件设置不同的 PackageId，而宿主可以保留原来 0x7f 不变，这样就永远不会有冲突发生了 如何解决资源冲突 制定一个不用冲突的命名规范 library Module 的 build.gradle 中设置资源前缀(推荐) android { resourcePrefix &quot;&lt;前缀&gt;&quot; }2.2 资源索引(resources.arsc)最终生成的是资源索引表 resources.arsc ，resources.arsc 是一个编译后的二进制文件, 在 AndroidStudio 打开 resources.arsc 文件，如下所示 Android 正是利用这个索引表根据资源 ID 进行资源的查找，为不同语言、不同地区、不同设备提供相对应的最佳资源。查找和通过 Resources 和 AssetManger 来完成的 在文中提到了两个工具 Apksigner 和 Jarsigner，下面一起来了解一下 Apksigner 和 Jarsigner 的区别 Apksigner 和 Jarsigner 的区别在 Android Studio 中点击菜单 Build-&gt;Generate signed apk… 打包签名过程中,可以看到两种签名选项 V1(Jar Signature) 和 V2(Full APK Signature) Jarsigner 是 JDK 提供的针对 JAR 包签名的通用工具 Apksigner 是 Google 官方提供的针对 Android APK 签名及验证的专用工具 在 Android 11 以上使用 V4 签名，Android 9.0 以上使用 V3 签名，Android 7.0 开始使用 V2 签名，但在 Android 7.0 以下版本, 只能用旧签名方案 V1 签名 V1 签名: Android 7 以下使用 V1 签名，V1 签名会对 ZIP 压缩包的每个文件进行验证, 签名后还能对压缩包修改(移动/重新压缩文件)，对 V1 签名的 APK/JAR 解压,在 META-INF 存放签名文件(MANIFEST.MF, CERT.SF, CERT.RSA), 其中 MANIFEST.MF 文件保存所有文件的 SHA1 指纹(除了 META-INF 文件), 由此可知: V1 签名是对压缩包中单个文件签名验证 V2 签名: Android 7 开始增加了 V2 签名，V2 签名会对 ZIP 压缩包的整个文件验证, 签名后不能修改压缩包(包括 zipalign), 对 V2 签名的 APK 解压, 没有发现签名文件, 重新压缩后 V2 签名就失效, 由此可知: V2 签名是对整个 APK 签名验证 V3 签名: Android 9 增加了 V3 签名，V3 签名在 V2 的基础上，仍然采用检查整个压缩包的校验方式，支持 APK 密钥轮替，这使应用能够在 APK 更新过程中更改其签名密钥 v3 签名新增的新块（attr） 会记录我们之前的签名信息以及新的签名信息，支持 APK 密钥轮替方案，来做签名的替换和升级。这意味着，只要旧签名证书在手，我们就可以通过它在新的 APK 文件中，更改签名。 需要注意的是：对于覆盖安装的情况，签名校验只支持升级，而不支持降级 V4 签名: 在 Android 11 之前，建议不要使用 APK 密钥轮替，在 Android 11 之后增加了 V4 签名，V4 签名将签名存储在单独的 .apk.idsig 文件中。v4 签名需要 v2 或 v3 签名作为补充。 关于签名更多内容，会在后续文章内介绍。 总结: V1 签名是对压缩包中单个文件签名验证 V2 签名是对整个 APK 签名验证 zipalign 可以在 V1 签名后执行 zipalign 不能在 V2 签名后执行,只能在 V2 签名之前执行 V2 签名更安全(不能修改压缩包) V2 签名验证时间更短(不需要解压验证), 因而安装速度加快 apksigner 工具默认同时使用 V1 和 V2 签名, 以兼容 Android 7.0 以下版本 Android 7 以下使用 V1 签名 Android 7 开始增加了 V2 签名 Android 9 增加了 V3 签名 Android 11 之后增加了 V4 签名 V3 签名 和 V4 签名 目前只能在 Google Play 上使用 参考文献 Google的 Apk 构建流程 Android Studio 中为应用签名 AAPT2","link":"/2020/06/07/android10/package-manager/01-APK-generate/"},{"title":"关于 adb 命令你所需要知道的","text":"概述Android Debug Bridge (adb) 是一个通用命令行工具，是 Android 开发/测试人员必备工具，关于adb的详细介绍可以查看谷歌 adb 官方中文文档 Android Debug Bridge, 这里只是总结了一下常用的命令 文章中涉及的命令说明 文章中的命令只针对于连接一个设备的情况，如果连接多个设备，需要在 adb shell -s 后面指定设备序列号, 格式如下所示： 格式：adb -s 225278f8 shell获取设备序列号:adb devices &lt;serial number&gt; : 设备序列号 &lt;package_name&gt; : Apk 的包名 &lt;local&gt; : pc 端路径 &lt;remote&gt; : Android 设备上的路径 &lt;filepath_in_device&gt; : Android 设备的文件路径 &lt;local_apk_path&gt; : pc 端 apk 的路径 &lt;package_name&gt;/&lt;main_class&gt; : Apk包名 / 启动类，格式如下所示 格式：google.architecture.universal/.ActivityMain打开Apk，然后输入下面命令查看：adb shell dumpsys window | grep mCurrentFocus 命令总结以下所有命令参考谷歌 adb 官方文档 Android Debug Bridge，列出了经常用命令 常用命令 备注 命令 查看连接设备 adb devices 查看连接设备列表信息 adb devices -l 指定设备 adb -s &lt;serial number&gt; shell 执行gc adb shell pkill -l 10 &lt;package_name&gt; 上传文件和下载文件 备注 命令 将电脑上的文件上传的设备 adb push &lt;local&gt; &lt;remote&gt; 设备中的文件下载到电脑 adb pull &lt;remote&gt; &lt;local&gt; 安装和卸载应用 备注 命令 安装Apk ​adb install &lt;local_apk_path&gt; 安装Apk 并且授予Apk所有权限 ​adb install -g &lt;local_apk_path&gt; 覆盖安装Apk且保留数据 ​adb install &lt;local_apk_path&gt; 降级安装Apk ​adb install -d &lt;local_apk_path&gt; 卸载Apk ​adb uninstall &lt;package_name&gt; 卸载Apk且保留数据 adb shell pm uninstall -k &lt;package_name&gt; 静默安装应用 ​adb shell pm install -t -r &lt;local_apk_path&gt; 卸载所有应用(包括系统应用) ​adb shell pm uninstall -k --user 0 &lt;package_name&gt; pm 备注 命令 显示第三放应用 adb shell pm list package -3 显示系统应用 adb shell pm list packages -s 显示apk文件路径和包名列表 adb shell pm list packages -f 查看apk路径 adb shell pm path &lt;package_name&gt; 清除数据和缓存 adb shell pm clear &lt;package_name&gt; dumpsys 备注 命令 查看运行Apk的包名 adb shell dumpsys window | grep mCurrentFocus 查看Activity任务栈 adb shell dumpsys activity activities 查看堆的分配情况 adb shell dumpsys meminfo &lt;package_name&gt; 查看应用信息 adb shell dumpsys package &lt;package_name&gt; 获取设备显示屏参数信息 adb shell dumpsys window displays 清除bugreport信息 adb shell dumpsys batterystats --reset 从bugreport中过滤关键字信息 adb shell dumpsys batterystats | grep 关键字 进入dozeModel deep状态 adb shell dumpsys deviceidle force-idle 进入dozeModel light状态 adb shell dumpsys deviceidle force-idle light 退出dozeModel adb shell dumpsys deviceidle unforce 设置手机电量为15％ adb shell dumpsys battery set level 15 退出充电状态 adb shell dumpsys battery unplug 恢复默认值 adb shell dumpsys battery reset 禁用doze mode adb shell dumpsys deviceidle disable adb shell dumpsys deviceidle whitelist getprop 备注 命令 获取设备型号 adb shell getprop ro.product.model 获取设备的Android系统版本 adb shell getprop ro.build.version.release dvm 最大可用内存 adb shell getprop | grep dalvik.vm.heapsize 单个程序限制最大可用内存 adb shell getprop | grep heapgrowthlimit wm 备注 命令 获取设备屏幕分辨率 adb shell wm size 获取设备屏幕密度（单位：dpi） adb shell wm density 调试命令 备注 命令 查看应用的进程 adb shell ps -ef | grep &lt;package_name&gt; 查看内存占用情况 `adb shell ps 查看Activity的启动时间 ​adb shell am start -W &lt;package_name&gt;/&lt;main_class&gt; 强制关闭应用 ​adb shell am force-stop &lt;package_name&gt; 实时查看设备CPU、内存占用等信息 adb shell top 实时查看内存占用排名前number的应用 adb shell top -m &lt;number&gt; 为Apk跑number次monkey测试 adb shell monkey -v -p &lt;package_name&gt; &lt;number&gt; 获取设备的MAC地址 adb shell cat /sys/class/net/wlan0/address 获取设备的内存占用信息 adb shell cat /proc/meminfo 其他命令 备注 命令 查看日志 adb shell logcat | grep '关键字' 输出日志到log.txt文件 adb shell logcat | grep '关键字' &gt; log.txt 截取屏幕 ​adb shell screencap -p &lt;filepath_in_device&gt; 录制屏幕 adb shell screenrecord -p &lt;filepath_in_device&gt; 常见问题汇总列举一些常见问题，后续会不断完善 1. ubuntu 下使用 adb 出现 no permissions 问题解决方案运行 sudo adb devices 出现下列情况 List of devices attached 2aca417d no permissions 如何解决 no permissions？ 在未连接 Android 设备的情况下，运行命令 lsusb, 查看一下 ubuntu 下的 usb Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 003: ID 413c:2113 Dell Computer Corp. Bus 001 Device 002: ID 413c:301a Dell Computer Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 连接 Android 设备, 打开 usb 调试模式，运行命令 lsusb, 查看一下 ubuntu 下的 usb Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 003: ID 413c:2113 Dell Computer Corp. Bus 001 Device 002: ID 413c:301a Dell Computer Corp. Bus 001 Device 055: ID 18d1:4ee7 Google Inc. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 通过对比两个结果，可以查看到新连接的 Android 设备信息，注意其 ID 号，这里是18d1:4ee7 然后进入到 /etc/udev/rules.d/ 目录下，查看是否有 .rules 文件．没有则可以自己新建一个(名字可以随意取，不能有中文)，添加端口信息到文件中 # 打开一个文件sudo vim 51-android.rules# 添加端口信息到51-android.rulesSUBSYSTEM==&quot;usb&quot;,ATTRS{idVendor}==&quot;18d1&quot;,ATTRS{idProduct}==&quot;4ee7&quot;,MODE=&quot;0666&quot; 这里 18d1 和 4ee7 则分别是上一步中查看到的 android 设备的信息，MODE 表示权限，完成之后执行下面命令 sudo chmod a+rx /etc/udev/rules.d/51-android.rulessudo service udev restart 最后拔掉 usb 重新连接，然后在运行下面命令重启 adb 服务 sudo adb kill-serversudo adb start-serversudo adb devices 如果上述步骤都操作正确，运行 sudo adb devices 如下所示，就可以使用 adb 操作设备了 List of devices attached 2aca417d device 参考文献 谷歌adb官方中文文档 adb常用命令整理 awesome-adb ADB-常用命令 针对低电耗模式和应用待机模式进行优化","link":"/2020/08/22/android/03-adb/"},{"title":"基于 Smali 文件 Android Studio 动态调试 APP","text":"最近在研究动态调试技术，网上关于基于 Smali 动态调试App的教程很多，很多细节都没有贴出来，走了很多弯路，将调研结果分享一下，如果有写的不好地方，欢迎指正 Github：https://github.com/hi-dhl/DebugApkSmali 准备工作 一部 Root 过的 Android 手机，打开开发者模式 Xposed 的运行的环境 安装 smalidea 插件，点击这里下载 安装 BDOpener.apk 或者 XDebug.apk 反编译 Apk(apktool)点击 这里下载 最新的 apktool , 并配置好环境（不同环境配置的方式不同，参考 官网） 下载你需要反编译的 Apk 文件，执行 apktool d 反编译Apk名字.apk 如果反编译出来多个smali文件夹，可以用ant写个脚本，多个文件夹合并成一个 smalideaAndroidStudio 如果要调试smali代码，需要安装第三方插件: smalidea AS中【Android Studio–&gt;Preferences–&gt;Plugins–&gt;Install plugin from desk…】，安装插件 Android Studio 导入 smali 新疆一个 Android 工程项目（ps: 一定要新建Android项目，否则可能会找不到 “Attach debuger to Android Process”）删掉自动创建的资源和代码文件 复制反编译好的 smali 文件, 到新建 Android 项目 java 文件夹下 PS: 也可以使用我配置好的项目 “ApkSampleSmali” , 需要安装提供的 Sample.apk进行测试 Android Studio 动态调试配置新建调试配置，【Run–&gt;Edit Configurations–&gt; + –&gt;Remote】，name 随意，端口 8700 动态调试 在 smali 代码中打入断点，如下图标记1 然后点击 “Attach debuger to Android Process” ，如下图标记2 选择你要调试的进程，手动进入对应功能, 即进入断点动态调试（ps: 如果你想要的进程没有展示出来，请重新勾选 xposed module(BDOpener), 重启手机） 运行环境信息 Xposed Version90-beta3 BDOpener 1.0 AndoridStudio 3.3.2 smalidea 0.0.5 apktool 2.4.0","link":"/2020/05/30/AndroidStudio/02-smalidea/"},{"title":"解决在 Android Studio 3.2 找不到 Android Device Monitor 工具","text":"升级到 AndroidStudio 最新版本( &gt;3.2 )朋友们都会遇到一个问题，找不到 DDMS [Android Device Monitor], 只能从 SDK 目录下找到 monitor 启动 DDMS [Android Device Monitor]，所以写了一个插件快速启动 Android Device Monitor 源码及使用方式开发工具：IntelliJ IDEA Github地址：https://github.com/hi-dhl/DeviceMonitorPlugin 插件下载地址：https://github.com/hi-dhl/DeviceMonitorPlugin/releases/download/1.0/DeviceMonitorPlugin.jar 安装方式： 打开 AndroidStudio 选择 Preference -&gt; Plugins-&gt; install plugin from disk 选择下载好的插件 [DeviceMonitorPlugin.jar] -&gt; 重启 AndroidStudio 如何启动： 打开 AndroidStudio 菜单栏 tools -&gt; 单击 DeviceMonitor PS: Google 虽然删除了 AdnroidStudio 启动入口，但是本地 SDK 中还是存在，插件通过动态获取本地 SDK 路径启动 AndroidDeviceMonitor, 由于电脑性能不同，启动速度会有不同 Google 为什么弃用 Android Device MonitorAndroid Developers官网上的原文链接 Android Device Monitor 是一个 Android 应用调试和分析工具提供了一个 UI 工具，但是大部分组件在 Android Studio 3.1 已经弃用了, 并且会在 Android Studio 3.2 中移除，将会用新的工具帮助开发人员调试和分析 Android 应用 详情戳这里 插件核心代码public class Monitor extends AnAction { @Override public void actionPerformed(AnActionEvent anActionEvent) { try { Project project = anActionEvent.getData(PlatformDataKeys.PROJECT); String os = AndroidUtils.getPlatformName(); String sdkPath = AndroidUtils.getApkLocalProperties(project); if (os.toLowerCase().startsWith(&quot;win&quot;)) { sdkPath += File.separator + &quot;tools&quot; + File.separator + &quot;monitor.bat&quot;; } else { sdkPath += File.separator + &quot;tools&quot; + File.separator + &quot;monitor&quot;; } Runtime.getRuntime().exec(sdkPath); } catch (Exception e) { } }} /** * 动态获取本地Android SDK的路径 * * @param project * @return */public static String getApkLocalProperties(Project project) { String sdkPath = &quot;&quot;; try { String path = project.getBasePath() + File.separator + &quot;local.properties&quot;; Properties properties = new Properties(); InputStream inputStream = new FileInputStream(path); properties.load(inputStream); sdkPath = properties.getProperty(&quot;sdk.dir&quot;); } catch (Exception e) { } return sdkPath;} Github地址：https://github.com/hi-dhl/DeviceMonitorPlugin","link":"/2020/05/30/AndroidStudio/01-monitor/"},{"title":"10分钟入门Shell脚本编程","text":"前言写下这篇文章，是对自己在学习和使用过程中的总结，文笔不是很好，如果有什么问题欢迎沟通交流 Github地址：https://github.com/hi-dhl/fast_guides Shell是什么Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务, Shell脚本（shell script），是一种为Shell编写的脚本程序。我们经常说的shell通常都是指shell脚本。 环境和工具Shell跟java、php、Python编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Mac OS，Linux 自带了shell解释器，Windows比较麻烦，因为Win7专业版和旗舰版默认安装PowerShell，标准版和家庭版中就没有安装的，为了方便建议安装cygwin PHP、Python 也可以作为Shell编程PHP、Python是属于高级编程语言，但是也可以做Shell编程，因为只要有解释器，也可以用作脚本编程 如下是一个Python Shell Script示例（假设文件名叫op_python_base.py）： #!/usr/bin/env python3 //告诉Python从系统环境中找python# -*- coding: utf-8 -*- //设置为UTF-8编码for index in range(10): print(index); 源码：op_python_base 如下是一个PHP Shell Script示例（假设文件名叫op_php_base.php）： #!/usr/bin/php&lt;?phpfor($i=0 ;$i&lt;10; $i++){ echo $i;}?&gt; 源码：op_php_base 为什么要学习Shell既然PHP、Python都可以用来写脚本编程，那为什么还要学习陌生、晦涩难懂的Shell，主要有一下几个原因 环境兼容性，Win7专业版和旗舰版默认安装PowerShell，标准版和家庭版中就没有安装的，其他主流的操作系统都预制了Shell解释器，所以使用sh、bash编写，提供给其他人使用是非常方便的，但是PHP、Python 等等需要安装相应的环境 如果你想做一些定时任务比如说检测进程是否存在，自动备份，或者说自动部署环境、服务器之间的数据同步等等sh、bash会是你最好的选择 sh与bashsh: Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh bash: Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash 第一个shell脚本我们先来看一个例子我相信写过代码的童鞋，应该对下面的代码很熟悉并不陌生，（假设文件名叫op_base.sh）： #!/usr/bin/env bashmkdir codecd codefor ((i=0; i&lt;3; i++)); do touch test_${i}.txt echo &quot;shell很简单&quot; &gt;&gt; test_${i}.txtdone 第一行：从系统path中寻找指定脚本的解释程序第二行：创建 名叫code文件夹第三行：进入创建的文件夹第四行：for循环3次第四行：创建文件第五行：往创建的文件中写入信息第六行：结束循环 mkdir, touch，cd，touch，echo都是系统命令，在命令行下可以直接执行for, do, done 是shell脚本语言 for循环的语法 源码：op_base.sh 编写Shell新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php，扩展名为php，如果你用Python，扩展名为python 第一行一般是这样： #!/usr/bin/php#!/usr/bin/env python3#!/usr/bin/env bash #!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行 /env 是系统的PATH目录中查找 运行 Shell 脚本有两种方法：作为可执行程序chmod +x op_base.sh./op_base.sh 第一行设置 op_base.sh可执行权限第二行执行op_base.sh 作为参数/bin/sh op_base.sh 变量定义变量时，变量名前不需要加符号和Python一样但是在PHP语言中变量需要加$，如： my_name=&quot;jack&quot;my_name='jack'; ps: 变量名和等号之间不能有空格,变量后面不能有; Shell中的引号和PHP类似，字符串可以用单引号，也可以用双引号 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行 双引号： 双引号里可以有变量 双引号里可以出现转义字符 但是在Python中单引号和双引号是没有区别，但是Python 还有三个引号，在三个引号内字符都不会被转义 使用变量对于已经定义过的变量，使用的适合在前面添加$ echo $my_nameecho ${my_name} 变量名外面的花括号是可选的，加不加都行,建议使用第二种形式 注释以“#”开头的行就是注释，会被解释器忽略。 多行注释sh里没有多行注释，只能每一行加一个#号。就像这样： #--------------------------------------------# Author: jack ## Notes: 10分钟入门Shell脚本编程## Project home page:# https://github.com/hi-dhl/fast_guides#-------------------------------------------- 字符串字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似 Shell不像其他语言有php、python 有很多数据类型，在Shell中常用的数据类型字符串数字和字符串（ps: 除了数字和字符串，也没啥其它类型好用了，哈哈） 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行 双引号： 双引号里可以有变量 双引号里可以出现转义字符 字符串操作拼接字符串my_name=&quot;jack&quot;;my_age=&quot;20岁&quot;echo $my_name $my_ageecho $my_name$my_age 获取字符串长度echo ${#my_name} 截取字符串echo ${my_name:0:2} 源码：op_str.sh Shell 数组定义数组在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： name=(name1 name2 name3) 还可以单独定义数组的各个分量： ary[0]=name1ary[1]=name2ary[3]=name3 ps: 可以不使用连续的下标，而且下标的范围没有限制 读取数组读取数组元素值的一般格式是： ${数组名[下标]} 例如： echo ${name[0]} 使用@符号可以获取数组中的所有元素，例如： echo ${name[@]} 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同，例如： # 取得数组元素的个数length=${#name[@]}echo $length# 或者length=${#name[*]}echo $length# 取得数组单个元素的长度lengthn=${#name[n]}echo $length 源码：op_arry.sh Shell 流程控制和Java、PHP、Python等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)： &lt;?phpif (isset($_GET[&quot;q&quot;])) { search(q);}else { // 不做任何事情} 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else ifif condition1then command1elif condition2 then command2else commandNfi 例子： #!/usr/bin/env basha=1b=2if [ $a == $b ] then echo &quot;a 等于 b&quot; elif [ $a -gt $b ] then echo &quot;a 大于 b&quot; elif [ $a -lt $b ] then echo &quot;a 小于 b&quot; else echo &quot;没有符合的条件&quot; fi 源码：op_if.sh for 循环Shell的for循环和Python 有点类似 Python的for循环for index in 1,2,3,4,5: print(index); Shell的for循环，第一种写法for index in 1 2 3 4 5; do echo &quot;index=&quot;$indexdone Shell的for循环，第二种写法for ((i=0; i&lt;5; i++)); do echo &quot;i=&quot;$idone 源码：op_for.sh while 语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。 int=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 源码：op_while.sh Shell结合系统命令sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。 例如定时检测nginx、mysql是否被关闭path=/var/loglog=${path}/httpd-mysql.logname=(apache mysql)exs_init[0]=&quot;service httpd start&quot;exs_init[1]=&quot;/etc/init.d/mysqld restart&quot;for ((i=0; i&lt;2; i++)); do echo &quot;检查${name[i]}进程是否存在&quot; ps -ef|grep ${name[i]} |grep -v grep if [ $? -eq 0 ]; then pid=$(pgrep -f ${name[i]}) echo &quot;`date +&quot;%Y-%m-%d %H:%M:%S&quot;` ${name[$i]} is running with pid $pid&quot; &gt;&gt; ${log} else $(${exs_init[i]}) echo &quot;`date +&quot;%Y-%m-%d %H:%M:%S&quot;` ${name[$i]} start success&quot; &gt;&gt; ${log} fidone 解释：检测 nginx、mysql进程是否存在，如果不存在了会自动重新启动。脚本每次运行会写日志的，没事可以去看看该日志文件，如果进程是不是真的经常性不存在，恐怕就要排查一下深层原因了。 源码：check_nginx.sh 编辑 /etc/crontab 文件crontab -e 在文件最后添加一行： */5 * * * * /xxx/check_nginx.sh &gt; /dev/null 2&gt;&amp;1 上表示每 5 分钟，执行一下脚本 /xxx/check_nginx.sh，其中xxx代表路径 /dev/null 2&gt;&amp;1 的意思是该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。 # For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * command to be executed 添加完配置，需要重启才能生效service crond restart","link":"/2020/05/21/Linux/01-shell/"}],"tags":[{"name":"AndroidStudio","slug":"AndroidStudio","link":"/tags/AndroidStudio/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"动画","slug":"动画","link":"/tags/%E5%8A%A8%E7%94%BB/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Protobuf","slug":"Protobuf","link":"/tags/Protobuf/"},{"name":"Android 12","slug":"Android-12","link":"/tags/Android-12/"},{"name":"Jetpack","slug":"Jetpack","link":"/tags/Jetpack/"},{"name":"Compose","slug":"Compose","link":"/tags/Compose/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"kotlin","slug":"kotlin","link":"/tags/kotlin/"},{"name":"译文","slug":"译文","link":"/tags/%E8%AF%91%E6%96%87/"},{"name":"Fragment","slug":"Fragment","link":"/tags/Fragment/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"Koin","slug":"Koin","link":"/tags/Koin/"},{"name":"Android源码","slug":"Android源码","link":"/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Android10-包管理系统","slug":"Android10-包管理系统","link":"/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Android10-资源管理系统","slug":"Android10-资源管理系统","link":"/tags/Android10-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Android10-窗口管理系统","slug":"Android10-窗口管理系统","link":"/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"AndroidStudio","slug":"AndroidStudio","link":"/categories/AndroidStudio/"},{"name":"算法动画","slug":"算法动画","link":"/categories/%E7%AE%97%E6%B3%95%E5%8A%A8%E7%94%BB/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Android 12","slug":"Android-12","link":"/categories/Android-12/"},{"name":"Android,AndroidStudio","slug":"Android-AndroidStudio","link":"/categories/Android-AndroidStudio/"},{"name":"Jetpack","slug":"Jetpack","link":"/categories/Jetpack/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"译文","slug":"translated","link":"/categories/translated/"},{"name":"译文,Kotlin","slug":"译文-Kotlin","link":"/categories/%E8%AF%91%E6%96%87-Kotlin/"},{"name":"译文,AndroidStudio","slug":"译文-AndroidStudio","link":"/categories/%E8%AF%91%E6%96%87-AndroidStudio/"},{"name":"Android10","slug":"Android10","link":"/categories/Android10/"}]}