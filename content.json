{"pages":[{"title":"","text":"google-site-verification: googlede5fd50279499fe2.html","link":"/googlede5fd50279499fe2.html"}],"posts":[{"title":"「译」Kotlin 的性能优化那些事","text":"前言 原标题: Item: Consider aggregating elements to a map 原文地址: https://blog.kotlin-academy.com/item…… 原文作者：Marcin Moskala 这篇文章应该可以说是 [译][2.4K Start] 放弃 Dagger 拥抱 Koin 文章的续集，在 “放弃 Dagger 拥抱 Koin” 文章中介绍了过渡使用 Inline 修饰符所带来的后果，以及 Koin 团队在为修复 1x 版本所做的性能优化，这边文章将继续学习如何提升 Kotlin 的查询速度。 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 如何提升 Kotlin 的查询速度？ 性能和代码可读性该做如何选择？ Kotlin 内存泄露那些事, 消除过期的对象引用？ 如何提高 Kotlin 代码的可读性？ Kotlin 算法：一行代码实现杨辉三角？ 这篇文章涉及很多重要的知识点，带着自己理解，请耐心读下去，应该可以从中学到很多技巧 译文我们需要多次访问大量的数据情况，这其实并不少见，例如： cache：从服务上下载的数据，然后保存在本地内存中以更快地访问它们 repository：从一些文件中加载数据 in-memory repository：用于不同类型的内存测试 这些数据可能表示一些用户、id、配置等等，它们通常以 list 形式返给我们，它们可能以相同的方式存储在内存中： class NetworkUserRepo(val userService: UserService): UserRepo { private var users: List&lt;User&gt;? = null override fun getUser(id: UserId): User? { if(users == null) { users = userService.getUsers() } return users?.firstOrNull { it.id == id } }}class ConfigurationsRepository( val configurations: List&lt;Configuration&gt;) { fun getByName(name: String) = configurations .firstOrNull { it.name == name }}class InMemoryUserRepo: UserRepo { private val users: MutableList&lt;User&gt; = mutableListOf() override fun getUser(id: UserId): User? = users.firstOrNull { it.id == id } fun addUser(user: User) { user.add(user) }} 这可能是存储这些元素的最好方式，注意我们是如何加载数据如何使用的，我们通过某个标识符或者名字访问这些元素（它们与我们设计数据库时唯一值有关），当 n 等于 list 的大小时，在 list 中查找元素的复杂度为 O(n)，更准确的说，平均需要 n / 2 次比较才能找到一个元素，如果是一个比较的大的 list，查找效率极其低效，解决这个问题的一个好办法是使用 Map 代替 list, Kotlin 默认使用的是 hash map, 更具体的说是 LinkedHashMap，当我们使用 hash map 查找元素的性能要好得多, 实际上 JVM 使用的 hash map 的大小根据映射本身的大小进行了调整, 如果实现 hashCode 方式正确，查找一个元素只需要进行一次比较。 这是 InMemoryRepo 中使用 map 代替 list class InMemoryUserRepo: UserRepo { private val users: MutableMap&lt;UserId, User&gt; = mutableMapOf() override fun getUser(id: UserId): User? = users[id] fun addUser(user: User) { user.put(user.id, user) }} 大多是其他操作，比如修改或者迭代这些数据（可能使用集合方法 filter, map, flatMap, sorted, sum 等等）对于 list 和 map 性能差不多的。 那么我们如何从 list 转换到 map，或者从 map 转换到 list，使用 associate 方法来完成 list 转换到 map，最常见的方法是 associateBy，它构建一个映射，其中的值是列表中的元素，键是通过一个 lambda 表达式提供。 data class User(val id: Int, val name: String)val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Marek&quot;))val byId = users.associateBy { it.id }byId == mapOf(1 to User(1, &quot;Michal&quot;), 2 to User(2, &quot;Marek&quot;)) val byName = users.associateBy { it.name }byName == mapOf(&quot;Michal&quot; to User(1, &quot;Michal&quot;), &quot;Marek&quot; to User(2, &quot;Marek&quot;)) 注意，映射中的键必须是唯一的，否则相同键值的元素会被删掉，这就是为什么我们应该根据唯一标识符进行关联（对于键值不是唯一的，应该使用 groupBy 方法） val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Michal&quot;))val byName = users.associateBy { it.name }byName == mapOf(&quot;Michal&quot; to User(2, &quot;Michal&quot;)) 从 map 转换到 list 使用 values 方法 val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Michal&quot;))val byId = users.associateBy { it.id }users == byId.values 如何在 repositories 中用 Map 提高元素访问的性能 class NetworkUserRepo(val userService: UserService): UserRepo { private var users: Map&lt;UserId, User&gt;? = null override fun getUser(id: UserId): User? { if(users == null) { users = userService.getUsers().associateBy { it.id } } return users?.get(id) }}class ConfigurationsRepository( configurations: List&lt;Configuration&gt;) { val configurations: Map&lt;String, Configuration&gt; = configurations.associateBy { it.name } fun getByName(name: String) = configurations[name]} 这个技巧是非常重要的，但是并不适合所有的 cases，当我们需要访问比较大的 list 的时候是非常有用的，这在后台访问是非常重要的，这些 list 可能在后台每秒被访问很多次，但是在前台并不重要（这里说的是 Android 或者 iOS）用户最多只会访问几次 repository，需要注意的是从 list 转换到 map 是需要时间的，如果过渡使用，可能会对性能有不好的影响。 译者思考作者总共从三个方面 Network、Configurations、InMemory 告诉我们应该如何从 list 转 map, 或者从 map 转 list, 以及应该在后台需要多次访问很大的数据集合中使用 map，过渡的使用只会对性能产生负面的影响。 list 转 map 调用用 associateBy 方法，接受一个 lambda 表达式 val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Michal&quot;))val byName = users.associateBy { it.name }byName == mapOf(&quot;Michal&quot; to User(2, &quot;Michal&quot;)) 从 map 转 list 调用 values 方法 val users = listOf(User(1, &quot;Michal&quot;), User(2, &quot;Michal&quot;))val byId = users.associateBy { it.id }users == byId.values 这是一个非常重要的优化的手段（使用空间换取时间），在 [译][2.4K Start] 放弃 Dagger 拥抱 Koin 文章中介绍了当我们引入 Koin 1x 的时候冷启动时间变长了，而且在有大量依赖的时候，查找的时间会有点长，用过这个版本的朋友，应该都会有这个感觉，Koin 团队的解决方案中用到了 HashMap，使用空间换取时间，查找一个 Definition 时间复杂度变成了 O(1)，从提高的访问速度。 其实我们应该在头脑中，保持内存管理的意识，在每次优化、修改代码之前，不要急于写代码，先整理一下思路，在头脑中过一遍自己的方案，我们应该为项目找到一个折衷方案，不仅要考虑内存和性能，还要考虑代码的可读性。当我们做一个应用程序，在大多数情况下可读性更重要。当我们开发一个库时，通常性能和内存更重要。 性能和代码可读性该做如何选择如果用 Java 和 Kotlin 语言刷过 LeetCode，使用相同的思路实现同一个算法，在正常的 Case 中，Kotlin 和 Java 执行时间差值很小，数据量越大的情况下 Kotlin 和 Java 差距会越来越大，Kotlin 执行时间会越来越慢，但是为什么 Kotlin 语言还会成为 Android 开发的首选语言呢？来看一下作者 Marcin Moskala 另外一篇文章 My favorite examples of functional programming in Kotlin 展示的快排算法。 在之前的文章中分享了过这个算法，现在我们来分析一下这个算法。 fun &lt;T : Comparable&lt;T&gt;&gt; List&lt;T&gt;.quickSort(): List&lt;T&gt; = if(size &lt; 2) this else { val pivot = first() val (smaller, greater) = drop(1).partition { it &lt;= pivot} smaller.quickSort() + pivot + greater.quickSort() } // 使用 [2,5,1] -&gt; [1,2,5]listOf(2,5,1).quickSort() // [1,2,5] 这是一个非常酷的函数式编程的例子，当看到这个算法的第一感觉，它非常的简洁，可读性很强，其次我们来看一下这个算法执行时间，其实它根本没有针对性能进行优化。 如果你需要使用高性能的算法，你可以使用 Java 标准库当中的函数，Kotlin 扩展函数 sorted() 就是用 Java 标准库中的函数，Java 标准库中的函数效率会更高的，但是实际执行时间怎么样呢？生成一个随机数数组，使用使用 quickSort() 和 sorted() 方法进行排序，比较它们的执行时间，代码如下所示： val r = Random()listOf(100_000, 1_000_000, 10_000_000) .asSequence() .map { (1..it).map { r.nextInt(1000000000) } } .forEach { list: List&lt;Int&gt; -&gt; println(&quot;Java stdlib sorting of ${list.size} elements took ${measureTimeMillis { list.sorted() }}&quot;) println(&quot;quickSort sorting of ${list.size} elements took ${measureTimeMillis { list.quickSort() }}&quot;) } 执行结果如下所示： Java stdlib sorting of 100000 elements took 83quickSort sorting of 100000 elements took 163Java stdlib sorting of 1000000 elements took 558quickSort sorting of 1000000 elements took 859Java stdlib sorting of 10000000 elements took 6182quickSort sorting of 10000000 elements took 12133` 正如你所见，quickSort() 比 sorted() 排序算法要慢两倍，在正常情况下，差值通常在 0.1ms 和 0.2ms 之间，基本上可以忽略不计，但是它更简洁，可读性更强。这解释了在某些情况下，我们可以考虑使用一个优化程度稍低，但可读性强且简洁的函数，你同意作者这种观点吗？ Kotlin 内存泄露那些事, 消除过期的对象引用我看过很多文章都说 Kotlin 简洁和高效，Kotlin 确实很简洁，在 “如何提高 Kotlin 代码的可读性” 部分我会列举一些例子，但是高效的背后是有代价的，这块往往很容易被我们忽略，这就需要我们去研究 kotlin 语法糖背后的魔法，当我们在开发的时候，选择合适的语法糖，尽量避免这些错误，例如带有 lnmba 表达式高阶函数，不使用 Inline 修饰符，会被编译成匿名内部类等等，更详细的内容参考 [译][2.4K Start] 放弃 Dagger 拥抱 Koin Inline 修饰符带来的性能损失部分。 内存管理最重要的一条规则是，不使用的对象应该被释放 这篇文章 Effective Java in Kotlin, item 7: Eliminate obsolete object references 作者也列举了 Kotlin 的一些例子，例如我们需要使用 mutableLazy 属性委托，像 lazy 一样工作，我们来看一下实现代码： fun &lt;T&gt; mutableLazy(initializer: () -&gt; T): ReadWriteProperty&lt;Any?, T&gt; = MutableLazy(initializer)private class MutableLazy&lt;T&gt;( val initializer: () -&gt; T) : ReadWriteProperty&lt;Any?, T&gt; { private var value: T? = null private var initialized = false override fun getValue( thisRef: Any?, property: KProperty&lt;*&gt; ): T { synchronized(this) { if (!initialized) { value = initializer() initialized = true } return value as T } } override fun setValue( thisRef: Any?, property: KProperty&lt;*&gt;, value: T ) { synchronized(this) { this.value = value initialized = true } }} 如何使用： var game: Game? by mutableLazy { readGameFromSave() }fun setUpActions() { startNewGameButton.setOnClickListener { game = makeNewGame() startGame() } resumeGameButton.setOnClickListener { startGame() }} 思考一下 mutableLazy 实现正确吗？ 它有一个地方不对，lnmba 表达式 initializer 在使用后没有被删除。这意味着只要对 MutableLazy 实例的引用存在，它就会被保持，即使它不再有用，如何改进 MutableLazy 实现的方法，优化代码如下所示： fun &lt;T&gt; mutableLazy(initializer: () -&gt; T): ReadWriteProperty&lt;Any?, T&gt; = MutableLazy(initializer)private class MutableLazy&lt;T&gt;( var initializer: (() -&gt; T)?) : ReadWriteProperty&lt;Any?, T&gt; { private var value: T? = null override fun getValue( thisRef: Any?, property: KProperty&lt;*&gt; ): T { synchronized(this) { val initializer = initializer if (initializer != null) { value = initializer() this.initializer = null } return value as T } } override fun setValue( thisRef: Any?, property: KProperty&lt;*&gt;, value: T ) { synchronized(this) { this.value = value this.initializer = null } }} 在使用完之后将 initializer 设置为 null，它将会被 GC 回收。特别要注意当一个高阶函数会被编译成匿名类时或者它是一个未知类（任何或泛型类型）时，这个优化显得非常重要，我们来看一下 Kotlin stdlib 库中的类 SynchronizedLazyImpl 代码如下所示：kotlin-stdlib……/kotlin/util/LazyJVM.kt private class SynchronizedLazyImpl&lt;out T&gt;( initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable { private var initializer: (() -&gt; T)? = initializer private var _value: Any? = UNINITIALIZED_VALUE private val lock = lock ?: this override val value: T get() { val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) { @Suppress(&quot;UNCHECKED_CAST&quot;) return _v1 as T } return synchronized(lock) { val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) { @Suppress(&quot;UNCHECKED_CAST&quot;) (_v2 as T) } else { val typedValue = initializer!!() _value = typedValue initializer = null typedValue } } } ......} 请注意，在使用完之后 initializers 设置为 null，将会被 GC 回收 如何提高 Kotlin 代码的可读性上文提到了 Kotlin 简洁可读性很强，但是呢通过 AndroidStudio 提供了 convert our Java code to Kotlin 插件，将 Java 代码转换为 Kotlin 代码，Java-Style Kotlin 的代码明显很难看，那么如何提升 Kotlin 代码的可读性，我想分享几个很酷的例子 Improve Java to Kotlin code review，用到了 Elvis 表达式、run, with 等等函数 消除!! myList!!.length change to myList?.length 空检查 if (callback != null) { callback!!.response()} change to callback?.response() 使用 Elvis 表达式 if (toolbar != null) { if (arguments != null) { toolbar!!.title = arguments!!.getString(TITLE) } else { toolbar!!.title = &quot;&quot; }} change to toolbar?.title = arguments?.getString(TITLE) ?: “” 使用 scope 函数 val intent = intentUtil.createIntent(activity!!.applicationContext) activity!!.startActivity(intent)dismiss() change to activity?.run { val intent = intentUtil.createIntent(this) startActivity(intent) dismiss() } ps: scope 函数还有 run, with, let, also and apply，它们的区别是什么，如何正确使用它们，后面的文章会详细的介绍。 使用 takeIf if 函数 if (something != null &amp;&amp; something == preference) { something.doThing() change to something?.takeIf { it == preference }?.let { something.doThing() } Android TextUtil if (TextUtils.isEmpty(someString)) {...}val joinedString = TextUtils.join(COMMA, separateList) change to if (someString.isEmpty()) {...}val joinedString = separateList.joinToString(separator = COMMA) Java Util val strList = Arrays.asList(&quot;someString&quot;) change to val strList = listOf(&quot;someString&quot;) Empty and null if (myList == null || myList.isEmpty()) {...} change to if (myList.isNullOrEmpty() {...} 避免对对象进行重复操作 recyclerView.setLayoutManager(layoutManager)recyclerView.setAdapter(adapter) recyclerView.setItemAnimator(animator) change to with(recyclerView) { setLayoutManager(layoutManager) setAdapter(adapter) setItemAnimator(animator)} 避免列表循环 for (str in stringList) { println(str)} change to stringList.forEach { println(it) } 避免使用 mutable 集合 val stringList: List&lt;String&gt; = mutableListOf()for (other in otherList) { stringList.add(dosSomething(other))} change to val stringList = otherList.map { dosSomething(it) } 使用 when 代替 if if (requestCode == REQUEST_1) { doThis()} else if (requestCode == REQUEST_2) { doThat()} else { doSomething()} change to when (requestCode) { REQUEST_1 -&gt; doThis() REQUEST_1 -&gt; doThat() else -&gt; doSomething()} 使用 const companion object { val EXTRA_STRING = &quot;EXTRA_EMAIL&quot; val EXTRA_NUMBER = 12345} change to companion object { const val EXTRA_STRING = &quot;EXTRA_EMAIL&quot; const val EXTRA_NUMBER = 12345} 如果有更好的例子，欢迎留言 Kotlin 算法：一行代码实现杨辉三角我想分享一个很酷的算法，用一行代码实现杨辉三角，代码来自 Marcin Moskala 大神的 Twitter fun pascal() = generateSequence(listOf(1)) { prev -&gt; listOf(1) + (1..prev.lastIndex).map { prev[it - 1] + prev[it] } + listOf(1)}fun main() { pascal().take(10).forEach(::println)} 安利一个译者自己撸的导航网站基于 Python + Material Design 开发的 “为互联网人而设计 国内国外名站导航“ ，收集了国内外热门网址，涵括新闻、体育、生活、娱乐、设计、产品、运营、前端开发、Android开发等等导航网站 地址 参考文献 Item: Consider aggregating elements to a map Effective Java in Kotlin, item 7: Eliminate obsolete object references Improve Java to Kotlin code review","link":"/2020/08/05/translate/04-kotlin-performance/"},{"title":"「译」放弃 Dagger 拥抱 Koin","text":"前言 原标题: Koin vs Dagger, Say hello to Koin 原文地址: https://blog.usejournal.com/android-koin… 原文作者：Farshid ABZ 作者这篇文章到目前为止已经收到了 2.4k+ 的赞，冲上了 Medium 热门，非常好的一篇文章，我也使用 Koin + kotlin + databinding 结合着 inline、reified 强大的特性封装了基础库，包含了 DataBindingActivity、DataBindingFragment、DataBindingDialog、DataBindingListAdapter 等等, 正在陆续添加新的组件。 文章：https://juejin.im/post/5e9c434a51882573663f6cc6 GitHub：https://github.com/hi-dhl/JDataBinding 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 Dagger 和 Koin 优势劣势对比？应该选择 Dagger 还是 Koin？ koin 语法特性？ Koin 为什么可以做到无代码生成、无反射？ Inline 修饰符做什么用的？如何正确使用？带来的性能损失？ 只是用 Inline 修饰符，为什么编译器会给我们一个警告？ 为什么编译器建议 inline 修饰符需要和 lambda 表达式一起使用呢？ 什么时候应该使用 inline 修饰符？ Reified 修饰符做什么用？如何使用？ Koin 带来性能损失的那些事？ Kotlin 用 5 行代码实现快排算法？ 这篇文章涉及很多重要的知识点，请耐心读下去，我相信应该会给大家带来很多不一样的东西。 译文当我正在反复学习 Dagger 的时候，我遇见了 Koin，Koin 不仅节省了我的时间，还提高了效率，将我从复杂 Dagger 给释放出来了。 这篇文章将会告诉你什么是 Koin，与 Dagger 对比有那些优势，以及如何使用 Koin。 是什么 KoinKoin 是为 Kotlin 开发者提供的一个实用型轻量级依赖注入框架，采用纯 Kotlin 语言编写而成，仅使用功能解析，无代理、无代码生成、无反射。 Dagger vs Koin为了正确比较这两种方式，我们用 Dagger 和 Koin 去实现了一个项目，项目的架构都是 MVVM，其中用到了 retrofit 和 LiveData，包含了 1 个Activity、4 个 fragments、5 个 view models、1 个 repository 和 1 个 web service 接口, 这应该是一个小型项目的基础架构了 先来看一下 DI 包下的结构，左边是 Dagger，右边是 Koin 如你所见配置 Dagger 需要很多文件 而 Koin 只需要 2 个文件，例如 用 Dagger 注入 1 个 view models 就需要 3 个文件（真的需要用这么多文件吗？） 比较 Dagger 和 Koin 代码行数我使用 Statistic 工具来统计的，反复对比了项目编译前和编译后，Dagger 和 Koin 生成的代码行数，结果是非常吃惊的 正如你看到的 Dagger 生成的代码行比 Koin 多两倍 Dagger 和 Koin 编译时间怎么样呢每次编译之前我都会先 clean 然后才会 rebuild，我得到下面这个结果 Koin:BUILD SUCCESSFUL in 17s88 actionable tasks: 83 executed, 5 up-to-dateDagger:BUILD SUCCESSFUL in 18s88 actionable tasks: 83 executed, 5 up-to-date 我认为这个结果证明了，如果是在一个更大、更真实的项目中，这个代价是非常昂贵。 Dagger 和 Koin 使用上怎么样呢如果你想在 MVVM 和 Android Support lib 中使用 Dagger 你必须这么做。 首先在 module gradle 中 添加 Dagger 依赖。 kapt &quot;com.google.dagger:dagger-compiler:$dagger_version&quot;kapt &quot;com.google.dagger:dagger-android-processor:$dagger_version&quot;implementation &quot;com.google.dagger:dagger:$dagger_version&quot; 然后创建完 modules 和 components 文件之后， 需要在 Application 中 初始化 Dagger（或者其他方式初始化 Dagger）。 Class MyApplication : Application(), HasActivityInjector { @Inject lateinit var dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Activity&gt; override fun activityInjector() = dispatchingAndroidInjector fun initDagger() { DaggerAppComponent .builder() .application(this) .build() .inject(this) }} 所有的 Activity 继承 BaseActivity，我们需要实现 HasSupportFragmentInjector 和 inject DispatchingAndroidInjector。 对于 view models，我们需要在 BaseFragment 中注入 ViewModelFactory，并实现 Injectable。 但这并不是全部。还有更多的事情要做。 对于每一个 ViewModel、Fragment 和 Activity 我们需要告诉 DI 如何注入它们，正如你所见我们有 ActivityModule、FragmentModule、和 ViewModelModule。 我们来看一下下面的代码 @Moduleabstract class ActivityModule { @ContributesAndroidInjector(modules = [FragmentModule::class]) abstract fun contributeMainActivity(): MainActivity //Add your other activities here} Fragments 如下所示： @Moduleabstract class FragmentModule { @ContributesAndroidInjector abstract fun contributeLoginFragment(): LoginFragment @ContributesAndroidInjector abstract fun contributeRegisterFragment(): RegisterFragment @ContributesAndroidInjector abstract fun contributeStartPageFragment(): StartPageFragment} ViewModels 如下所以： @Moduleabstract class ViewModelModule { @Binds abstract fun bindViewModelFactory(factory: ViewModelFactory): ViewModelProvider.Factory @Binds @IntoMap @ViewModelKey(loginViewModel::class) abstract fun bindLoginFragmentViewModel(loginViewModel: loginViewModel): ViewModel @Binds @IntoMap @ViewModelKey(StartPageViewModel::class) abstract fun bindStartPageViewModel(startPageViewModel: StartPageViewModel): ViewModel ......} 所以你必须在 DI modules 中添加这些 Fragments、Activities 和 ViewModels。 那么在 Koin 中如何做 你需要在 module gradle 中添加 Koin 依赖 implementation &quot;org.koin:koin-android-viewmodel:$koin_version&quot; 然后我们需要创建 module 文件，稍后我告诉你怎么做，实际上我们并不需要像 Dagger 那么多文件。 Dagger 还有其他问题 学习 Dagger 成本是很高的，如果有人加入你的项目或者团队，他/她不得不花很多时间学习 Dagger，我使用 Dagger 两年了，到现在还不是很了解，每次我开始学习 Andorid 新技术的时候，我不得不去搜索和学习如何用 Dagger 实现新技术。 来看一下 Koin 代码 首先我们需要添加 Koin 依赖，如下所示： implementation &quot;org.koin:koin-android-viewmodel:$koin_version&quot; 我们使用的是 koin-android-viewmodel 库，因为我们希望在 MVVM 中使用它，当然还有其他的依赖库。 添加完依赖之后，我们来实现第一个 module 文件，像 Dagger 一样，可以在一个单独的文件中实现每个模块，但是由于代码简单，我决定在一个文件中实现所有模块，你也可以把它们分开。 首先我们需要了解一下 koin 语法特性 get()： 解析 Koin 模块中的实例，调用 get() 函数解析所请求组件需要的实例，这个 get() 函数通常用于构造函数中，注入构造函数值 factory：声明这是一个工厂组件，每次请求都为您提供一个新实例 single：采用单例设计模式 name：用于命名定义，当您希望具有不同类型的同一个类的多个实例时，需要使用它 我们没有创建具有多个注释和多个组件的许多文件，而是为 DI 注入每个类的时候，提供一个简单、可读的文件。 了解完 koin 语法特性之后，我们来解释下面代码什么意思 private val retrofit: Retrofit = createNetworkClient() createNetworkClient 方法创建 Retrofit 实例，设置 baseUrl，添加 ConverterFactory 和 Interceptor private val generalApi: GeneralApi = retrofit.create(GeneralApi::class.java)private val authApi: AuthApi = retrofit.create(AuthApi::class.java) AuthApi 和 GeneralApi 是 retrofit 接口 val viewModelModule = module { viewModel { LoginFragmentViewModel(get()) } viewModel { StartPageViewModel() } } 在 module 文件中声明为 viewModel， Koin 将会向 ViewModelFactory 提供 viewModel，将其绑定到当前组件。 正如你所见，在 LoginFragmentViewModel 构造函数中有调用了 get() 方法，get() 会解析一个 LoginFragmentViewModel 需要的参数，然后传递给 LoginFragmentViewModel，这个参数就是 AuthRepo。 最后在 Application onCreate 方法中添加如下代码 startKoin(this, listOf(repositoryModule, networkModule, viewModelModule)) 这里只是调用 startKoin 方法，传入一个上下文和一个希望用来初始化 Koin 的模块列表。 现在使用 ViewModel 比使用纯 ViewModel 更容易，在 Fragment 和 Activity 视图中添加下面的代码 private val startPageViewModel: StartPageViewModel by viewModel() 通过这段代码，koin 为您创建了一个 StartPageViewModel 对象，现在你可以在 Fragment 和 Activity 中使用 view model 译者思考作者总共从以下 4 个方面对比了 Dagger 和 Kotlin： 文件数量：基于 mvvm 架构，分别使用了 Dagger 和 koltin 作为依赖注入框架，初始化 Dagger 时至少需要 9 个文件，而 koltin 只需要 2 个文件，Dagger 文件数量远超过 koltin 代码行数：作者使用了 Statistic 工具，反复对比了项目编译前和编译后，Dagger 和 Koin 生成的代码行数，如下图所示 反复的对比了 Dagger 和 Koin 编译时间，结果如下所示 koin 比 Dagger 快 Koin:BUILD SUCCESSFUL in 17s88 actionable tasks: 83 executed, 5 up-to-dateDagger:BUILD SUCCESSFUL in 18s88 actionable tasks: 83 executed, 5 up-to-date 学习成本巨大，如果使用了 Dagger 朋友，应该和作者的感觉是一样的，Dagger 学习的成本是非常高的，如果项目中引入了 Dagger 意味着团队每个人都要学习 Dagger，无疑这个成本是巨大的，而且使用起来非常的复杂 注意：作者在 Application 中调用 startKoin 方法初始化 Koin 的模块列表，是 Koin 1X 的方式，Koin 团队在 2x 的时候做了很多改动（下面会介绍），初始化 Koin 的模块列有所改动，代码如下所示： startKoin { // Use Koin Android Logger androidLogger() // declare Android context androidContext(this@MainApplication) // declare modules to use modules(module1, module2 ...)} Koin 为什么可以做到无代码生成、无反射Koin 作为一个轻量级依赖注入框架，为什么可以做到无代码生成、无反射？因为 kotlin 强大的语法糖（例如 Inline、Reified 等等）和函数式编程，我们先来看一段代码。koin-projects/koin-core/src/main/kotlin/org/koin/dsl/Module.kt 案例一 // typealias 是用来为已经存在的类型重新定义名字的typealias ModuleDeclaration = Module.() -&gt; Unitfun module(createdAtStart: Boolean = false, override: Boolean = false, moduleDeclaration: ModuleDeclaration): Module { // 创建 Module val module = Module(createdAtStart, override) // 执行匿扩展函数 moduleDeclaration(module) return module}// 如何使用val mModule: Module = module { single { ... } factory { ... }} Module 是一个 lambda 表达式，才可以在 “{}” 里面自由定义 single 和 factory，会等到你需要的时候才会执行。 案例二 inline fun &lt;reified T : ViewModel&gt; Module.viewModel( qualifier: Qualifier? = null, override: Boolean = false, noinline definition: Definition&lt;T&gt;): BeanDefinition&lt;T&gt; { val beanDefinition = factory(qualifier, override, definition) beanDefinition.setIsViewModel() return beanDefinition} 内联函数支持具体化的类型参数，使用 reified 修饰符来限定类型参数，以在函数内部访问它了，由于函数是内联的，不需要反射，通过上面两个案例，说明了为什么 Koin 可以做到无代码生成、无反射。建议大家都去看看 Koin 的源码，能够从中学到很多技巧，后面我会花好几篇文章分析 Koin 源码。 Inline 修饰符带来的性能损失Inline (内联函数) 的作用：提升运行效率，调用被 inline 修饰符的函数，会把里面的代码放到我调用的地方。 如果阅读过 Koin 源码的朋友，应该会发现 inline 都是和 lambda 表达式和 reified 修饰符配套在一起使用的，如果只使用 inline 修饰符标记函数会怎么样？ 只使用 inline 修饰符会有性能问题，在这篇文章 Consider inline modifier for higher-order functions 也分析了只使用 inline 修饰符为什么会带来性能问题，并且 Android Studio 也会给一个大大大的警告。 编译器建议我们在含有 lambda 表达式作为形参的函数中使用内联，既然 Inline 修饰符可以提升运行效率，为什么编译器会给我们一个警告？ 为什么编译器建议 inline 修饰符需要和 lambda 表达式一起使用呢？ 1. 既然 Inline 修饰符可以提升运行效率，为什么编译器会给我们一个警告？ 刚才我们说过调用被 inline 修饰符的函数，会把里面的代码放到我调用的地方，来看一下下面这段代码。 inline fun twoPrintTwo() { print(2) print(2)}inline fun twoTwoPrintTwo() { twoPrintTwo() twoPrintTwo()}inline fun twoTwoTwoPrintTwo() { twoTwoPrintTwo() twoTwoPrintTwo()}fun twoTwoTwoTwoPrintTwo() { twoTwoTwoPrintTwo() twoTwoTwoPrintTwo()} 执行完最后一个方法 twoTwoTwoTwoPrintTwo，反编译出来的结果是非常令人吃惊的，结果如下所示： public static final void twoTwoTwoTwoPrintTwo() { byte var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print(var1); var1 = 2; System.out.print();} 这显示了使用 Inline 修饰符的主要问题，当我们过度使用它们时，代码会快速增长。这就是为什么 IntelliJ 在我们使用它的时候会给出警告。 2. 为什么编译器建议 inline 修饰符需要和 lambda 表达式一起使用呢？ 因为 JVM 是不支持 lambda 表达式的，非内联函数中的 Lambda 表达式会被编译为匿名类，这对性能开销是非常巨大的，而且它们的创建和使用都较慢，当我们使用 inline 修饰符时，我们根本不需要创建任何其他类，来看一下下面代码。 fun main(args: Array&lt;String&gt;) { var a = 0 // 带 inline 的 Lambda 表达式 repeat(100_000_000) { a += 1 } var b = 0 // 不带 inline 的 Lambda 表达式 noinlineRepeat(100_000_000) { b += 1 }} 编译结果如下： // Java 代码public static final void main(@NotNull String[] args) { int a = 0; // 带 inline 的 Lambda 表达式, 会把里面的代码放到我调用的地方 int times$iv = 100000000; int var3 = 0; for(int var4 = times$iv; var3 &lt; var4; ++var3) { ++a; } // 不带 inline 的 Lambda 表达式，会被编译为匿名类 final IntRef b = new IntRef(); b.element = 0; noinlineRepeat(100000000, (Function1)(new Function1() { public Object invoke(Object var1) { ++b.element; return Unit.INSTANCE; } }));} 那么我们应该在什么时候使用 inline 修饰符呢？ 使用 inline 修饰符时最常见的场景就是把函数作为另一个函数的参数时(高阶函数)，例如 filter、map、joinToString 或者一些独立的函数 repeat。 如果没有函数类型作为参数，也没有 reified 实化类型参数时，不应该使用 inline 修饰符了。 从分析 Koin 源码，inline 应该 lambda 表达式或者 reified 修饰符配合在一起使用的，另外 Android Studio 越来越智能了，如果在不正确的地方使用，会有一个大大大的警告。 Reified 修饰符，具体化的类型参数reified （具体化的类型参数）：使用 reified 修饰符来限定类型参数，结合着 inline 修饰符具体化的类型参数，可以直接在函数内部访问它。 我想分享两个使用 Reified 修饰符很常见的例子 reified-type-parameters，使用 Java 是不可能实现的。 案例一： inline fun &lt;reified T&gt; Gson.fromJson(json: String) = fromJson(json, T::class.java) // 使用val user: User = Gson().fromJson(json)val user = Gson().fromJson&lt;User&gt;(json) 案例二： inline fun &lt;reified T: Activity&gt; Context.startActivity(vararg params: Pair&lt;String, Any?&gt;) = AnkoInternals.internalStartActivity(this, T::class.java, params) Koin 带来性能损失的那些事思考了很久需不需要写这部分内容，因为在 Koin 2x 的版本的时候已经修复了，这是官方的链接 News from the trenches — What’s next for Koin?，后来想想还是写写吧，作为自己的一个学习笔记。 这个源于有个人开了一个 Issue(Bad performance in some Android devices) 现在已经被关闭了，他指出了当 Dependency 数量越来越多的时候，Koin 效能会越来越差，而且还做了一个对比如下图所示： 如果使用过 Koin 1x 的朋友应该会感觉到，引入 Koin 1x 冷启动时间边长了，而且在有大量依赖的时候，查找的时间会有点长，后来 Koin 团队也发现确实存在这个问题，到底是怎么回事呢？ 他们在 BeanRegistry 类中维护了一个列表，用来存储了 BeanDefinition，然后使用 Kotlin 的 filter 函数找出对应的 BeanDefinition，所以找出一个 Definition 时间复杂度是 O(n)，如果平均有 M 层 Dependency，那么时间复杂度会变成 O(m*n)。 Koin 团队的解决方案是用了 HashMap，使用空间换取时间，查找一个 Definition 时间复杂度变成了 O(1)，优化之后的结果如下： Koin 2x 不仅在性能优化上有很大的提升，也拓展了很多新的特性，例如 FragmentFactory 能够依赖注入到 Fragments 中就像 ViewModels 一样，还有自动拆箱等等，在后面的文章会详细的分析一下。 Kotlin 用 5 行代码实现快排算法我想分享一个快速排序算法，这是一个很酷的函数编程的例子 share cool examples，当我看到这段代码的时候惊呆了，居然还可以这么写。 fun &lt;T : Comparable&lt;T&gt;&gt; List&lt;T&gt;.quickSort(): List&lt;T&gt; = if(size &lt; 2) this else { val pivot = first() val (smaller, greater) = drop(1).partition { it &lt;= pivot} smaller.quickSort() + pivot + greater.quickSort() } // 使用 [2,5,1] -&gt; [1,2,5]listOf(2,5,1).quickSort() // [1,2,5] 最后分享一个译者自己撸的导航网站译者基于 Python + Material Design 开发的 “为互联网人而设计 国内国外名站导航“ ，收集了国内外热门网址，涵括新闻、体育、生活、娱乐、设计、产品、运营、前端开发、Android开发等等导航网站，如果你有什么好的建议，也可以留言，导航地址 ： http://site.51git.cn/ ps: 网站中的地址如果有原作者不希望展示的，可以留言告诉我，我会立刻删除 国际资讯网址大全 Android 网址大全 参考文献 My favorite examples of functional programming in Kotlin koin 官网:https://insert-koin.io/ Effective Kotlin: Consider inline modifier for higher-order functions","link":"/2020/08/04/translate/03-dagger-koin/"},{"title":"「译」Google 工程师详解 FragmentFactory 如何优雅使用 Koin 以及源码分析","text":"前言 原标题: Android Fragments: FragmentFactory 原文地址: https://proandroiddev.com/fragmentfactory…… 原文作者：Husayn Hakeem 在之前的文章 [译][Google工程师] 刚刚发布了 Fragment 的新特性 “Fragment 间传递数据的新方式” 以及源码分析 介绍了 Fragment 1.3.0 中添加了几个重要的 API。 继续上一篇文章，介绍一下 FragmentFactory 和 FragmentContainerView 以及如何和 Koin 一起使用， 这是 Google 在 Fragment 1.2.0 上做的重要的更新，强烈建议大家去使用 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 FragmentFactory 是什么？ 什么情况下使用 FragmentFactory？ FragmentContainerView 是什么？ 为什么 Google 强烈建议使用 FragmentContainerView？ Koin 如何和 FragmentFactory 一起使用以及源码分析？ 如何处理嵌套 Fragment? 这篇文章涉及很多重要新的知识点，带着自己理解，请耐心读下去，应该可以从中学到很多技巧。 译文现在我们可以使用 FragmentFactory 来完成 Fragment 构造函数的注入，但是这不是开发人员必须使用的 API, 在某些情况下，它可以被认为是一种很好的设计方法，帮助我们测试带有外部依赖项的 Fragment。 这篇文章将会解释什么是 FragmentFactory，什么时候以及如何使用它，如何处理嵌套 Fragment。 什么是 FragmentFactory？之前 Fragment 的实例都是通过使用默认的空的构造函数进行实例化，这是因为系统需要在某些情况下重新初始化它，比如配置更改或者 App 的进程重建，如果没有默认构造函数的限制，系统不知道如何重新初始化 Fragment 实例。 FragmentFactory 出现就是为了解决这个限制，通过向其提供实例化 Fragment 所需的参数/依赖关系，FragmentFactory 可以帮助系统创建 Fragment 实例。 如何使用 FragmentFactory？如果你的 Fragment 没有空的构造函数，您需要创建一个 FragmentFactory 来处理初始化它，通过继承 FragmentFactory 并且覆盖 FragmentFactory#instantiate() 来完成。 class CustomFragmentFactory(private val dependency: Dependency) : FragmentFactory() { override fun instantiate(classLoader: ClassLoader, className: String): Fragment { if (className == CustomFragment::class.java.name) { return CustomFragment(dependency) } return super.instantiate(classLoader, className) }} Fragment 是由 FragmentManagers 来管理的，所以为了使用 FragmentFactory 需要关联 FragmentManager，更具体的说它必须分配给包含 Fragment 组件的 FragmentManager，它可以是 Activity 或者 Fragment。 什么时候 FragmentFactory 和 FragmentManager 做关联FragmentFactory 负责在 Activity 和 parent Fragment 初始化 Fragment，所以应该在创建 Fragment 之前设置它。 在创建 component’s View 之前：如果在 XML 中定义 Fragment，应该使用 Fragment 的 tag &lt;fragment&gt; 或者 FragmentContainerView。 在创建 Fragment 之前：如果 Fragment 是动态添加的应该使用 FragmentTransaction。 在系统恢复 Fragment 之前：如果是因为配置更改或者 App 的进程重建，导致 Fragment 重建。 有了这些限制，可以在 Activity#onCreate() 和 Fragment#onCreate() 之前关联 FragmentFactory 和 FragmentManager，在这两个调用处 view 创建之前会重新初始化 Fragment。 这也就意味着应该在 super#onCreate() 之前关联 FragmentFactory 和 FragmentManager。 在 Activity 关联 FragmentFactory 和 FragmentManager class HostActivity : AppCompatActivity() { private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) { supportFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) // ... }} 在 Fragment 关联 FragmentFactory 和 FragmentManager class ParentFragment : Fragment() { private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) { childFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) // ... }} 需要使用 FragmentFactory 吗？到目前为止，您可能已经使用它们的默认构造函数创建 Fragment，然后使用 Dagger 或 Koin 这样的库注入它们需要的依赖项，或者在它们被使用之前在 Fragment 中初始化它们。 如果你的 Fragment 有一个默认的空构造函数，那么就不需要使用 FragmentFactory，如果在 Fragment 构造函数中接受参数，必须使用 FragmentFactory，否者会抛出 Fragment.InstantiationException 异常 如何同时使用 Fragment 和 FragmentFactory？只需要在创建 Fragment 之前，设置 FragmentFactory，它就会被用来实例化，这意味着在添加 Fragments 之前使用自定义的 FragmentFactory。 静态添加： 使用 Fragment 的 tag &lt;fragment&gt; 和 FragmentContainerView。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.fragment.app.FragmentContainerView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/customFragment&quot; android:name=&quot;com.example.CustomFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:tag=&quot;custom_fragment&quot; /&gt; 设置 FragmentFactory 用于初始化在Fragment 声明的 FragmentContainerView class HostActivity : AppCompatActivity() { private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) { supportFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) setContentView(R.layout.activity_with_fragment_container_view) }} 动态添加： 使用 FragmentTransaction#add() 方法动态的添加 Fragment class HostActivity : AppCompatActivity() { private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) { supportFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) setContentView(R.layout.activity_with_empty_frame_layout) if (savedInstanceState == null) { supportFragmentManager.beginTransaction() .add(R.id.content, CustomFragment::class.java, arguments) .commit() } }} FragmentFactory 和嵌套的 Fragment如果 parent Fragment 包含嵌套的 Fragment 或者多层次嵌套的 Fragment，它们都会使用 parent Fragment 的相同 FragmentFactory，嵌套 Fragment 需要调用 Fragment#childFragmentManager.fragmentFactory class ParentFragment : Fragment() { override fun onCreate(savedInstanceState: Bundle?) { childFragmentManager.fragmentFactory = parentFragmentFactory super.onCreate(savedInstanceState) if (savedInstanceState == null) { // Add NestedFragment } }}class NestedFragment : Fragment() { override fun onCreate(savedInstanceState: Bundle?) { childFragmentManager.fragmentFactory = childFragmentFactory super.onCreate(savedInstanceState) if (savedInstanceState == null) { // Add NestedNestedFragment } }}class NestedNestedFragment : Fragment() 译者思考我们来总结一下 Fragment 几个重要的更新，以及在什么情况下使用： 之前 Fragment 的实例都是通过使用默认的空的构造函数进行实例化的，FragmentFactory 出现就是为了解决这个限制。 FragmentFactory 不是必须要使用的，如果在 Fragment 构造函数中接受参数，必须使用 FragmentFactory FragmentFactory 需要在 Activity 或者 Fragment 中使用，并且需要在 Activity#onCreate() 和 Fragment#onCreate() 之前和 FragmentManager 做关联 嵌套的 Fragment 或者多层次嵌套的 Fragment，使用的是相同 FragmentFactory 正因为 FragmentFactory 出现，可以在 Fragment 构造函数中传递参数，意味着可以使用 Koin 等框架，可以实现构造函数依赖注入，后面我会演示如何使用 接下来一起了解一下什么 FragmentContainerView，为什么 Google 强烈建议使用 FragmentContainerView 容器来存储动态添加的 Fragment。 FragmentContainerView 是什么？为什么 Google 强烈建议使用？我们先来看一下 Google 的更新说明： FragmentContainerView： FragmentContainerView 是一个自定义 View 继承 FrameLayout，与 ViewGroups 不同，它只接受 Fragment Views。 为什么 Google 强烈建议使用？ 之前在 Google issue 提了一个 fragment z-ordering 的问题，就是说 Fragment 进入和退出动画会导致一个问题，进入的 Fragment 会在退出的 Fragment下面，直到它完全退出屏幕，这会导致在 Fragment 之间切换时产生错误的动画。 使用 FragmentContainerView 带来的好处是改进了对 fragment z-ordering 的处理。这是 Google 演示的例子，优化了两个 Fragment 退出和进入过渡不会互相重叠，使用 FragmentContainerView 将先开启退出动画然后才是进入动画。 Koin 如何和 FragmentFactory 一起使用以及源码分析在之前的文章 [译][2.4K Start] 放弃 Dagger 拥抱 Koin 分析了 Koin 性能，如果没有看过，建议可以去了解一下。 Koin 团队在 2.1.0 版本开始支持 Fragment 的依赖注入，截图如下所示： 1. 添加 Koin Fragment 依赖 implementation &quot;org.koin:koin-androidx-fragment:2.1.5&quot; 2. 创建 Fragment 并传递 ViewModel class FragmentTest(val mainViewModel: MainViewModel) : Fragment(){ ......} 3. 创建 Fragment modules val viewModelsModule = module { viewModel { MainViewModel() }}val fragmentModules = module { fragment { FragmentTest(get()) }}val appModules = listOf(fragmentModules, viewModelsModule) 4. 在调用 startKoin 方法时设置 KoinFragmentFactory startKoin { AndroidLogger(Level.DEBUG) androidContext(this@App) fragmentFactory() loadKoinModules(appModules)} fragmentFactory 是 KoinApplication 的扩展函数，提供了 KoinFragmentFactory 代码如下所示： koin.loadModules(listOf(module { single&lt;FragmentFactory&gt; { KoinFragmentFactory() } }))} 一起来分析 KoinFragmentFactory 内部的源码： class KoinFragmentFactory(val scope: Scope? = null) : FragmentFactory(), KoinComponent { override fun instantiate(classLoader: ClassLoader, className: String): Fragment { val clazz = Class.forName(className).kotlin val instance = if (scope != null) { scope.getOrNull&lt;Fragment&gt;(clazz) }else{ getKoin().getOrNull&lt;Fragment&gt;(clazz) } return instance ?: super.instantiate(classLoader, className) }} 继承 FragmentFactory 并且重写了 FragmentFactory#instantiate() 方法，在这个函数中，我们使用 className 作为参数获取 Fragment，并尝试从 Koin 中检索 Fragment 实例 5. 在 onCreate 方法之前 调用 setupKoinFragmentFactory 绑定 FragmentFactory override fun onCreate(savedInstanceState: Bundle?) { setupKoinFragmentFactory() super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)} 6. 添加 Fragment 并传递 Bundle val arguments = Bundle().apply { putString(FragmentTest.KEY_NAME, &quot;来源于 MainActivity&quot;)}supportFragmentManager.beginTransaction() .replace(R.id.container, FragmentTest::class.java, arguments) .commit() 相关源码已经上传到 JDataBinding 中, 可以查看 App、MainActivity、AppModule 和 FragmentTest 这几个类 参考文献 https://github.com/InsertKoinIO/koin/issues/647 Android Fragments: FragmentFactory https://developer.android.com/jetpack/androidx/releases/fragment","link":"/2020/07/31/translate/02-fragment-data/"},{"title":"「译」Google 最新发布了 Fragment 的新特性 Fragment 间传递数据的新方式 以及源码分析","text":"前言 原标题: Android Fragments: Fragment Result 原文地址: https://proandroiddev.com/android-fragments-fragment-result…… 原文作者: Husayn Hakeem 就在 2020/05/07 号 Now in Android #17 更新了，发布 Android 的新特性，其中就包括 Fragment 间通信的新方式，大家可以点击这里前往，看看都有那些更新 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 新 Fragment 间通信的方式的使用？ 新 Fragment 间通信的源码分析？ 汇总 Fragment 之间的通信的方式？ 译文Frrgament 间传递数据可以通过多种方式，包括使用 target Fragment APIs (Fragment.setTargetFragment() 和 Fragment.getTargetFragment())，ViewModel 或者 使用 Fragments’ 父容器 Activity，target Fragment APIs 已经过时了，现在鼓励使用新的 Fragment result APIs 完成 Frrgament 之间传递数据，其中传递数据由 FragmentManager 处理，并且在 Fragments 设置发送数据和接受数据 在 Frrgament 之间传递数据使用新的 Fragment APIs 在 两个 Frrgament 之间的传递，没有任何引用，可以使用它们公共的 FragmentManager，它充当 Frrgament 之间传递数据的中心存储。 接受数据如果想在 Fragment 中接受数据，可以在 FragmentManager 中注册一个 FragmentResultListener，参数 requestKey 可以过滤掉 FragmentManager 发送的数据 FragmentManager.setFragmentResultListener( requestKey, lifecycleOwner, FragmentResultListener { requestKey: String, result: Bundle -&gt; // Handle result }) 参数 lifecycleOwner 可以观察生命周期，当 Fragment 的生命周期处于 STARTED 时接受数据。如果监听 Fragment 的生命周期，您可以在接收到新数据时安全地更新 UI，因为 view 的创建(onViewCreated() 方法在 onStart() 之前被调用)。 当生命周期处于 LifecycleOwner STARTED 的状态之前，如果有多个数据传递，只会接收到最新的值 当生命周期处于 LifecycleOwner DESTROYED 时，它将自动移除 listener，如果想手动移除 listener，需要调用 FragmentManager.setFragmentResultListener() 方法，传递空的 FragmentResultListener 在 FragmentManager 中注册 listener，依赖于 Fragment 发送返回的数据 如果在 FragmentA 中接受 FragmentB 发送的数据，FragmentA 和 FragmentB 处于相同的层级，通过 parent FragmentManager 进行通信，FragmentA 必须使用 parent FragmentManager 注册 listener parentFragmentManager.setFragmentResultListener(...) 如果在 FragmentA 中接受 FragmentB 发送的数据，FragmentA 是 FragmentB 的父容器， 他们通过 child FragmentManager 进行通信 childFragmentManager.setFragmentResultListener(...) listener 必须设置的Fragment 相同的 FragmentManager 发送数据如果 FragmentB 发送数据给 FragmentA，需要在 FragmentA 中注册 listener，通过 parent FragmentManager 发送数据 parentFragmentManager.setFragmentResult( requestKey, // Same request key FragmentA used to register its listener bundleOf(key to value) // The data to be passed to FragmentA) 测试 Fragment Results测试 Fragment 是否成功接收或发送数据，可以使用 FragmentScenario API 接受数据如果在 FragmentA 中注册 FragmentResultListener 接受数据，你可以模拟 parent FragmentManager 发送数据，如果在 FragmentA 中正确注册了 listener，可以用来验证 FragmentA 是否能收到数据，例如，如果在 FragmentA 中接受数据并更新 UI, 可以使用 Espresso APIs 来验证是否期望的数据 @Testfun shouldReceiveData() { val scenario = FragmentScenario.launchInContainer(FragmentA::class.java) // Pass data using the parent fragment manager scenario.onFragment { fragment -&gt; val data = bundleOf(KEY_DATA to &quot;value&quot;) fragment.parentFragmentManager.setFragmentResult(&quot;aKey&quot;, data) } // Verify data is received, for example, by verifying it's been displayed on the UI onView(withId(R.id.textView)).check(matches(withText(&quot;value&quot;))) } 发送数据可以在 FragmentB 的 parent FragmentManager 上注册一个 FragmentResultListener 来测试 FragmentB 是否成功发送数据，当发送数据结束时，可以来验证这个 listener 是否能收到数据 @Testfun shouldSendData() { val scenario = FragmentScenario.launchInContainer(FragmentB::class.java) // Register result listener var receivedData = &quot;&quot; scenario.onFragment { fragment -&gt; fragment.parentFragmentManager.setFragmentResultListener( KEY, fragment, FragmentResultListener { key, result -&gt; receivedData = result.getString(KEY_DATA) }) } // Send data onView(withId(R.id.send_data)).perform(click()) // Verify data was successfully sent assertThat(receivedData).isEqualTo(&quot;value&quot;)} 示例项目下面的示例项目，展示了如何使用 Fragment 新的 API android-playground: https://github.com/husaynhakeem/android-playground… 总结虽然使用了 Fragment result APIs，替换了过时的 Fragment target APIs，但是新的 APIs 在Bundle 作为数据传传递方面有一些限制，只能传递简单数据类型、Serializable 和 Parcelable 数据，Fragment result APIs 允许程序从崩溃中恢复数据，而且不会持有对方的引用，避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 译者的思考这是译者的一些思考，总结一下 Fragment 1.3.0-alpha04 新增加的 Fragment 间通信的 API 数据接受 FragmentManager.setFragmentResultListener( requestKey, lifecycleOwner, FragmentResultListener { requestKey: String, result: Bundle -&gt; // Handle result }) 数据发送 parentFragmentManager.setFragmentResult( requestKey, // Same request key FragmentA used to register its listener bundleOf(key to value) // The data to be passed to FragmentA) 那么 Fragment 间通信的新 API 给我们带来哪些好处呢： 在 Fragment 之间传递数据，不会持有对方的引用 当生命周期处于 ON_START 时开始处理数据，避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 当生命周期处于 ON_DESTROY 时，移除监听 我们一起来从源码的角度分析一下 Google 是如何做的 源码分析按照惯例从调用的方法来分析，数据接受时，调用了 FragmentManager 的 setFragmentResultListener 方法androidx.fragment/fragment/1.3.0-alpha04……androidx/fragment/app/FragmentManager.java private final ConcurrentHashMap&lt;String, LifecycleAwareResultListener&gt; mResultListeners = new ConcurrentHashMap&lt;&gt;();@Overridepublic final void setFragmentResultListener(@NonNull final String requestKey, @NonNull final LifecycleOwner lifecycleOwner, @Nullable final FragmentResultListener listener) { // mResultListeners 是 ConcurrentHashMap 的实例，用来储存注册的 listener // 如果传递的参数 listener 为空时，移除 requestKey 对应的 listener if (listener == null) { mResultListeners.remove(requestKey); return; } // Lifecycle是一个生命周期感知组件，一般用来响应Activity、Fragment等组件的生命周期变化 final Lifecycle lifecycle = lifecycleOwner.getLifecycle(); // 当生命周期处于 DESTROYED 时，直接返回 // 避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 if (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) { return; } // 开始监听生命周期 LifecycleEventObserver observer = new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { // 当生命周期处于 ON_START 时开始处理数据 if (event == Lifecycle.Event.ON_START) { // 开始检查受到的数据 Bundle storedResult = mResults.get(requestKey); if (storedResult != null) { // 如果结果不为空，调用回调方法 listener.onFragmentResult(requestKey, storedResult); // 清除数据 setFragmentResult(requestKey, null); } } // 当生命周期处于 ON_DESTROY 时，移除监听 if (event == Lifecycle.Event.ON_DESTROY) { lifecycle.removeObserver(this); mResultListeners.remove(requestKey); } } }; lifecycle.addObserver(observer); mResultListeners.put(requestKey, new FragmentManager.LifecycleAwareResultListener(lifecycle, listener));} Lifecycle是一个生命周期感知组件，一般用来响应Activity、Fragment等组件的生命周期变化 获取 Lifecycle 去监听 Fragment 的生命周期的变化 当生命周期处于 ON_START 时开始处理数据，避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 当生命周期处于 ON_DESTROY 时，移除监听 接下来一起来看一下数据发送的方法，调用了 FragmentManager 的 setFragmentResult 方法androidx.fragment/fragment/1.3.0-alpha04……androidx/fragment/app/FragmentManager.java private final ConcurrentHashMap&lt;String, Bundle&gt; mResults = new ConcurrentHashMap&lt;&gt;();private final ConcurrentHashMap&lt;String, LifecycleAwareResultListener&gt; mResultListeners = new ConcurrentHashMap&lt;&gt;(); @Overridepublic final void setFragmentResult(@NonNull String requestKey, @Nullable Bundle result) { if (result == null) { // mResults 是 ConcurrentHashMap 的实例，用来存储数据传输的 Bundle // 如果传递的参数 result 为空，移除 requestKey 对应的 Bundle mResults.remove(requestKey); return; } // mResultListeners 是 ConcurrentHashMap 的实例，用来储存注册的 listener // 获取 requestKey 对应的 listener LifecycleAwareResultListener resultListener = mResultListeners.get(requestKey); if (resultListener != null &amp;&amp; resultListener.isAtLeast(Lifecycle.State.STARTED)) { // 如果 resultListener 不为空，并且生命周期处于 STARTED 状态时，调用回调 resultListener.onFragmentResult(requestKey, result); } else { // 否则保存当前传输的数据 mResults.put(requestKey, result); }} 获取 requestKey 注册的 listener 当生命周期处于 STARTED 状态时，开始发送数据 否则保存当前传输的数据 源码分析到这里结束了，我们一起来思考一下，在之前我们的都有那些数据传方式 汇总 Fragment 之间的通信的方式 通过共享 ViewModel 或者关联 Activity来完成，Fragment 之间不应该直接通信 参考 Google: ViewModel#sharing 通过接口，可以在 Fragment 定义接口，并在 Activity 实现它 参考 Google: 与其他 Fragment 通信 通过使用 findFragmentById 方法，获取 Fragment 的实例，然后调用 Fragment 的公共方法 参考 Google: 与其他 Fragment 通信 调用 Fragment.setTargetFragment() 和 Fragment.getTargetFragment() 方法，但是注意 target fragment 需要直接访问另一个 fragment 的实例，这是十分危险的，因为你不知道目标 fragment 处于什么状态 Fragment 新的 API, setFragmentResult() 和 setFragmentResultListener() 综合以上通信方式，那么你认为 Fragment 之间通信最好的方式是什么？ 参考文献 Now in Android #17: https://medium.com/androiddeve…… Pass data between fragments: https://developer.android.com/training/basi…… ViewModel#sharing: https://developer.android.com/topic/librari…… 与其他 Fragment 通信: https://developer.android.com/training/basic……","link":"/2020/06/10/translate/01-fragment/"},{"title":"0xA07 Android 10 源码分析：Window 的类型 以及 三维视图层级分析","text":"引言 这是 Android 10 源码分析系列的第 7 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 在之前的文章 0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构 介绍了 Activity、Window、PhoneWindow、WindowManager 之间的关系，以及 Activity 和 Dialog 的视图绑定过程，而这篇文章主要两个目的： 对上一篇文章 0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构 做深入的了解 为后面的篇文章「如何在 Andorid 系统里添加自定义 View」等等做好铺垫 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 Window 都有那些常用的参数? Window 都那些类型？每个类型的意思？以及作用？ Window 那些过时的 API 以及处理方案？ Window 视图层级顺序是如何确定的？ Window 都那些 flag？每个 flag 的意思？以及作用？ Window 的软键盘模式？每个模式的意思？以及如何使用？ Kotlin 小技巧？ 在开始分析之前，我们先来看一张图，熟悉一下几个基本概念，这些概念伴将随着整篇文章 我们在手机上看到的界面是二维的，但是实际上是一个三维，如上图所示 Window：是一个抽象类，它作为一个顶级视图添加到 WindowManager 中，View 是依附于 Window 而存在的，对 View 进行管理 WindowManager：它是一个接口，继承自接口 ViewManager，对 Window 进行管理 PhoneWindow：Window 唯一实现类，添加到 WindowManager 的根容器中 WindowManagerService：WindowManager 是 Window 的容器，管理着 Window，对 Window 进行添加和删除，最终具体的工作都是由 WindowManagerService 来处理的，WindowManager 和 WindowManagerService 通过 Binder 来进行跨进程通信，WindowManagerService 才是 Window 的最终管理者 这篇文章重要知识点是 Window 视图层级顺序是如何确定的，其他内容都是一些概念的东西，可以选择性的阅读，了解完基本概念之后，进入这篇文章的核心内容，我们先来了解一下 Window 都有那些常用的参数 Window 都有那些常用的参数Window 的参数都被定义在 WindowManager 的静态内部类 LayoutParams 中frameworks/base/core/java/android/view/WindowManager#LayoutParams.java public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable { // window 左上角的 x 坐标 public int x; // window 左上角的 y 坐标 public int y; // Window 的类型 public int type; // Window 的 flag 用于控制 Window 的显示 public int flags; // window 软键盘输入区域的显示模式 public int softInputMode; // window 的透明度，取值为0-1 public float alpha = 1.0f; // window 在屏幕中的位置 public int gravity; // window 的像素点格式，值定义在 PixelFormat 中 public int format;} 接下来我们我们主要来介绍一下 Window 的类型、Window 视图层级顺序、Window 的 flag、和 window 软键盘模式 Window 都那些类型以及作用Window 的类型大概可以分为三类： 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window）， Window 的类型通过 type 值来表示，每个大类型又包含多个小类型，它们都定义在 WindowManager 的静态内部类 LayoutParamsframeworks/base/core/java/android/view/WindowManager#LayoutParams.java public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable { public int type; // 应用程序 Window 的开始值 public static final int FIRST_APPLICATION_WINDOW = 1; // 应用程序 Window 的结束值 public static final int LAST_APPLICATION_WINDOW = 99; // 子 Window 类型的开始值 public static final int FIRST_SUB_WINDOW = 1000; // 子 Window 类型的结束值 public static final int LAST_SUB_WINDOW = 1999; // 系统 Window 类型的开始值 public static final int FIRST_SYSTEM_WINDOW = 2000; // 系统 Window 类型的结束值 public static final int LAST_SYSTEM_WINDOW = 2999;} 类型 值 备注 FIRST_APPLICATION_WINDOW 1 应用程序 Window 的开始值 LAST_APPLICATION_WINDOW 99 应用程序 Window 的结束值 FIRST_SUB_WINDOW 1000 子 Window 的开始值 LAST_SUB_WINDOW 1999 子 Window 的结束值 FIRST_SYSTEM_WINDOW 2000 系统 Window 的开始值 LAST_SYSTEM_WINDOW 2999 系统 Window 的结束值 小技巧：如果是层级在 2000（FIRST_SYSTEM_WINDOW）以下的是不需要申请弹窗权限的 应用程序 Window（Application Window）：它的区间范围 [1,99]，例如 Activity frameworks/base/core/java/android/view/WindowManager#LayoutParams.java* // 应用程序 Window 的开始值public static final int FIRST_APPLICATION_WINDOW = 1;// 应用程序 Window 的基础值public static final int TYPE_BASE_APPLICATION = 1;// 普通的应用程序public static final int TYPE_APPLICATION = 2;// 特殊的应用程序窗口，当程序可以显示 Window 之前使用这个 Window 来显示一些东西public static final int TYPE_APPLICATION_STARTING = 3;// TYPE_APPLICATION 的变体，在应用程序显示之前，WindowManager 会等待这个 Window 绘制完毕public static final int TYPE_DRAWN_APPLICATION = 4;// 应用程序 Window 的结束值public static final int LAST_APPLICATION_WINDOW = 99; 类型 备注 FIRST_APPLICATION_WINDOW 应用程序 Window 的开始值 TYPE_BASE_APPLICATION 应用程序 Window 的基础值 TYPE_APPLICATION 普通的应用程序 TYPE_APPLICATION_STARTING 特殊的应用程序窗口，当程序可以显示 Window 之前使用这个 Window 来显示一些东西 TYPE_DRAWN_APPLICATION TYPE_APPLICATION 的变体 在应用程序显示之前，WindowManager 会等待这个 Window 绘制完毕 LAST_APPLICATION_WINDOW 应用程序 Window 的结束值 子 Window（Sub Windwow）：它的区间范围 [1000,1999]，这些 Window 按照 Z-order 顺序依附于父 Window 上（关于 Z-order 后文有介绍），并且他们的坐标空间相对于父 Window 的，例如：PopupWindow frameworks/base/core/java/android/view/WindowManager#LayoutParams.java* // 子 Window 类型的开始值public static final int FIRST_SUB_WINDOW = 1000;// 应用程序 Window 顶部的面板。这些 Window 出现在其附加 Window 的顶部。public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;// 用于显示媒体(如视频)的 Window。这些 Window 出现在其附加 Window 的后面。public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1;// 应用程序 Window 顶部的子面板。这些 Window 出现在其附加 Window 和任何Window的顶部public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;// 当前Window的布局和顶级Window布局相同时，不能作为子代的容器public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3;// 用显示媒体 Window 覆盖顶部的 Window， 这是系统隐藏的 APIpublic static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4;// 子面板在应用程序Window的顶部，这些Window显示在其附加Window的顶部， 这是系统隐藏的 APIpublic static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5;// 子 Window 类型的结束值public static final int LAST_SUB_WINDOW = 1999; 类型 备注 FIRST_SUB_WINDOW 子 Window 的开始值 TYPE_APPLICATION_PANEL 应用程序 Window 顶部的面板，这些 Window 出现在其附加 Window 的顶部 TYPE_APPLICATION_MEDIA 用于显示媒体(如视频)的 Window，这些 Window 出现在其附加 Window 的后面 TYPE_APPLICATION_SUB_PANEL 应用程序 Window 顶部的子面板，这些 Window 出现在其附加 Window 和任何Window的顶部 TYPE_APPLICATION_ATTACHED_DIALOG 当前Window的布局和顶级Window布局相同时，不能作为子代的容器 TYPE_APPLICATION_MEDIA_OVERLAY 用显示媒体 Window 覆盖顶部的 Window， 这是系统隐藏的 API TYPE_APPLICATION_ABOVE_SUB_PANEL 子面板在应用程序Window的顶部，这些Window显示在其附加Window的顶部， 这是系统隐藏的 API LAST_SUB_WINDOW 子 Window 的结束值 系统 Window（System Window）: 它区间范围 [2000,2999]，例如：Toast，输入法窗口，系统音量条窗口，系统错误窗口 frameworks/base/core/java/android/view/WindowManager#LayoutParams.java* // 系统Window类型的开始值public static final int FIRST_SYSTEM_WINDOW = 2000;// 系统状态栏，只能有一个状态栏，它被放置在屏幕的顶部，所有其他窗口都向下移动public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW;// 系统搜索窗口，只能有一个搜索栏，它被放置在屏幕的顶部public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_SYSTEM_ALERT = FIRST_SYSTEM_WINDOW+3;// 已经从系统中被移除，可以使用 TYPE_KEYGUARD_DIALOG 代替public static final int TYPE_KEYGUARD = FIRST_SYSTEM_WINDOW+4;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_TOAST = FIRST_SYSTEM_WINDOW+5;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW+6;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_PRIORITY_PHONE = FIRST_SYSTEM_WINDOW+7;// 系统对话框窗口public static final int TYPE_SYSTEM_DIALOG = FIRST_SYSTEM_WINDOW+8;// 锁屏时显示的对话框public static final int TYPE_KEYGUARD_DIALOG = FIRST_SYSTEM_WINDOW+9;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_SYSTEM_ERROR = FIRST_SYSTEM_WINDOW+10;// 输入法窗口，位于普通 UI 之上，应用程序可重新布局以免被此窗口覆盖public static final int TYPE_INPUT_METHOD = FIRST_SYSTEM_WINDOW+11;// 输入法对话框，显示于当前输入法窗口之上public static final int TYPE_INPUT_METHOD_DIALOG= FIRST_SYSTEM_WINDOW+12;// 墙纸public static final int TYPE_WALLPAPER = FIRST_SYSTEM_WINDOW+13;// 状态栏的滑动面板public static final int TYPE_STATUS_BAR_PANEL = FIRST_SYSTEM_WINDOW+14;// 应用程序叠加窗口显示在所有窗口之上public static final int TYPE_APPLICATION_OVERLAY = FIRST_SYSTEM_WINDOW + 38;// 系统Window类型的结束值public static final int LAST_SYSTEM_WINDOW = 2999; 类型 备注 FIRST_SYSTEM_WINDOW 系统 Window 类型的开始值 TYPE_STATUS_BAR 系统状态栏，只能有一个状态栏，它被放置在屏幕的顶部，所有其他窗口都向下移动 TYPE_SEARCH_BAR 系统搜索窗口，只能有一个搜索栏，它被放置在屏幕的顶部 TYPE_PHONE API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_SYSTEM_ALERT API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_KEYGUARD 已经从系统中被移除，可以使用 TYPE_KEYGUARD_DIALOG 代替 TYPE_TOAST API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_SYSTEM_OVERLAY API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_PRIORITY_PHONE API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_SYSTEM_ERROR API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_APPLICATION_OVERLAY 应用程序叠加窗口显示在所有窗口之上 TYPE_SYSTEM_DIALOG 系统对话框窗口 TYPE_KEYGUARD_DIALOG 锁屏时显示的对话框 TYPE_INPUT_METHOD 输入法窗口，位于普通 UI 之上，应用程序可重新布局以免被此窗口覆盖 TYPE_INPUT_METHOD_DIALOG 输入法对话框，显示于当前输入法窗口之上 TYPE_WALLPAPER 墙纸 TYPE_STATUS_BAR_PANEL 状态栏的滑动面板 LAST_SYSTEM_WINDOW 系统 Window 类型的结束值 需要注意的是： TYPE_PHONE、TYPE_SYSTEM_ALERT、TYPE_TOAST、TYPE_SYSTEM_OVERLAY、TYPE_PRIORITY_PHONE、TYPE_SYSTEM_ERROR 这些 type 在 API 26 中均已经过时，使用 TYPE_APPLICATION_OVERLAY 代替，需要申请 Manifest.permission.SYSTEM_ALERT_WINDOW 权限 TYPE_KEYGUARD 已经被从系统中移除，可以使用 TYPE_KEYGUARD_DIALOG 来代替 Window 视图层级顺序我们在手机上看的是二维的，但是实际上是三维的显示，如下图所示 在文章开头介绍了参数类型包含了 Window 的 x 轴坐标、Window 的 y 轴坐标， 既然是一个三维坐标系，那么 z 轴坐标在哪里？ 接下来就是我们要分析的非常重要的一个类 WindowManagerService，当添加 Window 的时候已经确定好了 Window 的层级，显示的时候才会根据当前的层级确定 Window 应该在哪一层显示 WindowManager 是 Window 的容器，管理着 Window，对 Window 进行添加和删除，具体的工作都是由 WMS 来处理的，WindowManager 和 WMS 通过 Binder 来进行跨进程通信，WMS 才是 Window 的最终管理者，我先来看一下 WMS 的 addWindow 方法frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java public int addWindow(Session session, IWindow client, int seq, LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel, InsetsState outInsetsState) { final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow); ...... win.mToken.addWindow(win); ...... win.getParent().assignChildLayers(); ...... } WindowState 计算当前 Window 层级 win.mToken.addWindow 这个方法将当前的 win 放入 WindowList 中，WindowList 是一个 ArrayList displayContent.assignWindowLayers 方法 计算 z-order 值, z-order 值越大越靠前，就越靠近用户 Window 视图层级顺序 用 Z-order 来表示，Z-order 对应着 WindowManager.LayoutParams 的 type 值，Z-order 可以理解为 Android 视图的层级概念，值越大越靠前，就越靠近用户。 WindowState 就是 windowManager 中的窗口，一个 WindowState 表示一个 window 那么 Z-order 的值的计算逻辑在 WindowState 类中，WindowState 构造的时候初始化当前的 mBaseLayer 和 mSubLayer，这两个参数应该是决定 z-order 的两个因素frameworks/base/services/core/java/com/android/server/wm/WindowState.java static final int TYPE_LAYER_MULTIPLIER = 10000;static final int TYPE_LAYER_OFFSET = 1000; WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token, WindowState parentWindow, int appOp, int seq, WindowManager.LayoutParams a, int viewVisibility, int ownerId, boolean ownerCanAddInternalSystemWindow, PowerManagerWrapper powerManagerWrapper) { // 判断该是否在子 Window 的类型范围内[1000,1999] if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) { // 调用 getWindowLayerLw 方法返回值在[1,33]之间，根据不同类型的 Window 在屏幕上进行排序 mBaseLayer = mPolicy.getWindowLayerLw(parentWindow) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; // mSubLayer 子窗口的顺序 // 调用 getSubWindowLayerFromTypeLw 方法返回值在[-2.3]之间 ，返回子 Window 相对于父 Window 的位置 mSubLayer = mPolicy.getSubWindowLayerFromTypeLw(a.type); ...... } else { mBaseLayer = mPolicy.getWindowLayerLw(this) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; mSubLayer = 0; ...... } } mBaseLayer 是基础序，对应的区间范围 [1,33] mSubLayer 相同分组下的子 Window 的序，对应的区间范围 [-2.3] 判断该是否在子 Window 的类型范围内[1000,1999] 如果是子 Window，调用 getWindowLayerLw 方法，计算 mBaseLayer 的值，返回一个用来对 Window 进行排序的任意整数，调用 getSubWindowLayerFromTypeLw 方法，计算 mSubLayer 的值，返回子 Window 相对于父 Window 的位置 如果不是子 Window，调用 getWindowLayerLw 方法，计算 mBaseLayer 的值，返回一个用来对 Window 进行排序的任意整数，mSubLayer 值为 0 计算 mBaseLayer 的值调用 WindowManagerPolicy 的 getWindowLayerLw 方法，计算 mBaseLayer 的值frameworks/base/services/core/java/com/android/server/policy/WindowManagerPolicy.java int APPLICATION_LAYER = 2;int APPLICATION_MEDIA_SUBLAYER = -2;int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1;int APPLICATION_PANEL_SUBLAYER = 1;int APPLICATION_SUB_PANEL_SUBLAYER = 2;int APPLICATION_ABOVE_SUB_PANEL_SUBLAYER = 3; /*** 根据不同类型的 Window 在屏幕上进行排序* 返回一个用来对窗口进行排序的任意整数，数字越小，表示的值越小*/ default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) { // 判断是否在应用程序 Window 类型的取值范围内 [1,99] if (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) { return APPLICATION_LAYER; } switch (type) { case TYPE_WALLPAPER: // 壁纸，通过 window manager 删除它 return 1; case TYPE_PHONE: // 电话 return 3; case TYPE_SEARCH_BAR: // 搜索栏 return 6; case TYPE_SYSTEM_DIALOG: // 系统的 dialog return 7; case TYPE_TOAST: // 系统 toast return 8; case TYPE_INPUT_METHOD: // 输入法 return 15; case TYPE_STATUS_BAR: // 状态栏 return 17; case TYPE_KEYGUARD_DIALOG: //锁屏 return 20; ...... case TYPE_POINTER: // the (mouse) pointer layer return 33; default: return APPLICATION_LAYER; }} 根据不同类型的 Window 在屏幕上进行排序，返回一个用来对 Window 进行排序的任意整数，数字越小，表示的值越小，通过以下公式来计算它的基础序 ，基础序越大，Z-order 值越大越靠前，就越靠近用户，我们以 Activity 为例： Activity 属于应用层 Window，它的取值范围在 [1,99] 内，调用 getWindowLayerLw 方法返回 APPLICATION_LAYER，APPLICATION_LAYER 值为 2，通过下面方法进行计算 static final int TYPE_LAYER_MULTIPLIER = 10000;static final int TYPE_LAYER_OFFSET = 1000;mBaseLayer = mPolicy.getWindowLayerLw(parentWindow) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; 那么最终 Activity 的 mBaseLayer 值是 21000 计算 mSubLayer 的值调用 getSubWindowLayerFromTypeLw 方法 ，传入 WindowManager.LayoutParams 的实例 a 的 type 值，计算 mSubLayer 的值frameworks/base/services/core/java/com/android/server/policy/WindowManagerPolicy.java int APPLICATION_LAYER = 2;int APPLICATION_MEDIA_SUBLAYER = -2;int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1;int APPLICATION_PANEL_SUBLAYER = 1;int APPLICATION_SUB_PANEL_SUBLAYER = 2;int APPLICATION_ABOVE_SUB_PANEL_SUBLAYER = 3;/*** 计算 Window 相对于父 Window 的位置* 返回 一个整数，正值在前面，表示在父 Window 上面，负值在后面，表示在父 Window 的下面*/default int getSubWindowLayerFromTypeLw(int type) { switch (type) { case TYPE_APPLICATION_PANEL: // 1000 case TYPE_APPLICATION_ATTACHED_DIALOG: // 1003 return APPLICATION_PANEL_SUBLAYER; // return 1 case TYPE_APPLICATION_MEDIA:// 1001 return APPLICATION_MEDIA_SUBLAYER;// return -2 case TYPE_APPLICATION_MEDIA_OVERLAY: return APPLICATION_MEDIA_OVERLAY_SUBLAYER; // return -1 case TYPE_APPLICATION_SUB_PANEL:// 1002 return APPLICATION_SUB_PANEL_SUBLAYER;// return 2 case TYPE_APPLICATION_ABOVE_SUB_PANEL: return APPLICATION_ABOVE_SUB_PANEL_SUBLAYER;// return 3 } return 0;} 计算子 Window 相对于父 Window 的位置，返回一个整数，正值表示在父 Window 上面，负值表示在父 Window 的下面 Window 的 flagWindow 的 flag 用于控制 Window 的显示，它们的值也是定义在 WindowManager 的内部类 LayoutParams 中frameworks/base/core/java/android/view/WindowManager#LayoutParams.java // 当 Window 可见时允许锁屏public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = 0x00000001;// Window 后面的内容都变暗public static final int FLAG_DIM_BEHIND = 0x00000002;@Deprecated// API 已经过时，Window 后面的内容都变模糊public static final int FLAG_BLUR_BEHIND = 0x00000004;// Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的// Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODALpublic static final int FLAG_NOT_FOCUSABLE = 0x00000008;// 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件// Window 之外的 view 也是可以响应 touch 事件。public static final int FLAG_NOT_TOUCH_MODAL = 0x00000020;// 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口。public static final int FLAG_NOT_TOUCHABLE = 0x00000010;// 只要 Window 可见时屏幕就会一直亮着public static final int FLAG_KEEP_SCREEN_ON = 0x00000080;// 允许 Window 占满整个屏幕public static final int FLAG_LAYOUT_IN_SCREEN = 0x00000100;// 允许 Window 超过屏幕之外public static final int FLAG_LAYOUT_NO_LIMITS = 0x00000200;// 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示public static final int FLAG_FULLSCREEN = 0x00000400;// 表示比FLAG_FULLSCREEN低一级，会显示状态栏public static final int FLAG_FORCE_NOT_FULLSCREEN = 0x00000800;// 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件public static final int FLAG_IGNORE_CHEEK_PRESSES = 0x00008000;// 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件。public static final int FLAG_WATCH_OUTSIDE_TOUCH = 0x00040000;@Deprecated// 窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;// 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制，// 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色。public static final int FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS = 0x80000000;// 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸public static final int FLAG_SHOW_WALLPAPER = 0x00100000; flag 备注 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON 当 Window 可见时允许锁屏 FLAG_DIM_BEHIND Window 后面的内容都变暗 FLAG_BLUR_BEHIND API 已经过时，Window 后面的内容都变模糊 FLAG_NOT_FOCUSABLE Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的，Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL FLAG_NOT_TOUCH_MODAL 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件，Window 之外的 view 也是可以响应 touch 事件 FLAG_NOT_TOUCHABLE 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口 FLAG_KEEP_SCREEN_ON 只要 Window 可见时屏幕就会一直亮着 FLAG_LAYOUT_IN_SCREEN 允许 Window 占满整个屏幕 FLAG_LAYOUT_NO_LIMITS 允许 Window 超过屏幕之外 FLAG_FULLSCREEN 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示 FLAG_FORCE_NOT_FULLSCREEN 表示比FLAG_FULLSCREEN低一级，会显示状态栏 FLAG_IGNORE_CHEEK_PRESSES 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件 FLAG_WATCH_OUTSIDE_TOUCH 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件 FLAG_SHOW_WHEN_LOCKED 已经过时，窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制， 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色 FLAG_SHOW_WALLPAPER 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸 window 软键盘模式表示 window 软键盘输入区域的显示模式，常见的情况 Window 的软键盘打开会占据整个屏幕，遮挡了后面的视图，例如看直播的时候底部有个输入框点击的时候，输入框随着键盘一起上来，而有的时候，希望键盘覆盖在所有的 View 之上，界面保持不动等等 软键盘模式(SoftInputMode) 值，与 AndroidManifest 中 Activity 的属性 android:windowSoftInputMode 是对应的，因此可以在 AndroidManifest 文件中为 Activity 设置android:windowSoftInputMode &lt;activity android:windowSoftInputMode=&quot;adjustNothing&quot; /&gt; 也可以在 Java 代码中为 Window 设置 SoftInputMode getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING); SoftInputMode 常用的有以下几个值 // 不会改变软键盘的状态public static final int SOFT_INPUT_STATE_UNCHANGED = 1;// 当用户进入该窗口时，隐藏软键盘public static final int SOFT_INPUT_STATE_HIDDEN = 2;// 当窗口获取焦点时，隐藏软键盘public static final int SOFT_INPUT_STATE_ALWAYS_HIDDEN = 3;// 当用户进入窗口时，显示软键盘public static final int SOFT_INPUT_STATE_VISIBLE = 4;// 当窗口获取焦点时，显示软键盘public static final int SOFT_INPUT_STATE_ALWAYS_VISIBLE = 5;// window会调整大小以适应软键盘窗口public static final int SOFT_INPUT_MASK_ADJUST = 0xf0;// 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置public static final int SOFT_INPUT_ADJUST_UNSPECIFIED = 0x00;// 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方// 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用；// 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏。public static final int SOFT_INPUT_ADJUST_RESIZE = 0x10;// 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的,// 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方// 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用public static final int SOFT_INPUT_ADJUST_PAN = 0x20;// 将不会调整大小，直接覆盖在window上public static final int SOFT_INPUT_ADJUST_NOTHING = 0x30; model 备注 SOFT_INPUT_STATE_UNCHANGED 不会改变软键盘的状态 SOFT_INPUT_STATE_VISIBLE 当用户进入窗口时，显示软键盘 SOFT_INPUT_STATE_HIDDEN 当用户进入该窗口时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_HIDDEN 当窗口获取焦点时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_VISIBLE 当窗口获取焦点时，显示软键盘 SOFT_INPUT_MASK_ADJUST window 会调整大小以适应软键盘窗口 SOFT_INPUT_ADJUST_UNSPECIFIED 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置 SOFT_INPUT_ADJUST_RESIZE 1. 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方 2. 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用 3. 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏 SOFT_INPUT_ADJUST_PAN 1. 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的 2. 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方 3. 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用 SOFT_INPUT_ADJUST_NOTHING 将不会调整大小，直接覆盖在window上 Kotlin 小技巧利用 plus (+) 和 plus (-) 对 Map 集合做运算，如下所示： fun main() { val numbersMap = mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3) // plus (+) println(numbersMap + Pair(&quot;four&quot;, 4)) // {one=1, two=2, three=3, four=4} println(numbersMap + Pair(&quot;one&quot;, 10)) // {one=10, two=2, three=3} println(numbersMap + Pair(&quot;five&quot;, 5) + Pair(&quot;one&quot;, 11)) // {one=11, two=2, three=3, five=5} // plus (-) println(numbersMap - &quot;one&quot;) // {two=2, three=3} println(numbersMap - listOf(&quot;two&quot;, &quot;four&quot;)) // {one=1, three=3}} 总结到这里就结束了，这篇文章主要介绍了 Window 的类型大概可以分为三类： 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window）。 分别介绍了 Window 的类型、Window 视图层级顺序、Window 的 flag、和 window 软键盘模式为后面的内容做铺垫 Window 都有那些常用的参数? 参数 备注 x window 左上角的 x 坐标 y window 左上角的 y 坐标 type Window 的类型 flag Window 的 flag 用于控制 Window 的显示 softInputMode window 软键盘输入区域的显示模式 alpha Window 的透明度，取值为0-1 gravity Window 在屏幕中的位置 alpha Window 的透明度，取值为0-1 format Window 的像素点格式，值定义在 PixelFormat 中 Window 都有那些类型？ 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window），子 Window 依附于父 Window 上，并且他们的坐标空间相对于父 Window 的，每个大类型又包含多个小类型，每个类型在上文的表格中已经列出来了， Window 那些过时的 API 以及处理方案？ TYPE_PHONE、TYPE_SYSTEM_ALERT、TYPE_TOAST、TYPE_SYSTEM_OVERLAY、TYPE_PRIORITY_PHONE、TYPE_SYSTEM_ERROR 这些 type 在 API 26 中均已经过时，使用 TYPE_APPLICATION_OVERLAY 代替，需要申请 Manifest.permission.SYSTEM_ALERT_WINDOW 权限 TYPE_KEYGUARD 已经被从系统中移除，可以使用 TYPE_KEYGUARD_DIALOG 来代替 Window 视图层级顺序是如何确定的？ Window 的参数 x、y，分别表示 Window 左上角的 x 坐标，Window 左上角的 y 坐标，Window 视图层级顺序 用 Z-order 来表示，Z-order 对应着 WindowManager.LayoutParams 的 type 值，Z-order 可以理解为 Android 视图的层级概念，值越大越靠前，就越靠近用户。而 mBaseLayer 和 mSubLayer 决定 z-order 的两个因素 Window 都那些 flag？ Window 的 flag 用于控制 Window 的显示，flag 的参数如下所示： flag 备注 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON 当 Window 可见时允许锁屏 FLAG_DIM_BEHIND Window 后面的内容都变暗 FLAG_BLUR_BEHIND API 已经过时，Window 后面的内容都变模糊 FLAG_NOT_FOCUSABLE Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的，Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL FLAG_NOT_TOUCH_MODAL 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件，Window 之外的 view 也是可以响应 touch 事件 FLAG_NOT_TOUCHABLE 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口 FLAG_KEEP_SCREEN_ON 只要 Window 可见时屏幕就会一直亮着 FLAG_LAYOUT_IN_SCREEN 允许 Window 占满整个屏幕 FLAG_LAYOUT_NO_LIMITS 允许 Window 超过屏幕之外 FLAG_FULLSCREEN 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示 FLAG_FORCE_NOT_FULLSCREEN 表示比FLAG_FULLSCREEN低一级，会显示状态栏 FLAG_IGNORE_CHEEK_PRESSES 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件 FLAG_WATCH_OUTSIDE_TOUCH 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件 FLAG_SHOW_WHEN_LOCKED 已经过时，窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制， 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色 FLAG_SHOW_WALLPAPER 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸 Window 软键盘模式？ Window 的软键盘模式表示 Window 软键盘输入区域的显示模式 model 备注 SOFT_INPUT_STATE_UNCHANGED 不会改变软键盘的状态 SOFT_INPUT_STATE_VISIBLE 当用户进入窗口时，显示软键盘 SOFT_INPUT_STATE_HIDDEN 当用户进入该窗口时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_HIDDEN 当窗口获取焦点时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_VISIBLE 当窗口获取焦点时，显示软键盘 SOFT_INPUT_MASK_ADJUST window 会调整大小以适应软键盘窗口 SOFT_INPUT_ADJUST_UNSPECIFIED 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置 SOFT_INPUT_ADJUST_RESIZE 1. 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方 2. 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用 3. 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏 SOFT_INPUT_ADJUST_PAN 1. 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的 2. 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方 3. 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用 SOFT_INPUT_ADJUST_NOTHING 将不会调整大小，直接覆盖在window上 参考文献 https://developer.android.google.cn/…/WindowManager.LayoutParams https://www.jianshu.com/p/3528255475a2","link":"/2020/06/07/android10/window-manager/07-WindowManagerService/"},{"title":"0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构","text":"0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构 引言 这是 Android 10 源码分析系列的第 6 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 Acivity 和 Dialog 视图解析绑定过程？ Activity 的视图如何与 Window 关联的？ Window 如何与 WindowManager 关联？ Dialog 的视图如何与 Window 关联？ 本文主要分析 Activity、Window、PhoneWindow、WindowManager 之间的关系，为我们后面的文章 「如何在 Andorid 系统里添加自定义View」 等等文章奠定基础，先来了解一下它们的基本概念 Activity：应用视图的容器。 WindowManager：它是一个接口类，继承自接口 ViewManager，对 Window 进行管理 Window：它是一个抽象类，它作为一个顶级视图添加到 WindowManager 中，对 View 进行管理 PhoneWindow：Window唯一实现类，Window是一个抽象概念，添加到WindowManager的根容器 DecorView: 它是 PhoneWindow 内部的一个成员变量，继承自 FrameLayout，FrameLayout 继承自 ViewGroup 在分析他们之前的关系之前，我们先来回顾一下 Acivity 和 Dialog 视图解析绑定的过程 Acivity 和 Dialog 视图解析绑定的过程Acivity 和 Dialog 相关的文章： 0xA03 Android 10 源码分析：APK 加载流程之资源加载 0xA04 Android 10 源码分析：APK 加载流程之资源加载（二） 0xA05 Android 10 源码分析：Dialog 加载绘制流程以及在 Kotlin、DataBinding 中的使用 在之前的文章 分别介绍了 Acivity 和 自定义 Dialog 视图的解析和绑定，总的来说分为三步 调用 LayoutInflater 的 inflate 方法，深度优先遍历解析 View 调用 ViewGroup 的 addView 方法将子 View 添加到根布局中 调用 WindowManager 的 addView 方法添加根布局 LayoutInflater 的 inflate 方法有多个重载的方法，常用的是下面三个参数的方法frameworks/base/core/java/android/view/LayoutInflater.java public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null);} resource：要解析的 xml 布局文件 Id root：表示根布局 attachToRoot：是否要添加到父布局 root 中 resource 其实很好理解就是资源 Id，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 当 View 解析完成之后，最后会调用 WindowManager 的 addView 方法，WindowManager 是一个接口类，继承自接口 ViewManager，用来管理 Window，它的实现类为 WindowManagerImpl，所以调用 WindowManager 的 addView 方法，实际上调用的是 WindowManagerImpl 的 addView 方法frameworks/base/core/java/android/view/WindowManagerImpl.java public final class WindowManagerImpl implements WindowManager { @UnsupportedAppUsage // 单例的设计模式 private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; private final Window mParentWindow; ...... public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); // mGlobal 是 WindowManagerGlobal 的实例 mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); } ...... } mGlobal 是 WindowManagerGlobal 的实例，使用的单例设计模式，参数 mParentWindow 是 Window 的实例，实际上是委托给 WindowManagerGlobal 去实现的 到这里我们关于 Acivity 和 Dialog 视图的解析和添加过程大概介绍完了，关于 Dialog 的视图如何与 Window 绑定在 0xA05 Android 10 源码分析：Dialog 加载绘制流程以及在 Kotlin、DataBinding 中的使用 文章中介绍了，接下来分析一下 Activity、Window、WindowManager 的关系 Activity、Window、WindowManager 的关系在 Activity 内部维护着一个 Window 的实例变量 mWindowframeworks/base/core/java/android/app/Activity.java public class Activity extends ContextThemeWrappe{ private Window mWindow;}``` Window 是一个抽象类，它的具体实现类为 PhoneWindow，在 Activity 的 attach 方法中给 Window 的实例变量 mWindow 赋值**frameworks/base/core/java/android/app/Activity.java** final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { …… mWindow = new PhoneWindow(this, window, activityConfigCallback); ...... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); ......} * 创建了 PhoneWindow 并赋值给 mWindow* 调用 PhoneWindow 的 setWindowManager 方法，这个方法的具体实现发生在 Window 中，最终调用的是 Window 的 setWindowManager 方法**frameworks/base/core/java/android/view/Window.java** public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { …… // mWindowManager 是 WindowManagerImpl的实例变量 mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);} 将 WindowManager 转换为 WindowManagerImpl，之后调用 createLocalWindowManager 方法，并传递当前的 Window 对象，构建 WindowManagerImpl 对象，之后赋值给 mWindowManager**frameworks/base/core/java/android/view/WindowManagerImpl.java** public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mContext, parentWindow);} 其实在 createLocalWindowManager 方法中，就做了一件事，将 Window 作为参数构建了一个 WindowManagerImpl 对象返还给调用处&lt;br/&gt;总的来说，其实就是在 Activity 的 attach 方法中，通过调用 Window 的 setWindowManager 方法将 Window 和 WindowManager 关联在了一起&lt;br/&gt;PhoneWindow 是 Window 的实现类，它是一个窗口，本身并不具备 View 相关的能力，实际上在 PhoneWindow 内部维护这一个变量 mDecor**frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java** public class PhoneWindow extends Window{ // This is the top-level view of the window, containing the window decor. private DecorView mDecor; private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { // 完成DecorView的实例化 mDecor = generateDecor(-1); …… } if (mContentParent == null) { // 调用 generateLayout 方法 要负责了DecorView的初始设置，诸如主题相关的feature、DecorView的背景 mContentParent = generateLayout(mDecor); } ...... } // 完成DecorView的实例化 protected DecorView generateDecor(int featureId) { ...... return new DecorView(context, featureId, this, getAttributes()); } // 调用 generateLayout 方法 要负责了DecorView的初始设置， // 诸如主题相关的feature、DecorView的背景，同时也初始化 contentParent protected ViewGroup generateLayout(DecorView decor) { ...... ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ...... }} * mDecor 是 window 的顶级视图，它继承自 FrameLayout，它的创建过程由 installDecor 完成，然后在 installDecor 方法中通过 generateDecor 方法来完成DecorView的实例化* 调用 generateLayout 方法 要负责了DecorView的初始设置，诸如主题相关的feature、DecorView的背景，同时也初始化 contentParent* mDecor 它实际上是一个 ViewGroup，当在 Activity 中调用 setContentView 方法，通过调用 inflater 方法把布局资源转换为一个 View，然后添加到 DecorView 的 mContenParnent 中当 View 初始化完成之后，最后会进入 ActivityThread 的 handlerResumeActivity 方法，执行了r.activity.makeVisible()方法**frameworks/base/core/java/android/app/ActivityThread.java** public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { …… if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } ...... }最终调用 Activity 的 makeVisible 方法，把 decorView 添加到 WindowManage 中**frameworks/base/core/java/android/app/Activity.java** void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE);} 到这里他们之间的关系明确了：* 一个 Activity 持有一个 PhoneWindow 的对象，而一个 PhoneWindow 对象持有一个 DecorView 的实例* PhoneWindow 继承自 Window，一个 Window 对象内部持有 mWindowManager 的实例，通过调用 setWindowManager 方法与 WindowManager 关联在一起* WindowManager 继承自 ViewManager，WindowManagerImpl 是 WindowManager 接口的实现类，但是具体的功能都会委托给 WindowManagerGlobal 来实现* 调用 WindowManager 的 addView 方法，实际上调用的是 WindowManagerImpl 的 addView 方法## 总结#### Acivity 和 Dialog 视图解析绑定过程？* 1. 调用 LayoutInflater 的 inflate 方法，深度优先遍历解析 View* 2. 调用 ViewGroup 的 addView 方法将子 View 添加到根布局中* 3. 调用 WindowManager 的 addView 方法添加根布局#### Activity 的视图如何与 Window 关联的？* 在 Activity 内部维护着一个 Window 的实例变量 mWindow**frameworks/base/core/java/android/app/Activity.java** public class Activity extends ContextThemeWrappe{ private Window mWindow;} * 最后调用 Activity 的 makeVisible 方法，把 decorView 添加到 WindowManage 中**frameworks/base/core/java/android/app/Activity.java** void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE);} #### Window 如何与 WindowManager 关联？在 Activity 的 attach 方法中，调用 PhoneWindow 的 setWindowManager 方法，这个方法的具体实现发生在 Window 中，最终调用的是 Window 的 setWindowManager 方法，将 Window 和 WindowManager 关联在了一起**frameworks/base/core/java/android/view/Window.java** public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { …… // mWindowManager 是 WindowManagerImpl的实例变量 mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);} #### Dialog 的视图如何与 Window 关联？* 在 Dialog 的构造方法中初始化了 Window 对象 **frameworks/base/core/java/android/app/Dialog.java** Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { … // 获取WindowManager对象 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 构建PhoneWindow final Window w = new PhoneWindow(mContext); // mWindow 是PhoneWindow实例 mWindow = w; …} * 调用 Dialog 的 show 方法，完成 view 的绘制和 Dialog 的显示**frameworks/base/core/java/android/app/Dialog.java** public void show() { // 获取DecorView mDecor = mWindow.getDecorView(); // 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); // 将DecorView和布局参数添加到WindowManager中 mWindowManager.addView(mDecor, l);} ## 参考文献 * [http://liuwangshu.cn/framework/wm/1-windowmanager.html](http://liuwangshu.cn/framework/wm/1-windowmanager.html) * [https://gudong.site/2017/05/08/activity-windown-decorview.html](https://gudong.site/2017/05/08/activity-windown-decorview.html)","link":"/2020/06/07/android10/window-manager/06-Window-WindowManager/"},{"title":"0xA05 Android 10 源码分析：Dialog加载绘制流程以及在Kotlin、DataBinding中的使用","text":"引言 这是 Android 10 源码分析系列的第 5 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 Dialog的的创建流程？ Dialog的视图怎么与Window做关联了？ 自定义CustomDialog的view的是如何绑定的? 如何使用Kotlin具名可选参数构造类，实现构建者模式？ 相比于Java的构建者模式，通过具名可选参数构造类具有以下优点? 如何在Dialog中使用DataBinding？ 阅读本文之前，如果之前没有看过 Apk加载流程之资源加载一 和 Apk加载流程之资源加载二 点击下方链接前去查看，这几篇文章都是互相关联的 0xA03 Android 10 源码分析：Apk加载流程之资源加载（一） 0xA04 Android 10 源码分析：Apk加载流程之资源加载（二） 本文主要来主要围绕以下几个方面来分析: Dialog加载绘制流程 如何使用Kotlin具名可选参数构造类，实现构建者模式 如何在Dialog中使用DataBinding 源码分析在开始分析Dialog的源码之前，需要了解一下Dialog加载绘制流程，涉及到的数据结构与职能 在包 android.app 下： Dialog：Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑 AlertDialog：继承自Dialog，是具体的Dialog的操作实现类 AlertDialog.Builder：是AlertDialog的内部类，主要用于构造AlertDialog AlertController：是AlertDialog的控制类 AlertController.AlertParams：是AlertController的内部类，负责AlertDialog的初始化参数 了解完相关的数据结构与职能，接下来回顾一下Dialog的创建流程 AlertDialog.Builder builder = new AlertDialog.Builder(this);builder.setIcon(R.mipmap.ic_launcher);builder.setMessage(&quot;Message部分&quot;);builder.setTitle(&quot;Title部分&quot;);builder.setView(R.layout.activity_main);builder.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); }});builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); }});alertDialog = builder.create();alertDialog.show(); 上面代码都不会很陌生，主要使用了设计模式当中-构建者模式， 构建AlertDialog.Builder对象 builder.setXXX 系列方法完成Dialog的初始化 调用builder.create()方法创建AlertDialog 调用AlertDialog的show()完成View的绘制并显示AlertDialog 主要通过上面四步完成Dialog的创建和显示，接下来根据源码来分析每个方法的具体实现，以及Dialog的视图怎么与Window做关联 1 构建AlertDialog.Builder对象AlertDialog.Builder builder = new AlertDialog.Builder(this); AlertDialog.Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法frameworks/base/core/java/android/app/AlertDialog.java // AlertController.AlertParams类型的成员变量private final AlertController.AlertParams P;public Builder(Context context) { this(context, resolveDialogTheme(context, Resources.ID_NULL));}public Builder(Context context, int themeResId) { // 构造ContextThemeWrapper，ContextThemeWrapper 是 Context的子类，主要用来处理和主题相关的 // 初始化成为变量 P P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId)));} ContextThemeWrapper 继承自ContextWrapper，Application、Service继承自ContextWrapper，Activity继承自ContextThemeWrapper P是AlertDialog.Builder中的AlertController.AlertParams类型的成员变量 AlertParams中包含了与AlertDialog视图中对应的成员变量，调用builder.setXXX系列方法之后，我们传递的参数就保存在P中了 1.1 AlertParams封装了初始化参数AlertController.AlertParams 是AlertController的内部类，负责AlertDialog的初始化参数frameworks/base/core/java/com/android/internal/app/AlertController.java public AlertParams(Context context) {mContext = context;// mCancelable 用来控制点击外部是否可取消，默认可以取消mCancelable = true;// LayoutInflater 主要来解析layout.xml文件mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);} 主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量，LayoutInflater 主要来解析layout.xml文件，关于LayoutInflater可以参考之前的文章0xA04 Android 10 源码分析：Apk加载流程之资源加载（二） 初始化完成AlertParams之后，就完成了AlertDialog.Builder的构建 2 调用AlertDialog.Builder的setXXX系列方法AlertDialog.Builder初始化完成之后，调用它的builder.setXXX 系列方法完成Dialog的初始化frameworks/base/core/java/android/app/AlertDialog.java // ... 省略了很多builder.setXXX方法public Builder setTitle(@StringRes int titleId) { P.mTitle = P.mContext.getText(titleId); return this;}public Builder setMessage(@StringRes int messageId) { P.mMessage = P.mContext.getText(messageId); return this;}public Builder setPositiveButton(@StringRes int textId, final OnClickListener listener) { P.mPositiveButtonText = P.mContext.getText(textId); P.mPositiveButtonListener = listener; return this;}public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this;}// ... 省略了很多builder.setXXX方法 上面所有setXXX方法都是给Builder的成员变量P赋值，并且他们的返回值都是Builder类型，因此可以通过消息琏的方式调用 builder.setTitle().setMessage().setPositiveButton()... PS: 在Kotlin应该尽量避免使用构建者模式，使用Kotlin中的具名可选参数，实现构建者模式，代码更加简洁，为了不影响阅读的流畅性，将这部分内容放到了文末扩展阅读部分 3 builder.create方法builder.setXXX 系列方法之后调用builder.create方法完成AlertDialog构建，接下来看一下create方法frameworks/base/core/java/android/app/AlertDialog.java public AlertDialog create() { // P.mContext 是ContextWrappedTheme 的实例 final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); // Dialog的参数其实保存在P这个类里面 // mAler是AlertController的实例，通过这个方法把P中的变量传给AlertController.AlertParams P.apply(dialog.mAlert); // 用来控制点击外部是否可取消,mCancelable 默认为true dialog.setCancelable(P.mCancelable); // 如果可以取消设置回调监听 if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } // 设置一系列监听 dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } // 返回 AlertDialog 对象 return dialog;} 根据P.mContex 构建了一个AlertDialog mAler是AlertController的实例，调用apply方法把P中的变量传给AlertController.AlertParams 设置是否可以点击外部取消，默认可以取消，同时设置回调监听 最后返回AlertDialog对象 3.1 如何构建AlertDialog我们来分析一下AlertDialog是如何构建的，来看一下它的造方法具体实现frameworks/base/core/java/android/app/AlertDialog.java AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); // getContext() 返回的是ContextWrapperTheme // getWindow() 返回的是 PhoneWindow // mAlert 是AlertController的实例 mAlert = AlertController.create(getContext(), this, getWindow());} PhoneWindows是什么时候创建的？AlertDialog继承自Dialog，首先调用了super的构造方法，来看一下Dialog的构造方法frameworks/base/core/java/android/app/Dialog.java Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { ... // 获取WindowManager对象 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 构建PhoneWindow final Window w = new PhoneWindow(mContext); // mWindow 是PhoneWindow实例 mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setOnWindowSwipeDismissedCallback(() -&gt; { if (mCancelable) { cancel(); } }); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); // 继承 Handler mListenersHandler = new ListenersHandler(this);} 获取WindowManager对象，构建了PhoneWindow，到这里我们知道了PhoneWindow是在Dialog构造方法创建的 初始化了Dialog的成员变量mWindow，mWindow 是PhoneWindow的实例 初始化了Dialog的成员变量mListenersHandler，mListenersHandler继承Handler 我们回到AlertDialog构造方法，在AlertDialog构造方法内，调用了 AlertController.create方法，来看一下这个方法 public static final AlertController create(Context context, DialogInterface di, Window window) { final TypedArray a = context.obtainStyledAttributes( null, R.styleable.AlertDialog, R.attr.alertDialogStyle, R.style.Theme_DeviceDefault_Settings); int controllerType = a.getInt(R.styleable.AlertDialog_controllerType, 0); a.recycle(); // 根据controllerType 使用不同的AlertController switch (controllerType) { case MICRO: // MicroAlertController 是matrix风格 继承自AlertController return new MicroAlertController(context, di, window); default: return new AlertController(context, di, window); }} 根据controllerType 返回不同的AlertController，到这里分析完了AlertDialog是如何构建的 4 调用Dialog的show方法显示Dialog调用AlertDialog.Builder的create方法之后返回了AlertDialog的实例，最后调用了AlertDialog的show方法显示dialog，但是AlertDialog是继承自Dialog的，实际上调用的是Dialog的show方法frameworks/base/core/java/android/app/Dialog.java public void show() { // mShowing变量用于表示当前dialog是否正在显示 if (mShowing) { if (mDecor != null) { if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); } mDecor.setVisibility(View.VISIBLE); } return; } mCanceled = false; // mCreated这个变量控制dispatchOnCreate方法只被执行一次 if (!mCreated) { dispatchOnCreate(null); } else { // Fill the DecorView in on any configuration changes that // may have occured while it was removed from the WindowManager. final Configuration config = mContext.getResources().getConfiguration(); mWindow.getDecorView().dispatchConfigurationChanged(config); } // 用于设置ActionBar onStart(); // 获取DecorView mDecor = mWindow.getDecorView(); if (mActionBar == null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { final ApplicationInfo info = mContext.getApplicationInfo(); mWindow.setDefaultIcon(info.icon); mWindow.setDefaultLogo(info.logo); mActionBar = new WindowDecorActionBar(this); } // 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); boolean restoreSoftInputMode = false; if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) { l.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; restoreSoftInputMode = true; } // 将DecorView和布局参数添加到WindowManager中，完成view的绘制 mWindowManager.addView(mDecor, l); if (restoreSoftInputMode) { l.softInputMode &amp;= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; } mShowing = true; // 向Handler发送一个Dialog的消息，从而显示AlertDialog sendShowMessage();} 判断dialog是否已经显示，如果显示了直接返回 判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法 获取布局参数添加到WindowManager，调用addView方法完成view的绘制 向Handler发送一个Dialog的消息，从而显示AlertDialog 4.1 dispatchOnCreate在上面代码中，根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法frameworks/base/core/java/android/app/Dialog.java void dispatchOnCreate(Bundle savedInstanceState) { if (!mCreated) { // 调用 onCreate 方法 onCreate(savedInstanceState); mCreated = true; }} 在dispatchOnCreate方法中主要调用Dialog的onCreate方法, Dialog的onCreate方法是个空方法，由于我们创建的是AlertDialog对象，AlertDialog继承于Dialog，所以调用的是AlertDialog的onCreate方法frameworks/base/core/java/android/app/AlertDialog.java protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mAlert.installContent();} 在这方法里面调用了AlertController的installContent方法，来看一下具体的实现逻辑frameworks/base/core/java/com/android/internal/app/AlertController.java public void installContent() { // 获取相应的Dialog布局文件 int contentView = selectContentView(); // 调用setContentView方法解析布局文件 mWindow.setContentView(contentView); // 初始化布局文件中的组件 setupView();} 调用selectContentView方法获取布局文件，来看一下具体的实现 frameworks/base/core/java/com/android/internal/app/AlertController.java* private int selectContentView() { if (mButtonPanelSideLayout == 0) { return mAlertDialogLayout; } if (mButtonPanelLayoutHint == AlertDialog.LAYOUT_HINT_SIDE) { return mButtonPanelSideLayout; } return mAlertDialogLayout;} 返回的布局是mAlertDialogLayout，布局文件是在AlertController的构造方法初始化的frameworks/base/core/java/com/android/internal/app/AlertController.java mAlertDialogLayout = a.getResourceId( R.styleable.AlertDialog_layout, R.layout.alert_dialog); 调用Window.setContentView方法解析布局文件，Activity的setContentView最后也是调用了Window.setContentView这个方法，具体的解析流程，可以参考之前的文章Activity布局加载流程 0xA03 Android 10 源码分析：Apk加载流程之资源加载 调用setupView方法初始化布局文件中的组件, 到这里dispatchOnCreate方法分析结束 4.2 调用mWindowManager.addView完成View的绘制回到我们的Dialog的show方法，在执行了dispatchOnCreate方法之后，又调用了onStart方法，这个方法主要用于设置ActionBar，然后初始化WindowManager.LayoutParams对象，最后调用mWindowManager.addView()方法完成界面的绘制，绘制完成之后调用sendShowMessage方法frameworks/base/core/java/android/app/Dialog.java private void sendShowMessage() { if (mShowMessage != null) { // Obtain a new message so this dialog can be re-used Message.obtain(mShowMessage).sendToTarget(); }} 向Handler发送一个Dialog的消息，从而显示AlertDialog，该消息最终会在ListenersHandler中的handleMessage方法中被执行，ListenersHandler是Dialog的内部类，继承Handlerframeworks/base/core/java/android/app/Dialog.java public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; }} 如果msg.what = SHOW，会执行OnShowListener.onShow方法，msg.what的值和OnShowListener调用setOnShowListener方法赋值的frameworks/base/core/java/android/app/Dialog.java public void setOnShowListener(@Nullable OnShowListener listener) { if (listener != null) { mShowMessage = mListenersHandler.obtainMessage(SHOW, listener); } else { mShowMessage = null; }} mListenersHandler构造了Message对象，当我们在Dialog中发送showMessage的时候，被mListenersHandler所接收 4.3 自定义Dialog的view的是如何绑定的在上文分析中根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法，在dispatchOnCreate方法中主要调用Dialog的onCreate方法，由于创建的是AlertDialog对象，AlertDialog继承于Dialog，所以实际调用的是AlertDialog的onCreate方法，来完成布局文件的解析，和布局文件中控件的初始化 同理我们自定义CustomDialog继承自Dialog，所以调用的是自定义CustomDialog的onCreate方法，代码如下 public class CustomDialog extends Dialog { Context mContext; // ... 省略构造方法 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); LayoutInflater inflater = (LayoutInflater) mContext .getSystemService(Context.LAYOUT_INFLATER_SERVICE); View view = inflater.inflate(R.layout.custom_dialog, null); setContentView(view); }} 在onCreate方法中调用了 Dialog的setContentView 方法, 来分析setContentView方法frameworks/base/core/java/android/app/Dialog.java public void setContentView(@NonNull View view) { mWindow.setContentView(view);} mWindow是PhoneWindow的实例，最后调用的是PhoneWindow的setContentView解析布局文件，Activity的setContentView最后也是调用了PhoneWindow的setContentView方法，具体的解析流程，可以参考之前的文章Activity布局加载流程 0xA03 Android 10 源码分析：Apk加载流程之资源加载 总结Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑 Dialog的的创建流程？ 构建AlertDialog.Builder对象 builder.setXXX 系列方法完成Dialog的初始化 调用builder.create()方法创建AlertDialog 调用AlertDialog的show()初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，最终将Dialog显示出来 Dialog的视图怎么与Window做关联了？ 在Dialog的构造方法中初始化了Window对象 Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { ... // 获取WindowManager对象 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 构建PhoneWindow final Window w = new PhoneWindow(mContext); // mWindow 是PhoneWindow实例 mWindow = w; ...} 调用Dialog的show方法，完成view的绘制和Dialog的显示 public void show() { // 获取DecorView mDecor = mWindow.getDecorView(); // 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); // 将DecorView和布局参数添加到WindowManager中 mWindowManager.addView(mDecor, l);} 最终会通过WindowManager将DecorView添加到Window之中，用WIndow对象实现界面的加载与显示逻辑 自定义CustomDialog的view的是如何绑定的? 调用Dialog的show方法，在该方法内部会根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法，在dispatchOnCreate方法中主要调用Dialog的onCreate方法 自定义CustomDialog继承自Dialog，所以调用的是自定义CustomDialog的onCreate方法，在CustomDialog的onCreate方法中调用setContentView方法，最后调用的是PhoneWindow的setContentView解析布局文件，解析流程参考0xA03 Android 10 源码分析：Apk加载流程之资源加载 如何使用Kotlin具名可选参数构造类，实现构建者模式？ 这部分内容参考扩展阅读部分 相比于Java的构建者模式，通过具名可选参数构造类具有以下优点? 代码非常的简洁 每个参数名都可以显示的，声明对象时无须按照顺序书写，非常的灵活 构造函数中每个参数都是val声明的，在多线程并发业务场景中更加的安全 Kotlin的require方法，让我们在参数约束上更加的友好 如何在Dialog中使用DataBinding？ 这部分内容参考扩展阅读部分 扩展阅读1. Kotlin实现构建者模式刚才在上文中提到了，在Kotlin中应该尽量避免使用构建者模式，使用Kotlin的具名可选参数构造类，实现构建者模式，代码更加简洁 在 “Effective Java” 书中介绍构建者模式时，是这样子描述它的：本质上builder模式模拟了具名的可算参数，就像Ada和Python中的一样 关于Java用构建者模式实现自定义dialog，可以参考这边文章 Builder Pattern in Java，代码显得很长……..幸运的是，Kotlin是一门拥有具名可选参数的变成语言，Kotlin中的函数和构造器都支持这一特性，接下里我们使用具名可选参数构造类，实现构建者模式，点击JDataBinding前往查看，核心代码如下： class AppDialog( context: Context, val title: String? = null, val message: String? = null, val yes: AppDialog.() -&gt; Unit) : DataBindingDialog(context, R.style.AppDialog) { init { requireNotNull(message) { &quot;message must be not null&quot; } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) requestWindowFeature(Window.FEATURE_NO_TITLE) setContentView(root) display.text = message btnNo.setOnClickListener { dismiss() } btnYes.setOnClickListener { yes() } }} 调用方式也更加的简单 AppDialog( context = this@MainActivity, message = msg, yes = { // do something }).show() 相比于Java的构建者模式，通过具名可选参数构造类具有以下优点: 代码非常的简洁 每个参数名都可以显示的，声明对象时无须按照顺序书写，非常的灵活 构造函数中每个参数都是val声明的，在多线程并发业务场景中更加的安全 Kotlin的require方法，让我们在参数约束上更加的友好 2. 如何在Dialog中使用DataBindingDataBinding是什么？查看Google官网，会有更详细的介绍 DataBinding 是 Google 在 Jetpack 中推出的一款数据绑定的支持库，利用该库可以实现在页面组件中直接绑定应用程序的数据源 在使用Kotlin的具名可选参数构造类实现Dailog构建者模式的基础上，用DataBinding进行二次封装，加上DataBinding数据绑定的特性，使Dialog变得更加简洁、易用 Step1: 定义一个基类DataBindingDialog abstract class DataBindingDialog(@NonNull context: Context, @StyleRes themeResId: Int) : Dialog(context, themeResId) { protected inline fun &lt;reified T : ViewDataBinding&gt; binding(@LayoutRes resId: Int): Lazy&lt;T&gt; = lazy { requireNotNull( DataBindingUtil.bind&lt;T&gt;(LayoutInflater.from(context).inflate(resId, null)) ) { &quot;cannot find the matched view to layout.&quot; } }} Step2: 改造AppDialog class AppDialog( context: Context, val title: String? = null, val message: String? = null, val yes: AppDialog.() -&gt; Unit) : DataBindingDialog(context, R.style.AppDialog) { private val mBinding: DialogAppBinding by binding(R.layout.dialog_app) init { requireNotNull(message) { &quot;message must be not null&quot; } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) requestWindowFeature(Window.FEATURE_NO_TITLE) mBinding.apply { setContentView(root) display.text = message btnNo.setOnClickListener { dismiss() } btnYes.setOnClickListener { yes() } } }} 同理DataBinding在Activity、Fragment、Adapter中的使用也是一样的，利用Kotlin的inline、reified、DSL等等语法，可以设计出更加简洁并利于维护的代码 关于基于DataBinding封装的DataBindingActivity、DataBindingFragment、DataBindingDialog基础库相关代码，后续也会陆续完善基础库，点击JDataBinding前往查看，欢迎start","link":"/2020/06/07/android10/window-manager/05-Dialog/"},{"title":"0xA04 Android 10 源码分析：Apk加载流程之资源加载（二）","text":"引言 这是 Android 10 源码分析系列的第 4 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 通过这篇文章你将学习到以下内容，将在文末会给出相应的答案 View 中的 INVISIBLE、VISIBLE、GONE 都有什么作用？ 为什么 ViewStub 是大小为0的视图 ViewStub 有什么作用？ ViewStub 是如何创建的？ 为什么 ViewStub 能做到延迟加载？ ViewStub 指定的 Layout 布局文件是什么时候被加载的？ LayoutInflater 是一个抽象类它如何被创建的？ 系统服务存储在哪里？如何获取和添加系统服务？ 在上一篇文章 0xA02 Android 10 源码分析：APK 加载流程之资源加载 中通过 LayoutInflater.inflate 方法解析 XML 文件，了解到了系统如何对 merge、include 标签是如何处理的，本文主要围绕以下两方面内容 系统对 ViewStub 如何处理？ LayoutInflater 是如何被创建的？ 系统对 merge、include 是如何处理的 使用 merge 标签必须有父布局，且依赖于父布局加载 merge 并不是一个 ViewGroup，也不是一个 View，它相当于声明了一些视图，等待被添加，解析过程中遇到 merge 标签会将 merge 标签下面的所有子 view 添加到根布局中 merge 标签在 XML 中必须是根元素 相反的 include 不能作为根元素，需要放在一个 ViewGroup 中 使用 include 标签必须指定有效的 layout 属性 使用 include 标签不写宽高是没有关系的，会去解析被 include 的 layout merge 标签为什么可以起到优化布局的效果？ 解析过程中遇到 merge 标签，会调用 rInflate 方法，部分代码如下 // 根据元素名解析，生成对应的viewfinal View view = createViewFromTag(parent, name, context, attrs);final ViewGroup viewGroup = (ViewGroup) parent;final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子viewrInflateChildren(parser, view, attrs, true);// 添加解析的viewviewGroup.addView(view, params); 解析 merge 标签下面的所有子 view，然后添加到根布局中更多信息查看0xA02 Android 10 源码分析：APK 加载流程之资源加载，接下来看一下系统对 ViewStub 如何处理 1. ViewStub是什么关于 ViewStub 的介绍，可以点击下方官网链接查看官网链接https://developer.android.google.cn/reference/android…ViewStub ViewStub 的继承结构 简单来说主要以下几点： ViewStub 控件是一个不可见， 大小为 0 的视图 当 ViewStub 控件设置可见，或者调用 inflate() 方法，ViewStub 所指定的 layout 资源就会被加载 ViewStub 也会从其父控件中移除，ViewStub 会被新加载的 layout 文件代替 为什么 ViewStub 是大小为 0 的视图frameworks/base/core/java/android/view/ViewStub.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // 设置视图大小为0 setMeasuredDimension(0, 0);} ViewStub 的作用 主要用来延迟布局的加载，例如：在 Android 中非常常见的布局，用 ListView 来展示列表信息，当没有数据或者网络加载失败时, 加载空的 ListView 会占用一些资源，如果用 ViewStub 包裹 ListView，当有数据时，才会调用 inflate() 方法显示 ListView，起到延迟加载了布局效果 1.1 ViewStub 是如何被创建的在上篇文章 0xA02 Android 10 源码分析：APK 加载流程之资源加载 中，介绍了 View 的创建是通过调用了 LayoutInflater.createView 方法根据完整的类的路径名利用反射机制构建 View 对象，因为 ViewStub 是继承 View，所以 ViewStub 的创建和 View 的创建是相同的，来看一下 LayoutInflater.createView 方法frameworks/base/core/java/android/view/LayoutInflater.java ...try { // 利用构造函数，创建View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // 如果是ViewStub，则设置LayoutInflater final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view;} finally { mConstructorArgs[0] = lastContext;}... 根据完整的类的路径名利用反射机制构建 View 对象，如果遇到 ViewStub 将当前 LayoutInflater 设置给 ViewStub，当 ViewStub 控件设置可见，或者调用 inflate()，会调用 LayoutInflater 的 inflate 方法完成布局加载，接下来分析 ViewStub 的构造方法 1.2 ViewStub 的构造方法在上面提到了根据完整的类的路径名利用反射机制构建 View 对象，当 View 对象被创建的时候，会调用它的构造函数，来看一下 ViewStub 的构造方法 public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); saveAttributeDataForStyleable(context, R.styleable.ViewStub, attrs, a, defStyleAttr, defStyleRes); // 解析xml中设置的 android:inflatedId 的属性 mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); // 解析xml中设置的 android:layout 属性 mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); // 解析xml中设置的 android:id 属性 mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); // view不可见 setVisibility(GONE); // 不会调用 onDraw 方法绘制内容 setWillNotDraw(true);} 获取 android:inflatedId、android:layout、android:id 的值 调用 setVisibility 方法，设置 View 不可见 调用 setWillNotDraw 方法，不会调用 onDraw 方法绘制内容 在上面提到了如果想要加载 ViewStub 所指定的 layout 资源，需要设置 ViewStub 控件设置可见，或者调用 inflate() 方法，来看一下 ViewStub 的 setVisibility 方法 1.3 ViewStub 的 setVisibility 方法setVisibility(int visibility) 方法，参数 visibility 对应三个值分别是 INVISIBLE、VISIBLE、GONE VISIBLE：视图可见 INVISIBLE：视图不可见的，它仍然占用布局的空间 GONE：视图不可见，它不占用布局的空间 接下里查看一下 ViewStub 的 setVisibility 方法frameworks/base/core/java/android/view/ViewStub.java @Overridepublic void setVisibility(int visibility) { if (mInflatedViewRef != null) { // mInflatedViewRef 是 WeakReference的实例，调用inflate方法时候初始化 View view = mInflatedViewRef.get(); if (view != null) { // 设置View可见 view.setVisibility(visibility); } else { throw new IllegalStateException(&quot;setVisibility called on un-referenced view&quot;); } } else { super.setVisibility(visibility); // 当View为空且设置视图可见(VISIBLE、INVISIBLE)，调用inflate方法 if (visibility == VISIBLE || visibility == INVISIBLE) { inflate(); } }} mInflatedViewRef 是 WeakReference 的实例，调用 inflate 方法时候初始化 从 mInflatedViewRef 缓存中获取 View，并且设置 View 可见 当 View 为空且设置视图可见(VISIBLE、INVISIBLE)，会调用 inflate方法 1.4 ViewStub.inflate 方法调用了 ViewStub 的 setVisibility 方法，最后都会调用 ViewStub.inflate 方法，来查看一下frameworks/base/core/java/android/view/ViewStub.java public View inflate() { final ViewParent viewParent = getParent(); if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) { if (mLayoutResource != 0) { final ViewGroup parent = (ViewGroup) viewParent; // 解析布局视图 // 返回的view是android:layout指定的布局文件最顶层的view final View view = inflateViewNoAdd(parent); // 移除ViewStub // 添加view到被移除的ViewStub的位置 replaceSelfWithView(view, parent); // 添加view到 mInflatedViewRef 中 mInflatedViewRef = new WeakReference&lt;&gt;(view); if (mInflateListener != null) { // 加载完成之后，回调onInflate 方法 mInflateListener.onInflate(this, view); } return view; } else { // 需要在xml中设置android:layout，不是layout，否则会抛出异常 throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); } } else { // ViewStub不能作为根布局，它需要放在ViewGroup中, 否则会抛出异常 throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); }} 调用 inflateViewNoAdd 方法返回 android:layout 指定的布局文件最顶层的 View 调用 replaceSelfWithView 方法, 移除 ViewStub, 添加 View 到被移除的 ViewStub 的位置 添加 View 到 mInflatedViewRef 中 加载完成之后，回调 onInflate 方法 需要注意以下两点： 使用 ViewStub 需要在 XML 中设置 android:layout，不是 layout，否则会抛出异常 ViewStub 不能作为根布局，它需要放在 ViewGroup 中, 否则会抛出异常 来查看一下 inflateViewNoAdd 方法和 replaceSelfWithView 方法 1.5 ViewStub.inflateViewNoAdd 方法调用 inflateViewNoAdd 方法返回 android:layout 指定的布局文件最顶层的 Viewframeworks/base/core/java/android/view/ViewStub.java private View inflateViewNoAdd(ViewGroup parent) { final LayoutInflater factory; // mInflater 是View被创建的时候，如果是ViewStub, 将LayoutInflater赋值给mInflater if (mInflater != null) { factory = mInflater; } else { // 如果mInflater为空，则创建LayoutInflater factory = LayoutInflater.from(mContext); } // 从指定的 mLayoutResource 资源中解析布局视图 // mLayoutResource 是在xml设置的 Android:layout 指定的布局文件 final View view = factory.inflate(mLayoutResource, parent, false); // mInflatedId 是在xml设置的 inflateId if (mInflatedId != NO_ID) { // 将id复制给view view.setId(mInflatedId); //注意：如果指定了mInflatedId , 被inflate的layoutView的id就是mInflatedId } return view;} mInflater 是 View 被创建的时候，如果是 ViewStub, 将 LayoutInflater 赋值给 mInflater 如果 mInflater 为空则通过 LayoutInflater.from(mContext) 构建 LayoutInflater 调用 LayoutInflater 的 inflate 方法解析布局视图 将 mInflatedId 设置 View 1.6 ViewStub.replaceSelfWithView 方法调用 replaceSelfWithView 方法, 移除 ViewStub, 添加 View 到被移除的 ViewStub 的位置frameworks/base/core/java/android/view/ViewStub.java private void replaceSelfWithView(View view, ViewGroup parent) { // 获取ViewStub在视图中的位置 final int index = parent.indexOfChild(this); // 移除ViewStub // 注意：调用removeViewInLayout方法之后，调用findViewById()是找不到该ViewStub对象 parent.removeViewInLayout(this); final ViewGroup.LayoutParams layoutParams = getLayoutParams(); // 将xml中指定的 android:layout 布局文件中最顶层的View，添加到被移除的 ViewStub的位置 if (layoutParams != null) { parent.addView(view, index, layoutParams); } else { parent.addView(view, index); }} 获取 ViewStub 在视图中的位置，然后移除 ViewStub 添加 android:layout 布局文件中最顶层的 View 到被移除的 ViewStub 的位置 1.7 ViewStub 的注意事项 使用 ViewStub 需要在 XML 中设置 android:layout，不是 layout，否则会抛出异常 throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); ViewStub 不能作为根布局，它需要放在 ViewGroup 中, 否则会抛出异常 throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); 一旦调用 setVisibility(View.VISIBLE) 或者 inflate() 方法之后，该 ViewStub 将会从试图中被移除（此时调用 findViewById() 是找不到该 ViewStub 对象). // 获取ViewStub在视图中的位置final int index = parent.indexOfChild(this);// 移除ViewStub// 注意：调用removeViewInLayout方法之后，调用findViewById()是找不到该ViewStub对象parent.removeViewInLayout(this); 如果指定了 mInflatedId , 被 inflate 的 layoutView 的 id 就是 mInflatedId // mInflatedId 是在xml设置的 inflateIdif (mInflatedId != NO_ID) { // 将id复制给view view.setId(mInflatedId); //注意：如果指定了mInflatedId , 被inflate的layoutView的id就是mInflatedId} 被 inflate 的 layoutView 的 layoutParams 与 ViewStub 的 layoutParams 相同. final ViewGroup.LayoutParams layoutParams = getLayoutParams();// 将xml中指定的 android:layout 布局文件中最顶层的View 也就是根view，// 添加到被移除的 ViewStub的位置if (layoutParams != null) { parent.addView(view, index, layoutParams);} else { parent.addView(view, index);} 到这里关于 ViewStub 的构建、布局的加载以及注意事项分析完了，接下来分析一下 LayoutInflater 是如何被创建的 2 关于LayoutInflater在 0xA02 Android 10 源码分析：APK 加载流程之资源加载 文章中，介绍了 Activity 启动的时候通过调用 LayoutInflater 的 inflater 的方法加载 layout 文件，那么 LayoutInflater 是如何被创建的呢，先来看一段代码，相信下面的代码都不会很陌生 public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) { return new AllVh(LayoutInflater .from(viewGroup.getContext()) .inflate(R.layout.list_item, viewGroup, false));} LayoutInflater的inflate方法的三个参数都代表什么意思？ resource：要解析的 XML 布局文件 Id root：表示根布局 attachToRoot：是否要添加到父布局 root中 resource 其实很好理解就是资源 Id，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该View中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 2.1 LayoutInflater 是如何被创建的LayoutInflater 是一个抽象类，通过调用了 from() 的静态函数，经由系统服务 LAYOUT_INFLATER_SERVICE，最终创建了一个 LayoutInflater 的子类对象 PhoneLayoutInflater，继承结构如下： LayoutInflater.from(ctx) 就是根据传递过来的 Context 对象，调用 getSystemService() 来获取对应的系统服务, 来看一下这个方法frameworks/base/core/java/android/view/LayoutInflater.java public static LayoutInflater from(Context context) { // 获取系统服务 LAYOUT_INFLATER_SERVICE ，并赋值给 LayoutInflater // Context 是一个抽象类，真正的实现类是ContextImpl LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) { throw new AssertionError(&quot;LayoutInflater not found.&quot;); } return LayoutInflater;} 而 Context 本身是一个抽象类，它真正的实例化对象是 ContextImplframeworks/base/core/java/android/app/ContextImpl.java public Object getSystemService(String name) { // SystemServiceRegistry 是管理系统服务的 // 调用getSystemService方法，通过服务名字查找对应的服务 return SystemServiceRegistry.getSystemService(this, name);} 2.2 SystemServiceRegistrySystemServiceRegistry 管理所有的系统服务，调用 getSystemService 方法，通过服务名字查找对应的服务frameworks/base/core/java/android/app/SystemServiceRegistry.java public static Object getSystemService(ContextImpl ctx, String name) { // SYSTEM_SERVICE_FETCHERS 是一个map集合 // 从 map 集合中取出系统服务 ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;} ServiceFetcher 为 SystemServiceRegistry 类的静态内部接口，定义了 getService 方法 ServiceFetcher 的实现类 CachedServiceFetcher 实现了 getService方法 所有的系统服务都存储在一个 map 集合 SYSTEM_SERVICE_FETCHERS当 中，调用 get 方法来获取对应的服务 如果有 getSystemService 方法来获取服务，那么相应的也会有添加服务的方法frameworks/base/core/java/android/app/SystemServiceRegistry.java private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass, ServiceFetcher&lt;T&gt; serviceFetcher) { SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);} 通过调用 SYSTEM_SERVICE_NAMES 的 put 方法，往 map 集合中添加数据，那么 registerService 是什么时候调用的，在 SystemServiceRegistry 类中搜索 registerService 方法，知道了在类加载的时候通过静态代码块中添加的，来看一下 static { // 初始化加载所有的系统服务 ... // 省略了很多系统服务 registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() { @Override public LayoutInflater createService(ContextImpl ctx) { return new PhoneLayoutInflater(ctx.getOuterContext()); }}); ... // 省略了很多系统服务} 最终是创建了一个 PhoneLayoutInflater 并返回的，到这里 LayoutInflater 的创建流程就分析完了 总结View 中的 INVISIBLE、VISIBLE、GONE 都有什么作用？ 如果想隐藏或者显示 View，可以通过调用 setVisibility(int visibility) 方法来实现，参数 visibility 对应三个值分别是INVISIBLE、VISIBLE、GONE VISIBLE：视图可见 INVISIBLE：视图不可见的，它仍然占用布局的空间 GONE：视图不可见，它不占用布局的空间 为什么 ViewStub 是大小为0的视图？frameworks/base/core/java/android/view/ViewStub.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // 设置视图大小为0 setMeasuredDimension(0, 0);} ViewStub 有什么作用？ ViewStub 的作用主要用来延迟布局的加载 ViewStub 是如何创建的？ 因为 ViewStub 是继承 View, 所以 ViewStub 的创建和 View 的创建是相同的，通过调用了 LayoutInflater.createView 方法根据完整的类的路径名利用反射机制构建 View 对象frameworks/base/core/java/android/view/LayoutInflater.java ...try { // 利用构造函数，创建View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // 如果是ViewStub，则设置LayoutInflater final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view;} finally { mConstructorArgs[0] = lastContext;}... 为什么 ViewStub 能做到延迟加载？ 因为在解析 layout 文件过程中遇到 ViewStub，只是构建 ViewStub 的对象和初始化 ViewStub 的属性，没有真正开始解析 View，所以可以做到延迟初始化 ViewStub 指定的 Layout 布局文件是什么时候被加载的？ 当ViewStub 控件设置可见，或者调用 inflate() 方法，ViewStub 所指定的 layout 资源就会被加载 LayoutInflater 是一个抽象类它如何被创建的？ LayoutInflater 是一个抽象类，通过调用了 from() 的静态函数，经由系统服务 LAYOUT_INFLATER_SERVICE，最终创建了一个 LayoutInflater的子类对象 PhoneLayoutInflater，继承结构如下： LayoutInflater.from(ctx) 就是根据传递过来的 Context 对象，调用 getSystemService() 来获取对应的系统服务 系统服务存储在哪里？如何获取和添加系统服务？ SystemServiceRegistry 管理所有的系统服务，所有的系统服务都存储在一 个map集合SYSTEM_SERVICE_FETCHERS 当中，调用 getSystemService 方法获取系统服务，调用 registerService 方法添加系统服务","link":"/2020/06/07/android10/resource-manager/04-APK-resource2/"},{"title":"0xA03 Android 10 源码分析：APK 加载流程之资源加载","text":"引言 这是 Android 10 源码分析系列的第 3 篇 分支：android-10.0.0_r14 全文阅读大概 15 分钟 通过这篇文章你将学习到以下内容，文末会给出相应的答案 LayoutInflater的inflate 方法的三个参数都代表什么意思？ 系统对 merge、include 是如何处理的 merge 标签为什么可以起到优化布局的效果？ XML 中的 View 是如何被实例化的？ 为什么复杂布局会产生卡顿？在 Android 10 上做了那些优化？ BlinkLayout 是什么？ 前面两篇文章 0xA01 Android 10 源码分析：APK 是如何生成的 和 0xA02 Android 10 源码分析：APK 的安装流程 分析了 APK 大概可以分为代码和资源两部分，那么 APK 的加载也是分为代码和资源两部分，代码的加载涉及了进程的创建、启动、调度，本文主要来分析一下资源的加载，如果没有看过 APK 是如何生成的 和 APK 的安装流程 可以点击下方连接前往： 0xA01 Android 10 源码分析：APK 是如何生成的 0xA02 Android 10 源码分析：APK 的安装流程 1. Android 资源Android 资源大概分为两个部分：assets 和 res assets 资源 assets 资源放在 assets 目录下，它里面保存一些原始的文件，可以以任何方式来进行组织，这些文件最终会原封不动的被打包进 APK 文件中，通过AssetManager 来获取 asset 资源，代码如下 AssetManager assetManager = context.getAssets();InputStream is = assetManager.open(&quot;fileName&quot;); res资源 res 资源放在主工程的 res 目录下，这类资源一般都会在编译阶段生成一个资源 ID 供我们使用，res 目录包括 animator、anim、 color、drawable、layout、menu、raw、values、XML等，通过 getResource() 去获取 Resources 对象 Resources res = getContext().getResources(); APK 的生成过程中，会生成资源索引表 resources.arsc 文件和 R.java 文件，前者资源索引表 resources.arsc 记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息，后者定义了各个资源 ID 常量，运行时通过 Resources 和 AssetManger 共同完成资源的加载，如果资源是个文件，Resouces 先根据资源 ID 查找出文件名，AssetManger 再根据文件名查找出具体的资源，关于 resources.arsc，可以查看 0xA01 ASOP应用框架：APK 是如何生成的 2. 资源的加载和解析到 View 的生成下面代码一定不会很陌生，在 Activity 常见的几行代码 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.main_activity)} 一起来分析一下调用 setContentView 方法之后做了什么事情，接下来查看一下 Activity 中的 setContentView 方法frameworks/base/core/java/android/app/Activity.java public void setContentView(@LayoutRes int layoutResID) { // 实际上调用的是PhoneWindow.setContentView方法 getWindow().setContentView(layoutResID); initWindowDecorActionBar();} 调用 getWindow 方法返回的是 mWindow，mWindow 是 Windowd 对象，实际上是调用它的唯一实现类 PhoneWindow.setContentView 方法 2.1 Activity -&gt; PhoneWindowPhoneWindow 是 Window 的唯一实现类，它的结构如下： 当调用 Activity.setContentView 方法实际上调用的是 PhoneWindow.setContentView 方法frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java public void setContentView(int layoutResID) { // mContentParent是ID为ID_ANDROID_CONTENT的FrameLayout // 调用setContentView方法，就是给ID为ID_ANDROID_CONTENT的View添加子View if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { // FEATURE_CONTENT_TRANSITIONS，则是标记当前内容加载有没有使用过度动画 // 如果内容已经加载过，并且不需要动画，则会调用removeAllViews mContentParent.removeAllViews(); } // 检查是否设置了FEATURE_CONTENT_TRANSITIONS if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { // 解析指定的XML资源文件 mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } mContentParentExplicitlySet = true;} 先判断 mContentParent 是否为空，如果为空则调用 installDecor 方法，生成 mDecor，并将它赋值给 mContentParent 根据 FEATURE_CONTENT_TRANSITIONS 标记来判断是否加载过转场动画 如果设置了 FEATURE_CONTENT_TRANSITIONS 则添加 Scene 来过度启动，否则调用 mLayoutInflater.inflate(layoutResID, mContentParent)，解析资源文件，创建 View, 并添加到 mContentParent 视图中 2.2 PhoneWindow -&gt; LayoutInflater当调用 PhoneWindow.setContentView 方法，之后调用 LayoutInflater.inflate 方法，来解析 XML 资源文件frameworks/base/core/java/android/view/LayoutInflater.java public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null);} inflate 它有多个重载方法，最后调用的是 inflate(resource, root, root != null) 方法frameworks/base/core/java/android/view/LayoutInflater.java public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); // 根据XML预编译生成compiled_view.dex, 然后通过反射来生成对应的View，从而减少XmlPullParser解析Xml的时间 // 需要注意的是在目前的release版本中不支持使用 View view = tryInflatePrecompiled(resource, res, root, attachToRoot); if (view != null) { return view; } // 获取资源解析器 XmlResourceParser XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); }} 这个方法主要做了三件事： 根据 XML 预编译生成 compiled_view.dex, 然后通过反射来生成对应的 View 获取 XmlResourceParser 解析 View 注意：在目前的 release 版本中不支持使用 tryInflatePrecompiled 方法源码如下： private void initPrecompiledViews() { // Precompiled layouts are not supported in this release. // enabled 是否启动预编译布局，这里始终为false boolean enabled = false; initPrecompiledViews(enabled);}private void initPrecompiledViews(boolean enablePrecompiledViews) { mUseCompiledView = enablePrecompiledViews; if (!mUseCompiledView) { mPrecompiledClassLoader = null; return; } ...}View tryInflatePrecompiled(@LayoutRes int resource, Resources res, @Nullable ViewGroup root, boolean attachToRoot) { // mUseCompiledView始终为false if (!mUseCompiledView) { return null; } // 获取需要解析的资源文件的 pkg 和 layout String pkg = res.getResourcePackageName(resource); String layout = res.getResourceEntryName(resource); try { // 根据mPrecompiledClassLoader通过反射获取预编译生成的view对象的Class类 Class clazz = Class.forName(&quot;&quot; + pkg + &quot;.CompiledView&quot;, false, mPrecompiledClassLoader); Method inflater = clazz.getMethod(layout, Context.class, int.class); View view = (View) inflater.invoke(null, mContext, resource); if (view != null &amp;&amp; root != null) { // 将生成的view 添加根布局中 XmlResourceParser parser = res.getLayout(resource); try { AttributeSet attrs = Xml.asAttributeSet(parser); advanceToRootNode(parser); ViewGroup.LayoutParams params = root.generateLayoutParams(attrs); // 如果 attachToRoot=true添加到根布局中 if (attachToRoot) { root.addView(view, params); } else { // 否者将获取到的根布局的LayoutParams，设置到生成的view中 view.setLayoutParams(params); } } finally { parser.close(); } } return view; } catch (Throwable e) { } finally { } return null;} tryInflatePrecompiled 方法是 Android 10 新增的方法，这是一个在编译器运行的一个优化，因为布局文件越复杂 XmlPullParser 解析 XML 越耗时, tryInflatePrecompiled 方法根据 XML 预编译生成compiled_view.dex, 然后通过反射来生成对应的 View，从而减少 XmlPullParser 解析 XML 的时间，然后根据 attachToRoot 参数来判断是添加到根布局中，还是设置 LayoutParams 参数返回给调用者 用一个全局变量 mUseCompiledView 来控制是否启用 tryInflatePrecompiled 方法，根据源码分析，mUseCompiledView 始终为 false 了解了 tryInflatePrecompiled 方法之后，在来查看一下 inflate 方法中的三个参数都什么意思 resource：要解析的 XML 布局文件 ID root：表示根布局 attachToRoot：是否要添加到父布局 root 中 resource 其实很好理解就是资源 ID，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 根据源码知道调用 tryInflatePrecompiled 方法返回的 view 为空，继续往下执行调用 Resources 的 getLayout 方法获取资源解析器 XmlResourceParser 2.3 LayoutInflater -&gt; Resources上面说到 XmlResourceParser 是通过调用 Resources 的 getLayout 方法获取的，getLayout 方法又去调用了 Resources 的loadXmlResourceParser 方法frameworks/base/core/java/android/content/res/Resources.java public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException { return loadXmlResourceParser(id, &quot;layout&quot;);}XmlResourceParser loadXmlResourceParser(@AnyRes int id, @NonNull String type) throws NotFoundException { // TypedValue 主要用来存储资源 final TypedValue value = obtainTempTypedValue(); try { final ResourcesImpl impl = mResourcesImpl; // 获取XML资源，保存到 TypedValue impl.getValue(id, value, true); if (value.type == TypedValue.TYPE_STRING) { // 为指定的XML资源，加载解析器 return impl.loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type); } throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id) + &quot; type #0x&quot; + Integer.toHexString(value.type) + &quot; is not valid&quot;); } finally { releaseTempTypedValue(value); }} TypedValue 是动态的数据容器，主要用来存储 Resource 的资源，获取 XML 资源保存到 TypedValue，之后调用 ResourcesImpl 的 loadXmlResourceParser 方法加载对应的解析器 2.4 Resources -&gt; ResourcesImplResourcesImpl 实现了 Resource 的访问，它包含了 AssetManager 和所有的缓存，通过 Resource 的 getValue 方法获取 XML 资源保存到 TypedValue，之后就会调用 ResourcesImpl 的 loadXmlResourceParser 方法对该布局资源进行解析frameworks/base/core/java/android/content/res/ResourcesImpl.java XmlResourceParser loadXmlResourceParser(@NonNull String file, @AnyRes int id, int assetCookie, @NonNull String type) throws NotFoundException { if (id != 0) { try { synchronized (mCachedXmlBlocks) { final int[] cachedXmlBlockCookies = mCachedXmlBlockCookies; final String[] cachedXmlBlockFiles = mCachedXmlBlockFiles; final XmlBlock[] cachedXmlBlocks = mCachedXmlBlocks; // 首先从缓存中查找XML资源 final int num = cachedXmlBlockFiles.length; for (int i = 0; i &lt; num; i++) { if (cachedXmlBlockCookies[i] == assetCookie &amp;&amp; cachedXmlBlockFiles[i] != null &amp;&amp; cachedXmlBlockFiles[i].equals(file)) { // 调用newParser方法去构建一个XmlResourceParser对象，返回给调用者 return cachedXmlBlocks[i].newParser(id); } } // 如果缓存中没有，则创建XmlBlock，并将它放到缓存中 // XmlBlock是已编译的XML文件的一个包装类 final XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file); if (block != null) { final int pos = (mLastCachedXmlBlockIndex + 1) % num; mLastCachedXmlBlockIndex = pos; final XmlBlock oldBlock = cachedXmlBlocks[pos]; if (oldBlock != null) { oldBlock.close(); } cachedXmlBlockCookies[pos] = assetCookie; cachedXmlBlockFiles[pos] = file; cachedXmlBlocks[pos] = block; // 调用newParser方法去构建一个XmlResourceParser对象，返回给调用者 return block.newParser(id); } } } catch (Exception e) { final NotFoundException rnf = new NotFoundException(&quot;File &quot; + file + &quot; from xml type &quot; + type + &quot; resource ID #0x&quot; + Integer.toHexString(id)); rnf.initCause(e); throw rnf; } } throw new NotFoundException(&quot;File &quot; + file + &quot; from xml type &quot; + type + &quot; resource ID #0x&quot; + Integer.toHexString(id));} 首先从缓存中查找 XML 资源之后调用 newParser 方法，如果缓存中没有，则调用 AssetManger 的 openXmlBlockAsset 方法创建一个 XmlBlock，并将它放到缓存中，XmlBlock 是已编译的 XML 文件的一个包装类frameworks/base/core/java/android/content/res/AssetManager.java XmlBlock openXmlBlockAsset(int cookie, @NonNull String fileName) throws IOException { Preconditions.checkNotNull(fileName, &quot;fileName&quot;); synchronized (this) { ensureOpenLocked(); // 调用native方法nativeOpenXmlAsset, 加载指定的XML资源文件，得到ResXMLTree // xmlBlock是ResXMLTree对象的地址 final long xmlBlock = nativeOpenXmlAsset(mObject, cookie, fileName); if (xmlBlock == 0) { throw new FileNotFoundException(&quot;Asset XML file: &quot; + fileName); } // 创建XmlBlock，封装xmlBlock，返回给调用者 final XmlBlock block = new XmlBlock(this, xmlBlock); incRefsLocked(block.hashCode()); return block; }} 最终调用 native 方法 nativeOpenXmlAsset 去打开指定的 XML 文件，加载对应的资源，来查看一下 navtive 方法 NativeOpenXmlAssetframeworks/base/core/jni/android_util_AssetManager.cpp // java方法对应的native方法{&quot;nativeOpenXmlAsset&quot;, &quot;(JILjava/lang/String;)J&quot;, (void*)NativeOpenXmlAsset} static jlong NativeOpenXmlAsset(JNIEnv* env, jobject /*clazz*/, jlong ptr, jint jcookie, jstring asset_path) { ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie); ... const DynamicRefTable* dynamic_ref_table = assetmanager-&gt;GetDynamicRefTableForCookie(cookie); std::unique_ptr&lt;ResXMLTree&gt; xml_tree = util::make_unique&lt;ResXMLTree&gt;(dynamic_ref_table); status_t err = xml_tree-&gt;setTo(asset-&gt;getBuffer(true), asset-&gt;getLength(), true); asset.reset(); ... return reinterpret_cast&lt;jlong&gt;(xml_tree.release());} C++ 层的 NativeOpenXmlAsset 方法会创建 ResXMLTree 对象，返回的是 ResXMLTree 在 C++ 层的地址 Java 层 nativeOpenXmlAsse t方法的返回值 xmlBlock 是 C++ 层的 ResXMLTree 对象的地址，然后将 xmlBlock 封装进 XmlBlock 中返回给调用者 当 xmlBlock 创建之后，会调用 newParser 方法，构建一个 XmlResourceParser 对象，返回给调用者 2.5 ResourcesImpl -&gt; XmlBlockXmlBlock 是已编译的 XML 文件的一个包装类，XmlResourceParser 负责对 XML 的标签进行遍历解析的，它的真正的实现是 XmlBlock 的内部类 XmlBlock.Parser，而真正完成 XML 的遍历操作的函数都是由 XmlBlock 来实现的，为了提升效率都是通过 JNI 调用 native 的函数来做的，接下来查看一下 newParser 方法frameworks/base/core/java/android/content/res/XmlBlock.java public XmlResourceParser newParser(@AnyRes int resId) { synchronized (this) { // mNative是C++层的ResXMLTree对象的地址 if (mNative != 0) { // nativeCreateParseState方法根据 mNative 查找到ResXMLTree， // 在C++层构建一个ResXMLParser对象， // 构建Parser，封装ResXMLParser，返回给调用者 return new Parser(nativeCreateParseState(mNative, resId), this); } return null; }} 这个方法做两件事 mNative 是 C++ 层的 ResXMLTree 对象的地址，调用 native 方法 nativeCreateParseState，在 C++ 层构建一个 ResXMLParser 对象，返回 ResXMLParser 对象在 C++ 层的地址 Java 层拿到 ResXMLParser 在 C++ 层地址，构建 Parser，封装 ResXMLParser，返回给调用者 接下来查看一下 native 方法 nativeCreateParseStateframeworks/base/core/jni/android_util_XmlBlock.cpp // java方法对应的native方法{ &quot;nativeCreateParseState&quot;, &quot;(JI)J&quot;, (void*) android_content_XmlBlock_nativeCreateParseState } static jlong android_content_XmlBlock_nativeCreateParseState(JNIEnv* env, jobject clazz, jlong token, jint res_id){ ResXMLTree* osb = reinterpret_cast&lt;ResXMLTree*&gt;(token); if (osb == NULL) { jniThrowNullPointerException(env, NULL); return 0; } ResXMLParser* st = new ResXMLParser(*osb); if (st == NULL) { jniThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, NULL); return 0; } st-&gt;setSourceResourceId(res_id); st-&gt;restart(); return reinterpret_cast&lt;jlong&gt;(st);} token 对应 Java 层 mNative，是 C++ 层的 ResXMLTree 对象的地址 调用 C++ 层 android_content_XmlBlock_nativeCreateParseState 方法，根据 token找到 ResXMLTree 对象 在 C++ 层构建一个 ResXMLParser 对象，返给 Java 层对应 ResXMLParser 对象在 C++ 层的地址 Java 层拿到 ResXMLParser 在 C++ 层地址，封装到 Parser 中 2.6 再次回到 LayoutInflater经过一系列的跳转，最后调用 XmlBlock.newParser 方法获取资源解析器 XmlResourceParser，之后回到 LayoutInflater 调用处 inflate 方法，然后调用 rInflate 方法解析 Viewframeworks/base/core/java/android/view/LayoutInflater.java public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { // 获取context final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; // 存储根布局 View result = root; try { // 处理 START_TA G和 END_TAG advanceToRootNode(parser); final String name = parser.getName(); // 解析merge标签，rInflate方法会将merge标签下面的所有子view添加到根布局中 // 这也是为什么merge标签可以简化布局的效果 if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); } // 解析merge标签下的所有的View，添加到根布局中 rInflate(parser, root, inflaterContext, attrs, false); } else { // 如果不是merge标签，调用createViewFromTag方法解析布局视图，这里的temp其实是我们xml里的top view final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; // 如果根布局不为空的话，且attachToRoot为false，为View设置布局参数 if (root != null) { // 获取根布局的LayoutParams params = root.generateLayoutParams(attrs); // attachToRoot为false，为View设置LayoutParams if (!attachToRoot) { temp.setLayoutParams(params); } } // 解析当前View下面的所有子View rInflateChildren(parser, temp, attrs, true); // 如果 root 不为空且 attachToRoot 为false，将解析出来的View 添加到根布局 if (root != null &amp;&amp; attachToRoot) { root.addView(temp, params); } // 如果根布局为空 或者 attachToRoot 为false，返回当前的View if (root == null || !attachToRoot) { result = temp; } } } catch (XmlPullParserException e) { final InflateException ie = new InflateException(e.getMessage(), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; } catch (Exception e) { throw ie; } finally { } return result; }} 解析 merge 标签，使用 merge 标签必须有父布局，且依赖于父布局加载 rInflate 方法会将 merge 标签下面的所有 View 添加到根布局中 如果不是 merge 标签，调用 createViewFromTag 解析布局视图，返回 temp, 这里的 temp 其实是我们 XML 里的 Top View 调用 rInflateChildren 方法，传递参数 temp，在 rInflateChildren方 法里内部，会调用 rInflate 方法, 解析当前 View 下面的所有子 View 通过分析源码知道了attachToRoot 和 root的参数代表什么意思，这里总结一下： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的View生成 LayoutParams并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 无论是不是 merge 标签，最后都会调用 rInflate 方法进行 View 树的解析，他们的区别在于，如果是 merge 标签传递的参数 finishInflate 是 false，如果不是 merge 标签传递的参数 finishInflate 是 trueframeworks/base/core/java/android/view/LayoutInflater.java void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException { // 获取数的深度 final int depth = parser.getDepth(); int type; boolean pendingRequestFocus = false; // 逐个 View 解析 while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) { if (type != XmlPullParser.START_TAG) { continue; } final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) { // 解析android:focusable=&quot;true&quot;, 获取View的焦点 pendingRequestFocus = true; consumeChildElements(parser); } else if (TAG_TAG.equals(name)) { // 解析android:tag标签 parseViewTag(parser, parent, attrs); } else if (TAG_INCLUDE.equals(name)) { // 解析include标签，include标签不能作为根布局 if (parser.getDepth() == 0) { throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); } parseInclude(parser, context, parent, attrs); } else if (TAG_MERGE.equals(name)) { // merge标签必须作为根布局 throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); } else { // 根据元素名解析，生成View final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); // rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子View rInflateChildren(parser, view, attrs, true); // 添加解析的View viewGroup.addView(view, params); } } if (pendingRequestFocus) { parent.restoreDefaultFocus(); } // 如果finishInflate为true，则调用onFinishInflate方法 if (finishInflate) { parent.onFinishInflate(); }} 整个 View 树的解析过程如下： 获取 View 树的深度 逐个 View 解析 解析 android:focusable=”true”, 获取 View 的焦点 解析 android:tag 标签 解析 include 标签，并且 include 标签不能作为根布局 解析 merge 标签，并且 merge 标签必须作为根布局 根据元素名解析，生成对应的 View rInflateChildren 方法内部调用的 rInflate 方法，深度优先遍历解析所有的子 View 添加解析的 View 注意：通过分析源码, 以下几点需要特别注意 include 标签不能作为根元素，需要放在 ViewGroup中 merge 标签必须为根元素，使用 merge 标签必须有父布局，且依赖于父布局加载 当 XmlResourseParser 对 XML 的遍历，随着布局越复杂，层级嵌套越多，所花费的时间也越长，所以对布局的优化，可以使用 meger 标签减少层级的嵌套 在解析过程中调用 createViewFromTag 方法，根据元素名解析，生成对应的 View，接下来查看一下 createViewFromTag 方法frameworks/base/core/java/android/view/LayoutInflater.java private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) { return createViewFromTag(parent, name, context, attrs, false);}View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) { if (name.equals(&quot;view&quot;)) { name = attrs.getAttributeValue(null, &quot;class&quot;); } // 如果设置了theme, 构建一个ContextThemeWrapper if (!ignoreThemeAttr) { final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) { context = new ContextThemeWrapper(context, themeResId); } ta.recycle(); } try {\b\b // 如果name是blink，则创建BlinkLayout // 如果设置factory，根据factory进行解析, 这是系统留给我们的Hook入口 View view = tryCreateView(parent, name, context, attrs); // 如果 tryCreateView方法返回的View为空，则判断是内置View还是自定义View // 如果是内置的View则调用onCreateView方法，如果是自定义View 则调用createView方法 if (view == null) { final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try { // 如果使用自定义View，需要在XML指定全路径的， // 例如：com.hi.dhl.CustomView，那么这里就有个.了 // 可以利用这一点判定是内置的View，还是自定义View if (-1 == name.indexOf('.')) { // 解析内置View view = onCreateView(context, parent, name, attrs); } else { // 解析自定义View view = createView(context, name, null, attrs); } /** * onCreateView方法与createView方法的区别 * onCreateView方法：会给内置的View前面加一个前缀，例如：android.widget，最终会调用createView方法 * createView方法: 据完整的类的路径名利用反射机制构建View对象 */ } finally { mConstructorArgs[0] = lastContext; } } return view; } catch (InflateException e) { throw e; } catch (ClassNotFoundException e) { throw ie; } catch (Exception e) { throw ie; }} 解析 View 标签，如果设置了 theme, 构建一个 ContextThemeWrapper 调用 tryCreateView 方法，如果 name 是 blink，则创建 BlinkLayout，如果设置 factory，根据 factory 进行解析，这是系统留给我们的 Hook 入口，我们可以人为的干涉系统创建 View，添加更多的功能 如果 tryCreateView 方法返回的 View 为空，则分别调用 onCreateView 方法和 createView 方法，onCreateView 方法解析内置 View，createView 方法解析自定义 View 在解析过程中，会先调用 tryCreateView 方法，来看一下 tryCreateView 方法内部做了什么frameworks/base/core/java/android/view/LayoutInflater.java public final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) { // BlinkLayout它是FrameLayout的子类，是LayoutInflater中的一个内部类, // 如果当前标签为TAG_1995，则创建一个隔500毫秒闪烁一次的BlinkLayout来承载它的布局内容 if (name.equals(TAG_1995)) { // Let's party like it's 1995! // 源码注释也很有意思，写了Let's party like it's 1995!, 据说是为了庆祝1995年的复活节 return new BlinkLayout(context, attrs); } // 如果设置factory，根据factory进行解析, 这是系统留给我们的Hook入口，我们可以人为的干涉系统创建View，添加更多的功能 if (mFactory2 != null) { view = mFactory2.onCreateView(parent, name, context, attrs); } else if (mFactory != null) { view = mFactory.onCreateView(name, context, attrs); } else { view = null; } if (view == null &amp;&amp; mPrivateFactory != null) { view = mPrivateFactory.onCreateView(parent, name, context, attrs); } return view;} 如果 name 是 blink，则创建 BlinkLayout，返给调用者 如果设置 factory，根据 factory 进行解析, 这是系统留给我们的 Hook 入口，我们可以人为的干涉系统创建 View，添加更多的功能，例如夜间模式，将 View 返给调用者 根据刚才的分析，会先调用 tryCreateView 方法，如果这个方法返回的 View 为空，然后会调用 onCreateView 方法对内置 View 进行解析，createView 方法对自定义 View 进行解析 onCreateView 方法与 createView 方法的有什么区别 onCreateView 方法：会给内置的 View 前面加一个前缀，例如： android.widget，最终会调用 createView 方法 createView 方法: 根据完整的类的路径名利用反射机制构建 View 对象 来看一下这两个方法的实现，LayoutInflater 是一个抽象类，我们实际使用的是 PhoneLayoutInflater，它的结构如下 PhoneLayoutInflater 重写了 LayoutInflater 的 onCreatView 方法，这个方法就是给内置的 View 前面加一个前缀frameworks/base/core/java/com/android/internal/policy/PhoneLayoutInflater.java private static final String[] sClassPrefixList = { &quot;android.widget.&quot;, &quot;android.webkit.&quot;, &quot;android.app.&quot;}; protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException { for (String prefix : sClassPrefixList) { try { View view = createView(name, prefix, attrs); if (view != null) { return view; } } catch (ClassNotFoundException e) { } } return super.onCreateView(name, attrs);} onCreateView 方法会给内置的 View 前面加一个前缀，之后调用 createView 方法，真正的 View 构建还是在 LayoutInflater 的 createView 方法里完成的，createView 方法根据完整的类的路径名利用反射机制构建 View 对象frameworks/base/core/java/android/view/LayoutInflater.java public final View createView(@NonNull Context viewContext, @NonNull String name, @Nullable String prefix, @Nullable AttributeSet attrs) throws ClassNotFoundException, InflateException { ... try { if (constructor == null) { // 如果在缓存中没有找到构造函数，则根据完整的类的路径名利用反射机制构建View对象 clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); if (mFilter != null &amp;&amp; clazz != null) { boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) { failNotAllowed(name, prefix, viewContext, attrs); } } // 利用反射机制构建clazz, 将它的构造函数存入sConstructorMap中，下次可以直接从缓存中查找 constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); } else { // 如果从缓存中找到了缓存的构造函数 if (mFilter != null) { Boolean allowedState = mFilterMap.get(name); if (allowedState == null) { // 根据完整的类的路径名利用反射机制构建View对象 clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); ... } else if (allowedState.equals(Boolean.FALSE)) { failNotAllowed(name, prefix, viewContext, attrs); } } } ... try { // 利用构造函数，创建View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // 如果是ViewStub，则设置LayoutInflater final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view; } finally { mConstructorArgs[0] = lastContext; } } catch (NoSuchMethodException e) { throw ie; } catch (ClassCastException e) { throw ie; } catch (ClassNotFoundException e) { throw e; } catch (Exception e) { throw ie; } finally { }}``` * 先从缓存中寻找构造函数，如果存在直接使用* 如果没有找到根据完整的类的路径名利用反射机制构建 View 对象到了这里关于 APK 的布局 XML 资源文件的查找和解析 -&gt; View 的生成流程到这里就结束了## 总结那我们就来依次来回答上面提出的几个问题**LayoutInflater 的 inflate 的三个参数都代表什么意思？*** resource：要解析的 XML 布局文件 ID* root：表示根布局* attachToRoot：是否要添加到父布局 root 中resource 其实很好理解就是资源 ID，而 root 和 attachToRoot 分别代表什么意思：* 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回* 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该 View 中去* 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回**系统对 merge、include 是如何处理的*** 使用 merge 标签必须有父布局，且依赖于父布局加载* merge 并不是一个 ViewGroup，也不是一个 View，它相当于声明了一些视图，等待被添加，解析过程中遇到 merge 标签会将 merge 标签下面的所有子 view 添加到根布局中* merge 标签在 XML 中必须是根元素* 相反的 include 不能作为根元素，需要放在一个 ViewGroup 中* 使用 include 标签必须指定有效的 layout 属性* 使用 include 标签不写宽高是没有关系的，会去解析被 include 的 layout**merge 标签为什么可以起到优化布局的效果？**解析过程中遇到 merge 标签，会调用 rInflate 方法，部分代码如下 // 根据元素名解析，生成对应的Viewfinal View view = createViewFromTag(parent, name, context, attrs);final ViewGroup viewGroup = (ViewGroup) parent;final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子ViewrInflateChildren(parser, view, attrs, true);// 添加解析的ViewviewGroup.addView(view, params); 解析 merge 标签下面的所有子 View，然后添加到根布局中**View 是如何被实例化的？**View 分为系统 View 和自定义 View, 通过调用 onCreateView 与createView 方法进行不同的处理* onCreateView 方法：会给内置的 View 前面加一个前缀，例如：android.widget，最终会调用 createView 方法* createView 方法：根据完整的类的路径名利用反射机制构建 View 对象**为什么复杂布局会产生卡顿？在 Android 10 上做了那些优化？*** XmlResourseParser 对 XML 的遍历，随着布局越复杂，层级嵌套越多，所花费的时间也越长* 调用 onCreateView 与 createView 方法是通过反射创建 View 对象导致的耗时* 在 Android 10上，新增 tryInflatePrecompiled 方法是为了减少 XmlPullParser 解析 XML 的时间，但是用一个全局变量 mUseCompiledView 来控制是否启用 tryInflatePrecompiled 方法，根据源码分析，mUseCompiledView 始终为 false，所以 tryInflatePrecompiled 方法目前在 release 版本中不可使用**BlinkLayout 是什么？**BlinkLayout 继承 FrameLayout，是一种会闪烁的布局，被包裹的内容会一直闪烁，根据源码注释 Let's party like it's 1995!，BlinkLayout 是为了庆祝 1995 年的复活节, 有兴趣可以看看 [reddit](https://www.reddit.com/r/androiddev/comments/3sekn8/lets_party_like_its_1995_from_the_layoutinflater/) 上的讨论，来查看一下它的源码是如何实现的&lt;br/&gt; private static class BlinkLayout extends FrameLayout { private static final int MESSAGE_BLINK = 0x42; private static final int BLINK_DELAY = 500; private boolean mBlink; private boolean mBlinkState; private final Handler mHandler; public BlinkLayout(Context context, AttributeSet attrs) { super(context, attrs); mHandler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { if (msg.what == MESSAGE_BLINK) { if (mBlink) { mBlinkState = !mBlinkState; // 每隔500ms循环调用 makeBlink(); } // 触发dispatchDraw invalidate(); return true; } return false; } }); } private void makeBlink() { // 发送延迟消息 Message message = mHandler.obtainMessage(MESSAGE_BLINK); mHandler.sendMessageDelayed(message, BLINK_DELAY); } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); mBlink = true; mBlinkState = true; makeBlink(); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); mBlink = false; mBlinkState = true; // 移除消息，避免内存泄露 mHandler.removeMessages(MESSAGE_BLINK); } @Override protected void dispatchDraw(Canvas canvas) { if (mBlinkState) { super.dispatchDraw(canvas); } }} 通过源码分析可以看出，BlinkLayout 通过 Handler 每隔 500ms 发送消息，在 handleMessage 中循环调用 invalidate 方法，通过调用 invalidate 方法，来触发 dispatchDraw 方法，做到一闪一闪的效果 ## 参考 * [https://www.reddit.com/r/androiddev/comments/3sekn8/lets_party_like_its_1995_from_the_layoutinflater/](https://www.reddit.com/r/androiddev/comments/3sekn8/lets_party_like_its_1995_from_the_layoutinflater/) * [https://github.com/RTFSC-Android/RTFSC/blob/master/LayoutInflater.md](https://github.com/RTFSC-Android/RTFSC/blob/master/LayoutInflater.md) * [https://www.yuque.com/beesx/beesandroid/gd7w9o](https://www.yuque.com/beesx/beesandroid/gd7w9o)","link":"/2020/06/07/android10/resource-manager/03-APK-resource/"},{"title":"0xA02 Android 10 源码分析：APK 的安装流程","text":"前言 这是 Android 10 源码分析系列的第 2 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 上一篇文章介绍了 0xA01 Android 10 源码分析：APK 是如何生成的，这篇文章接着介绍如何安装 APK，需要说一下 Android 10 及更高版本中, 安装器 PackageInstaller 源码位置有所变动 PackageInstaller 源码所在位置PackageInstaller 是系统内置的应用程序，用于安装和卸载应用 在 Android 9 及更低版本中，软件包安装和权限控制功能包含在 PackageInstaller 软件包 (//packages/apps/PackageInstaller) 中。在 Android 10 及更高版本中，权限控制功能位于单独的软件包 PermissionController (//packages/apps/PermissionController)，这两个软件包在 Android 10 中的位置如下图所示，更多信息点击这里前往 Android 权限 Android 9 及更低版本中 ： 软件包安装和权限控制功能源码路径：packages/apps/PackageInstaller Android 10 及更高版本： 权限控制功能 PermissionController 源码路径：packages/apps/PermissionController/ 安装器 PackageInstaller 源码路径：frameworks/base/packages/PackageInstaller/ 在 Android 系统不同的目录存放不同类型的应用 /system/framwork：保存的是资源型的应用程序，它们用来打包资源文件 /system/app：保存系统自带的应用程序 /data/app：保存用户安装的应用程序 /data/data：应用数据目录 /data/app-private：保存受DRM保护的私有应用程序 /vendor/app：保存设备厂商提供的应用程序 查看 PackageInstaller 源码方式 AOSP-PackageInstaller: 包含了安装器 PackageInstaller(7.1.2、8.1.0、9.0.0、10.0.0) 的源码，可以切换分之查看，跟随 Android 版本更新，你永远可以看到最新的源代码 aospxref：这是一个在线查看 Android 源码网站，服务器在阿里云访问速度很快，文末有关这个网站的介绍 googlesource-PackageInstaller：这是安装器 PackageInstaller 在 googlesource 上的地址 1. APK 的安装方式安装 APK 主要分为以下三种场景 安装系统应用：系统启动后调用 PackageManagerService.main() 初始化注册解析安装工作 public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { // Self-check for initial settings. PackageManagerServiceCompilerMapping.checkProperties(); PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); m.enableSystemUserPackages(); ServiceManager.addService(&quot;package&quot;, m); final PackageManagerNative pmn = m.new PackageManagerNative(); ServiceManager.addService(&quot;package_native&quot;, pmn); return m;} 通过 adb 安装：通过 pm 参数，调用 PM 的 runInstall 方法，进入 PackageManagerService 安装安装工作 通过系统安装器 PackageInstaller 进行安装：先调用 InstallStart 进行权限检查之后启动 PackageInstallActivity，调用 PackageInstallActivity 的 startInstall 方法，点击 OK 按钮后进入 PackageManagerService 完成拷贝解析安装工作 所有安装方式大致相同，最终就是回到 PackageManagerService 中，安装一个 APK 的大致流程如下： 拷贝到 APK 文件到指定目录 解压缩 APK，拷贝文件，创建应用的数据目录 解析 APK 的 AndroidManifest.xml 文件 向 Launcher 应用申请添加创建快捷方式 本文主要来分析通过安装器 PackageInstaller 安装 APK，这是用户最常用的一种方式 2. PackageInstaller 的入口下面代码一定不会很陌生，这就是我们常用的安装 APK 的代码（PS: 关于静默安装我会后续分享在逆向开发相关的文章） Intent intent = new Intent(Intent.ACTION_VIEW);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);/** 自Android N开始，是通过FileProvider共享相关文件，但是Android Q对公* 有目录 File API进行了限制，只能通过Uri来操作*/if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q){ // filePath是通过ContentResolver得到的 intent.setDataAndType(Uri.parse(filePath) ,&quot;application/vnd.android.package-archive&quot;); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);}else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(mContext, &quot;com.dhl.file.fileProvider&quot;, file); intent.setDataAndType(contentUri, &quot;application/vnd.android.package-archive&quot;);} else { intent.setDataAndType(Uri.fromFile(file), &quot;application/vnd.android.package-archive&quot;);}startActivity(intent);// 需要在AndroidManifest添加权限&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt; 通过 intent.setDataAndType 方法指定 Intent 的数据类型为 application/vnd.android.package-archive，隐式匹配的 Activity 为 InstallStart：frameworks/base/packages/PackageInstaller/AndroidManifest.xml &lt;activity android:name=&quot;.InstallStart&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot; android:exported=&quot;true&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;content&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;data android:scheme=&quot;content&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_INSTALL&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 本文分析的是 10.0 的源码，在 8.0、9.0、10.0 等等版本中隐式匹配的 Activity 是 InstallStart，7.0 隐式匹配的 Activity 是 PackageInstallerActivity 安装器 PackageInstaller 的入口 Activity 是 InstallStart，定义了两个 scheme：content 和 package 3. APK 的安装流程通过上面方式找到了入口 Activity，下面我们来查看一下 APK 是如何安装的 3.1 InstallStart主要工作： 判断是否勾选“未知来源”选项，若未勾选跳转到设置安装未知来源界面 对于大于等于 Android 8.0 版本，会先检查是否申请安装权限，若没有则中断安装 判断 Uri 的 Scheme 协议，若是 content 则调用 InstallStaging, 若是 package 则调用 PackageInstallerActivity 当我们调用上面安装代码来安装 APK 时。会跳转到 InstallStart, 并调用它的 onCreate 方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallStart.java @Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ... final boolean isSessionInstall = PackageInstaller.ACTION_CONFIRM_INSTALL.equals(intent.getAction()); ... final ApplicationInfo sourceInfo = getSourceInfo(callingPackage); final int originatingUid = getOriginatingUid(sourceInfo); boolean isTrustedSource = false; // 判断是否勾选“未知来源”选项 if (sourceInfo != null &amp;&amp; (sourceInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) { isTrustedSource = intent.getBooleanExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, false); } if (!isTrustedSource &amp;&amp; originatingUid != PackageInstaller.SessionParams.UID_UNKNOWN) { final int targetSdkVersion = getMaxTargetSdkVersionForUid(this, originatingUid); // 如果targetSdkVerison小于0中止安装 if (targetSdkVersion &lt; 0) { Log.w(LOG_TAG, &quot;Cannot get target sdk version for uid &quot; + originatingUid); mAbortInstall = true; // 如果targetSdkVersion大于等于26（8.0）, 且获取不到REQUEST_INSTALL_PACKAGES权限中止安装 } else if (targetSdkVersion &gt;= Build.VERSION_CODES.O &amp;&amp; !declaresAppOpPermission( originatingUid, Manifest.permission.REQUEST_INSTALL_PACKAGES)) { Log.e(LOG_TAG, &quot;Requesting uid &quot; + originatingUid + &quot; needs to declare permission &quot; + Manifest.permission.REQUEST_INSTALL_PACKAGES); mAbortInstall = true; } } ... // 如果设置了ACTION_CONFIRM_PERMISSIONS，则调用PackageInstallerActivity。 if (isSessionInstall) { nextActivity.setClass(this, PackageInstallerActivity.class); } else { Uri packageUri = intent.getData(); // 判断Uri的Scheme协议是否是content if (packageUri != null &amp;&amp; packageUri.getScheme().equals( ContentResolver.SCHEME_CONTENT)) { // [IMPORTANT] This path is deprecated, but should still work. // 这个路径已经被起用了，但是仍然可以工作 // 调用InstallStaging来拷贝file/content，防止被修改 nextActivity.setClass(this, InstallStaging.class); } else if (packageUri != null &amp;&amp; packageUri.getScheme().equals( PackageInstallerActivity.SCHEME_PACKAGE)) { // 如果Uri中包含package，则调用PackageInstallerActivity nextActivity.setClass(this, PackageInstallerActivity.class); } else { // Uri不合法 Intent result = new Intent(); result.putExtra(Intent.EXTRA_INSTALL_RESULT, PackageManager.INSTALL_FAILED_INVALID_URI); setResult(RESULT_FIRST_USER, result); nextActivity = null; } } if (nextActivity != null) { startActivity(nextActivity); } finish();} 根据 Uri 的 Scheme 协议，若是 content 则调用 InstallStaging，查看 InstallStaging 的 onResume方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallStaging.java @Overrideprotected void onResume() { super.onResume(); if (mStagingTask == null) { if (mStagedFile == null) { // 创建临时文件 mStagedFile 用来存储数据 try { mStagedFile = TemporaryFileManager.getStagedFile(this); } catch (IOException e) { showError(); return; } } // 启动 StagingAsyncTask，并传入了content协议的Uri mStagingTask = new StagingAsyncTask(); mStagingTask.execute(getIntent().getData()); }} 创建临时文件 mStagedFile 用来存储数据 启动 StagingAsyncTask，并传入了 content 协议的 Uri private final class StagingAsyncTask extends AsyncTask&lt;Uri, Void, Boolean&gt; { @Override protected Boolean doInBackground(Uri... params) { ... Uri packageUri = params[0]; try (InputStream in = getContentResolver().openInputStream(packageUri)) { ... // 将packageUri（content协议的Uri）的内容写入到mStagedFile中 try (OutputStream out = new FileOutputStream(mStagedFile)) { byte[] buffer = new byte[1024 * 1024]; int bytesRead; while ((bytesRead = in.read(buffer)) &gt;= 0) { // Be nice and respond to a cancellation if (isCancelled()) { return false; } out.write(buffer, 0, bytesRead); } } } catch (IOException | SecurityException | IllegalStateException e) { Log.w(LOG_TAG, &quot;Error staging apk from content URI&quot;, e); return false; } return true; } @Override protected void onPostExecute(Boolean success) { if (success) { // 如果写入成功，调用DeleteStagedFileOnResult Intent installIntent = new Intent(getIntent()); installIntent.setClass(InstallStaging.this, DeleteStagedFileOnResult.class); installIntent.setData(Uri.fromFile(mStagedFile)); ... startActivity(installIntent); InstallStaging.this.finish(); } else { showError(); } }} doInBackground 方法中将 packageUri（content 协议的 Uri）的内容写入到 mStagedFile 中 如果写入成功，调用 DeleteStagedFileOnResult 的 OnCreate 方法： frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/DeleteStagedFileOnResult.java protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (savedInstanceState == null) { // 启动PackageInstallerActivity Intent installIntent = new Intent(getIntent()); installIntent.setClass(this, PackageInstallerActivity.class); installIntent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION); startActivityForResult(installIntent, 0); }} 经过分析 InstallStaging 主要起了中转作用，将 content 协议的 Uri 转换为 File 协议，最后跳转到 PackageInstallerActivity 3.2 PackageInstallerActivity主要工作： 显示安装界面 初始化安装需要用的各种对象，比如 PackageManager、IPackageManager、AppOpsManager、UserManager、PackageInstaller 等等 根据传递过来的 Scheme 协议做不同的处理 检查是否允许、初始化安装 在准备安装的之前，检查应用列表判断该应用是否已安装，若已安装则提示该应用已安装，由用户决定是否替换 在安装界面，提取出 APK 中权限信息并展示出来 点击 OK 按钮确认安装后，会调用 startInstall 开始安装工作 PackageInstallerActivity 才是应用安装器 PackageInstaller 真正的入口 Activity，查看它的 onCreate 方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java protected void onCreate(Bundle icicle) { getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS); super.onCreate(null); // 初始化安装需要用到的对象 mPm = getPackageManager(); mIpm = AppGlobals.getPackageManager(); mAppOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); // 根据Uri的Scheme做不同的处理 boolean wasSetUp = processPackageUri(packageUri); if (!wasSetUp) { return; } // 显示安装界面 bindUi(); // 检查是否允许安装包，如果允许则启动安装。如果不允许显示适当的对话框 checkIfAllowedAndInitiateInstall();} 主要做了对象的初始化，解析 Uri 的 Scheme，初始化界面，安装包检查等等工作，接着查看一下 processPackageUri 方法 private boolean processPackageUri(final Uri packageUri) { mPackageURI = packageUri; final String scheme = packageUri.getScheme(); // 根据这个Scheme协议分别对package协议和file协议进行处理 switch (scheme) { case SCHEME_PACKAGE: { try { // 通过PackageManager对象获取指定包名的包信息 mPkgInfo = mPm.getPackageInfo(packageUri.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.MATCH_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + packageUri.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); return false; } mAppSnippet = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } break; case ContentResolver.SCHEME_FILE: { // 根据packageUri创建一个新的File File sourceFile = new File(packageUri.getPath()); // 解析APK得到APK的信息，PackageParser.Package存储了APK的所有信息 PackageParser.Package parsed = PackageUtil.getPackageInfo(this, sourceFile); if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); return false; } // 根据PackageParser.Package得到的APK信息，生成PackageInfo mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mAppSnippet = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } break; default: { throw new IllegalArgumentException(&quot;Unexpected URI scheme &quot; + packageUri); } } return true;} 主要对 Scheme 协议分别对 package 协议和 file 协议进行处理 SCHEME_PACKAGE： 在 package 协议中调用了 PackageManager.getPackageInfo 方法生成 PackageInfo，PackageInfo 是跨进程传递的包数据（activities、receivers、services、providers、permissions等等）包含 APK 的所有信息 SCHEME_FILE： 在 file 协议的处理中调用了 PackageUtil.getPackageInfo 方法，方法内部调用了 PackageParser.parsePackage() 把 APK 文件的 manifest 和签名信息都解析完成并保存在了 Package，Package 包含了该 APK 的所有信息 调用 PackageParser.generatePackageInfo 生成 PackageInfo 接着往下走，都解析完成之后，回到 onCreate 方法，继续调用 checkIfAllowedAndInitiateInstall 方法 private void checkIfAllowedAndInitiateInstall() { // 首先检查安装应用程序的用户限制，如果有限制并弹出弹出提示Dialog或者跳转到设置界面 final int installAppsRestrictionSource = mUserManager.getUserRestrictionSource( UserManager.DISALLOW_INSTALL_APPS, Process.myUserHandle()); if ((installAppsRestrictionSource &amp; UserManager.RESTRICTION_SOURCE_SYSTEM) != 0) { showDialogInner(DLG_INSTALL_APPS_RESTRICTED_FOR_USER); return; } else if (installAppsRestrictionSource != UserManager.RESTRICTION_NOT_SET) { startActivity(new Intent(Settings.ACTION_SHOW_ADMIN_SUPPORT_DETAILS)); finish(); return; } // 判断如果允许安装未知来源或者根据Intent判断得出该APK不是未知来源 if (mAllowUnknownSources || !isInstallRequestFromUnknownSource(getIntent())) { initiateInstall(); } else { // 检查未知安装源限制,如果有限制弹出Dialog,显示相应的信息 final int unknownSourcesRestrictionSource = mUserManager.getUserRestrictionSource( UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, Process.myUserHandle()); final int unknownSourcesGlobalRestrictionSource = mUserManager.getUserRestrictionSource( UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, Process.myUserHandle()); final int systemRestriction = UserManager.RESTRICTION_SOURCE_SYSTEM &amp; (unknownSourcesRestrictionSource | unknownSourcesGlobalRestrictionSource); if (systemRestriction != 0) { showDialogInner(DLG_UNKNOWN_SOURCES_RESTRICTED_FOR_USER); } else if (unknownSourcesRestrictionSource != UserManager.RESTRICTION_NOT_SET) { startAdminSupportDetailsActivity(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES); } else if (unknownSourcesGlobalRestrictionSource != UserManager.RESTRICTION_NOT_SET) { startAdminSupportDetailsActivity( UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY); } else { // 处理未知来源的APK handleUnknownSources(); } }} 主要检查安装应用程序的用户限制，当 APK 文件不对或者安装有限制则调用 showDialogInner 方法，弹出 dialog 提示用户，显示相应的错误信息，来看一下都有那些错误信息 // Dialog identifiers used in showDialogprivate static final int DLG_BASE = 0;// package信息错误private static final int DLG_PACKAGE_ERROR = DLG_BASE + 2;// 存储空间不够private static final int DLG_OUT_OF_SPACE = DLG_BASE + 3;// 安装错误private static final int DLG_INSTALL_ERROR = DLG_BASE + 4;// 用户限制的未知来源private static final int DLG_UNKNOWN_SOURCES_RESTRICTED_FOR_USER = DLG_BASE + 5;private static final int DLG_ANONYMOUS_SOURCE = DLG_BASE + 6;// 在wear上不支持private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7;private static final int DLG_EXTERNAL_SOURCE_BLOCKED = DLG_BASE + 8;// 安装限制用户使用的应用程序private static final int DLG_INSTALL_APPS_RESTRICTED_FOR_USER = DLG_BASE + 9; 如果用户允许安装未知来源，会调用 initiateInstall 方法 private void initiateInstall() { String pkgName = mPkgInfo.packageName; // 检查设备上是否存在相同包名的APK String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] { pkgName }); if (oldName != null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] != null) { pkgName = oldName[0]; mPkgInfo.packageName = pkgName; mPkgInfo.applicationInfo.packageName = pkgName; } // 检查package是否已安装, 如果已经安装则显示对话框提示用户是否替换。 try { mAppInfo = mPm.getApplicationInfo(pkgName, PackageManager.MATCH_UNINSTALLED_PACKAGES); if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) == 0) { mAppInfo = null; } } catch (NameNotFoundException e) { mAppInfo = null; } // 初始化确认安装界面 startInstallConfirm();} 根据包名获取应用程序的信息，调用 startInstallConfirm 方法初始化安装确认界面后，当用户点击确认按钮之后发生了什么，接着查看确认按钮点击事件 private void bindUi() { ... // 点击确认按钮，安装APK mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install), (ignored, ignored2) -&gt; { if (mOk.isEnabled()) { if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, true); finish(); } else { // 启动Activity来完成应用的安装 startInstall(); } } }, null); // 点击取消按钮，取消此次安装 mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel), (ignored, ignored2) -&gt; { // Cancel and finish setResult(RESULT_CANCELED); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, false); } finish(); }, null); setupAlert(); mOk = mAlert.getButton(DialogInterface.BUTTON_POSITIVE); mOk.setEnabled(false);} 当用户点击确认按钮调用了 startInstall 方法，启动子 Activity 完成 APK 的安装 private void startInstall() { // 启动子Activity来完成应用的安 Intent newIntent = new Intent(); newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mPkgInfo.applicationInfo); newIntent.setData(mPackageURI); newIntent.setClass(this, InstallInstalling.class); ... if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI); startActivity(newIntent); finish();} startInstall 方法用来跳转到 InstallInstalling，并关闭掉当前的 PackageInstallerActivity 3.3 InstallInstalling主要工作： 向包管理器发送包的信息，然后等待包管理器处理结果 注册一个观察者 InstallEventReceiver，并接受安装成功和失败的回调 在方法 onResume 中创建同步栈，打开安装 session，设置安装进度条 InstallInstalling 首先向包管理器发送包的信息，然后等待包管理器处理结果，并在方法 InstallSuccess 和方法 InstallFailed 进行成功和失败的处理，查看 InstallInstalling 的 onCreate 方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallInstalling.java protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ... // 判断安装的应用是否已经存在 if (&quot;package&quot;.equals(mPackageURI.getScheme())) { try { getPackageManager().installExistingPackage(appInfo.packageName); launchSuccess(); } catch (PackageManager.NameNotFoundException e) { launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); } } else { final File sourceFile = new File(mPackageURI.getPath()); PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, appInfo, sourceFile); ... if (savedInstanceState != null) { // 如果savedInstanceState 不为空，获取已经存在mSessionId 和mInstallId 重新注册 mSessionId = savedInstanceState.getInt(SESSION_ID); mInstallId = savedInstanceState.getInt(INSTALL_ID); try { // 根据mInstallId向InstallEventReceiver注册一个观察者，launchFinishBasedOnResult会接收到安装事件的回调 InstallEventReceiver.addObserver(this, mInstallId, this::launchFinishBasedOnResult); } catch (EventResultPersister.OutOfIdsException e) { } } else { // 如果为空创建SessionParams，代表安装会话的参数 // 解析APK, 并将解析的参数赋值给SessionParams PackageInstaller.SessionParams params = new PackageInstaller.SessionParams( PackageInstaller.SessionParams.MODE_FULL_INSTALL); ... try { // 注册InstallEventReceiver，并在launchFinishBasedOnResult会接收到安装事件的回调 mInstallId = InstallEventReceiver .addObserver(this, EventResultPersister.GENERATE_NEW_ID, this::launchFinishBasedOnResult); } catch (EventResultPersister.OutOfIdsException e) { launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); } try { // createSession 内部通过IPackageInstaller与PackageInstallerService进行进程间通信， // 最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId mSessionId = getPackageManager().getPackageInstaller().createSession(params); } catch (IOException e) { launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); } } ... }} 最终都会注册一个观察者 InstallEventReceiver，并在 launchFinishBasedOnResult 会接收到安装事件的回调，其中 InstallEventReceiver 继承自 BroadcastReceiver，用于接收安装事件并回调给 EventResultPersister createSession 内部通过 IPackageInstaller 与 PackageInstallerService 进行进程间通信，最终调用的是 PackageInstallerService的createSession 方法来创建并返回 mSessionId 接下来在 onResume 方法创建 InstallingAsyncTask 用来执行 APK 的安装，接着查看 onResume 方法 protected void onResume() { super.onResume(); if (mInstallingTask == null) { PackageInstaller installer = getPackageManager().getPackageInstaller(); // 根据mSessionId 获取SessionInfo, 代表安装会话的详细信息 PackageInstaller.SessionInfo sessionInfo = installer.getSessionInfo(mSessionId); if (sessionInfo != null &amp;&amp; !sessionInfo.isActive()) { mInstallingTask = new InstallingAsyncTask(); mInstallingTask.execute(); } else { // 安装完成后会收到广播 mCancelButton.setEnabled(false); setFinishOnTouchOutside(false); } }} 得到 SessionInfo 创建并创建 InstallingAsyncTask，InstallingAsyncTask 的 doInBackground 方法设置安装进度条，并将 APK 信息写入 PackageInstaller.Session，写入完成之后，在 InstallingAsyncTask 的 onPostExecute 进行成功与失败的处理，接着查看 onPostExecute 方法 protected void onPostExecute(PackageInstaller.Session session) { if (session != null) { Intent broadcastIntent = new Intent(BROADCAST_ACTION); broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND); broadcastIntent.setPackage(getPackageName()); broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId); PendingIntent pendingIntent = PendingIntent.getBroadcast( InstallInstalling.this, mInstallId, broadcastIntent, PendingIntent.FLAG_UPDATE_CURRENT); session.commit(pendingIntent.getIntentSender()); mCancelButton.setEnabled(false); setFinishOnTouchOutside(false); } else { getPackageManager().getPackageInstaller().abandonSession(mSessionId); if (!isCancelled()) { launchFailure(PackageManager.INSTALL_FAILED_INVALID_APK, null); } }} 创建了 broadcastIntent，并通过 PackageInstaller.Session 的 commit 方法发送出去，通过 broadcastIntent 构造方法指定的 Intent 的 Action 为 BROADCAST_ACTION，而 BROADCAST_ACTION 是一个常量值 private static final String BROADCAST_ACTION = &quot;com.android.packageinstaller.ACTION_INSTALL_COMMIT&quot;; 回到 InstallInstalling.OnCreate 方法，在 OnCreate 方法注册 InstallEventReceiver，而 InstallEventReceiver 继承自 BroadcastReceiver，而使用 BroadcastReceiver 需要在 AndroidManifest.xml注册，接着查看 AndroidManifest.xml：/frameworks/base/packages/PackageInstaller/AndroidManifest.xml &lt;receiver android:name=&quot;.InstallEventReceiver&quot; android:permission=&quot;android.permission.INSTALL_PACKAGES&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;com.android.packageinstaller.ACTION_INSTALL_COMMIT&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 安装结束之后，会在观察者 InstallEventReceiver 注册的回调方法 launchFinishBasedOnResult 处理安装事件的结果，接着查看 launchFinishBasedOnResult private void launchFinishBasedOnResult(int statusCode, int legacyStatus, String statusMessage) { if (statusCode == PackageInstaller.STATUS_SUCCESS) { launchSuccess(); } else { launchFailure(legacyStatus, statusMessage); }}private void launchSuccess() { Intent successIntent = new Intent(getIntent()); successIntent.setClass(this, InstallSuccess.class); successIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); startActivity(successIntent); finish();} private void launchFailure(int legacyStatus, String statusMessage) { Intent failureIntent = new Intent(getIntent()); failureIntent.setClass(this, InstallFailed.class); failureIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); failureIntent.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, legacyStatus); failureIntent.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, statusMessage); startActivity(failureIntent); finish();} 安装成功和失败，都会启动一个新的 Activity（InstallSuccess、InstallFailed）将结果展示给用户，然后 finish 掉 InstallInstalling 4. 总结总结一下 PackageInstaller 安装APK的过程： 根据根据 Uri 的 Scheme 找到入口 InstallStart InstallStart 根据 Uri 的 Scheme 协议不同做不同的处理 都会调用 PackageInstallerActivity, 然后分别对package协议和 file 协议的 Uri 进行处理 PackageInstallerActivity 检查未知安装源限制,如果安装源限制弹出提示 Dialog 点击 OK 按钮确认安装后，会调用 startInstall 开始安装工作 如果用户允许安装，然后跳转到 InstallInstalling，进行 APK 的安装工作 在 InstallInstalling 中，向包管理器发送包的信息，然后注册一个观察者 InstallEventReceiver，并接受安装成功和失败的回调 5. 关于 packages.xml在 Andorid 系统目录 “/data/system” 下保存很多系统文件，主要介绍 packages.xml 文件 packages.xml：记录了系统中所有安装的应用信息，包括基本信息、签名和权限、APK 文件的路径、native 库的存储路径 系统启动的时候会通过 PackageManagerServcie 读取这个文件加载系统中所有安装的应用，这个文件在开发中也是非常有帮助的，不同厂商会对 Android 源码有不同的修改，如果我们需要分析系统 App 的源码，就通过这个 packages.xml 找到目标 APK，dump 出来分析源码 以下是 packages.xml 文件部分内容 &lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;packages&gt; &lt;version sdkVersion=&quot;27&quot; databaseVersion=&quot;3&quot; fingerprint=&quot;Meizu/meizu_M1822_CN/M1822:8.1.0/OPM1.171019.026/1539943691:user/release-keys&quot; /&gt; &lt;version volumeUuid=&quot;primary_physical&quot; sdkVersion=&quot;27&quot; databaseVersion=&quot;27&quot; fingerprint=&quot;Meizu/meizu_M1822_CN/M1822:8.1.0/OPM1.171019.026/1539943691:user/release-keys&quot; /&gt; &lt;meizu_version meizu_fingerprint=&quot;8.1.0-1541573178_stable&quot; /&gt; &lt;permission-trees /&gt; &lt;permissions&gt; &lt;item name=&quot;com.meizu.voiceassistant.push.permission.MESSAGE&quot; package=&quot;com.meizu.voiceassistant&quot; protection=&quot;2&quot; /&gt; &lt;item name=&quot;com.meizu.safe.alphame.permission.DATA&quot; package=&quot;com.meizu.safe&quot; protection=&quot;18&quot; /&gt; &lt;item name=&quot;android.permission.REAL_GET_TASKS&quot; package=&quot;android&quot; protection=&quot;18&quot; /&gt; ...... &lt;item name=&quot;android.permission.MODIFY_PHONE_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.WAKE_LOCK&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;1&quot; /&gt; &lt;/package&gt; &lt;package name=&quot;com.android.providers.telephony&quot; codePath=&quot;/system/priv-app/TelephonyProvider&quot; nativeLibraryPath=&quot;/system/priv-app/TelephonyProvider/lib&quot; primaryCpuAbi=&quot;arm64-v8a&quot; publicFlags=&quot;1007402501&quot; privateFlags=&quot;8&quot; ft=&quot;11e8dc5d800&quot; it=&quot;11e8dc5d800&quot; ut=&quot;11e8dc5d800&quot; version=&quot;27&quot; sharedUserId=&quot;1001&quot; isOrphaned=&quot;true&quot; forceFull=&quot;true&quot;&gt; &lt;sigs count=&quot;1&quot;&gt; &lt;cert index=&quot;0&quot; /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=&quot;android.permission.SEND_RECEIVE_STK_INTENT&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.BIND_INCALL_SERVICE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; ...... &lt;item name=&quot;android.permission.UPDATE_APP_OPS_STATS&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;1&quot; /&gt; &lt;/package&gt; 5.1. package 表示包信息 name 表示应用的包名 codePath 表示的是 APK 文件的路径 nativeLibraryPath 表示应用的 native 库的存储路径 it 表示应用安装的时间 ut 表示应用最后一次修改的时间 version 表示应用的版本号 userId 表示所属于的 id 5.2. sign 表示应用的签名 count 表示标签中包含有多少个证书 cert 表示具体的证书的值 5.3. perms 表示应用声明使用的权限，每一个子标签代表一项权限6. 安利一个在线查看 Android 源码网站aospxref 是 weishu 大神搭建一个在线查看在线查看 Android源码网站, 访问速度非常快 在这之前我常用的在线查看 Android 源码的网站 androidxref，访问速度不仅慢，而且更新也不及时，现在 Android 10 发布了，这个网站到现在提供的最新的代码还是 Andorid 9 aospxref 提供了与 androidxref 完全一样的源码浏览和交叉索引功能；除此之外，它还有一些别的优点： 跟随 Android 版本更新，你永远可以看到最新的源代码。 服务器在阿里云，国内访问速度贼快。 opengrok 版本较高，查阅代码时会有自动提示。 对页面做过部分优化，使用更便捷；比如可以在任意界面跳转到首页。 参考 Android包管理总结 安利一个看 Android 源代码的网站 Android 权限 Android包管理机制（一）PackageInstaller的初始化","link":"/2020/06/07/android10/package-manager/02-APK-install/"},{"title":"0xA01 Android 10 源码分析：APK 是如何生成的","text":"前言 这是 Android 10 源码分析系列的第 1 篇 分支：android-10.0.0_r14 全文阅读大概 5 分钟 在 Android Studio 中直接点击 Run ‘app’ 就可以在 build/outputs/apk 生成可以在 android 设备中安装的 APK 文件，那么 APK 生成的过程是怎么样的呢？ APK 文件大概可以分为两个部分：代码和资源，所以打包的也分为代码和资源两个部分，我们可以根据 Google提供的流程图 来具体了解一个 APK 的构建过程 新版构建流程图 APK 打包的内容主要有：应用模块也就是自己开发的用到的源代码、资源文件、aidl 接口文件，还有就是依赖模块即源代码用到的第三方依赖库如：aar、jar、so 文件 为了能够清楚的了解 APK 是如何生成的, 来看一下老版构建流程图 老版构建流程图 在了解 APK 生成的过程之前，我们需要了解一下图中各个工具的作用 工具 名字 功能 AAPT/APT2 Android 资源打包工具 AIDL 将所有的 AIDL 接口转化为 Java 接口 Javac(Java Compiler) 将所有的 Java 代码编译成 Class文件 Dex 将 Class 文件编译成 Dex 文件 Apkbuilder 将处理后的资源和代码打包生成 APK 文件 Jarsigner/Apksigner 对未签名的 APK 文件进行签名 Zipalign 优化签名后的 APK，减少运行时所占用的内存 构建过程1. 使用 AAPT 工具生成 R.java 文件AAPT（Android Asset Packaging Tool）android 资源打包工具，将资源文件（包括AndroidManifest.xml、布局文件、各种 xml 资源等）打包生成 R.java 文件，将 AndroidManifest.xml 生成二进制的 AndroidManifest.java 文件 aapt p -M AndroidManifest.xml -S output/res/ -I android.jar -J ./ -F input/out.apkp：打包-M：AndroidManifest.xml 文件路径-S：res 目录路径-A：assets 目录路径-I：android.jar 路径，会用到的一些系统库-J 指定生成的 R.java 的输出目录-F 具体指定 APK 文件的输出 但是从 Android Studio 3.0 开始，google 默认开启了 AAPT2 作为资源编译的编译器，AAPT2 的出现为资源的增量编译提供了支持，aapt2 主要分两步，compile 和 link compile aapt2 compile -o res.apk --dir output/res/-o：指定已编译资源的输出路径--dir：指定包含多个资源文件的资源目录 link aapt2 link -o input/out.apk -I tools/android.jar --manifest output/AndroidManifest.xml -A res.apk --java ./-o：指定链接的资源 APK 的输出路径-I：指定 android.jar 路径--manifest：指定 AndroidManifest.xml 路径--java ：指定要在其中生成 R.java 的目录 2. 所有的 AIDL 接口转化为 Java 接口使用 AIDL（Android Interface Denifition Language），位于 sdk\\build-tools 目录下的 aidl 工具，将源码文件、aidl 文件、framework.aidl 等所有的 AIDL 文件，生成相应的 Java 文件，命令如下： aidl -Iaidl -pAndroid/Sdk/platforms/android-29/framework.aidl -obuild aidl/com/android/vending/billing/IInAppBillingService.aidl-I 指定 import 语句的搜索路径，注意 -I 与目录之间一定不要有空格-p 指定系统类的 import 语句路径，如果是要用到 android.os.Bundle 系统的类，一定要设置 sdk 的 framework.aidl 路径-o 生成 java 文件的目录，注意 -o 与目录之间一定不要有空格，而且这设置项一定要在 aidl 文件路径之前设置 3. 将 Java 代码编译成 Class 文件使用 Javac（Java Compiler）把项目中所有的 Java 代码编译成 class 文件, 包括 Java 源文件、AAPT 生成的 R.java 文件 以及 aidl 生成的 Java 接口文件，命令如下： javac -target 1.8 -bootclasspath platforms/android-28/android.jar -d ./java/com/testjni/*.java 4. 将 Class 文件编译成 Dex 文件使用 DX 工具将所有的 Class 文件（包括第三方库中的 class 文件）转换成 Dex 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），该过程主要完成 Java 字节码转换成 Dalvik 字节码, 命令如下： java -jar dx.jar --dex --ouput=classes.dex ./java/com/testjni/*.class--dex：将 class 文件转成dex文件--output：指定生成 dex 文件到具体位置 5. 打包生成 APK 文件使用 Apkbuilder（主要用到的是 sdk/tools/lib/sdklib.jar 文件中的 ApkBuilderMain 类）将所有的 Dex 文件、Resource.arsc、Res 文件夹、Assets 文件夹、AndroidManifest.xml 打包生成 APK 文件（未签名） 6. 对 APK 文件签名使用 Apksigner（Android官方针对 APK 签名及验证工具）或 Jarsigner（JDK提供针对 jar 包签名工具）对未签名的 APK 文件进行签名 ps：如果使用 Apksigner 签名需要（7. 优化 APK 文件）放到（6. 对 APK 文件签名）签名前面，为什么？请查看关于 Apksigner 和 Jarsigner 的区别，请移步到文末 7. 优化 APK 文件使用 zipalign 对签名后的 APK 文件进行对齐处理，对齐的主要过程是将 APK 包中所有的资源文件距离文件起始偏移为 4 字节整数倍，这样通过内存映射访问 APK 文件时的速度会更快，减少其在设备上运行时所占用的内存 总结上述打包过程都是 AndroidStudio 编译时，调用各种编译命令自动完成的, 总结一下上述打包过程： 除了 assets 和 res/raw 资源被原装不动地打包进 APK 之外，其它的资源都会被编译或者处理 除了 assets 资源之外，其它的资源都会被赋予一个资源 ID 打包工具负责编译和打包资源，编译完成之后，会生成一个 resources.arsc 文件和一个 R.java，前者保存的是一个资源索引表，后者定义了各个资源 ID 常量 应用程序配置文件 AndroidManifest.xml 同样会被编译成二进制的 xml 文件，然后再打包到 APK 里面去 应用程序在运行时通过 AssetManager 来访问资源，或通过资源 ID 来访问，或通过文件名来访问 APK 文件大概可以分为两个部分：代码和资源, 代码部分通过 Javac 将 Java 代码编译成 Class 文件, 然后通过 DX 工具将 Class 文件编译成 Dex 文件，接下来我们主要来分析一下资源的编译和打包 资源的编译和打包在分析资源的编译和打包之前，我们需要了解一下 Android 都有哪些资源，其实 Android 资源大概分为两个部分：assets 和 res 1. assets 资源assets 资源放在 assets 目录下，它里面保存一些原始的文件，可以以任何方式来进行组织，这些文件最终会原封不动的被打包进 APK 文件中，通过 AssetManager 来获取 asset 资源，代码如下 AssetManager assetManager = context.getAssets();InputStream is = assetManager.open(&quot;fileName&quot;); 2. res 资源res 资源放在主工程的 res 目录下，这类资源一般都会在编译阶段生成一个资源ID供我们使用，res 目录包括 animator、anim、 color、drawable、layout、menu、raw、values、xml 等 上述资源文件除了 raw 类型资源，以及 drawable 文件夹下的 Bitmap 资源之外，其它的资源文件均会被编译成二进制格式的 XML 文件，生成的二进制格式的 XML 文件分别有一个字符串资源池，用来保存文件中引用到的每一个字符串 这样原来在文本格式的 XML 文件中的每一个放置字符串的地方在二进制格式的XML文件中都被替换成一个索引到字符串资源池的整数值，将整数值保存在 R.java 类中，R.java 会和其他源文件一起编译到 APK 中去 将资源编译成二进制文件，都是由 AAPT 工具来完成的，资源打包主要有以下几个流程： 解析 AndroidManifest.xml，获得应用程序的包名称，创建资源表 添加被引用资源包，被添加的资源会以一种资源 ID 的方式定义在 R.java 中 资源打包工具创建一个 AaptAssets 对象，收集当前需要编译的资源文件，收集到的资源保存在 AaptAssets 对象对象中 将上一步 AaptAssets 对象保存的资源，添加到资源表 ResourceTable 中去，用于最终生成资源描述文件 resources.arsc 编译 values 类资源，这类资源包括数组、颜色、尺寸、字符串等值 给 style、array 这类资源分配资源 ID 编译 XML 资源文件，编译的流程分为：① 解析 XML 文件 ② 赋予属性名称资源 ID ③ 解析属性值 ④ 将 XML 文件从文本格式转换为二进制格式 生成资源索引表 resources.arsc 2.1 资源 IDAAP 工具会所有的资源都会生成一个 R.java 文件，并且每个资源都对应 R.java 中的十六进制整数变量，其实这些十六进制的整数是由三部分组成：PackageId + TypeId + ItemValue，代码所示： public final class R { public static final class anim { public static final int abc_fade_in=0x7f010000; public static final int abc_fade_in=0x7f010001; //*** } public static final class string { public static final int a11y_no_data=0x7f100000; public static final int a11y_no_permission=0x7f100001; //*** }} 最高字节是 Package ID 表示命名空间，标明资源的来源，Android 系统自己定义了两个 Package ID，系统资源命名空间：0x01 和 应用资源命名空间：0x7f 正因为应用资源命名空间：0x7f，我们在做插件化的时候就会出现一个问题，宿主和插件包，合并资源后资源 ID 冲突。通过上面分析要解决这个问题，就要为不同的插件设置不同的 PackageId，而宿主可以保留原来 0x7f 不变，这样就永远不会有冲突发生了 如何解决资源冲突 制定一个不用冲突的命名规范 library Module 的 build.gradle 中设置资源前缀(推荐) android { resourcePrefix &quot;&lt;前缀&gt;&quot; }2.2 资源索引(resources.arsc)最终生成的是资源索引表 resources.arsc ，resources.arsc 是一个编译后的二进制文件, 在 AndroidStudio 打开 resources.arsc 文件，如下所示 Android 正是利用这个索引表根据资源 ID 进行资源的查找，为不同语言、不同地区、不同设备提供相对应的最佳资源。查找和通过 Resources 和 AssetManger 来完成的 在文中提到了两个工具 Apksigner 和 Jarsigner，下面一起来了解一下 Apksigner 和 Jarsigner 的区别 Apksigner 和 Jarsigner 的区别在 Android Studio 中点击菜单 Build-&gt;Generate signed apk… 打包签名过程中,可以看到两种签名选项 V1(Jar Signature) 和 V2(Full APK Signature) Jarsigner 是 JDK 提供的针对 JAR 包签名的通用工具 Apksigner 是 Google 官方提供的针对 Android APK 签名及验证的专用工具 从Android 7.0 开始, 谷歌增加新签名方案 V2 Scheme (APK Signature)，但Android 7.0 以下版本, 只能用旧签名方案 V1 scheme (JAR signing) V1(Jar Signature)签名: 来自 JDK(Jarsigner)，对 ZIP 压缩包的每个文件进行验证, 签名后还能对压缩包修改(移动/重新压缩文件)，对 V1 签名的 APK/JAR 解压,在 META-INF 存放签名文件(MANIFEST.MF, CERT.SF, CERT.RSA), 其中 MANIFEST.MF 文件保存所有文件的 SHA1 指纹(除了 META-INF 文件), 由此可知: V1 签名是对压缩包中单个文件签名验证 V2(Full APK Signature)签名: 来自 Google(apksigner), 对 ZIP 压缩包的整个文件验证, 签名后不能修改压缩包(包括 zipalign), 对 V2 签名的 APK 解压, 没有发现签名文件, 重新压缩后 V2 签名就失效, 由此可知: V2 签名是对整个 APK 签名验证 创建发布密钥库，请参阅在 Android Studio 中为应用签名 总结 V1 签名是对压缩包中单个文件签名验证 V2 签名是对整个 APK 签名验证 zipalign 可以在 V1 签名后执行 zipalign 不能在 V2 签名后执行,只能在 V2 签名之前执行 V2 签名更安全(不能修改压缩包) V2 签名验证时间更短(不需要解压验证), 因而安装速度加快 注意: apksigner 工具默认同时使用 V1 和 V2 签名,以兼容 Android 7.0 以下版本 参考文献 Google的 Apk 构建流程 Android Studio 中为应用签名 AAPT2","link":"/2020/06/07/android10/package-manager/01-APK-generate/"},{"title":"剑指 Offer 19：删正则表达式匹配","text":"题目来源于 LeetCode 剑指 offer 第 19 号问题： 正则表达式匹配。题目难度为 Hard。 中文地址：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/ 题目描述请实现一个函数用来匹配包含 . 和 * 的正则表达式。模式中的字符 . 表示任意一个字符，而 * 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 aaa 与模式 a.a 和 ab*ac*a 匹配，但与 aa.a 和 ab*a 均不匹配。 示例 1： 输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2： 输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。 示例 3： 输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4： 输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5： 输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 说明： s 可能为空，且只包含从 a-z 的小写字母 p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 * 思路：注意： 假设输入的字符串 s = &quot;aab&quot; 和 p = &quot;c*a*b&quot;，其中 c* 或者 a* 它们是一个整体，例如 c* 可以是 0 个 c ，也可以是多个 c。 字符 .* 可以表示任意字符（0 个或者多个） 算法流程如下： 假设主串为 s，模式串为 p，需要关注正则表达式 p 的最后一个字符是谁，它有三种可能： p[j-1] = 正常字符 p[j-1] = '.' p[j-1] = '*' 只需要针对上面三种情况讨论即可 情况一：p[j-1] = 正常字符 需要看最后一个字符串是否相等: 如果相等的话，就要匹配前面的字符串是否相等， 即 s[i-1] == p[j-1] 公式为 dp[i][j] = dp[i-1][j-1] 如果不相等的话，就要看最后一个字符串是 . 还是 * 情况二：p[j-1] = ‘.’ 字符 . 是万能字符，可以直接让它等于 s[i-1]，同情况一处理 dp[i][j] = dp[i-1][j-1] 情况三：p[j-1] = ‘*’ 字符 * 可以匹配 0 个或多个前面的字符，而是否能取 0 个或者多个字符，需要看前面的 p[j-2] 是否等于 s[i-1] 当 p[j-2] != s[i-1] 如果它们不相等，则最后两个字符废掉了，即 dp[i][j] = dp[i][j-2] 当 p[j-2] == s[i-1] 或者 p[j-2] = '.' 字符 * 可以匹配 0 个或多个前面的字符，p[j-2] = '.' 可以直接让它等于 s[i-1] 取 0 个字符 例如：s = aab, p = aabb，虽然 j-2 和 i-1 相等，但是 dp[i][j-2] 已经匹配了，直接删除 j-1 和 j-2，即 dp[i][j] = dp[i][j-2] 取 1 个字符 例如：s = aab, p = aab，取1个字符，相当于去掉 p[j-1]，即 dp[i][j] = dp[i][j-1] 取多个字符 例如：s = aabb, p = aab，需要判断 s = aab 和 p = aab 是否匹配，如果可以匹配，那么 s 后面再加上一个 b 也没关系，因为 * 可以变成多个 b，即 dp[i][j] = dp[i-1][j] 总结： 情况一 和 情况二，可以当做一种情况来处理，即 val ms = s[i - 1]val mp = p[j - 1]if (mp == ms || mp == '.') { dp[i][j] = dp[i - 1][j - 1]} 无论 p[j-2] 是否等于 s[i-1]，都可以删除掉最后两个字符 dp[i][j] = dp[i][j] || dp[i][j - 2] 当 p[j-2] == s[i-1] 或者 p[j-2] = '.' 可以取 1 个或者多个字符 val mpLast = p[j - 2]if (ms == mpLast || mpLast == '.') { dp[i][j] = dp[i - 1][j] || dp[i][j - 1]} 初始化 空串和空正则是匹配的，即 dp[0][0] = true 需要初始化第一行，当 p[i-1] 为 * 可以把 i-2 和 i-1 处的字符删掉，并且只有 [0, i-3] 为 true 才可以让 dp[0][i] = true 复杂度分析： M 是字符串 s 的长度， N 是字符串 p 的长度 时间复杂度：O(MN) ，需要遍历每个字符进行匹配，即时间复杂度为 O(MN) 空间复杂度：O(MN)，需要建立数组 dp 保存匹配的结果 Kotlin 实现class Solution { fun isMatch(s: String, p: String): Boolean { val row = s.length val colum = p.length val dp = Array(row + 1) { BooleanArray(colum + 1) } dp[0][0] = true; for (i in 1..colum) { if (p[i - 1] == '*' &amp;&amp; dp[0][i - 2]) { dp[0][i] = true } } for (i in 1..row) { for (j in 1..colum) { val ms = s[i - 1] val mp = p[j - 1] if (mp == ms || mp == '.') { dp[i][j] = dp[i - 1][j - 1] } else if (mp == '*') { if (j &lt; 2) continue val mpLast = p[j - 2] if (ms == mpLast || mpLast == '.') { dp[i][j] = dp[i - 1][j] || dp[i][j - 1] } dp[i][j] = dp[i][j] || dp[i][j - 2] } } } return dp[row][colum] }} Java 实现class Solution { public boolean isMatch(String s, String p) { if (s == null || p == null) { return false; } int row = s.length(); int colum = p.length(); boolean[][] dp = new boolean[row + 1][colum + 1]; dp[0][0] = true; for (int j = 1; j &lt;= colum; j++) { if (p.charAt(j - 1) == '*' &amp;&amp; dp[0][j - 2]) { dp[0][j] = true; } } for (int i = 1; i &lt;= row; i++) { for (int j = 1; j &lt;= colum; j++) { char ms = s.charAt(i - 1); char mp = p.charAt(j - 1); /** * 两种情况 * 和 非* */ if (ms == mp || mp == '.') { // 非* dp[i][j] = dp[i - 1][j - 1]; } else if (mp == '*') { // 遇到 * 号，则代码 P[m−2]=c 可以重复0次或多次，它们是一个整体 c* if (j &lt; 2) continue; char mpLast = p.charAt(j - 2); if (mpLast == ms || mpLast == '.') { dp[i][j] = dp[i - 1][j] || dp[i][j - 1]; } // P[n−1] 是 0 个 c，P 最后两个字符废了 dp[i][j] = dp[i][j] || dp[i][j - 2]; } } } return dp[row][colum]; }}","link":"/2020/08/08/LeetCode/offer/2020-08-08/"},{"title":"剑指 Offer 18：删除链表的节点","text":"题目来源于 LeetCode 剑指 offer 第 18 号问题： 删除链表的节点。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof 题目描述给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 示例 1： 输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2： 输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 思路：如何删除节点： 假设 current 指向 head 节点，tmpNode 为要删除的节点，算法如下 val tmpNode = current.next;current.next = tmpNode.next 算法流程如下： current 指向 head 节点 如果 head == null 即返回 head 节点 如果头节点是要删除的节点，即 head.val == val 返回 head.next, 删除头节点 循环遍历下一个节点是否为空 while (current?.next != null) { ... } 判断下一个节点是否是要删除的节点，如果是则调用删除节点算法 val tmpNode = current.next;current.next = tmpNode.next 循环遍历结束，返回 head 节点 复杂度分析： 时间复杂度：O(N) ，N 为链表长度，假设要删除的节点在末尾，即时间复杂度为 O(N) 空间复杂度：O(1)，current 占用常数大小的空间，可以不用计算，即空间复杂度为 O(1) Kotlin 实现class Solution { fun deleteNode(head: ListNode?, `val`: Int): ListNode? { if (head == null) return head if (head.`val` == `val`) return head.next var current = head while (current?.next != null) { val tmpNode = current.next; if (tmpNode.`val` == `val`) { current.next = tmpNode.next break; } current = tmpNode } return head }} Java 实现class Solution { public ListNode deleteNode(ListNode head, int val) { if (head == null) return head; if (head.val == val) return head.next; ListNode current = head; while (current.next != null) { ListNode tmp = current.next; if (tmp.val == val) { current.next = tmp.next; break; } current = tmp; } return head; }}","link":"/2020/08/06/LeetCode/offer/18-shan-chu-lian-biao-de-jie-dian/"},{"title":"剑指 Offer 17：打印从1到最大的n位数","text":"题目来源于 LeetCode 剑指 offer 第 17 号问题： 打印从1到最大的n位数。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/ 题目描述输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1： 输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 说明： 用返回一个整数列表来代替打印 n 为正整数 思路一：由于本题要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内，但是在实际面试过程中，面试官肯定会考大数，也就意味着会越界。 算法流程如下： 如果考大数的话，无论 int 还是 long 类型它们的取值范围都是有限的，因此只能使用字符串 String 类型。 result 表示一个整数列表，num 存储生成的字符串，x 表示当前所在位数，假设 n = 2 时，生成 1 ~ 99 的全排列流程如下： 从下标 x = 0 开始，先固定十位为 0 ~ 9 x = x + 1, 开始递归遍历个位为 0 ~ 9 当 x == n 时，递归遍历结束 复杂度分析： n 表示需要生成数字的位数 时间复杂度：O(10^n) ，递归生成的数字的排列个数为 10^n 空间复杂度：O(n)，字符串 num 使用线性排列 Kotlin 实现class Solution { val defNum = charArrayOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9'); var index = 0; fun printNumbers(n: Int): IntArray { val num = CharArray(n) var max = 1 // kotlin 中使用 Math.pow 要求参数都是double类型，所以这里自动生成对应的位数 for (i in 1..n) { max = max * 10; } val result = IntArray(max - 1) dfs(num, result, 0) // 开始递归遍历 return result; } fun dfs(num: CharArray, result: IntArray, x: Int) { if (x == num.size) { // 生成的数字前面可能有 0 例如：000,001,002... 等等 // parstInt 方法删除高位多余的 0 val res = parstInt(num); // 过滤掉第一个数字 0 if (res &gt; 0) { result[index] = res index = index + 1 } return; } for (c in defNum) { num[x] = c dfs(num, result, x + 1) } } fun parstInt(num: CharArray): Int { var sum = 0 var isNotZero = false for (c in num) { // 生成的数字前面可能有 0 例如：000,001,002... 等等 // 过滤掉高位多余的 0 if (!isNotZero) { if (c == '0') { continue } else { isNotZero = true } } sum = sum * 10 + (c - '0') } return sum; }} Java 实现public class Solution { char[] defNum = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; int index = 0; public int[] printNumbers(int n) { char[] num = new char[n]; int[] result = new int[(int) Math.pow(10, n) - 1]; dfs(num, result, 0); // 开始递归遍历 return result; } public void dfs(char[] num, int[] result, int x) { if (x == num.length) { // 生成的数字前面可能有 0 例如：000,001,002... 等等 // parstInt 方法删除高位多余的 0 int res = parseInt(num); // 过滤掉第一个数字 0 if (res &gt; 0) { result[index++] = res; } return; } for (char c : defNum) { num[x] = c; dfs(num, result, x + 1); } } public int parseInt(char[] num) { int sum = 0; boolean isNotZero = false; for (char c : num) { // 生成的数字前面可能有 0 例如：000,001,002... 等等 // 过滤掉高位多余的 0 if (!isNotZero) { if (c == '0') { continue; } else { isNotZero = true; } } sum = sum * 10 + (c - '0'); } return sum; }} 思路二：思路二比较简单，题目要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内。 假设 n = 2 时，生成 1 ~ 99，数字范围等价于 [1, 100 -1] , 最大取值相当于 Math.pow(10, n) - 1 也可以循环生成最大取值，如下所示 var max = 1;for (i in 1..n) { max = max * 10;} Kotlinclass Solution { fun printNumbers(n: Int): IntArray { var max = 1; for (i in 1..n) { max = max * 10; } val result = IntArray(max - 1) for (i in 1 until max) { result[i - 1] = i } return result; }} Javapublic class Solution { public int[] printNumbers(int n) { int max = 1; for (int i = 1; i &lt;= n; i++) { max = max * 10; } int[] result = new int[max - 1]; for (int i = 1; i &lt; max; i++) { result[i - 1] = i; } return result; }}","link":"/2020/08/05/LeetCode/offer/17-da-yin-cong-1dao-zui-da-de-nwei-sh/"},{"title":"剑指 Offer 16：数值的整数次方","text":"题目来源于 LeetCode 剑指 offer 第 16 号问题：数值的整数次方。题目难度为 Medium。和第 50 号问题 相同 中文地址：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/ 50 号问题-英文地址：https://leetcode.com/problems/powx-n/ 50 号问题-中文地址：https://leetcode-cn.com/problems/powx-n/ 题目描述实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例 1： 输入: 2.00000, 10输出: 1024.00000 示例 2： 输入: 2.10000, 3输出: 9.26100 示例 3： 输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明： -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。 思路：这到题用到了位运算符，我们先来回顾一下： x &gt;&gt; 1 等价于 (x = x / 2)x &lt;&lt; 1 等价于 (x = x * 2)x &amp; 1 等价于 (x % 2 == 1) 以下图片来自 LeetCode 社区 算法流程如下： x 表示整数， m 表示平方，res 累计结果 当 x == 0 时，返回 0 ，避免后续的 x = 1 / x 出错 当 x &lt; 0 时，需要转为 x &gt;= 0，在这个范围内求解，即 x = 1 / x; m *= -1 初始化 res 为 1 循环计算，当 m == 0 时跳出循环 当 (m &amp; 1) == 1 时，即 res = res * x 执行 x = x * x 将 m 右移 1 位，即 m = m &gt;&gt; 1 注意： m 可以取到 -2147483648（整型负数的最小值），执行 m *= -1; 会因越界而出错，所以需要将 m 转换成 long 型 复杂度分析： 时间复杂度：O(log2^n) ，2 分查找时间复杂度为对数级别 空间复杂度：O(1)，需要几个变量，占常数大小的空间 Kotlin 实现class Solution { fun myPow(x: Double, n: Int): Double { if (x == 0.0) return 0.0 var x1 = x var res = 1.0 var m = n.toLong() if (m &lt; 0) { x1 = 1 / x1 m = -1 * m } while (m &gt; 0) { if ((m % 2).toInt() == 1) res = res * x1 x1 = x1 * x1 m = m / 2 } return res }} Java 实现class Solution { // x &gt;&gt; 1 ==&gt; (x = x / 2) // x &lt;&lt; 1 ==&gt; (x = x * 2) // x &amp; 1 ==&gt; (x % 2 == 1) public double myPow(double x, int n) { if (x == 0) return 0; long m = n; double res = 1.0; if (m &lt; 0) { x = 1 / x; m *= -1; } while (m &gt; 0) { if ((m &amp; 1) == 1) res = res * x; x = x * x; m = m &gt;&gt; 1; } return res; }}","link":"/2020/07/27/LeetCode/offer/16-shu-zhi-de-zheng-shu-ci-fang/"},{"title":"剑指 Offer 15：二进制中 1 的个数","text":"题目来源于 LeetCode 剑指 offer 第 15 号问题：二进制中 1 的个数。题目难度为 Easy。和第 191 号问题（位1的个数） 相同 中文地址：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/ 191 号问题-英文地址：https://leetcode.com/problems/number-of-1-bits/ 191 号问题-中文地址：https://leetcode-cn.com/problems/number-of-1-bits/ 题目描述编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量） 示例 1： 输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 思路：位运算：我们先来回顾一下基本的位运算规则： 或运算（|）： 两位同时为 0，结果为 0，否则为 1 0 | 0 = 0； 0 | 1 = 1； 1 | 0 = 1； 1 | 1 = 1 与运算符（&amp;）： 两位同时为 1，结果为 1，否则为 0 0 &amp; 0 = 0; 0 &amp; 1 = 0; 1 &amp; 0 = 0; 1 &amp; 1 = 1; 异或运算： 两个相应位 值不同 时，结果为 1，否则为 0. 0 ^ 0 = 0； 0 ^ 1 = 1； 1 ^ 0 = 1； 1 ^ 1 = 0； 取反运算符（~）： 对一个二进制数按位取反，即将 0 变 1，1 变 0。 ~1 = 0； ~0 = 1； 如上所示根据位运算规则，我们可以利用 与运算符（&amp;） 来解。 1 &amp; 1 = 1 1 &amp; 0 = 0 变量声定义： result 用来存储累加的结果 n 为无符号整数 我们可以逐位循环判断，算法流程如下： 初始化 result 为 0 当 n == 0 时即循环结束 将 n &amp; 1 的结果，累加到 result 上，故 result += n &amp; 1 n 为无符号整数，所以将 n 无符号右移动 1 位，故 n = n &gt;&gt;&gt; 1 复杂度分析： 时间复杂度：O(log2^n) ，其中 n 代表最高位 1 所在的位数 空间复杂度：O(1)，需要一个额外的变量 result 来存储累加结果，result 占了一个常数大小的空间 Java 实现public class Solution { public int hammingWeight(int n) { int result = 0; while (n != 0) { result += n &amp; 1; n = n &gt;&gt;&gt; 1; } return result; }}","link":"/2020/07/19/LeetCode/offer/15-er-jin-zhi-zhong-1de-ge-shu-lcof/"},{"title":"剑指 Offer 14-2：剪绳子","text":"题目来源于 LeetCode 剑指 offer 第 14-2 号问题：剪绳子。题目难度为 Medium。和第 343 号问题（整数拆分） 相同 中文地址：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/ 整数拆分-英文地址：https://leetcode.com/problems/integer-break/ 整数拆分-中文地址：https://leetcode-cn.com/problems/integer-break/ 题目描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0] * k[1] * ... * k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2： 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 1000 思路：注意： 题目说了要做取模运算，凡是这种题，一定要注意精度问题。 一绳子长度为 n，假设这条绳子被分为 2 段或者 3 段。按照经验切分成 3 段比切分成 2 段的乘积要大，但是也有少数情况切分成 2 段比 3 段乘积大。 例如 n = 6, 2 段 3x3 比 3 段 2 x 2 x 2 要大 故所以我们列出所有的可能性寻找规律： 绳子长度为 n 计算方式 结果 2 1 + 1 ——&gt; 1 x 1 dp[2] = 1 3 1 + 2 ——&gt; 1 x 2 dp[3] = 2 4 2 + 2 ——&gt; 2 x 2 dp[4] = 4 5 2 + 3 = 1 + 4 ——&gt; 2 + 3 &gt; 1 + 4 dp[5] = 6 6 3 + 3 = 2 + 2+ 2 ——&gt; 3 x 3 &gt; 2 x 2 x 2 dp[6] = 9 7 3 + 4 ——&gt; 3 x dp[7-3] dp[7] = 12 8 3 + 5 ——&gt; 3 x dp[8-3] dp[8] = 18 当 n &gt;= 7 时可转化为多个短绳（长度 1~6）；其结果满足公式为 dp [n] = (dp[n - 3] * 3) % 1000000007 复杂度分析： 时间复杂度：O(N)，长度为 N 的绳子，需要计算 [1,n] 累计的最大值，故时间复杂度为 O(N) 空间复杂度：O(N)，需要建立长度为 N 的数组，存储每次计算的值，所以空间复杂度为 O(N) Koltin 实现class Solution { fun cuttingRope(n: Int): Int { val dp = LongArray(if (n &lt; 7) 8 else n + 1) dp[2] = 1 dp[3] = 2 dp[4] = 4 dp[5] = 6 dp[6] = 9 dp[7] = 12 for (i in 8..n) { dp[i] = (dp[i - 3] * 3) % 1000000007 } return dp[n].toInt() }} Java 实现class Solution { public int cuttingRope(int n) { int m = n; if (n &lt; 7) n = 7; long[] dp = new long[n + 1]; dp[2] = 1; dp[3] = 2; dp[4] = 4; dp[5] = 6; dp[6] = 9; dp[7] = 12; for (int i = 8; i &lt;= n; i++) { dp[i] = (dp[i - 3] * 3) % 1000000007; } return (int) dp[m]; }}","link":"/2020/07/18/LeetCode/offer/14-2-jian-sheng-zi-ii-lcof/"},{"title":"剑指 Offer 14-1：剪绳子","text":"题目来源于 LeetCode 剑指 offer 第 14-1 号问题：剪绳子。题目难度为 Medium。 中文地址：https://leetcode-cn.com/problems/jian-sheng-zi-lcof 题目描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0] * k[1] * … * k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2： 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 58 思路：一绳子长度为 n，假设这条绳子被分为 2 段或者 3 段。按照经验切分成 3 段比切分成 2 段的乘积要大，但是也有少数情况切分成 2 段比 3 段乘积大。 例如 n = 6, 2 段 3x3 比 3 段 2 x 2 x 2 要大 故所以我们列出所有的可能性寻找规律： 绳子长度为 n 计算方式 结果 2 1 + 1 ——&gt; 1 x 1 dp[2] = 1 3 1 + 2 ——&gt; 1 x 2 dp[3] = 2 4 2 + 2 ——&gt; 2 x 2 dp[4] = 4 5 2 + 3 = 1 + 4 ——&gt; 2 + 3 &gt; 1 + 4 dp[5] = 6 6 3 + 3 = 2 + 2+ 2 ——&gt; 3 x 3 &gt; 2 x 2 x 2 dp[6] = 9 7 3 + 4 ——&gt; 3 x dp[7-3] dp[7] = 12 8 3 + 5 ——&gt; 3 x dp[8-3] dp[8] = 18 当 n &gt;= 7 ；其结果满足公式为 dp [n] = 3 * dp[n - 3] 复杂度分析： 时间复杂度：O(N)，长度为 N 的绳子，需要计算 [1,n] 累计的最大值，故时间复杂度为 O(N) 空间复杂度：O(N)，需要建立长度为 N 的数组，存储每次计算的值，所以空间复杂度为 O(N) Koltin 实现class Solution { fun cuttingRope(n: Int): Int { val dp = IntArray(if (n &lt; 7) 8 else n + 1) dp[1] = 1 dp[2] = 1 dp[3] = 2 dp[4] = 4 dp[5] = 6 dp[6] = 9 dp[7] = 12 for (i in 8..n) { dp[i] = 3 * dp[i - 3] } return dp[n] }} Java 实现public class Solution { public int cuttingRope(int n) { int m = n; if (n &lt; 7) { n = 7; } int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 1; dp[3] = 2; dp[4] = 4; dp[5] = 6; dp[6] = 9; dp[7] = 12; for (int i = 8; i &lt;= n; i++) { dp[i] = 3 * dp[i - 3]; } return dp[m]; }}","link":"/2020/07/06/LeetCode/offer/14-1-jian-sheng-zi/"},{"title":"剑指 Offer 13：机器人的运动范围","text":"题目来源于 LeetCode 剑指 offer 第 13 号问题：机器人的运动范围。题目难度为 Medium。 中文地址：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/ 题目描述地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 输入：m = 2, n = 3, k = 1输出：3 示例 2： 输入：m = 3, n = 1, k = 0输出：1 提示： 1 &lt;= n,m &lt;= 100 0 &lt;= k &lt;= 20 思路一：BFS 广度优先搜索（队列）BFS: 通常利用队列实现广度优先遍历。 参数说明： queue 表示一个队列，存储访问过的单元格，robot 表示一个二维数组记录访问过的单元格，用 x 表示行的下标，y 表示列的下标。 过滤条件： 是否在单元格内（x&gt;m-1 或者 y&gt;n-1）。 是否已经访问过了。 数位之和是否超过了 k。 算法过程： 按照题目所说，机器人从 [0, 0] 开始移动，每次移动一格，表示 [0, 0] 是原始坐标，它只会向右或者向下移动。 初始化: 将起点坐标 [0, 0] 放进 queue 中。 循环遍历： 先使用 过滤条件： 过滤掉无用的坐标。 数组 robot 记录机器人访问过的单元格，如果访问过将单元格标记为 -1。 朝着右、下两个方向访问，并将其坐标添加进 queue。 并用一个辅助变量 res 计算机器人可到达的单元格。 复杂度分析： M,N 分别为矩阵行列大小。 时间复杂度：O(MN)，矩阵中有 M 行 N 列，最差的情况下遍历完所有的单元格，所以时间复杂度为 O(MN)。 空间复杂度：O(MN)，需要建立额外的数组记录当前格子是否已经访问过了，最差的情况下访问了所有的单元格，故占用额外空间 O(MN) 注意： 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 remove() poll() 查找 element() peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null Koltin 实现class Solution { fun movingCount(m: Int, n: Int, k: Int): Int { val robot = Array(m, { IntArray(n) }) val queue = LinkedList&lt;IntArray&gt;() var res = 0 queue.offer(intArrayOf(0,0)) while(!queue.isEmpty()){ val(x,y) = queue.poll() if(x&gt;m-1 || y&gt;n-1 || robot[x][y] == -1 || count(x) + count(y) &gt; k){ continue; } robot[x][y] = -1 res +=1 queue.offer(intArrayOf(x+1,y)) queue.offer(intArrayOf(x,y+1)) } return res } fun count(x: Int): Int { var sx = x var count = 0 while (sx &gt; 0) { count += sx % 10 sx = sx / 10 } return count }} Java 实现class Solution { public int bfs(int m, int n, int k) { int[][] robot = new int[m][n]; int res = 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]{0, 0}); while (!queue.isEmpty()) { int[] item = queue.poll(); int x = item[0]; int y = item[1]; if (x &gt; m - 1 || y &gt; n - 1 || count(x) + count(y) &gt; k || robot[x][y] == -1) { continue; } robot[x][y] = -1; res++; queue.offer(new int[]{x + 1, y}); queue.offer(new int[]{x, y + 1}); } return res; } int count(int x) { int count = 0; while (x &gt; 0) { count += x % 10; x = x / 10; } return count; }} 思路二：DFS 深度优先搜索(递归)DFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 递归的两个特点： 问题和子问题都会调用函数自身，所以要找寻问题与子问题的递归关系，采用自上而下的思考方式。 有个终止条件（临界点）结束当前递归。 参数说明： robot 表示一个二维数组记录访问过的单元格，用 x 表示行的下标，y 表示列的下标。 终止条件： 是否在单元格内（x&gt;m-1 或者 y&gt;n-1）。 是否已经访问过了。 数位之和是否超过了 k。 算法过程： 按照题目所说，机器人从 [0, 0] 开始移动，每次移动一格，表示 [0, 0] 是原始坐标，它只会向右或者向下移动。 数组 robot 记录机器人访问过的单元格，如果访问过将单元格标记为 -1。 朝着右、下两个方向访问，未访问过并且在单元格范围内，计算它们之和。 复杂度分析： M,N 分别为矩阵行列大小。 时间复杂度：O(MN)，矩阵中有 M 行 N 列，最差的情况下遍历完所有的单元格，所以时间复杂度为 O(MN)。 空间复杂度：O(MN)，需要建立额外的数组记录当前单元格是否已经访问过了，最差的情况下访问了所有的单元格，故占用额外空间 O(MN) Koltin 实现class Solution { fun movingCount(m: Int, n: Int, k: Int): Int { val robot = Array(m, { IntArray(n) }) return dfs(robot, 0, 0, m, n, k) } fun dfs(robot: Array&lt;IntArray&gt;, x: Int, y: Int, m: Int, n: Int, k: Int): Int { if (x &gt; m - 1 || y &gt; n - 1 || robot[x][y] == -1 || count(x) + count(y) &gt; k) { return 0 } robot[x][y] = -1 // 起点为0，0，每次只能移动一格，即向右 x +1 或者向下 y +1 return dfs(robot, x + 1, y, m, n, k) + dfs(robot, x, y + 1, m, n, k) + 1 } fun count(x: Int): Int { var sx = x var count = 0 while (sx &gt; 0) { count += sx % 10 sx = sx / 10 } return count }} Java 实现class Solution { public int movingCount(int m, int n, int k) { int[][] robot = new int[m][n]; return dfs(robot, 0, 0, k, m, n); } int dfs(int[][] robot, int x, int y, int k, int m, int n) { if (x &gt; m - 1 || y &gt; n - 1 || robot[x][y] == -1 || count(x) + count(y) &gt; k) { return 0; } robot[x][y] = -1; // 起点为0，0，每次只能移动一格，即向右 x +1 或者向下 y +1 return dfs(robot, x + 1, y, k, m, n) + dfs(robot, x, y + 1, k, m, n) + 1; } int count(int x) { int count = 0; while (x &gt; 0) { count += x % 10; x = x / 10; } return count; }}","link":"/2020/06/27/LeetCode/offer/13-ji-qi-ren-de-yun-dong-fan-wei/"},{"title":"剑指 Offer 12：矩阵中的路径","text":"题目来源于 LeetCode 剑指 offer 第 12 号问题：矩阵中的路径。题目难度为 Medium。和 第79号问题：单词搜索 一样 中文地址：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/ 题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的 3×4 的矩阵中包含一条字符串 “bfce” 的路径（路径中的字母用加粗标出）。 [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]] 但矩阵中不包含字符串 “abfb” 的路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例1: 输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true 示例2: 输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false 提示： 1 &lt;= board.length &lt;= 2001 &lt;= board[i].length &lt;= 200 思路：DFS 深度优先遍历(递归)DFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 递归的两个特点： 问题和子问题都会调用函数自身，所以要找寻问题与子问题的递归关系，采用自上而下的思考方式。 有个终止条件（临界点）结束当前递归。 参数说明： board 是一个二维数组，所以用 i 表示行的下标，j 表示列的下标，word 是一个字符串转为数组用 words 表示，k 表示数组 words 的下标。 算法过程： 按照题目所说，搜索过程中可以朝着上、下、左、右四个方向去遍历。 每个方向如果访问过了，将当前访问过的元素存为一个临时变量 tmp，并将访问过的元素修改为 '/'，表示已经访问过了不在重复访问。 如果匹配失败了，还原数组中修改过后的元素，从另外一个方向继续访问。 如果匹配成功了，也需要还原数组中修改过后的元素，回溯过程中，再次验证是否正确。 复杂度分析： M,N 分别为矩阵行列大小，K 为字符串 word 长度。 时间复杂度：O(3^k MN)，因为矩阵中有 M 行 N 列，所以时间复杂度为 O(MN)，搜索过程中可以朝着上、下、左、右四个方向去遍历，舍弃回溯那个方向，实际上只朝着三个方向去遍历，所以时间复杂度为 O(3^k)。 空间复杂度：O(K)，递归调用占用栈的空间，递归调用结束后，栈空间会被释放，只是使用了几个标示变量作为额外空间，这部分可以忽略不计，每次搜索中深度不会超过 K，因为占用栈的空间大小不会超过 O(K)。 Koltin 实现class Solution { fun exist(board: Array&lt;CharArray&gt;, word: String): Boolean { if (board.size &lt;= 0 || board[0].size &lt;= 0) { return false } val row = board.size val colum = board[0].size val words = word.toCharArray() for (i in 0 until row) { for (j in 0 until colum) { if (dfs(board, words, i, j, 0, row, colum)) { return true } } } return false } fun dfs(board: Array&lt;CharArray&gt;, words: CharArray, i: Int, j: Int, k: Int, row: Int, colum: Int): Boolean { if (i &gt; row - 1 || i &lt; 0 || j &gt; colum - 1 || j &lt; 0 || board[i][j] != words[k]) { return false } if (k == words.size - 1) { return true } val tmp = board[i][j] board[i][j] = '/' val result = dfs(board, words, i + 1, j, k + 1, row, colum) || dfs(board, words, i - 1, j, k + 1, row, colum) || dfs(board, words, i, j + 1, k + 1, row, colum) || dfs(board, words, i, j - 1, k + 1, row, colum) board[i][j] = tmp return result }} Java 实现class Solution { public boolean exist(char[][] board, String word) { if (board.length &lt;= 0 || board[0].length &lt;= 0) { return false; } char[] words = word.toCharArray(); int row = board.length; int colum = board[0].length; for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; colum; j++) { if (dfs(board, words, i, j, 0, row, colum)) { return true; } } } return false; } boolean dfs(char[][] borad, char[] words, int i, int j, int k, int row, int colum) { if (i &gt; row - 1 || i &lt; 0 || j &gt; colum - 1 || j &lt; 0 || borad[i][j] != words[k]) { return false; } if (k == words.length - 1) { return true; } char tmp = borad[i][j]; borad[i][j] = '/'; boolean result = dfs(borad, words, i + 1, j, k + 1, row, colum) || dfs(borad, words, i - 1, j, k + 1, row, colum) || dfs(borad, words, i, j + 1, k + 1, row, colum) || dfs(borad, words, i, j - 1, k + 1, row, colum); borad[i][j] = tmp; return result; }}","link":"/2020/06/27/LeetCode/offer/12-ju-zhen-zhong-de-lu-jing/"},{"title":"剑指 offer 11：旋转数组的最小数字","text":"题目来源于 LeetCode 剑指 offer 第 11 号问题：旋转数组的最小数字。题目难度为 Easy。和 第154号问题：寻找旋转排序数组中的最小值 II 一样 中文地址：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/ 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例1: 输入：[3,4,5,1,2]输出：1 示例2: 输入：[2,2,2,0,1]输出：0 思路：二分查找这道题目给出一个有序数组，之后转换成一个旋转数组作为输入数据，求旋转数组的最小数字。 例如 原数组 [1,2,3,4,5] 转换之后的旋转数组是 [3,4,5,1,2] 也有可能是 [4,5,1,2,3] 等等，旋转数组最小的数字是1。 二分查找不仅能用在有序数组上，而且还能用在减治的问题上，这道题也是减治问题。 用二分查找就首先应该寻找比较点，这是一个旋转数组所以最左边和最右边也就是我们的比较点，那么如何进行选择呢 如果用最左边位置 left 和中间位置 mid 的值进行比较是否可以？ 例如： 旋转数组 [3, 4, 5, 1, 2] 中的值都比左边大，但是最小的在右边，因此不合适。 如果用最右边边位置 right 和中间位置 mid 的值进行比较是否可以？ 例如：旋转数组 [3, 4, 5, 1, 2] 和 [2,3,4,5,1] 或者 [4,5,1,2,3]，最后小的在右边，那么用右边位置和中间位置的元素比较，不断缩小范围去查找 复杂度分析： 时间复杂度：O(log_2 N)，使用的二分查找算法，因此时间复杂度为 O(log_2 N) 空间复杂度：O(1)，只是使用了几个标示变量作为额外空间，可以忽略不计，因此空间复杂度 O(1) Koltin 实现class Solution { fun minArray(numbers: IntArray): Int { var left = 0 var right = numbers.size - 1 while (left &lt; right) { val mid = (left + right) ushr 1 when { numbers[mid] &gt; numbers[right] -&gt; left = mid + 1 numbers[mid] &lt; numbers[right] -&gt; right = mid else -&gt; right = right - 1 } } return numbers[left] }} Java 实现class Solution { public int minArray(int[] numbers) { int left = 0; int right = numbers.length - 1; while (left &lt; right) { int mid = (left + right) &gt;&gt; 1; if (numbers[mid] &gt; numbers[right]) { left = mid + 1; } else if (numbers[mid] &gt; numbers[right]) { right = mid; } else { right--; } } return numbers[left]; }}","link":"/2020/06/22/LeetCode/offer/11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/"},{"title":"剑指 offer 10-2：青蛙跳台阶问题","text":"题目来源于 LeetCode 剑指 offer 第 10_2 号问题：青蛙跳台阶问题。题目难度为 Easy。这道题和 第70号问题：爬楼梯 一样 中文地址：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/ 题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例1: 输入：n = 2输出：2 示例2: 输入：n = 7输出：21 提示： * 0 &lt;= n &lt;= 100思路：这道题 斐波那契（Fibonacci）问题一样，它们在公式稍微一些不同 斐波那契（Fibonacci）公式如下所示： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 青蛙跳台阶 公式如下所示： f(0)=1 , f(1)=1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 复杂度分析： 时间复杂度：O(n)，F(N) 需要循环 N 次，因此时间复杂度为 O(n) 空间复杂度：O(1)，只是使用了几个标示变量作为额外空间，可以忽略不计，因此空间复杂度 O(1) Koltin 实现class Solution { fun numWays(n: Int): Int { if (n == 1 || n == 0) { return 1; } var a = 1; var b = 2; var sum = b; for (i in 2 until n) { sum = (a + b) % 1000000007 a = b.also { b = sum } } return sum }} Java 实现class Solution { public int numWays(int n) { if (n == 0 || n == 1) { return 1; } int a = 1; int b = 2; int sum = b; for (int i = 2; i &lt; n; i++) { sum = (a + b) % 1000000007; a = b; b = sum; } return sum; }}","link":"/2020/06/22/LeetCode/offer/10-2-qing-wa-tiao-tai-jie-wen-ti-lcof:/"},{"title":"剑指 offer 10-1：斐波那契数列","text":"题目来源于 LeetCode 上第 10 号问题：斐波那契数列。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/ 题目描述写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2输出：1 示例 2： 输入：n = 5输出：5 提示： 0 &lt;= n &lt;= 100 思路：根据 斐波那契数列 公式求解即可，公式如下所示： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2) PS: 需要注意的是，每次计算的结果需要取模 Kotlin 实现class Solution { fun fib(n: Int): Int { return when { n == 0 -&gt; return 0 n == 1 -&gt; return 1 else -&gt; { val data = mutableListOf&lt;Int&gt;() data.add(0) data.add(1) for (i in 2..n) { data.add((data[i - 1] + data[i - 2]) % 1000000007) } return data[n] } } }} Java 实现public class Solution { public int fib(int n) { if (n == 0) { return 0; } int[] data = new int[n + 1]; data[0] = 0; data[1] = 1; for (int i = 2; i &lt;= n; i++) { data[i] = (data[i - 1] + data[i - 2]) % 1000000007; } return data[n]; }}","link":"/2020/06/15/LeetCode/offer/10-fei-bo-na-qi-shu-lie-lcof/"},{"title":"剑指 offer 09：用两个栈实现队列","text":"LeetCode 剑指 offer：用两个栈实现队列题目来源于 LeetCode 上第 09 号问题：用两个栈实现队列。题目难度为 Easy。和 主站 509 号问题相同。 中文地址：https://leetcode-cn.com/problems/yong……。 题目描述用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )。 示例 1: 输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 示例 2: 输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 思路：先来了解一下栈和队列的基本概念 栈 (Stack)：是一种后进先出(last in first off，LIFO)的数据结构，如下图所示： 队列：是一种先进先出的结构。，一端用来加入新元素，另一端用来删除元素。 算法步骤： 两个栈分别为 Stack 1 和 Stack 2，Stack 1 用于存储元素，Stack 2 作为辅助栈。 插入元素：将元素存储在 Stack 1 中。删除元素：如果 Stack 1 和 Stack 2 都为空返回 -1， 不为空，将 Stack 1 中的元素 pop 出来放到 Stack 2 中之后返回 Stack 2 栈顶元素，即可实现队列功能，假设： 一组输入数据 [1，2，3，4],如果放到队里中，队列是一种先进先出的结构，即输出结果为：[1，2，3，4], 我看一下栈是如何实现的： Stack 1 元素 [1，2，3，4] pop 出来放到 Stack 2 中，Stack 2 中的元素为 [4，3，2，1]。 栈是后进先出的结构，然后依次弹出 Stack 2 中的元素，即输出结果为：[1， 2，3，4]。 Koltin 实现class CQueue() { val stack1 = Stack&lt;Int&gt;() val stack2 = Stack&lt;Int&gt;() fun appendTail(value: Int) { stack1.push(value); } fun deleteHead(): Int { return when { !stack2.isEmpty() -&gt; stack2.pop() stack1.isEmpty() -&gt; -1 else -&gt; { while (!stack1.isEmpty()) { stack2.push(stack1.pop()) } return stack2.pop() } } }} Java 实现class CQueue { private Stack&lt;Integer&gt; stack1; private Stack&lt;Integer&gt; stack2; public CQueue() { stack1 = new Stack(); stack2 = new Stack(); } public void appendTail(int value) { stack1.push(value); } public int deleteHead() { if (!stack2.isEmpty()) { return stack2.pop(); } else if (stack1.isEmpty()) { return -1; } else { while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } return stack2.pop(); } }}","link":"/2020/06/15/LeetCode/offer/09-yong-liang-ge-zhan-shi-xian-dui-lie/"},{"title":"剑指 offer 06：从尾到头打印链表","text":"题目来源于 LeetCode 剑指 offer 第 06 号问题：从尾到头打印链表。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/ 题目描述输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例: 输入：head = [1,3,2]输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 思路 第一次遍历计算链表的长度，创建相同长度的数组 reverse 第二次遍历将值 逆序 添加进 reverse 中 复杂度分析： 时间复杂度：O(n)，第一次遍历计算链表的长度，第二次遍历添加进数组 空间复杂度：O(n)，需要额外使用一个数组存储 Kotlin 实现class Solution { fun reversePrint(head: ListNode?): IntArray = head?.let { var count = 0 var currentNode = head while (currentNode != null) { count++ currentNode = currentNode.next } val reverse = IntArray(count) { 0 } currentNode = head while (currentNode != null) { reverse[--count] = currentNode.`val` currentNode = currentNode.next } reverse } ?: intArrayOf()} Java 实现class Solution { public int[] reversePrint(ListNode head) { if (head == null) { return new int[]{}; } int count = 0; ListNode currentNode = head; while (currentNode != null) { count++; currentNode = currentNode.next; } int[] reverse = new int[count]; currentNode = head; while (currentNode != null) { reverse[--count] = currentNode.val; currentNode = currentNode.next; } return reverse; }}","link":"/2020/06/07/LeetCode/offer/06-list/"},{"title":"剑指 Offer 05：替换空格","text":"题目来源于 LeetCode 剑指 offer 第 05 号问题：替换空格。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/ 题目描述请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例: 输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制： 0 &lt;= s 的长度 &lt;= 10000 思路声明一个 StringBuffer，遍历字符串，如果遇见空格，添加 %20 到 buffer 中, 否则添加当前字符 复杂度分析： 时间复杂度：O(n)，当一个字符串的长度为 n 时，遍历字符串一遍，时间复杂度为 O(n) 空间复杂度：0(n)，需要创建 StringBuffer 有额外的开销，每次遇见空格，就替换为 %20，最坏的情况下，长度是原来的 3 倍 Kotlin 实现class Solution { fun replaceSpace(s: String): String { val buffer = StringBuffer() var i = 0 val len = s.length while (i &lt; len) { if (s[i] == ' ') { buffer.append(&quot;%20&quot;) } else { buffer.append(s[i]) } i++ } return buffer.toString() }} Java 实现class Solution { public String replaceSpace(String s) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == ' ') { buffer.append(&quot;%20&quot;); } else { buffer.append(s.charAt(i)); } } return buffer.toString(); }}","link":"/2020/05/31/LeetCode/offer/05-space/"},{"title":"剑指 Offer 04：二维数组中的查找","text":"题目来源于 LeetCode 剑指 offer 第 04 号问题：二维数组中的查找。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/ 题目描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000 思路：线性查找由题意得知，每个二维数组都有以下特点： 每一行都按照从左到右递增的顺序排序 每一列都按照从上到下递增的顺序排序 因为都是有序的，所以可以选择将左上角 或者 右上角作为起点，寻找一个和目标数字相等的数，在这里我选择右上角作为起点即 matrix[0][maxColumn] 其中 maxColumn = matrix[0].size - 1 即每一行的最大列数，算法步骤如下 初始化 raw = 0，column = maxColumn 如果 matrix[raw][column] == target，说明存在和目标数字相等的数返回 true 如果 matrix[raw][column] &gt; target, 说明当前元素大于目标值，所以当前元素所在的下面所有元素都大于目标值，因此 column - 1，往左边寻找 如果 matrix[raw][column] &lt; target，说明当前元素小于目标值，所以当前元素所在的左边所有元素都小于目标值，因此 raw + 1，往下面寻找 遍历结束之后，如果没有找到即返回 false 复杂度分析： 时间复杂度：O(n+m)，如果二维数组的有 n 行 m 列，那么在循环过程中行数不会超过 n 行，列数不会超过 m 列，因此在循环结束之后总的次数不会超过 n+m 次 空间复杂度：0(1)，因为没有额外的开销，在内存中一直都是恒定的 Kotlin 实现class Solution { fun findNumberIn2DArray(matrix: Array&lt;IntArray&gt;, target: Int): Boolean { if (matrix == null || matrix.size &lt;= 0 || matrix[0].size &lt;= 0) { return false; } var raw = 0 var column = matrix[0].size - 1; val maxRaw = matrix.size - 1; while (raw &lt;= maxRaw &amp;&amp; column &gt;= 0) { when { matrix[raw][column] == target -&gt; return true matrix[raw][column] &gt; target -&gt; column-- else -&gt; raw++ } } return false }} Java 实现class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length &lt;= 0 || matrix[0].length &lt;= 0) { return false; } int row = 0; int column = matrix[0].length - 1; int maxRow = matrix.length - 1; while (row &lt;= maxRow &amp;&amp; column &gt;= 0) { if (matrix[row][column] == target) { return true; } else if (matrix[row][column] &gt; target) { column--; } else { row++; } } return false; }}","link":"/2020/05/31/LeetCode/offer/04-arrays/"},{"title":"剑指 Offer 03：数组中重复的数字","text":"题目来源于 LeetCode 剑指 offer 第 03 号问题：数组中重复的数字。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/ 题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1: 输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 思路一：原地置换法题目指出 在一个长度为 n 的数组 nums 里的所有数字都在 [0,n-1] 的范围内，可遍历数组并通过交换操作使元素的 索引 与 值，通过索引找到对应的值，算法流程如下： 当 nums[i] == i 时，即 值 和 索引，一一对应无需交换 当 nums[nums[i]] == nums[i]，即索引 nums[i] 对应的值 和 nums[i] 相等，找到相同的值，返回此值 nums[i] 上面条件都不满足，即交换索引为 i 和 nums[i] 的元素值，将数字交换到对应索引位置 没有找到返回 -1，即代表数组中无相同值 例如数组 [2,0,1] 交换逻辑如下, 当 i = 0 时： temp = num[i], 即 temp = 2 num[i] = num[temp]，即 num[i] = 1 num[temp] = temp, 即 num[temp] = 2 将 即 值 和 索引 一一对应 Java实现public class Solution { public int findRepeatNumber(int[] nums) { int len = nums.length; for (int i = 0; i &lt; len; i++) { if (nums[i] == i) continue; if (nums[nums[i]] == nums[i]) { return nums[i]; } int temp = nums[i]; nums[nums[i]] = nums[temp]; nums[temp] = temp; } return -1; }} Koltin实现class Solution { fun findRepeatNumber(nums: IntArray): Int { for ((index, value) in nums.withIndex()) { if (value == index) continue if (nums[value] == nums[index]) { return nums[index] } val temp = value nums[value] = nums[temp] nums[temp] = temp } return -1 }} 思路二：哈希算法利用 Haset API 的特性，如果添加重复的元素会返回 false Java 实现public class Solution { public int findRepeatNumber2(int[] nums) { int len = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; len; i++) { if (!set.add(nums[i])) { return nums[i]; } } return -1; }} Koltin 实现class Solution { fun findRepeatNumber(nums: IntArray): Int { val set = HashSet&lt;Int&gt;() for ((index, value) in nums.withIndex()) { if (!set.add(value)) { return value; } } return -1 }}","link":"/2020/05/24/LeetCode/offer/03-number/"},{"title":"剑指 Offer 07：重建二叉树","text":"题目来源于 LeetCode 剑指 offer 第 07 号问题：重建二叉树。题目难度为 Medium。和第 105 号问题 相同 剑指offer 07 重建二叉树：https://leetcode-cn.com/problems/zhong-jian…… 105 号问题-英文地址：https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 105 号问题-中文地址：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\9 20 / \\ 15 7 限制： 0 &lt;= 节点个数 &lt;= 5000 思路：如果还不了解前序遍历和中序遍历算法可以点击下方链接前往 前序遍历中序遍历 前序遍历和中序遍历过程如下： 前序遍历：根结点 —&gt; 左节点 —&gt; 右节点 中序遍历：左节点—&gt; 根结点 —&gt; 右节点 根据前序遍历的规则，可知 preorder[0] 一定是整棵二叉树的根节点，如果根节点所在的下标为 index，根据中序遍历的规则，可知中序序列 inorder： 区间 inorder[0, index - 1] 属于根节点的左子树 区间 inorder[index + 1, n - 1] 属于根节点的右子树 根据前序遍历的规则一定是先遍历完左子树，然后才会遍历右子树，所以前序序列 preorder： 区间 preorder[1, index] 在根节点的 preorder[0] 的左边 区间 preorder[index+1, n] 在根节点的 preorder[0] 的右边 所以算法思路如下： 根节点是Preorder数组中的第一个元素，即 preorder[0] 在Inorder数组中查找根的位置 index 在Inorder数组中，根元素左边的元素是左子树，即区间 inorder[0, index - 1] 在Inorder数组中，根元素右边的元素是右子树，即区间 inorder[index + 1, n - 1] 在preorder数组中，区间 preorder[1, index] 在根节点的preorder[0] 的左边 在preorder数组中，preorder[index+1, n] 在根节点的preorder[0] 的右边 在由左子树中的元素组成的子数组上递归调用 在由右子树中的元素组成的子数组上递归地调用 复杂度分析： 时间复杂度：O(n), 遍历每一个节点，重建二叉树 空间复杂度：O(n)，需要存储建立的二叉树 Kotlin 尾递归实现class Solution { fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? { return tailrecOrder(preorder, inorder) } tailrec fun tailrecOrder(preorder: IntArray, inorder: IntArray): TreeNode? { if (preorder.size &lt;= 0 || inorder.size &lt;= 0) { return null; } val key = preorder[0] val root = TreeNode(key) if (preorder.size == 1) { return root } val index = getRootIndex(inorder, key) if (index &gt; 0 || index &lt; preorder.size) { // 计算左子树，所以根节点除外，从下标1开始 var pre = Arrays.copyOfRange(preorder, 1, index + 1) var inor = Arrays.copyOfRange(inorder, 0, index) root.left = tailrecOrder(pre, inor) pre = Arrays.copyOfRange(preorder, index + 1, preorder.size) inor = Arrays.copyOfRange(inorder, index + 1, inorder.size) root.right = tailrecOrder(pre, inor) } return root } fun getRootIndex(inorder: IntArray, key: Int): Int { inorder.forEachIndexed { index, item -&gt; if (item == key) { return index } } return -1 }} Java 实现class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length &lt;= 0 || inorder.length &lt;= 0) { return null; } int key = preorder[0]; TreeNode root = new TreeNode(key); if (preorder.length == 1) { return root; } int index = getRootIndex(inorder, key); if (index &gt; 0 || index &lt; preorder.length) { // 计算左子树，所以根节点除外，从下标1开始 int[] pre = Arrays.copyOfRange(preorder, 1, index + 1); int[] inor = Arrays.copyOfRange(inorder, 0, index); root.left = buildTree(pre, inor); pre = Arrays.copyOfRange(preorder, index + 1, preorder.length); inor = Arrays.copyOfRange(inorder, index + 1, inorder.length); root.right = buildTree(pre, inor); } return root; } private final int getRootIndex(int[] inorder, int key) { for (int i = 0; i &lt; preorder.length; i++) { if (preorder[i] == key) { return i; } } return -1; }}","link":"/2020/07/19/LeetCode/offer/07-zhong-jian-er-cha-shu-lcof/"},{"title":"LeetCode 搜索：完全平方数","text":"题目来源于 LeetCode 上 第 279 号问题：岛屿数量。题目难度为 Medium。 英文地址：https://leetcode.com/problems/perfect-squares/ 中文地址：https://leetcode-cn.com/problems/perfect-squares/ 题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1： 输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2： 输入: n = 13输出: 2解释: 13 = 4 + 9. 思路：广度优先遍历广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。 在 BFS 中使用队列的原因？ 结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。 队列的基本使用 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 remove() poll() 查找 element() peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null 算法流程如下： 将数字 N 转换为多树，按树的层次遍历即可（分解出 N 可能的组合），每一层的节点 = 用上一层的节点 - 完全平方数 新建一个 queue，用来存储访问的每个节点 用 HashSet 过滤掉计算过的组合，避免重复计算 循环判断队列是否为空，如果队列为空即循环终止 获取每层的长度，遍历每一层，计算出下一层的组合，添加到 queue 重复执行 3、4 遍历结束时，层数即是能组成完全平方数的最少个数 Kotlin 实现class Solution { fun numSquares(n: Int): Int { val square = mutableListOf&lt;Int&gt;() for (i in 1..n) { square.add(i * i) } val set = hashSetOf&lt;Int&gt;() val queue = LinkedList&lt;Int&gt;() queue.offer(n) var step = 0 while (queue.size &gt; 0) { step = step + 1 val count = queue.size for (i in 0 until count) { val item = queue.poll() loop@ for (j in square) { when { item == j -&gt; return step item &lt; j -&gt; break@loop else -&gt; { val sub = item - j; if (set.add(sub)) { queue.offer(sub) } } } } } } return step }} Java 实现class Solution { public int numSquares(int n) { List&lt;Integer&gt; square = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; n; i++) { square.add(i * i); } int step = 0; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(n); while (queue.size() &gt; 0) { step = step + 1; int count = queue.size(); for (int i = 0; i &lt; count; i++) { int item = queue.poll(); for (Integer subItem : square) { if (item == subItem) { return step; } else if (item &lt; subItem) { break; } else { int sub = item - subItem; if (set.add(sub)) { queue.offer(sub); } } } } } return step; }}","link":"/2020/08/01/LeetCode/search/02-perfect-squares/"},{"title":"LeetCode 搜索：岛屿数量","text":"题目来源于 LeetCode 上 第 200 号问题：岛屿数量。题目难度为 Medium。 英文地址：https://leetcode.com/problems/number-of-islands/ 中文地址：https://leetcode-cn.com/problems/number-of-islands/ 题目描述给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 输入:[['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]输出: 1 示例 2： 输入:[['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 思路一：广度优先遍历广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。 在 BFS 中使用队列的原因？ 结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。 队列的基本使用 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 remove() poll() 查找 element() peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null 算法流程如下： 广度优先搜索就是扫描整个二维网格，遇到 1 将其加入队列中，然后将其标记为 0, 直到队列为空，搜索结束。 复杂度分析： 时间复杂度：0(MN) ，M 是行数，N 是列数 空间复杂度：O(MN)，最坏的情况深度达到第 M 行 N 列 Kotlin 实现class Solution { fun numIslands(grid: Array&lt;CharArray&gt;): Int { if (grid.size == 0) { return 0; } var step = 0; val queue = LinkedList&lt;IntArray&gt;() val row = grid.size val colum = grid[0].size for (i in 0 until row) { for (j in 0 until colum) { if (grid[i][j] == '1') { step = step + 1 queue.offer(intArrayOf(i, j)) while (!queue.isEmpty()) { val (x1, y1) = queue.poll() if (x1 &lt; 0 || x1 &gt;= row || y1 &lt; 0 || y1 &gt;= colum || grid[x1][y1] == '0') { continue; } grid[x1][y1] = '0' queue.offer(intArrayOf(x1 + 1, y1)) queue.offer(intArrayOf(x1 - 1, y1)) queue.offer(intArrayOf(x1, y1 + 1)) queue.offer(intArrayOf(x1, y1 - 1)) } } } } return step }} Java 实现class Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int row = grid.length; int colum = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int step = 0; for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; colum; j++) { if (grid[i][j] == '1') { queue.offer(new int[]{i, j}); step++; while (!queue.isEmpty()) { int[] tmp = queue.poll(); int x1 = tmp[0]; int y1 = tmp[1]; if (x1 &lt; 0 || x1 &gt;= row || y1 &lt; 0 || y1 &gt;= colum || grid[x1][y1] == '0') { continue; } grid[x1][y1] = '0'; queue.offer(new int[]{x1 + 1, y1}); queue.offer(new int[]{x1 - 1, y1}); queue.offer(new int[]{x1, y1 + 1}); queue.offer(new int[]{x1, y1 - 1}); } } } } return step; }} 思路二：深度优先搜索DFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 递归的两个特点： 问题和子问题都会调用函数自身，所以要找寻问题与子问题的递归关系，采用自上而下的思考方式。 有个终止条件（临界点）结束当前递归。 参数说明： grid 表示一个二维网格 用 i 表示行的下标，j 表示列的下标 x1 表示当前所在的格子的横坐标 y1 表示当前所在的格子的纵坐标 终止条件： 是否在单元格内（x &gt;= row 或者 y &gt;= colum）。 如果当前格子已经访问过了，满足于 grid[x1][y1] == '0' 算法过程： 遍历整个网格 从坐标 [0, 0] 开始进行深度优先搜索，在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0 岛屿的数量就是进行深度优先搜索的次数 Kotlinclass Solution { fun numIslands(grid: Array&lt;CharArray&gt;): Int { if (grid.size == 0) { return 0; } var step = 0; val row = grid.size val colum = grid[0].size for (i in 0 until row) { for (j in 0 until colum) { if (grid[i][j] == '1') { step = step + 1 dfs(i, j, row, colum, grid) } } } return step } fun dfs(x1: Int, y1: Int, row: Int, colum: Int, grid: Array&lt;CharArray&gt;) { if (x1 &lt; 0 || x1 &gt;= row || y1 &lt; 0 || y1 &gt;= colum || grid[x1][y1] == '0') { return; } grid[x1][y1] = '0' dfs(x1 + 1, y1, row, colum, grid) dfs(x1 - 1, y1, row, colum, grid) dfs(x1, y1 + 1, row, colum, grid) dfs(x1, y1 - 1, row, colum, grid) }} Javaclass Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int row = grid.length; int colum = grid[0].length; int step = 0; for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; colum; j++) { if (grid[i][j] == '1') { step++; dfs(i, j, row, colum, grid); } } } return step; } void dfs(int x1, int y1, int row, int colum, char[][] grid) { if (x1 &lt; 0 || x1 &gt;= row || y1 &lt; 0 || y1 &gt;= colum || grid[x1][y1] == '0') { return; } grid[x1][y1] = '0'; dfs(x1 + 1, y1, row, colum, grid); dfs(x1 - 1, y1, row, colum, grid); dfs(x1, y1 + 1, row, colum, grid); dfs(x1, y1 - 1, row, colum, grid); }}","link":"/2020/07/31/LeetCode/search/01-number-of-islands/"},{"title":"LeetCode 字符串：无重复字符的最长子串","text":"题目来源于 LeetCode 上 第 3 号问题：最长公共前缀。题目难度为 Medium。 英文地址：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 中文地址：https://leetcode.com/problems/longest-substring-without-repeating-characters/ 题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1： 输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2： 输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路：滑动窗口什么是滑动窗口？ 在字符串 s 中使用左右指针，左指针 left，右指针 right，初始化 left = right = 0，不断增加 right 扩大窗口大小，满足一定条件的时候，left 向右移动缩小窗口，表示 开始枚举下一个字符作为起始位置。 算法流程如下： 以示例一中的字符串 abcabcbb 为例，从每一个字符开始的，不包含重复字符的最长子串，列举出所有的可能性，其中括号中表示选中的字符以及最长的字符串： 以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb 以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb 以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb 以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb 以 abca(b)cbb 开始的最长字符串为 abca(bc)bb 以 abcab(c)bb 开始的最长字符串为 abcab(cb)b 以 abcabc(b)b 开始的最长字符串为 abcabc(b)b 以 abcabcb(b) 开始的最长字符串为 abcabcb(b) 观察规律，当右指针出现重复字符的时候，更改了左指针的起始位置，继续不断的循环下去，直到所有字符都比较完，满足 滑动窗口 的定义，所以我们可以使用 滑动窗口 来解决这个问题： 检查当前数组长度是否为 0 ，如果是则返回空字符串 &quot;&quot; 左指针 left，右指针 right，初始化 left = right = 0 不断增加 right 扩大窗口大小，直到右侧出现了重复字符为止 移除左指针指向的元素，并将左指针向右移动一格，表示 开始枚举下一个字符作为起始位置 不断重复 3、4 直到所有字符都比较完 如何判断重复字符 可以使用 HashSet 或者 HashMap 来判断是否出现重复字符，HashSet 和 HashMap 采用的时候哈希算法，时间复杂度 0(1)。 复杂度分析： 时间复杂度：0(n) ，n 是字符串的长度，会将整个字符串遍历一次 空间复杂度：O(∣Σ∣)，使用哈希集合来存储出现过的字符，∣Σ∣ 表示字符串中最多可以出现的字符的个数 Java 实现class Solution { /** * 方法一：滑动窗口 hashSet * * @param s * @return */ public int lengthOfLongestSubstring(String s) { if (s == null || s.length() &lt;= 0) { return 0; } int r = 0; int count = 0; int len = s.length(); Set&lt;Character&gt; hashSet = new HashSet&lt;Character&gt;(); for (int i = 0; i &lt; len; i++) { if (i != 0) { hashSet.remove(s.charAt(i - 1)); } while (r &lt; len &amp;&amp; !hashSet.contains(s.charAt(r))) { hashSet.add(s.charAt(r)); r++; } count = Math.max(count, r - i); } return count; } /** * 方法二：滑动窗口 hashMap * * @param s * @return */ public int lengthOfLongestSubstring2(String s) { if (s == null || s.length() &lt;= 0) { return 0; } int left = 0; int count = 0; int len = s.length(); Map&lt;Character, Integer&gt; hashMap = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; len; i++) { if (hashMap.containsKey(s.charAt(i))) { left = Math.max(left, hashMap.get(s.charAt(i)) + 1); } hashMap.put(s.charAt(i), i); count = Math.max(count, i - left + 1); } return count; }} Kotlin 实现class Solution { // 方法一：滑动窗口 hashSet fun lengthOfLongestSubstring(s: String): Int { val len = s.length if (len &lt;= 0) return 0 var r = 0 var count = 0 val hashSet = mutableSetOf&lt;Char&gt;() for (i in 0 until len) { if (i != 0) { hashSet.remove(s[i - 1]) } while (r &lt; len &amp;&amp; !hashSet.contains(s[r])) { hashSet.add(s[r]) r++ } count = Math.max(count, r - i) } return count } // 方法二：滑动窗口 hashMap fun lengthOfLongestSubstring2(s: String): Int { val len = s.length; if (len == 0) { return 0 } var left = 0 var count = 0 val map = mutableMapOf&lt;Char, Int&gt;() for (i in 0 until len) { if (map.containsKey(s[i])) { left = Math.max(left, map.get(s[i])?.let { it + 1 } ?: left) } map.put(s[i], i) count = Math.max(count, i - left + 1) } return count }}","link":"/2020/07/30/LeetCode/character/02-longest-substring-without-repeating-characters/"},{"title":"LeetCode 字符串：最长公共前缀","text":"题目来源于 LeetCode 上 第 14 号问题：最长公共前缀。题目难度为 Easy。 英文地址：https://leetcode.com/problems/longest-common-prefix/ 中文地址：https://leetcode-cn.com/problems/longest-common-prefix/ 题目描述编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1： 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2： 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明： 所有输入只包含小写字母 a-z 。 思路一：算法流程如下： 检查当前数组长度是否为 0 ，如果是则返回空字符串 &quot;&quot; 假设第一个字符串为最长公共前缀 从前往后遍历所有字符串的每一列，比较第一个字符串相同列上的字符是否相同 如果相同则继续对下一列进行比较 如果不相同则当前列不再属于公共前缀，返回当前列之前的部分为最长公共前缀 以下图片来自 LeetCode 官方： 复杂度分析： 时间复杂度：0(mn) ，m 是字符串的数量， n 是每个字符串的长度，最坏的情况下，每个字符都比较一遍 空间复杂度：O(1)，使用了一些变量，占常数大小的空间 Kotlin 实现class Solution { fun longestCommonPrefix(strs: Array&lt;String&gt;): String { if (strs.size &lt;= 0) { return &quot;&quot; } val str0 = strs[0] val len = str0.length val count = strs.size for (i in 0 until len) { val c = str0[i] for (j in 1 until count) { if (i == strs[j].length || c != strs[j][i]) { return str0.substring(0, i) } } } return str0 }} Java 实现public class Solution { // 方法一 public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length &lt;= 0) { return &quot;&quot;; } String str0 = strs[0]; int len = str0.length(); int count = strs.length; for (int i = 0; i &lt; len; i++) { char c1 = str0.charAt(i); for (int j = 1; j &lt; count; j++) { if (i == strs[j].length() || c1 != strs[j].charAt(i)) { return str0.substring(0, i); } } } return str0; }} 思路二：算法流程如下： 检查当前数组长度是否为 0 ，如果是则返回空字符串 &quot;&quot; 假设第一个字符串为最长公共前缀 遍历后面字符串和第一个字符串做比较 如果不相同则退出循环，返回之前的字符串为最长公共前缀 复杂度分析： 时间复杂度：0(mn) ，m 是字符串的数量， n 是每个字符串的长度，最坏的情况下，每个字符都比较一遍 空间复杂度：O(1)，使用了一些变量，占常数大小的空间 Java 实现public class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length &lt;= 0) { return &quot;&quot;; } int count = strs.length; String str0 = strs[0]; for (int i = 0; i &lt; count; i++) { int j = 0; for (; j &lt; str0.length() &amp;&amp; j &lt; strs[i].length(); j++) { if (str0.charAt(j) != strs[i].charAt(j)) { break; } } str0 = str0.substring(0, j); } return str0; }}","link":"/2020/07/29/LeetCode/character/01-longest-common-prefix/"},{"title":"LeetCode 数组：2020 力扣杯：拿硬币","text":"题目来源于 2020 力扣杯！Code Your Future 春季全国编程大赛 01：拿硬币。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/na-ying-bi/ 题目描述桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。 示例 1： 输入：[4,2,1]输出：4解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例 2： 输入：[2,3,10]输出：8 限制： 1 &lt;= n &lt;= 41 &lt;= coins[i] &lt;= 10 思路根据题意每次至少可以拿一枚或者两枚力口币，求拿完所有力扣币的最少次数，根据它的限制条件 1 &lt;= coins[i] &lt;= 10 列举可能性找规律 当coins[1]时，第一次拿一枚，至少1次 当coins[2]时，第一次拿两枚，至少1次 当coins[3]时，第一次拿两枚，第二次拿一枚，至少2次 当coins[4]时，第一次拿两枚，第二次拿两枚，至少2次 当coins[5]时，第一次拿两枚，第二次拿两枚，第三次拿一枚，至少3次 当coins[6]时，第一次拿两枚，第二次拿两枚，第三次拿两枚，至少3次 …… 综合以上情况，可以发现当 i 为偶数时，至少次数 = i/2，当 i 为奇数时，至少次数 = i/2 + i%2，代码如下： Java实现class Solution { public int minCount(int[] coins) { int sum = 0; for (int i = 0; i &lt; coins.length; i++) { sum += coins[i] / 2; if (coins[i] % 2 != 0) { sum += 1; } } return sum; }} Koltin实现class Solution { fun minCount(coins: IntArray): Int { var sum = 0 coins.forEach { value -&gt; sum += value / 2 if (value % 2 != 0) sum += 1 } return sum }}","link":"/2020/06/28/LeetCode/2020code/01-na-ying-bi/"},{"title":"LeetCode 数组：两数之和2 - 输入数组有序","text":"题目来源于 LeetCode 上第 167号（Two Sum II - Input array is sorted）问题：两数之和2 - 输入数组有序。题目难度为 Easy。 英文地址：https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ 中文地址：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ 题目描述Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. 示例： Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 思路一：左右指针法初始化左指针low指向数组起始位置，右指针height指向数组结束位置，时间复杂度o(n) 如果numbers[low] 和 numbers[height]的和sum等于target，返回low+,height+1 如果numbers[low] 和 numbers[height]的和sum小于target，则low++ 如果numbers[low] 和 numbers[height]的和sum大于target，则height– Java实现public class Solution { public int[] twoSum(int[] numbers, int target) { int low = 0; int height = numbers.length - 1; while (low &lt; height) { int sum = numbers[low] + numbers[height]; if (sum == target) { return new int[]{low + 1, height + 1}; } else if (sum &lt; target) { low++; } else { height--; } } return new int[2]; }} Kotlin实现class Solution { fun twoSum(numbers: IntArray, target: Int): IntArray { var height = numbers.size - 1 var low = 0; while (low &lt; height) { val sum = numbers[low] + numbers[height] when { sum == target -&gt; return intArrayOf(low + 1, height + 1) sum &lt; target -&gt; low++ else -&gt; height-- } } return intArrayOf() }} 思路二：二分法查找题目可知找两个数之和 a+b = taget，循环数组每一个元素a, 从剩余的元素里面用二分法查找另外一个元素 b= taget-a 即可，时间复杂度为o(nlogn) 循环每个元素a 从剩余元素用二分法查找元素b = taget-a，返回索引idnex, 如果index ==-1 ，则无结果返回，如果index!=-1，则直接返回a+1,index+1 Java实现public class Solution { public int[] twoSum(int[] numbers, int target) { for (int a = 0; a &lt; numbers.length; a++) { int index = binarySearch(numbers, a + 1, target - numbers[a]); if (index != -1) return new int[]{a + 1, index + 1}; } return new int[2]; } public int binarySearch(int[] numbers, int start, int target) { int low = start; int height = numbers.length - 1; while (low &lt;= height) { int mind = (low + height) &gt;&gt;&gt; 1; if (numbers[mind] == target) return mind; if (numbers[mind] &lt; target) low = mind + 1; if (numbers[mind] &gt; target) height = mind - 1; } return -1; }} kotlin 实现class Solution { fun twoSum(numbers: IntArray, target: Int): IntArray { numbers.forEachIndexed { i, value -&gt; val index = binarySearch(numbers, i + 1, target - value) if (index != -1) { return intArrayOf(i + 1, index + 1) } } return intArrayOf() } fun binarySearch(numbers: IntArray, start: Int, target: Int): Int { var low = start var height = numbers.size - 1 while (low &lt;= height) { val mind = (low + height) ushr 1 when { numbers[mind] == target -&gt; return mind numbers[mind] &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return -1 }}","link":"/2020/06/28/LeetCode/arrays/01-two-sum-ii-input-array-is-sorted/"},{"title":"LeetCode 二叉树：判断两棵二叉树是否结构相同","text":"题目来源于 LeetCode 上第 100号（same-tree）问题：判断两棵二叉树是否结构相同。题目难度为 Easy。 英文地址：https://leetcode.com/problems/same-tree/ 中文地址：https://leetcode-cn.com/problems/same-tree/ 题目描述Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: Input: 1 1 / \\ 2 2 [1,2], [1,null,2]Output: false 思路一：非递归两棵二叉树结构相同，需要满足以下条件： 二叉树结构相同 二叉树对应节点值相同 根据层次遍历算法，访问每一个节点，检查每个节点是否相同，核心算法如下： if (p == null &amp;&amp; q == null) { continue;}if (p == null || q == null) { return false;}if (p.val != q.val) { return false;} Java实现class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q == null) { return true; } if (p == null || q == null) { return false; } Queue&lt;TreeNode&gt; pWrapQueue = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; qWrapQueue = new LinkedList(); pWrapQueue.offer(p); qWrapQueue.offer(q); while (!pWrapQueue.isEmpty() &amp;&amp; !qWrapQueue.isEmpty()) { TreeNode pNode = pWrapQueue.poll(); TreeNode qNode = qWrapQueue.poll(); if (pNode == null &amp;&amp; qNode == null) { continue; } if (pNode == null || qNode == null) { return false; } if (pNode.val != qNode.val) { return false; } pWrapQueue.offer(pNode.left); qWrapQueue.offer(qNode.left); pWrapQueue.offer(pNode.right); qWrapQueue.offer(qNode.right); } return pWrapQueue.size() == qWrapQueue.size(); }} Koltin实现class Solution { fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean { if (p == null &amp;&amp; q == null) { return true } if (p == null || q == null) { return false } val pWrapQueue = LinkedList&lt;TreeNode&gt;() val qWrapQueue = LinkedList&lt;TreeNode&gt;() pWrapQueue.offer(p) qWrapQueue.offer(q) while (!pWrapQueue.isEmpty() &amp;&amp; !qWrapQueue.isEmpty()) { val pNode = pWrapQueue.poll() val qNode = qWrapQueue.poll() if (pNode == null &amp;&amp; qNode == null) { continue; } if (pNode == null || qNode == null) { return false; } if (pNode.`val` != qNode.`val`) { return false; } pWrapQueue.offer(pNode.left) pWrapQueue.offer(pNode.right) qWrapQueue.offer(qNode.left) qWrapQueue.offer(qNode.right) } return pWrapQueue.size == qWrapQueue.size }} 思路二：递归Java实现class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null &amp;&amp; q == null) { return true; } if (p == null || q == null) { return false; } if (p.val == q.val) { return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); } return false; }} Koltin实现class Solution { tailrec fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean { if (p == null &amp;&amp; q == null) { return true } if (p == null || q == null) { return false } if (p.`val` == q.`val`) { return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right) } return false }}","link":"/2020/06/28/LeetCode/binary-tree/11-same-tree/"},{"title":"LeetCode 二叉树：求二叉树中的节点个数","text":"题目来源于 LeetCode 上第 222 号（ Count Complete Tree Nodes）问题：求二叉树中的节点个数。题目难度为 Medium。 英文地址：https://leetcode.com/problems/count-complete-tree-nodes/ 中文地址：https://leetcode-cn.com/problems/count-complete-tree-nodes/ 题目描述Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input: 1 / \\ 2 3 / \\ /4 5 6Output: 6 思路一：DFS假设每个节点都标记为1，空节点标记为0，将每个节点的和累加起来即可 Java实现class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } return countNodes(root.left) + countNodes(root.right) + 1; }} Koltin实现class Solution { private tailrec fun countNodes(root: TreeNode?): Int { if (root == null) { return 0 } return countNodes(root.left) + countNodes(root.right) + 1 } } 思路二：BFS假设每个节点都标记为1，空节点标记为0，根据前序、中序、后序、层次遍历访问每个节点，遇到不为空的节点+1，层次遍历算法如下，前序、中序、后序遍历原理相同 Java实现class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 0; while (!queue.isEmpty()) { count++; TreeNode node = queue.poll(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } return count; }} Koltin实现class Solution { fun countNodes(root: TreeNode?): Int { var count = 0 root?.let { it -&gt; val queue = LinkedList&lt;TreeNode&gt;() queue.offer(root) while (!queue.isEmpty()) { count++ val node = queue.poll() if (node.left != null) { queue.offer(node.left) } if (node.right != null) { queue.offer(node.right) } } } return count }} 扩展题目1. 求二叉树中第K层结点的个数构建一棵二叉树（不一定是二叉查找树），求出该二叉树中第K层中的结点个数（根结点为第0层） 代码如下 class Solution { public int countLevelNodes(TreeNode root, int k) { if (root == null || k &lt;= 0) { return 0; } if (k == 1) { return 1; } return countLevelNodes(root.left, k - 1) + countLevelNodes(root.right, k - 1); }} 2. 求二叉树第K层的叶子节点个数代码如下： class Solution { public int countLevelNodes(TreeNode root, int k) { if (root == null || k &lt;= 0) { return 0; } if (k == 1) { if (root.left != null &amp;&amp; root.right != null) { return 1; } else { return 0; } } return countLevelNodes(root.left, k - 1) + countLevelNodes(root.right, k - 1); }}","link":"/2020/06/28/LeetCode/binary-tree/10-count-complete-tree-nodes/"},{"title":"LeetCode 二叉树：自下而上分层遍历","text":"题目来源于 LeetCode 上第 107 号（Binary Tree Level Order Traversal II）问题：自下而上分层遍历。题目难度为 Easy。 英文地址：https://leetcode.com/problems/binary-tree-level-order-traversal-ii/ 中文地址：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/ 题目描述Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\9 20 / \\ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3]] 思路一：BFSBFS: 广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法，从根节点开始，沿着树(图)的宽度遍历树(图)的节点，如果所有节点均被访问，则算法中止 二叉树的自下而上分层遍历，和层次遍历相同，只不过在添加数据的时候，逆序添加，具体步骤如下： 新建一个 queue，用来存储访问的每个节点 新建一个 wrapList 集合，保存每层的数据 循环判断队列是否为空，如果队列为空即循环终止 获取每一层的数据的长度，将数据保存到 subList 中 遍历每层数据时，将下一层的节点保存到 queue 中 每层遍历结束，将当前层 subList 数据 逆序添加到 wrapList，如：wrapList.add(0, subList); 再次执行3~6，直到 queue 为空即结束循环 注意： 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 remove() poll() 查找 element() peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null Java实现class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if (root == null) { return wrapList; } queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); List&lt;Integer&gt; subList = new LinkedList(); for (int i = 0; i &lt; size; i++) { TreeNode node = queue.poll(); subList.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } wrapList.add(0, subList); } return wrapList; }} Koltin实现class Solution { fun levelOrderBottom(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; { val wrapList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() root?.let { val queue = ArrayDeque&lt;TreeNode&gt;() queue.offer(root) while (!queue.isEmpty()) { val subList = mutableListOf&lt;Int&gt;() var size = queue.size while (size &gt; 0) { val node = queue.poll() subList.add(node.`val`) if (node.left != null) queue.offer(node.left) if (node.right != null) queue.offer(node.right) size-- } wrapList.add(0, subList) } } return wrapList }} 思路二：DFSDFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 Java实现class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList(); dfs(wrapList, root, 0); return wrapList; } public void dfs(List&lt;List&lt;Integer&gt;&gt; subList, TreeNode root, int level) { if (root == null) { return; } if (level &gt;= subList.size()) { subList.add(0, new LinkedList&lt;Integer&gt;()); } subList.get(subList.size() - 1 - level).add(root.val); dfs(subList, root.left, level + 1); dfs(subList, root.right, level + 1); }} Koltin尾递归实现class Solution { fun levelOrderBottom(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; { val wrapList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() dfs(wrapList, root, 0) return wrapList } tailrec fun dfs(subList: MutableList&lt;MutableList&lt;Int&gt;&gt;, root: TreeNode?, level: Int) { if (root == null) { return } if (level &gt;= subList.size) { subList.add(0, mutableListOf&lt;Int&gt;()) } subList[subList.size - 1 - level].add(root.`val`) dfs(subList, root.left, level + 1) dfs(subList, root.right, level + 1) }}","link":"/2020/06/28/LeetCode/binary-tree/09-binary-tree-level-order-traversal/"},{"title":"LeetCode 二叉树：判断二叉树是不是平衡二叉树","text":"题目来源于 LeetCode 上第 110 号（Balanced Binary Tree）问题：判断二叉树是不是平衡二叉树。题目难度为 Easy。 英文地址：https://leetcode.com/problems/balanced-binary-tree/ 中文地址：https://leetcode-cn.com/problems/balanced-binary-tree/ 题目描述GGiven a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1.一个二叉树其中每个节点的两个子树的深度差不相差超过1 Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \\9 20 / \\ 15 7 Return true. Example 1: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \\ 2 2 / \\ 3 3 / \\4 4 Return false. 思路:平衡二叉树: 左右两个子树的深度差的绝对值不超过 1 任意一个节点的深度是由它左右两个子节点的深度决定的, 如果左右两个节点的最大深度分别为L1和R1，任意一个节点的差都满足 abs(L1 - R1)&lt;=1，那么就是平衡二叉树 Java实现public boolean isBalanced(TreeNode root) { return maxDepth(root) != -1;}public int maxDepth(TreeNode root) { if (root == null) { return 0; } int left = maxDepth(root.left); int right = maxDepth(root.right); if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) { return -1; } return Math.max(left, right) + 1;} Koltin尾递归实现fun isBalanced(root: TreeNode?): Boolean { return maxDepth(root) != -1}tailrec fun maxDepth(root: TreeNode?): Int { if (root == null) { return 0; } val left = maxDepth(root.left); val right = maxDepth(root.right); return if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) -1 else Math.max(left, right) + 1}","link":"/2020/06/28/LeetCode/binary-tree/08-balanced-binary-tree/"},{"title":"LeetCode 二叉树：计算二叉树的最大深度","text":"题目来源于 LeetCode 上第 111 号（Minimum Depth of Binary Tree）问题：计算二叉树的最小深度。题目难度为 Easy。 英文地址：https://leetcode.com/problems/minimum-depth-of-binary-tree/ 中文地址：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/ 题目描述Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\9 20 / \\ 15 7 return its minimum depth = 2. 思路:二叉树的最小深度: 从根节点到叶子节点的最短路径上的节点个数注意：叶子节点即没有左右子节点 任意一个节点的深度是由它左右两个子节点的深度决定的，如果左右两个子节点的深度分别为L1和R1，当前节点的最小深度就是 min(L1,R1)+1，公式如下： minDepth(root) = Math.min(minDepth(root.left), minDepth(root.right)) + 1 但是需要注意的是不能只判断左右两个子节点的深度的最小值，因为即使某个节点不是叶子节点，但是它的一个子节点是空节点，那么递归就会返回，从而误判这条路径是最短的，例如： 1 / 2 如果只是判断左右两个子节点的深度的最小值，那么返回结果是1，但是实际上这个二叉树的最小深度是2 Java实现public int minDepth(TreeNode root) { if (root == null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); if (left == 0 || right == 0) { return left + right + 1; } else { return Math.min(left, right) + 1; }} Koltin尾递归实现tailrec fun minDepth(root: TreeNode?): Int { if (root == null) { return 0; } val left = minDepth(root.left) val right = minDepth(root.right) return if (left == 0 || right == 0) left + right + 1 else Math.min(left, right) + 1}","link":"/2020/06/28/LeetCode/binary-tree/07-minimum-depth-of-binary-tree/"},{"title":"LeetCode 二叉树：计算二叉树的最大深度","text":"题目来源于 LeetCode 上第 104 号（Maximum Depth of Binary Tree）问题：计算二叉树的最大深度。题目难度为 Easy。 英文地址：https://leetcode.com/problems/maximum-depth-of-binary-tree/ 中文地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 题目描述Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\9 20 / \\ 15 7 return its depth = 3. 思路:二叉树的最大深度: 从根节点到叶子节点的最长路径上的节点个数注意：叶子节点即没有左右子节点 任意一个节点的深度是由它左右两个子节点的深度决定的，如果左右两个子节点的深度分别为L1和R1，当前节点的最大深度就是 max(L1,R1)+1，公式如下： maxDepth(root) = Math.max(maxDepth(root.left), maxDepth(root.right)) + 1 Java实现public int maxDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;} Koltin尾递归实现tailrec fun maxDepth(root: TreeNode?): Int { if (root == null) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1}","link":"/2020/06/28/LeetCode/binary-tree/06-maximum-depth-of-binary-tree/"},{"title":"LeetCode 二叉树：从前序与中序遍历序列构造二叉树","text":"题目来源于 LeetCode 上第 105号（Construct Binary Tree from Preorder and Inorder Traversal）问题：从前序与中序遍历序列构造二叉树。题目难度为 Medium。这道题目和 剑指offer： 07 重建二叉树 一样 英文地址：https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 中文地址：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 剑指offer 07 重建二叉树：https://leetcode-cn.com/problems/zhong-jian…… 题目描述Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 3 / \\9 20 / \\ 15 7 思路：如果还不了解前序遍历和中序遍历算法可以点击下方链接前往 前序遍历中序遍历 前序遍历和中序遍历过程如下： 前序遍历：根结点 —&gt; 左节点 —&gt; 右节点 中序遍历：左节点—&gt; 根结点 —&gt; 右节点 根据前序遍历的规则，可知 preorder[0] 一定是整棵二叉树的根节点，如果根节点所在的下标为 index，根据中序遍历的规则，可知中序序列 inorder： 区间 inorder[0, index - 1] 属于根节点的左子树 区间 inorder[index + 1, n - 1] 属于根节点的右子树 根据前序遍历的规则一定是先遍历完左子树，然后才会遍历右子树，所以前序序列 preorder： 区间 preorder[1, index] 在根节点的 preorder[0] 的左边 区间 preorder[index+1, n] 在根节点的 preorder[0] 的右边 所以算法思路如下： 根节点是Preorder数组中的第一个元素，即 preorder[0] 在Inorder数组中查找根的位置 index 在Inorder数组中，根元素左边的元素是左子树，即区间 inorder[0, index - 1] 在Inorder数组中，根元素右边的元素是右子树，即区间 inorder[index + 1, n - 1] 在preorder数组中，区间 preorder[1, index] 在根节点的preorder[0] 的左边 在preorder数组中，preorder[index+1, n] 在根节点的preorder[0] 的右边 在由左子树中的元素组成的子数组上递归调用 在由右子树中的元素组成的子数组上递归地调用 复杂度分析： 时间复杂度：O(n), 遍历每一个节点，重建二叉树 空间复杂度：O(n)，需要存储建立的二叉树 Kotlin 尾递归实现class Solution { fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? { return tailrecOrder(preorder, inorder) } tailrec fun tailrecOrder(preorder: IntArray, inorder: IntArray): TreeNode? { if (preorder.size &lt;= 0 || inorder.size &lt;= 0) { return null; } val key = preorder[0] val root = TreeNode(key) if (preorder.size == 1) { return root } val index = getRootIndex(inorder, key) if (index &gt; 0 || index &lt; preorder.size) { // 计算左子树，所以根节点除外，从下标1开始 var pre = Arrays.copyOfRange(preorder, 1, index + 1) var inor = Arrays.copyOfRange(inorder, 0, index) root.left = tailrecOrder(pre, inor) pre = Arrays.copyOfRange(preorder, index + 1, preorder.size) inor = Arrays.copyOfRange(inorder, index + 1, inorder.size) root.right = tailrecOrder(pre, inor) } return root } fun getRootIndex(inorder: IntArray, key: Int): Int { inorder.forEachIndexed { index, item -&gt; if (item == key) { return index } } return -1 }} Java 实现class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length &lt;= 0 || inorder.length &lt;= 0) { return null; } int key = preorder[0]; TreeNode root = new TreeNode(key); if (preorder.length == 1) { return root; } int index = getRootIndex(inorder, key); if (index &gt; 0 || index &lt; preorder.length) { // 计算左子树，所以根节点除外，从下标1开始 int[] pre = Arrays.copyOfRange(preorder, 1, index + 1); int[] inor = Arrays.copyOfRange(inorder, 0, index); root.left = buildTree(pre, inor); pre = Arrays.copyOfRange(preorder, index + 1, preorder.length); inor = Arrays.copyOfRange(inorder, index + 1, inorder.length); root.right = buildTree(pre, inor); } return root; } private final int getRootIndex(int[] inorder, int key) { for (int i = 0; i &lt; preorder.length; i++) { if (preorder[i] == key) { return i; } } return -1; }}","link":"/2020/06/28/LeetCode/binary-tree/05-binary-tree-construct/"},{"title":"LeetCode 二叉树：层次遍历","text":"题目来源于 LeetCode 上第 102号（Binary Tree Level Order Traversal）问题：二叉树的层次遍历。题目难度为 Medium。 英文地址: https://leetcode.com/problems/binary-tree-level-order-traversal/中文地址: https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 题目描述Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). Example: Given binary tree [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7return its level order traversal as:[ [3], [9,20], [15,7]] 二叉树的层次遍历过程：逐层遍历 结果为：4 2 6 1 3 5 7 思路一：BFSBFS: 广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法，从根节点开始，沿着树(图)的宽度遍历树(图)的节点，如果所有节点均被访问，则算法中止 二叉树的层次遍历即逐层遍历，由上图所示按照访问的顺序依次输出，得出需要用到队列 新建一个 queue，用来存储访问的每个节点 新建一个 wrapList 集合，保存每层的数据 循环判断队列是否为空，如果队列为空即循环终止 获取每一层的数据的长度，依次遍历，将数据保存到 currLevelList 中 遍历每层数据时，将下一层的节点保存到 queue 中 每层遍历结束，将当前层 currLevelList 数据保存到 wrapList 再次执行3~6，直到 queue 为空即结束循环 注意： 每种 Queue 方法存在两种形式： 如果操作失败，抛出了一个异常 其他的返回一个特殊值（null 或者 false，取决于操作） 操作类型 抛出异常 返回特殊值 插入 add(e) offer(e) 移除 弹出 poll() 查找 弹出 peek() Queue 的实现可以限制所持有元素的数量，这样的队列称为有界，有些 Queue 实现 java.util.concurrent 是有界的，但实现 java.util 不是： add ：继承自 Collection，插入一个元素，除非它会违反队列的容量限制，在这种情况下抛出 IllegalStateException offer ：方法仅用于有界队列，不能插入时，返回 fasle 在 remove 与 poll 方法都是从队列中删除第一个元素，如果队列为空： remove : removethrows NoSuchElementException poll : 返回 null element 与 peek 方法用于在队列的头部查询元素，如果队列为空： element : 抛出 NoSuchElementException peek : 返回 null Java实现class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { // 存储每层的数据 List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList(); if (root == null) return wrapList; // 存储访问过的每层节点 Queue&lt;TreeNode&gt; queue = new LinkedList(); queue.offer(root); while (!queue.isEmpty()) { int len = queue.size(); // 获取每层的数据的长度 List&lt;Integer&gt; currLevelList = new LinkedList(); // 遍历每次每层的数据 for (int i = 0; i &lt; len; i++) { root = queue.poll(); // 按照每层遍历的顺序，存储每层的节点 currLevelList.add(root.val); // 将下一层的节点入队 if (root.left != null) queue.add(root.left); if (root.right != null) queue.add(root.right); } wrapList.add(currLevelList); } return wrapList; }} Kotlin实现class Solution { fun levelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; { val wrapList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() root?.let { val queue = ArrayDeque&lt;TreeNode&gt;() queue.offer(root) while (queue.isNotEmpty()) { val currLevelList = mutableListOf&lt;Int&gt;() var len = queue.size while (len &gt; 0) { queue.poll()?.let { curNode -&gt; currLevelList.add(curNode.`val`) if (curNode.left != null) queue.offer(curNode.left) if (curNode.right != null) queue.offer(curNode.right) } len-- } wrapList.add(currLevelList) } } return wrapList }} 思路二：DFSDFS: 深度优先搜索算法（Depth-First-Search），是搜索算法的一种, 它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。 Java 实现class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList(); dfs(wrapList, root, 0); return wrapList; } public void dfs(List&lt;List&lt;Integer&gt;&gt; wrapList, TreeNode root, int level) { if (root == null) return; if (level &gt;= wrapList.size()) { wrapList.add(new LinkedList&lt;Integer&gt;()); } List&lt;Integer&gt; currLevelList = wrapList.get(level); currLevelList.add(root.val); dfs(wrapList, root.left, level + 1); dfs(wrapList, root.right, level + 1); }} Kotlin 尾递归class Solution { fun levelOrder(root: TreeNode?): List&lt;List&lt;Int&gt;&gt; { val wrapList = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() dfs(wrapList, root, 0) return wrapList } tailrec fun dfs(wrapList: MutableList&lt;MutableList&lt;Int&gt;&gt;, root: TreeNode?, level: Int) { if (root == null) return if (level &gt;= wrapList.size) { wrapList.add(mutableListOf&lt;Int&gt;()) } wrapList[level].add(root.`val`) dfs(wrapList, root.left, level + 1) dfs(wrapList, root.right, level + 1) }}","link":"/2020/06/28/LeetCode/binary-tree/04-binary-tree-level-order/"},{"title":"LeetCode 二叉树：后序遍历","text":"题目来源于 LeetCode 上第 145号（Binary Tree Postorder Traversal）问题：二叉树的后序遍历。题目难度为 Medium。 英文地址: https://leetcode.com/problems/binary-tree-postorder-traversal/ 中文地址: https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 题目描述Given a binary tree, return the postorder traversal of its nodes’ values. Example: Input: [1,null,2,3] 1 \\ 2 / 3Output: [3,2,1] 二叉树的后序遍历过程: 左节点 -&gt; 右节点 -&gt; 根节点，如下图所示： 结果为：1 3 2 5 7 6 4 思路一：非递归一般分析问题我们需要采用自上而下的思维，而解决问题有时候采用自下而上的方式，正如上图后续遍历的结果：1 3 2 5 7 6 4，我们采用逆向思维，4是2、6的根节点，而6是5、7的根节点，依次类推逆向输出的过程：根节点 -&gt; 右节点 -&gt; 左节点, 我可以结合栈的特性，以及前序遍历的过程：根节点 -&gt; 左节点 -&gt; 右节点，去思考，大概过程如下： 先将根节点入栈 循环判断判断栈不为空 取出栈顶元素，并添加到list集合（逆序添加） 如果左节点不为空，并将左节点入栈 如果右节点不为空，并将右节点入栈 Java实现class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack(); List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); if(root == null) return list; // 先将根节点入栈 stack.push(root); // 循环判断判断栈不为空 while(!stack.isEmpty()){ root = stack.pop(); // 取出栈顶元素，并添加到list集合（逆序添加） list.add(0,root.val); //如果左节点不为空，并将左节点入栈 if(root.left!=null) stack.push(root.left); // 如果右节点不为空，并将右节点入栈 if(root.right!=null) stack.push(root.right); } return list; } } Kotlin实现class Solution { fun postorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() root?.let { val stack = Stack&lt;TreeNode&gt;() stack.push(it) while (!stack.isEmpty()) { val current = stack.pop() list.add(0, current.`val`) if (current.left != null) stack.push(current.left) if (current.right != null) stack.push(current.right) } } return list }} 思路二：递归后序遍历的递归思路和中序遍历、前序遍历大概一致，根据递归的两个特点去思考 递归的两个特点： 1. 问题与子问题的递归关系，采用自上而下的思考方式2. 递归的终止条件是当结点为叶子结点时终止（因为叶子节点没有左右结点） Java实现class Solution { List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) { if (root == null) return list; postorderTraversal(root.left); postorderTraversal(root.right); list.add(root.val); return list; }} Kotlin 尾递归实现class Solution { fun postorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() tailrecPreorder(root, list) return list } tailrec fun tailrecPreorder(root: TreeNode?, list: MutableList&lt;Int&gt;) { if (root == null) { return } tailrecPreorder(root.left, list) tailrecPreorder(root.right, list) list.add(root.`val`) }}","link":"/2020/06/28/LeetCode/binary-tree/03-binary-tree-postorder/"},{"title":"LeetCode 二叉树：中序遍历","text":"题目来源于 LeetCode 上第 94号（Binary Tree Inorder Traversal）问题：二叉树的中序遍历。题目难度为 Medium。 英文地址: https://leetcode.com/problems/binary-tree-inorder-traversal/ 中文地址: https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 题目描述Given a binary tree, return the inorder traversal of its nodes’ values Example: Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,3,2] 二叉树的中序遍历过程: 左节点 -&gt; 根节点 -&gt; 右节点，如下图所示： 结果为：1 2 3 4 5 6 7 思路一：非递归 循环检测栈是否为空，或者根节点是否为空 循环检测左节点，保存在栈中 弹出栈顶元素，再将当前指针移到其右子节点上，若存在右子节点，在次执行步骤2 Java实现class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack(); List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // 循环检测栈是否为空，或者根节点是否为空 while (!stack.isEmpty() || root != null) { // 循环检测左节点，保存在栈中 while (root != null) { stack.push(root); root = root.left; } // 弹出栈顶元素 root = stack.pop(); list.add(root.val); // 再将当前指针移到其右子节点上，若存在右子节点，在次执行步骤2 root = root.right; } return list; }} kotlin 实现class Solution { fun inorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() val stack = Stack&lt;TreeNode&gt;() var current = root while (!stack.isEmpty() || current != null) { while (current != null) { stack.push(current) current = current.left } stack.pop()?.let { item -&gt; list.add(item.`val`) current = item.right } } return list; }} 思路二：递归中序遍历递归思路和前序遍历大概一致，根据递归的两个特点去思考 递归的两个特点： 1. 问题与子问题的递归关系，采用自上而下的思考方式2. 递归的终止条件是当结点为叶子结点时终止（因为叶子节点没有左右结点） java 实现class Solution { List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { if (root == null) return list; inorderTraversal(root.left); list.add(root.val); inorderTraversal(root.right); return list; }} kotlin 尾递归实现class Solution { fun inorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() tailrecInorder(root, list) return list; } tailrec fun tailrecInorder(root: TreeNode?, list: MutableList&lt;Int&gt; = mutableListOf()) { if (root == null) { return } tailrecInorder(root.left, list) list.add(root.`val`) tailrecInorder(root.right, list) }}","link":"/2020/06/28/LeetCode/binary-tree/02-binary-tree-inorder/"},{"title":"LeetCode 二叉树： 前序遍历","text":"题目来源于 LeetCode 上第 144号（Binary Tree Preorder Traversal）问题：二叉树的前序遍历，题目难度为 Medium。 英文地址: https://leetcode.com/problems/binary-tree-preorder-traversal/ 中文地址：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ 题目描述Given a binary tree, return the preorder traversal of its nodes’ values. Example: Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,2,3] 二叉树的前序遍历过程: 根节点 -&gt; 左节点 -&gt; 右节点，如图所示： 结果为: 4 2 1 3 6 5 7 思路一：非递归可以利用栈的特性来解这道题，主要步骤如下： 循环检测栈是否为空，或者根节点是否为空 循环检测左节点，保存到栈中 当左节点遍历结束之后，取出栈顶的右节点，再次执行步骤2 Java实现class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack(); List&lt;Integer&gt; list = new LinkedList(); // 循环检测栈是否为空，或者根节点是否为空 while (!stack.isEmpty() || root != null) { // 循环检测左节点，保存到栈中 while (root != null) { stack.push(root); list.add(root.val); root = root.left; } // 取出栈顶的右节点，再次执行步骤2 if (!stack.isEmpty()) { root = stack.pop().right; } } return list; }} Kotlin 实现class Solution { fun preorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() val stack = Stack&lt;TreeNode&gt;() stack.push(root); while (!stack.isEmpty()) { stack.pop()?.let { root -&gt; list.add(root.`val`) if (root.right != null) stack.push(root.right) if (root.left != null) stack.push(root.left) } } return list }} 思路二：递归递归的两个特点： 问题和子问题都会调用函数自身，所以要找寻问题与子问题的递归关系，采用自上而下的思考方式 有个终止条件（临界点）结束当前递归 因此二叉树前序遍历按照上面两步进行分解 1. 问题与子问题的递归关系，采用自上而下的思考方式 按照二叉树的前序遍历过程: 根节点 -&gt; 左节点 -&gt; 右节点 对于根节点4，它的左右节点分别是2、6，继续往下递推 假设根节点是2，它的左右节点是分别1、3，继续往下递推 假设根节点是1，它没有左右节点，此时递推结束了，然后往上回溯，以右节点3作为根节点，以此类推 因此问题与子问题的递归关系：preorder(root) = preorder(root-&gt;left) + preorder(root-&gt;right) 2. 递归的终止条件是当结点为叶子结点时终止（因为叶子节点没有左右子结点） 将上面思路用代码表示如下 Java实现class Solution { List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { // 叶子节点没有左右子结点 if (root == null) return list; list.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return list; }} Kotlin 实现class Solution { fun preorderTraversal(root: TreeNode?): List&lt;Int&gt; { val list = mutableListOf&lt;Int&gt;() tailrecPreorder(root, list) return list } tailrec fun tailrecPreorder(root: TreeNode?, list: MutableList&lt;Int&gt;) { if (root == null) { return } list.add(root.`val`) tailrecPreorder(root.left, list) tailrecPreorder(root.right, list) }}#","link":"/2020/06/28/LeetCode/binary-tree/01-binary-tree-preorder/"},{"title":"基于 Smali 文件 Android Studio 动态调试 APP","text":"最近在研究动态调试技术，网上关于基于 Smali 动态调试App的教程很多，很多细节都没有贴出来，走了很多弯路，将调研结果分享一下，如果有写的不好地方，欢迎指正 Github：https://github.com/hi-dhl/DebugApkSmali 准备工作 一部 Root 过的 Android 手机，打开开发者模式 Xposed 的运行的环境 安装 smalidea 插件，点击这里下载 安装 BDOpener.apk 或者 XDebug.apk 反编译 Apk(apktool)点击 这里下载 最新的 apktool , 并配置好环境（不同环境配置的方式不同，参考 官网） 下载你需要反编译的 Apk 文件，执行 apktool d 反编译Apk名字.apk 如果反编译出来多个smali文件夹，可以用ant写个脚本，多个文件夹合并成一个 smalideaAndroidStudio 如果要调试smali代码，需要安装第三方插件: smalidea AS中【Android Studio–&gt;Preferences–&gt;Plugins–&gt;Install plugin from desk…】，安装插件 Android Studio 导入 smali 新疆一个 Android 工程项目（ps: 一定要新建Android项目，否则可能会找不到 “Attach debuger to Android Process”）删掉自动创建的资源和代码文件 复制反编译好的 smali 文件, 到新建 Android 项目 java 文件夹下 PS: 也可以使用我配置好的项目 “ApkSampleSmali” , 需要安装提供的 Sample.apk进行测试 Android Studio 动态调试配置新建调试配置，【Run–&gt;Edit Configurations–&gt; + –&gt;Remote】，name 随意，端口 8700 动态调试 在 smali 代码中打入断点，如下图标记1 然后点击 “Attach debuger to Android Process” ，如下图标记2 选择你要调试的进程，手动进入对应功能, 即进入断点动态调试（ps: 如果你想要的进程没有展示出来，请重新勾选 xposed module(BDOpener), 重启手机） 运行环境信息 Xposed Version90-beta3 BDOpener 1.0 AndoridStudio 3.3.2 smalidea 0.0.5 apktool 2.4.0","link":"/2020/05/30/AndroidStudio/02-smalidea/"},{"title":"解决在 Android Studio 3.2 找不到 Android Device Monitor 工具","text":"升级到 AndroidStudio 最新版本( &gt;3.2 )朋友们都会遇到一个问题，找不到 DDMS [Android Device Monitor], 只能从 SDK 目录下找到 monitor 启动 DDMS [Android Device Monitor]，所以写了一个插件快速启动 Android Device Monitor 源码及使用方式开发工具：IntelliJ IDEA Github地址：https://github.com/hi-dhl/DeviceMonitorPlugin 插件下载地址：https://github.com/hi-dhl/DeviceMonitorPlugin/releases/download/1.0/DeviceMonitorPlugin.jar 安装方式： 打开 AndroidStudio 选择 Preference -&gt; Plugins-&gt; install plugin from disk 选择下载好的插件 [DeviceMonitorPlugin.jar] -&gt; 重启 AndroidStudio 如何启动： 打开 AndroidStudio 菜单栏 tools -&gt; 单击 DeviceMonitor PS: Google 虽然删除了 AdnroidStudio 启动入口，但是本地 SDK 中还是存在，插件通过动态获取本地 SDK 路径启动 AndroidDeviceMonitor, 由于电脑性能不同，启动速度会有不同 Google 为什么弃用 Android Device MonitorAndroid Developers官网上的原文链接 Android Device Monitor 是一个 Android 应用调试和分析工具提供了一个 UI 工具，但是大部分组件在 Android Studio 3.1 已经弃用了, 并且会在 Android Studio 3.2 中移除，将会用新的工具帮助开发人员调试和分析 Android 应用 详情戳这里 插件核心代码public class Monitor extends AnAction { @Override public void actionPerformed(AnActionEvent anActionEvent) { try { Project project = anActionEvent.getData(PlatformDataKeys.PROJECT); String os = AndroidUtils.getPlatformName(); String sdkPath = AndroidUtils.getApkLocalProperties(project); if (os.toLowerCase().startsWith(&quot;win&quot;)) { sdkPath += File.separator + &quot;tools&quot; + File.separator + &quot;monitor.bat&quot;; } else { sdkPath += File.separator + &quot;tools&quot; + File.separator + &quot;monitor&quot;; } Runtime.getRuntime().exec(sdkPath); } catch (Exception e) { } }} /** * 动态获取本地Android SDK的路径 * * @param project * @return */public static String getApkLocalProperties(Project project) { String sdkPath = &quot;&quot;; try { String path = project.getBasePath() + File.separator + &quot;local.properties&quot;; Properties properties = new Properties(); InputStream inputStream = new FileInputStream(path); properties.load(inputStream); sdkPath = properties.getProperty(&quot;sdk.dir&quot;); } catch (Exception e) { } return sdkPath;} Github地址：https://github.com/hi-dhl/DeviceMonitorPlugin","link":"/2020/05/30/AndroidStudio/01-monitor/"},{"title":"LeetCode二分查找：寻找比目标字母大的最小字母","text":"题目来源于 LeetCode 上第 744 号（Find Smallest Letter Greater Than Target）问题：寻找比目标字母大的最小字母。题目难度为 Easy。 英文地址：https://leetcode.com/problems/find-smallest-letter-greater-than-target/ 中文地址：https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/ 题目描述Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target. Letters also wrap around. For example, if the target is target = ‘z’ and letters = [‘a’, ‘b’], the answer is ‘a’. Examples: Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;a&quot; Output: &quot;c&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;c&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;d&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;g&quot; Output: &quot;j&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;j&quot; Output: &quot;c&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;k&quot; Output: &quot;c&quot;Note: 1. letters has a length in range [2, 10000]. 2. letters consists of lowercase letters, and contains at least 2 unique letters. 3. target is a lowercase letter. 二分查找从题意分析从有序列表中找比目标字母大的最小字母得知，这题应该使用二分查找，因为二分查找的时间复杂度 O(logn) 但是这题目有个坑，就是题意给的不准确，笔者也提交几次才通过，总结规律如下： 当 target &lt; letters[0] 时，即 letters[0] 是比目标字母大的最小字母，返回 letters[0] 当 target &gt;= letters[height -1], 即返回 letters[0] Java 实现class Solution { public char nextGreatestLetter(char[] letters, char target) { int low = 0; int height = letters.length - 1; if (target &lt; letters[0] || target &gt;= letters[height]) return letters[0]; while (low &lt;= height) { int mind = (low + height) &gt;&gt;&gt; 1; if (letters[mind] &lt;= target) { low = mind + 1; } else { height = mind - 1; } } return letters[low]; }} Koltin 实现class Solution { fun nextGreatestLetter(letters: CharArray, target: Char): Char { var low = 0 var height = letters.size - 1 if (target &lt; letters[0] || target &gt;= letters[height]) { return letters[0] } while (low &lt;= height) { val mid = (low + height) ushr 1 when { letters[mid] &lt;= target -&gt; low = mid + 1 else -&gt; height = mid - 1 } } return letters[low] }}","link":"/2020/05/24/LeetCode/binary-search/03-find-letter/"},{"title":"LeetCode二分查找：X的平方根","text":"题目来源于 LeetCode 上第 69号（Sqrt(x)）问题：X的平方根。题目难度为 Easy。 英文地址：https://leetcode.com/problems/sqrtx/ 中文地址：https://leetcode-cn.com/problems/sqrtx/ 题目描述Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4Output: 2 Example 2: Input: 8Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 思路：二分查找二分法的解题思路大致以下几个步骤： 寻找平方根 x 的区间范围：[low, height] 用二分法在区间 [low, height] 内寻找平方根 当 low &lt;= height 时：令 mind = (low + height) / 2，square = mind * mind 比较 square 与 x： 如果 square &gt; x，则 height = mind -1。 如果 square &lt; x，则 low = mind + 1。 如果 square == x，即平方根为 mind，返回 mind。 如果在区间内没有找到，则返回 height。 如何确定 x 的区间范围：[low, height]？ 当 x &gt;= 2 时：它的整数平方根一定小于 x / 2 且大于 0，即 0 &lt; a &lt; x / 2，例如 9 的的平方根是 3，16 的平方根是 4，8 的平方根是 2.82842… 取整数部分即是 2，以此类类推可以将区间范围在次缩小 即 0 &lt; a &lt; x / 4 当 x =1 时：即 1 / 4 的值为0了，所以为了兼顾 1 的特殊情况，需要将边界设为 x / 4 +1 综合以上两种情况 x 的区间范围：[0, x / 4 + 1]，为了提高效率所以使用了位运算符，即 x/4 等价于 x &gt;&gt;&gt; 2 Java实现class Solution { public int mySqrt(int x) { long low = 0; long height = (x &gt;&gt;&gt; 2) + 1; long lx = (long) x; while (low &lt;= height) { long mind = (low + height) &gt;&gt;&gt; 1; long square = mind * mind; if (square == lx) { return (int) mind; } else if (square &lt; lx) { low = mind + 1; } else { height = mind - 1; } } return (int)height; }} Kotlin 实现class Solution { fun mySqrt(x: Int): Int { var low = 0L var height = (x ushr 2).toLong() + 1 val target = x.toLong() while (low &lt;= height) { val mind = (low + height) ushr 1 val square: Long = mind * mind when { square == target -&gt; return mind.toInt() square &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return height.toInt() }}","link":"/2020/05/24/LeetCode/binary-search/02-x-square/"},{"title":"LeetCode二分查找：有效的完全平方数","text":"题目来源于 LeetCode 上第 367 号（Valid Perfect Square）问题：有效的完全平方数。题目难度为 Easy。 英文地址：https://leetcode.com/problems/valid-perfect-square/ 中文地址：https://leetcode-cn.com/problems/valid-perfect-square/ 题目描述Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: Input: 16Output: true Example 2: Input: 14Output: false 思路：二分查找什么是完全平方数？维基百科 数学上，平方数，或称完全平方数，是指可以写成某个整数的平方的数，即其平方根为整数的数。例如，9 = 3 × 3，它是一个平方数。 二分法的解题思路大致以下几个步骤： 寻找完全平方数 x 的区间范围：[low, height] 用二分法在区间 [low, height] 内寻找完全平方数 当 low &lt;= height 时：令 mind = (low + height) / 2，square = mind * mind 比较 square 与 x： 如果 square &gt; x，则 height = mind -1。 如果 square &lt; x，则 low = mind + 1。 如果 square == x，即完全平方数为 mind，返回 true。 如果在区间内没有找到，则返回 false。 如何确定 x 的区间范围：[low, height]？ 根据上面的概念 完全平方数 是某个整数的平方的数，也就是说 完全平方数 = n *n，例如，9 = 3 × 3 当 x &gt;= 2 时：它的整数平方根一定小于 x / 2 且大于 0，即 0 &lt; a &lt; x / 2 当 x =1 时：即 1 / 2 的值为0了，所以为了兼顾 1 的特殊情况，需要将边界设为 x / 2 +1 综合以上两种情况 x 的区间范围：[0, x / 2 + 1]，为了提高效率所以使用了位运算符，即 x/2 等价于 x &gt;&gt;&gt; 1 Java实现public class Solution { public boolean isPerfectSquare(int num) { long low = 0; long height = (num &gt;&gt;&gt; 1) + 1; while (low &lt;= height) { long mind = (low + height) &gt;&gt;&gt; 1; long square = mind * mind; if (square == num) { return true; } else if (square &lt; num) { low = mind + 1; } else { height = mind - 1; } } return false; }} Koltin实现class Solution { fun isPerfectSquare(num: Int): Boolean { var low = 0L var height = (num ushr 1).toLong() + 1 var target = num.toLong() while (low &lt;= height) { val mind: Long = (low + height) ushr 1 val square = mind * mind when { square == target -&gt; return true square &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return false }}","link":"/2020/05/23/LeetCode/binary-search/01-square/"},{"title":"10分钟入门Shell脚本编程","text":"前言写下这篇文章，是对自己在学习和使用过程中的总结，文笔不是很好，如果有什么问题欢迎沟通交流 Github地址：https://github.com/hi-dhl/fast_guides Shell是什么Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务, Shell脚本（shell script），是一种为Shell编写的脚本程序。我们经常说的shell通常都是指shell脚本。 环境和工具Shell跟java、php、Python编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Mac OS，Linux 自带了shell解释器，Windows比较麻烦，因为Win7专业版和旗舰版默认安装PowerShell，标准版和家庭版中就没有安装的，为了方便建议安装cygwin PHP、Python 也可以作为Shell编程PHP、Python是属于高级编程语言，但是也可以做Shell编程，因为只要有解释器，也可以用作脚本编程 如下是一个Python Shell Script示例（假设文件名叫op_python_base.py）： #!/usr/bin/env python3 //告诉Python从系统环境中找python# -*- coding: utf-8 -*- //设置为UTF-8编码for index in range(10): print(index); 源码：op_python_base 如下是一个PHP Shell Script示例（假设文件名叫op_php_base.php）： #!/usr/bin/php&lt;?phpfor($i=0 ;$i&lt;10; $i++){ echo $i;}?&gt; 源码：op_php_base 为什么要学习Shell既然PHP、Python都可以用来写脚本编程，那为什么还要学习陌生、晦涩难懂的Shell，主要有一下几个原因 环境兼容性，Win7专业版和旗舰版默认安装PowerShell，标准版和家庭版中就没有安装的，其他主流的操作系统都预制了Shell解释器，所以使用sh、bash编写，提供给其他人使用是非常方便的，但是PHP、Python 等等需要安装相应的环境 如果你想做一些定时任务比如说检测进程是否存在，自动备份，或者说自动部署环境、服务器之间的数据同步等等sh、bash会是你最好的选择 sh与bashsh: Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh bash: Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash 第一个shell脚本我们先来看一个例子我相信写过代码的童鞋，应该对下面的代码很熟悉并不陌生，（假设文件名叫op_base.sh）： #!/usr/bin/env bashmkdir codecd codefor ((i=0; i&lt;3; i++)); do touch test_${i}.txt echo &quot;shell很简单&quot; &gt;&gt; test_${i}.txtdone 第一行：从系统path中寻找指定脚本的解释程序第二行：创建 名叫code文件夹第三行：进入创建的文件夹第四行：for循环3次第四行：创建文件第五行：往创建的文件中写入信息第六行：结束循环 mkdir, touch，cd，touch，echo都是系统命令，在命令行下可以直接执行for, do, done 是shell脚本语言 for循环的语法 源码：op_base.sh 编写Shell新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php，扩展名为php，如果你用Python，扩展名为python 第一行一般是这样： #!/usr/bin/php#!/usr/bin/env python3#!/usr/bin/env bash #!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行 /env 是系统的PATH目录中查找 运行 Shell 脚本有两种方法：作为可执行程序chmod +x op_base.sh./op_base.sh 第一行设置 op_base.sh可执行权限第二行执行op_base.sh 作为参数/bin/sh op_base.sh 变量定义变量时，变量名前不需要加符号和Python一样但是在PHP语言中变量需要加$，如： my_name=&quot;jack&quot;my_name='jack'; ps: 变量名和等号之间不能有空格,变量后面不能有; Shell中的引号和PHP类似，字符串可以用单引号，也可以用双引号 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行 双引号： 双引号里可以有变量 双引号里可以出现转义字符 但是在Python中单引号和双引号是没有区别，但是Python 还有三个引号，在三个引号内字符都不会被转义 使用变量对于已经定义过的变量，使用的适合在前面添加$ echo $my_nameecho ${my_name} 变量名外面的花括号是可选的，加不加都行,建议使用第二种形式 注释以“#”开头的行就是注释，会被解释器忽略。 多行注释sh里没有多行注释，只能每一行加一个#号。就像这样： #--------------------------------------------# Author: jack ## Notes: 10分钟入门Shell脚本编程## Project home page:# https://github.com/hi-dhl/fast_guides#-------------------------------------------- 字符串字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似 Shell不像其他语言有php、python 有很多数据类型，在Shell中常用的数据类型字符串数字和字符串（ps: 除了数字和字符串，也没啥其它类型好用了，哈哈） 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行 双引号： 双引号里可以有变量 双引号里可以出现转义字符 字符串操作拼接字符串my_name=&quot;jack&quot;;my_age=&quot;20岁&quot;echo $my_name $my_ageecho $my_name$my_age 获取字符串长度echo ${#my_name} 截取字符串echo ${my_name:0:2} 源码：op_str.sh Shell 数组定义数组在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： name=(name1 name2 name3) 还可以单独定义数组的各个分量： ary[0]=name1ary[1]=name2ary[3]=name3 ps: 可以不使用连续的下标，而且下标的范围没有限制 读取数组读取数组元素值的一般格式是： ${数组名[下标]} 例如： echo ${name[0]} 使用@符号可以获取数组中的所有元素，例如： echo ${name[@]} 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同，例如： # 取得数组元素的个数length=${#name[@]}echo $length# 或者length=${#name[*]}echo $length# 取得数组单个元素的长度lengthn=${#name[n]}echo $length 源码：op_arry.sh Shell 流程控制和Java、PHP、Python等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)： &lt;?phpif (isset($_GET[&quot;q&quot;])) { search(q);}else { // 不做任何事情} 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else ifif condition1then command1elif condition2 then command2else commandNfi 例子： #!/usr/bin/env basha=1b=2if [ $a == $b ] then echo &quot;a 等于 b&quot; elif [ $a -gt $b ] then echo &quot;a 大于 b&quot; elif [ $a -lt $b ] then echo &quot;a 小于 b&quot; else echo &quot;没有符合的条件&quot; fi 源码：op_if.sh for 循环Shell的for循环和Python 有点类似 Python的for循环for index in 1,2,3,4,5: print(index); Shell的for循环，第一种写法for index in 1 2 3 4 5; do echo &quot;index=&quot;$indexdone Shell的for循环，第二种写法for ((i=0; i&lt;5; i++)); do echo &quot;i=&quot;$idone 源码：op_for.sh while 语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。 int=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 源码：op_while.sh Shell结合系统命令sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。 例如定时检测nginx、mysql是否被关闭path=/var/loglog=${path}/httpd-mysql.logname=(apache mysql)exs_init[0]=&quot;service httpd start&quot;exs_init[1]=&quot;/etc/init.d/mysqld restart&quot;for ((i=0; i&lt;2; i++)); do echo &quot;检查${name[i]}进程是否存在&quot; ps -ef|grep ${name[i]} |grep -v grep if [ $? -eq 0 ]; then pid=$(pgrep -f ${name[i]}) echo &quot;`date +&quot;%Y-%m-%d %H:%M:%S&quot;` ${name[$i]} is running with pid $pid&quot; &gt;&gt; ${log} else $(${exs_init[i]}) echo &quot;`date +&quot;%Y-%m-%d %H:%M:%S&quot;` ${name[$i]} start success&quot; &gt;&gt; ${log} fidone 解释：检测 nginx、mysql进程是否存在，如果不存在了会自动重新启动。脚本每次运行会写日志的，没事可以去看看该日志文件，如果进程是不是真的经常性不存在，恐怕就要排查一下深层原因了。 源码：check_nginx.sh 编辑 /etc/crontab 文件crontab -e 在文件最后添加一行： */5 * * * * /xxx/check_nginx.sh &gt; /dev/null 2&gt;&amp;1 上表示每 5 分钟，执行一下脚本 /xxx/check_nginx.sh，其中xxx代表路径 /dev/null 2&gt;&amp;1 的意思是该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。 # For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * command to be executed 添加完配置，需要重启才能生效service crond restart","link":"/2020/05/21/Linux/01-shell/"}],"tags":[{"name":"AndroidStudio","slug":"AndroidStudio","link":"/tags/AndroidStudio/"},{"name":"译文","slug":"译文","link":"/tags/%E8%AF%91%E6%96%87/"},{"name":"Koin","slug":"Koin","link":"/tags/Koin/"},{"name":"Fragment","slug":"Fragment","link":"/tags/Fragment/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"剑指Offer","slug":"剑指Offer","link":"/tags/%E5%89%91%E6%8C%87Offer/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"深度优先搜索","slug":"深度优先搜索","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","link":"/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Android源码","slug":"Android源码","link":"/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Android10-包管理系统","slug":"Android10-包管理系统","link":"/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Android10-资源管理系统","slug":"Android10-资源管理系统","link":"/tags/Android10-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Android10-窗口管理系统","slug":"Android10-窗口管理系统","link":"/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"逆向","slug":"逆向","link":"/categories/%E9%80%86%E5%90%91/"},{"name":"精选译文","slug":"精选译文","link":"/categories/%E7%B2%BE%E9%80%89%E8%AF%91%E6%96%87/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"剑指Offer","slug":"offer-algorithms","link":"/categories/offer-algorithms/"},{"name":"Android10","slug":"Android10","link":"/categories/Android10/"}]}