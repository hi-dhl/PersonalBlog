{"pages":[{"title":"","text":"google-site-verification: googlede5fd50279499fe2.html","link":"/googlede5fd50279499fe2.html"}],"posts":[{"title":"Google最新发布了 Fragment 的新特性 Fragment 间传递数据的新方式 以及源码分析","text":"原标题: Android Fragments: Fragment Result 原文地址: https://proandroiddev.com/android-fragments-fragment-result…… 原文作者: Husayn Hakeem 就在 2020/05/07 号 Now in Android #17 更新了，发布 Android 的新特性，其中就包括 Fragment 间通信的新方式，大家可以点击这里前往，看看都有那些更新 通过这篇文章你将学习到以下内容，将在译者思考部分会给出相应的答案 新 Fragment 间通信的方式的使用？ 新 Fragment 间通信的源码分析？ 汇总 Fragment 之间的通信的方式？ 译文Frrgament 间传递数据可以通过多种方式，包括使用 target Fragment APIs (Fragment.setTargetFragment() 和 Fragment.getTargetFragment())，ViewModel 或者 使用 Fragments’ 父容器 Activity，target Fragment APIs 已经过时了，现在鼓励使用新的 Fragment result APIs 完成 Frrgament 之间传递数据，其中传递数据由 FragmentManager 处理，并且在 Fragments 设置发送数据和接受数据 在 Frrgament 之间传递数据使用新的 Fragment APIs 在 两个 Frrgament 之间的传递，没有任何引用，可以使用它们公共的 FragmentManager，它充当 Frrgament 之间传递数据的中心存储。 接受数据如果想在 Fragment 中接受数据，可以在 FragmentManager 中注册一个 FragmentResultListener，参数 requestKey 可以过滤掉 FragmentManager 发送的数据 FragmentManager.setFragmentResultListener( requestKey, lifecycleOwner, FragmentResultListener { requestKey: String, result: Bundle -&gt; // Handle result }) 参数 lifecycleOwner 可以观察生命周期，当 Fragment 的生命周期处于 STARTED 时接受数据。如果监听 Fragment 的生命周期，您可以在接收到新数据时安全地更新 UI，因为 view 的创建(onViewCreated() 方法在 onStart() 之前被调用)。 当生命周期处于 LifecycleOwner STARTED 的状态之前，如果有多个数据传递，只会接收到最新的值 当生命周期处于 LifecycleOwner DESTROYED 时，它将自动移除 listener，如果想手动移除 listener，需要调用 FragmentManager.setFragmentResultListener() 方法，传递空的 FragmentResultListener 在 FragmentManager 中注册 listener，依赖于 Fragment 发送返回的数据 如果在 FragmentA 中接受 FragmentB 发送的数据，FragmentA 和 FragmentB 处于相同的层级，通过 parent FragmentManager 进行通信，FragmentA 必须使用 parent FragmentManager 注册 listener parentFragmentManager.setFragmentResultListener(...) 如果在 FragmentA 中接受 FragmentB 发送的数据，FragmentA 是 FragmentB 的父容器， 他们通过 child FragmentManager 进行通信 childFragmentManager.setFragmentResultListener(...) listener 必须设置的Fragment 相同的 FragmentManager 发送数据如果 FragmentB 发送数据给 FragmentA，需要在 FragmentA 中注册 listener，通过 parent FragmentManager 发送数据 parentFragmentManager.setFragmentResult( requestKey, // Same request key FragmentA used to register its listener bundleOf(key to value) // The data to be passed to FragmentA) 测试 Fragment Results测试 Fragment 是否成功接收或发送数据，可以使用 FragmentScenario API 接受数据如果在 FragmentA 中注册 FragmentResultListener 接受数据，你可以模拟 parent FragmentManager 发送数据，如果在 FragmentA 中正确注册了 listener，可以用来验证 FragmentA 是否能收到数据，例如，如果在 FragmentA 中接受数据并更新 UI, 可以使用 Espresso APIs 来验证是否期望的数据 @Testfun shouldReceiveData() { val scenario = FragmentScenario.launchInContainer(FragmentA::class.java) // Pass data using the parent fragment manager scenario.onFragment { fragment -&gt; val data = bundleOf(KEY_DATA to &quot;value&quot;) fragment.parentFragmentManager.setFragmentResult(&quot;aKey&quot;, data) } // Verify data is received, for example, by verifying it's been displayed on the UI onView(withId(R.id.textView)).check(matches(withText(&quot;value&quot;))) } 发送数据可以在 FragmentB 的 parent FragmentManager 上注册一个 FragmentResultListener 来测试 FragmentB 是否成功发送数据，当发送数据结束时，可以来验证这个 listener 是否能收到数据 @Testfun shouldSendData() { val scenario = FragmentScenario.launchInContainer(FragmentB::class.java) // Register result listener var receivedData = &quot;&quot; scenario.onFragment { fragment -&gt; fragment.parentFragmentManager.setFragmentResultListener( KEY, fragment, FragmentResultListener { key, result -&gt; receivedData = result.getString(KEY_DATA) }) } // Send data onView(withId(R.id.send_data)).perform(click()) // Verify data was successfully sent assertThat(receivedData).isEqualTo(&quot;value&quot;)} 示例项目下面的示例项目，展示了如何使用 Fragment 新的 API android-playground: https://github.com/husaynhakeem/android-playground… 总结虽然使用了 Fragment result APIs，替换了过时的 Fragment target APIs，但是新的 APIs 在Bundle 作为数据传传递方面有一些限制，只能传递简单数据类型、Serializable 和 Parcelable 数据，Fragment result APIs 允许程序从崩溃中恢复数据，而且不会持有对方的引用，避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 译者的思考这是译者的一些思考，总结一下 Fragment 1.3.0-alpha04 新增加的 Fragment 间通信的 API 数据接受 FragmentManager.setFragmentResultListener( requestKey, lifecycleOwner, FragmentResultListener { requestKey: String, result: Bundle -&gt; // Handle result }) 数据发送 parentFragmentManager.setFragmentResult( requestKey, // Same request key FragmentA used to register its listener bundleOf(key to value) // The data to be passed to FragmentA) 那么 Fragment 间通信的新 API 给我们带来哪些好处呢： 在 Fragment 之间传递数据，不会持有对方的引用 当生命周期处于 ON_START 时开始处理数据，避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 当生命周期处于 ON_DESTROY 时，移除监听 我们一起来从源码的角度分析一下 Google 是如何做的 源码分析按照惯例从调用的方法来分析，数据接受时，调用了 FragmentManager 的 setFragmentResultListener 方法androidx.fragment/fragment/1.3.0-alpha04……androidx/fragment/app/FragmentManager.java private final ConcurrentHashMap&lt;String, LifecycleAwareResultListener&gt; mResultListeners = new ConcurrentHashMap&lt;&gt;();@Overridepublic final void setFragmentResultListener(@NonNull final String requestKey, @NonNull final LifecycleOwner lifecycleOwner, @Nullable final FragmentResultListener listener) { // mResultListeners 是 ConcurrentHashMap 的实例，用来储存注册的 listener // 如果传递的参数 listener 为空时，移除 requestKey 对应的 listener if (listener == null) { mResultListeners.remove(requestKey); return; } // Lifecycle是一个生命周期感知组件，一般用来响应Activity、Fragment等组件的生命周期变化 final Lifecycle lifecycle = lifecycleOwner.getLifecycle(); // 当生命周期处于 DESTROYED 时，直接返回 // 避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 if (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) { return; } // 开始监听生命周期 LifecycleEventObserver observer = new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { // 当生命周期处于 ON_START 时开始处理数据 if (event == Lifecycle.Event.ON_START) { // 开始检查受到的数据 Bundle storedResult = mResults.get(requestKey); if (storedResult != null) { // 如果结果不为空，调用回调方法 listener.onFragmentResult(requestKey, storedResult); // 清除数据 setFragmentResult(requestKey, null); } } // 当生命周期处于 ON_DESTROY 时，移除监听 if (event == Lifecycle.Event.ON_DESTROY) { lifecycle.removeObserver(this); mResultListeners.remove(requestKey); } } }; lifecycle.addObserver(observer); mResultListeners.put(requestKey, new FragmentManager.LifecycleAwareResultListener(lifecycle, listener));} Lifecycle是一个生命周期感知组件，一般用来响应Activity、Fragment等组件的生命周期变化 获取 Lifecycle 去监听 Fragment 的生命周期的变化 当生命周期处于 ON_START 时开始处理数据，避免当 Fragment 处于不可预知状态的时，可能发生未知的问题 当生命周期处于 ON_DESTROY 时，移除监听 接下来一起来看一下数据发送的方法，调用了 FragmentManager 的 setFragmentResult 方法androidx.fragment/fragment/1.3.0-alpha04……androidx/fragment/app/FragmentManager.java private final ConcurrentHashMap&lt;String, Bundle&gt; mResults = new ConcurrentHashMap&lt;&gt;();private final ConcurrentHashMap&lt;String, LifecycleAwareResultListener&gt; mResultListeners = new ConcurrentHashMap&lt;&gt;(); @Overridepublic final void setFragmentResult(@NonNull String requestKey, @Nullable Bundle result) { if (result == null) { // mResults 是 ConcurrentHashMap 的实例，用来存储数据传输的 Bundle // 如果传递的参数 result 为空，移除 requestKey 对应的 Bundle mResults.remove(requestKey); return; } // mResultListeners 是 ConcurrentHashMap 的实例，用来储存注册的 listener // 获取 requestKey 对应的 listener LifecycleAwareResultListener resultListener = mResultListeners.get(requestKey); if (resultListener != null &amp;&amp; resultListener.isAtLeast(Lifecycle.State.STARTED)) { // 如果 resultListener 不为空，并且生命周期处于 STARTED 状态时，调用回调 resultListener.onFragmentResult(requestKey, result); } else { // 否则保存当前传输的数据 mResults.put(requestKey, result); }} 获取 requestKey 注册的 listener 当生命周期处于 STARTED 状态时，开始发送数据 否则保存当前传输的数据 源码分析到这里结束了，我们一起来思考一下，在之前我们的都有那些数据传方式 汇总 Fragment 之间的通信的方式 通过共享 ViewModel 或者关联 Activity来完成，Fragment 之间不应该直接通信 参考 Google: ViewModel#sharing 通过接口，可以在 Fragment 定义接口，并在 Activity 实现它 参考 Google: 与其他 Fragment 通信 通过使用 findFragmentById 方法，获取 Fragment 的实例，然后调用 Fragment 的公共方法 参考 Google: 与其他 Fragment 通信 调用 Fragment.setTargetFragment() 和 Fragment.getTargetFragment() 方法，但是注意 target fragment 需要直接访问另一个 fragment 的实例，这是十分危险的，因为你不知道目标 fragment 处于什么状态 Fragment 新的 API, setFragmentResult() 和 setFragmentResultListener() 综合以上通信方式，那么你认为 Fragment 之间通信最好的方式是什么？ 参考文献 Now in Android #17: https://medium.com/androiddeve…… Pass data between fragments: https://developer.android.com/training/basi…… ViewModel#sharing: https://developer.android.com/topic/librari…… 与其他 Fragment 通信: https://developer.android.com/training/basic…… 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译相关的文章，目前正在翻译一系列欧美精选文章，不仅仅是翻译，还有翻译背后对每篇文章思考，如果你喜欢这片文章，请帮我点个赞，感谢，期待与你一起成长 算法由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长 Android 10 源码系列正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 Android10-Source-Analysis，文章都会同步到这个仓库","link":"/2020/06/10/translate/01-fragment/"},{"title":"LeetCode 剑指 offer：从尾到头打印链表","text":"题目来源于 LeetCode 剑指 offer 第 06 号问题：从尾到头打印链表。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/ 题目描述输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例: 输入：head = [1,3,2]输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 思路 第一次遍历计算链表的长度，创建相同长度的数组 reverse 第二次遍历将值 逆序 添加进 reverse 中 复杂度分析： 时间复杂度：O(n)，第一次遍历计算链表的长度，第二次遍历添加进数组 空间复杂度：O(n)，需要额外使用一个数组存储 Kotlin 实现class Solution { fun reversePrint(head: ListNode?): IntArray = head?.let { var count = 0 var currentNode = head while (currentNode != null) { count++ currentNode = currentNode.next } val reverse = IntArray(count) { 0 } currentNode = head while (currentNode != null) { reverse[--count] = currentNode.`val` currentNode = currentNode.next } reverse } ?: intArrayOf()} Java 实现class Solution { public int[] reversePrint(ListNode head) { if (head == null) { return new int[]{}; } int count = 0; ListNode currentNode = head; while (currentNode != null) { count++; currentNode = currentNode.next; } int[] reverse = new int[count]; currentNode = head; while (currentNode != null) { reverse[--count] = currentNode.val; currentNode = currentNode.next; } return reverse; }} 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译相关的文章，请持续关注 由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长","link":"/2020/06/07/LeetCode/offer/03-list/"},{"title":"0xA07 Android 10 源码分析：Window 的类型 以及 三维视图层级分析","text":"引言 这是 Android 10 源码分析系列的第 7 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 在之前的文章 0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构 介绍了 Activity、Window、PhoneWindow、WindowManager 之间的关系，以及 Activity 和 Dialog 的视图绑定过程，而这篇文章主要两个目的： 对上一篇文章 0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构 做深入的了解 为后面的篇文章「如何在 Andorid 系统里添加自定义 View」等等做好铺垫 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 Window 都有那些常用的参数? Window 都那些类型？每个类型的意思？以及作用？ Window 那些过时的 API 以及处理方案？ Window 视图层级顺序是如何确定的？ Window 都那些 flag？每个 flag 的意思？以及作用？ Window 的软键盘模式？每个模式的意思？以及如何使用？ Kotlin 小技巧？ 在开始分析之前，我们先来看一张图，熟悉一下几个基本概念，这些概念伴将随着整篇文章 我们在手机上看到的界面是二维的，但是实际上是一个三维，如上图所示 Window：是一个抽象类，它作为一个顶级视图添加到 WindowManager 中，View 是依附于 Window 而存在的，对 View 进行管理 WindowManager：它是一个接口，继承自接口 ViewManager，对 Window 进行管理 PhoneWindow：Window 唯一实现类，添加到 WindowManager 的根容器中 WindowManagerService：WindowManager 是 Window 的容器，管理着 Window，对 Window 进行添加和删除，最终具体的工作都是由 WindowManagerService 来处理的，WindowManager 和 WindowManagerService 通过 Binder 来进行跨进程通信，WindowManagerService 才是 Window 的最终管理者 这篇文章重要知识点是 Window 视图层级顺序是如何确定的，其他内容都是一些概念的东西，可以选择性的阅读，了解完基本概念之后，进入这篇文章的核心内容，我们先来了解一下 Window 都有那些常用的参数 Window 都有那些常用的参数Window 的参数都被定义在 WindowManager 的静态内部类 LayoutParams 中frameworks/base/core/java/android/view/WindowManager#LayoutParams.java public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable { // window 左上角的 x 坐标 public int x; // window 左上角的 y 坐标 public int y; // Window 的类型 public int type; // Window 的 flag 用于控制 Window 的显示 public int flags; // window 软键盘输入区域的显示模式 public int softInputMode; // window 的透明度，取值为0-1 public float alpha = 1.0f; // window 在屏幕中的位置 public int gravity; // window 的像素点格式，值定义在 PixelFormat 中 public int format;} 接下来我们我们主要来介绍一下 Window 的类型、Window 视图层级顺序、Window 的 flag、和 window 软键盘模式 Window 都那些类型以及作用Window 的类型大概可以分为三类： 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window）， Window 的类型通过 type 值来表示，每个大类型又包含多个小类型，它们都定义在 WindowManager 的静态内部类 LayoutParamsframeworks/base/core/java/android/view/WindowManager#LayoutParams.java public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable { public int type; // 应用程序 Window 的开始值 public static final int FIRST_APPLICATION_WINDOW = 1; // 应用程序 Window 的结束值 public static final int LAST_APPLICATION_WINDOW = 99; // 子 Window 类型的开始值 public static final int FIRST_SUB_WINDOW = 1000; // 子 Window 类型的结束值 public static final int LAST_SUB_WINDOW = 1999; // 系统 Window 类型的开始值 public static final int FIRST_SYSTEM_WINDOW = 2000; // 系统 Window 类型的结束值 public static final int LAST_SYSTEM_WINDOW = 2999;} 类型 值 备注 FIRST_APPLICATION_WINDOW 1 应用程序 Window 的开始值 LAST_APPLICATION_WINDOW 99 应用程序 Window 的结束值 FIRST_SUB_WINDOW 1000 子 Window 的开始值 LAST_SUB_WINDOW 1999 子 Window 的结束值 FIRST_SYSTEM_WINDOW 2000 系统 Window 的开始值 LAST_SYSTEM_WINDOW 2999 系统 Window 的结束值 小技巧：如果是层级在 2000（FIRST_SYSTEM_WINDOW）以下的是不需要申请弹窗权限的 应用程序 Window（Application Window）：它的区间范围 [1,99]，例如 Activity frameworks/base/core/java/android/view/WindowManager#LayoutParams.java* // 应用程序 Window 的开始值public static final int FIRST_APPLICATION_WINDOW = 1;// 应用程序 Window 的基础值public static final int TYPE_BASE_APPLICATION = 1;// 普通的应用程序public static final int TYPE_APPLICATION = 2;// 特殊的应用程序窗口，当程序可以显示 Window 之前使用这个 Window 来显示一些东西public static final int TYPE_APPLICATION_STARTING = 3;// TYPE_APPLICATION 的变体，在应用程序显示之前，WindowManager 会等待这个 Window 绘制完毕public static final int TYPE_DRAWN_APPLICATION = 4;// 应用程序 Window 的结束值public static final int LAST_APPLICATION_WINDOW = 99; 类型 备注 FIRST_APPLICATION_WINDOW 应用程序 Window 的开始值 TYPE_BASE_APPLICATION 应用程序 Window 的基础值 TYPE_APPLICATION 普通的应用程序 TYPE_APPLICATION_STARTING 特殊的应用程序窗口，当程序可以显示 Window 之前使用这个 Window 来显示一些东西 TYPE_DRAWN_APPLICATION TYPE_APPLICATION 的变体 在应用程序显示之前，WindowManager 会等待这个 Window 绘制完毕 LAST_APPLICATION_WINDOW 应用程序 Window 的结束值 子 Window（Sub Windwow）：它的区间范围 [1000,1999]，这些 Window 按照 Z-order 顺序依附于父 Window 上（关于 Z-order 后文有介绍），并且他们的坐标空间相对于父 Window 的，例如：PopupWindow frameworks/base/core/java/android/view/WindowManager#LayoutParams.java* // 子 Window 类型的开始值public static final int FIRST_SUB_WINDOW = 1000;// 应用程序 Window 顶部的面板。这些 Window 出现在其附加 Window 的顶部。public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;// 用于显示媒体(如视频)的 Window。这些 Window 出现在其附加 Window 的后面。public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1;// 应用程序 Window 顶部的子面板。这些 Window 出现在其附加 Window 和任何Window的顶部public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2;// 当前Window的布局和顶级Window布局相同时，不能作为子代的容器public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3;// 用显示媒体 Window 覆盖顶部的 Window， 这是系统隐藏的 APIpublic static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4;// 子面板在应用程序Window的顶部，这些Window显示在其附加Window的顶部， 这是系统隐藏的 APIpublic static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5;// 子 Window 类型的结束值public static final int LAST_SUB_WINDOW = 1999; 类型 备注 FIRST_SUB_WINDOW 子 Window 的开始值 TYPE_APPLICATION_PANEL 应用程序 Window 顶部的面板，这些 Window 出现在其附加 Window 的顶部 TYPE_APPLICATION_MEDIA 用于显示媒体(如视频)的 Window，这些 Window 出现在其附加 Window 的后面 TYPE_APPLICATION_SUB_PANEL 应用程序 Window 顶部的子面板，这些 Window 出现在其附加 Window 和任何Window的顶部 TYPE_APPLICATION_ATTACHED_DIALOG 当前Window的布局和顶级Window布局相同时，不能作为子代的容器 TYPE_APPLICATION_MEDIA_OVERLAY 用显示媒体 Window 覆盖顶部的 Window， 这是系统隐藏的 API TYPE_APPLICATION_ABOVE_SUB_PANEL 子面板在应用程序Window的顶部，这些Window显示在其附加Window的顶部， 这是系统隐藏的 API LAST_SUB_WINDOW 子 Window 的结束值 系统 Window（System Window）: 它区间范围 [2000,2999]，例如：Toast，输入法窗口，系统音量条窗口，系统错误窗口 frameworks/base/core/java/android/view/WindowManager#LayoutParams.java* // 系统Window类型的开始值public static final int FIRST_SYSTEM_WINDOW = 2000;// 系统状态栏，只能有一个状态栏，它被放置在屏幕的顶部，所有其他窗口都向下移动public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW;// 系统搜索窗口，只能有一个搜索栏，它被放置在屏幕的顶部public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_SYSTEM_ALERT = FIRST_SYSTEM_WINDOW+3;// 已经从系统中被移除，可以使用 TYPE_KEYGUARD_DIALOG 代替public static final int TYPE_KEYGUARD = FIRST_SYSTEM_WINDOW+4;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_TOAST = FIRST_SYSTEM_WINDOW+5;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW+6;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_PRIORITY_PHONE = FIRST_SYSTEM_WINDOW+7;// 系统对话框窗口public static final int TYPE_SYSTEM_DIALOG = FIRST_SYSTEM_WINDOW+8;// 锁屏时显示的对话框public static final int TYPE_KEYGUARD_DIALOG = FIRST_SYSTEM_WINDOW+9;@Deprecated// API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替public static final int TYPE_SYSTEM_ERROR = FIRST_SYSTEM_WINDOW+10;// 输入法窗口，位于普通 UI 之上，应用程序可重新布局以免被此窗口覆盖public static final int TYPE_INPUT_METHOD = FIRST_SYSTEM_WINDOW+11;// 输入法对话框，显示于当前输入法窗口之上public static final int TYPE_INPUT_METHOD_DIALOG= FIRST_SYSTEM_WINDOW+12;// 墙纸public static final int TYPE_WALLPAPER = FIRST_SYSTEM_WINDOW+13;// 状态栏的滑动面板public static final int TYPE_STATUS_BAR_PANEL = FIRST_SYSTEM_WINDOW+14;// 应用程序叠加窗口显示在所有窗口之上public static final int TYPE_APPLICATION_OVERLAY = FIRST_SYSTEM_WINDOW + 38;// 系统Window类型的结束值public static final int LAST_SYSTEM_WINDOW = 2999; 类型 备注 FIRST_SYSTEM_WINDOW 系统 Window 类型的开始值 TYPE_STATUS_BAR 系统状态栏，只能有一个状态栏，它被放置在屏幕的顶部，所有其他窗口都向下移动 TYPE_SEARCH_BAR 系统搜索窗口，只能有一个搜索栏，它被放置在屏幕的顶部 TYPE_PHONE API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_SYSTEM_ALERT API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_KEYGUARD 已经从系统中被移除，可以使用 TYPE_KEYGUARD_DIALOG 代替 TYPE_TOAST API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_SYSTEM_OVERLAY API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_PRIORITY_PHONE API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_SYSTEM_ERROR API 已经过时，用 TYPE_APPLICATION_OVERLAY 代替 TYPE_APPLICATION_OVERLAY 应用程序叠加窗口显示在所有窗口之上 TYPE_SYSTEM_DIALOG 系统对话框窗口 TYPE_KEYGUARD_DIALOG 锁屏时显示的对话框 TYPE_INPUT_METHOD 输入法窗口，位于普通 UI 之上，应用程序可重新布局以免被此窗口覆盖 TYPE_INPUT_METHOD_DIALOG 输入法对话框，显示于当前输入法窗口之上 TYPE_WALLPAPER 墙纸 TYPE_STATUS_BAR_PANEL 状态栏的滑动面板 LAST_SYSTEM_WINDOW 系统 Window 类型的结束值 需要注意的是： TYPE_PHONE、TYPE_SYSTEM_ALERT、TYPE_TOAST、TYPE_SYSTEM_OVERLAY、TYPE_PRIORITY_PHONE、TYPE_SYSTEM_ERROR 这些 type 在 API 26 中均已经过时，使用 TYPE_APPLICATION_OVERLAY 代替，需要申请 Manifest.permission.SYSTEM_ALERT_WINDOW 权限 TYPE_KEYGUARD 已经被从系统中移除，可以使用 TYPE_KEYGUARD_DIALOG 来代替 Window 视图层级顺序我们在手机上看的是二维的，但是实际上是三维的显示，如下图所示 在文章开头介绍了参数类型包含了 Window 的 x 轴坐标、Window 的 y 轴坐标， 既然是一个三维坐标系，那么 z 轴坐标在哪里？ 接下来就是我们要分析的非常重要的一个类 WindowManagerService，当添加 Window 的时候已经确定好了 Window 的层级，显示的时候才会根据当前的层级确定 Window 应该在哪一层显示 WindowManager 是 Window 的容器，管理着 Window，对 Window 进行添加和删除，具体的工作都是由 WMS 来处理的，WindowManager 和 WMS 通过 Binder 来进行跨进程通信，WMS 才是 Window 的最终管理者，我先来看一下 WMS 的 addWindow 方法frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java public int addWindow(Session session, IWindow client, int seq, LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel, InsetsState outInsetsState) { final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow); ...... win.mToken.addWindow(win); ...... win.getParent().assignChildLayers(); ...... } WindowState 计算当前 Window 层级 win.mToken.addWindow 这个方法将当前的 win 放入 WindowList 中，WindowList 是一个 ArrayList displayContent.assignWindowLayers 方法 计算 z-order 值, z-order 值越大越靠前，就越靠近用户 Window 视图层级顺序 用 Z-order 来表示，Z-order 对应着 WindowManager.LayoutParams 的 type 值，Z-order 可以理解为 Android 视图的层级概念，值越大越靠前，就越靠近用户。 WindowState 就是 windowManager 中的窗口，一个 WindowState 表示一个 window 那么 Z-order 的值的计算逻辑在 WindowState 类中，WindowState 构造的时候初始化当前的 mBaseLayer 和 mSubLayer，这两个参数应该是决定 z-order 的两个因素frameworks/base/services/core/java/com/android/server/wm/WindowState.java static final int TYPE_LAYER_MULTIPLIER = 10000;static final int TYPE_LAYER_OFFSET = 1000; WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token, WindowState parentWindow, int appOp, int seq, WindowManager.LayoutParams a, int viewVisibility, int ownerId, boolean ownerCanAddInternalSystemWindow, PowerManagerWrapper powerManagerWrapper) { // 判断该是否在子 Window 的类型范围内[1000,1999] if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) { // 调用 getWindowLayerLw 方法返回值在[1,33]之间，根据不同类型的 Window 在屏幕上进行排序 mBaseLayer = mPolicy.getWindowLayerLw(parentWindow) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; // mSubLayer 子窗口的顺序 // 调用 getSubWindowLayerFromTypeLw 方法返回值在[-2.3]之间 ，返回子 Window 相对于父 Window 的位置 mSubLayer = mPolicy.getSubWindowLayerFromTypeLw(a.type); ...... } else { mBaseLayer = mPolicy.getWindowLayerLw(this) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; mSubLayer = 0; ...... } } mBaseLayer 是基础序，对应的区间范围 [1,33] mSubLayer 相同分组下的子 Window 的序，对应的区间范围 [-2.3] 判断该是否在子 Window 的类型范围内[1000,1999] 如果是子 Window，调用 getWindowLayerLw 方法，计算 mBaseLayer 的值，返回一个用来对 Window 进行排序的任意整数，调用 getSubWindowLayerFromTypeLw 方法，计算 mSubLayer 的值，返回子 Window 相对于父 Window 的位置 如果不是子 Window，调用 getWindowLayerLw 方法，计算 mBaseLayer 的值，返回一个用来对 Window 进行排序的任意整数，mSubLayer 值为 0 计算 mBaseLayer 的值调用 WindowManagerPolicy 的 getWindowLayerLw 方法，计算 mBaseLayer 的值frameworks/base/services/core/java/com/android/server/policy/WindowManagerPolicy.java int APPLICATION_LAYER = 2;int APPLICATION_MEDIA_SUBLAYER = -2;int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1;int APPLICATION_PANEL_SUBLAYER = 1;int APPLICATION_SUB_PANEL_SUBLAYER = 2;int APPLICATION_ABOVE_SUB_PANEL_SUBLAYER = 3; /*** 根据不同类型的 Window 在屏幕上进行排序* 返回一个用来对窗口进行排序的任意整数，数字越小，表示的值越小*/ default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow) { // 判断是否在应用程序 Window 类型的取值范围内 [1,99] if (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) { return APPLICATION_LAYER; } switch (type) { case TYPE_WALLPAPER: // 壁纸，通过 window manager 删除它 return 1; case TYPE_PHONE: // 电话 return 3; case TYPE_SEARCH_BAR: // 搜索栏 return 6; case TYPE_SYSTEM_DIALOG: // 系统的 dialog return 7; case TYPE_TOAST: // 系统 toast return 8; case TYPE_INPUT_METHOD: // 输入法 return 15; case TYPE_STATUS_BAR: // 状态栏 return 17; case TYPE_KEYGUARD_DIALOG: //锁屏 return 20; ...... case TYPE_POINTER: // the (mouse) pointer layer return 33; default: return APPLICATION_LAYER; }} 根据不同类型的 Window 在屏幕上进行排序，返回一个用来对 Window 进行排序的任意整数，数字越小，表示的值越小，通过以下公式来计算它的基础序 ，基础序越大，Z-order 值越大越靠前，就越靠近用户，我们以 Activity 为例： Activity 属于应用层 Window，它的取值范围在 [1,99] 内，调用 getWindowLayerLw 方法返回 APPLICATION_LAYER，APPLICATION_LAYER 值为 2，通过下面方法进行计算 static final int TYPE_LAYER_MULTIPLIER = 10000;static final int TYPE_LAYER_OFFSET = 1000;mBaseLayer = mPolicy.getWindowLayerLw(parentWindow) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; 那么最终 Activity 的 mBaseLayer 值是 21000 计算 mSubLayer 的值调用 getSubWindowLayerFromTypeLw 方法 ，传入 WindowManager.LayoutParams 的实例 a 的 type 值，计算 mSubLayer 的值frameworks/base/services/core/java/com/android/server/policy/WindowManagerPolicy.java int APPLICATION_LAYER = 2;int APPLICATION_MEDIA_SUBLAYER = -2;int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1;int APPLICATION_PANEL_SUBLAYER = 1;int APPLICATION_SUB_PANEL_SUBLAYER = 2;int APPLICATION_ABOVE_SUB_PANEL_SUBLAYER = 3;/*** 计算 Window 相对于父 Window 的位置* 返回 一个整数，正值在前面，表示在父 Window 上面，负值在后面，表示在父 Window 的下面*/default int getSubWindowLayerFromTypeLw(int type) { switch (type) { case TYPE_APPLICATION_PANEL: // 1000 case TYPE_APPLICATION_ATTACHED_DIALOG: // 1003 return APPLICATION_PANEL_SUBLAYER; // return 1 case TYPE_APPLICATION_MEDIA:// 1001 return APPLICATION_MEDIA_SUBLAYER;// return -2 case TYPE_APPLICATION_MEDIA_OVERLAY: return APPLICATION_MEDIA_OVERLAY_SUBLAYER; // return -1 case TYPE_APPLICATION_SUB_PANEL:// 1002 return APPLICATION_SUB_PANEL_SUBLAYER;// return 2 case TYPE_APPLICATION_ABOVE_SUB_PANEL: return APPLICATION_ABOVE_SUB_PANEL_SUBLAYER;// return 3 } return 0;} 计算子 Window 相对于父 Window 的位置，返回一个整数，正值表示在父 Window 上面，负值表示在父 Window 的下面 Window 的 flagWindow 的 flag 用于控制 Window 的显示，它们的值也是定义在 WindowManager 的内部类 LayoutParams 中frameworks/base/core/java/android/view/WindowManager#LayoutParams.java // 当 Window 可见时允许锁屏public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = 0x00000001;// Window 后面的内容都变暗public static final int FLAG_DIM_BEHIND = 0x00000002;@Deprecated// API 已经过时，Window 后面的内容都变模糊public static final int FLAG_BLUR_BEHIND = 0x00000004;// Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的// Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODALpublic static final int FLAG_NOT_FOCUSABLE = 0x00000008;// 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件// Window 之外的 view 也是可以响应 touch 事件。public static final int FLAG_NOT_TOUCH_MODAL = 0x00000020;// 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口。public static final int FLAG_NOT_TOUCHABLE = 0x00000010;// 只要 Window 可见时屏幕就会一直亮着public static final int FLAG_KEEP_SCREEN_ON = 0x00000080;// 允许 Window 占满整个屏幕public static final int FLAG_LAYOUT_IN_SCREEN = 0x00000100;// 允许 Window 超过屏幕之外public static final int FLAG_LAYOUT_NO_LIMITS = 0x00000200;// 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示public static final int FLAG_FULLSCREEN = 0x00000400;// 表示比FLAG_FULLSCREEN低一级，会显示状态栏public static final int FLAG_FORCE_NOT_FULLSCREEN = 0x00000800;// 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件public static final int FLAG_IGNORE_CHEEK_PRESSES = 0x00008000;// 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件。public static final int FLAG_WATCH_OUTSIDE_TOUCH = 0x00040000;@Deprecated// 窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替public static final int FLAG_SHOW_WHEN_LOCKED = 0x00080000;// 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制，// 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色。public static final int FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS = 0x80000000;// 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸public static final int FLAG_SHOW_WALLPAPER = 0x00100000; flag 备注 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON 当 Window 可见时允许锁屏 FLAG_DIM_BEHIND Window 后面的内容都变暗 FLAG_BLUR_BEHIND API 已经过时，Window 后面的内容都变模糊 FLAG_NOT_FOCUSABLE Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的，Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL FLAG_NOT_TOUCH_MODAL 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件，Window 之外的 view 也是可以响应 touch 事件 FLAG_NOT_TOUCHABLE 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口 FLAG_KEEP_SCREEN_ON 只要 Window 可见时屏幕就会一直亮着 FLAG_LAYOUT_IN_SCREEN 允许 Window 占满整个屏幕 FLAG_LAYOUT_NO_LIMITS 允许 Window 超过屏幕之外 FLAG_FULLSCREEN 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示 FLAG_FORCE_NOT_FULLSCREEN 表示比FLAG_FULLSCREEN低一级，会显示状态栏 FLAG_IGNORE_CHEEK_PRESSES 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件 FLAG_WATCH_OUTSIDE_TOUCH 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件 FLAG_SHOW_WHEN_LOCKED 已经过时，窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制， 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色 FLAG_SHOW_WALLPAPER 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸 window 软键盘模式表示 window 软键盘输入区域的显示模式，常见的情况 Window 的软键盘打开会占据整个屏幕，遮挡了后面的视图，例如看直播的时候底部有个输入框点击的时候，输入框随着键盘一起上来，而有的时候，希望键盘覆盖在所有的 View 之上，界面保持不动等等 软键盘模式(SoftInputMode) 值，与 AndroidManifest 中 Activity 的属性 android:windowSoftInputMode 是对应的，因此可以在 AndroidManifest 文件中为 Activity 设置android:windowSoftInputMode &lt;activity android:windowSoftInputMode=&quot;adjustNothing&quot; /&gt; 也可以在 Java 代码中为 Window 设置 SoftInputMode getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING); SoftInputMode 常用的有以下几个值 // 不会改变软键盘的状态public static final int SOFT_INPUT_STATE_UNCHANGED = 1;// 当用户进入该窗口时，隐藏软键盘public static final int SOFT_INPUT_STATE_HIDDEN = 2;// 当窗口获取焦点时，隐藏软键盘public static final int SOFT_INPUT_STATE_ALWAYS_HIDDEN = 3;// 当用户进入窗口时，显示软键盘public static final int SOFT_INPUT_STATE_VISIBLE = 4;// 当窗口获取焦点时，显示软键盘public static final int SOFT_INPUT_STATE_ALWAYS_VISIBLE = 5;// window会调整大小以适应软键盘窗口public static final int SOFT_INPUT_MASK_ADJUST = 0xf0;// 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置public static final int SOFT_INPUT_ADJUST_UNSPECIFIED = 0x00;// 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方// 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用；// 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏。public static final int SOFT_INPUT_ADJUST_RESIZE = 0x10;// 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的,// 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方// 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用public static final int SOFT_INPUT_ADJUST_PAN = 0x20;// 将不会调整大小，直接覆盖在window上public static final int SOFT_INPUT_ADJUST_NOTHING = 0x30; model 备注 SOFT_INPUT_STATE_UNCHANGED 不会改变软键盘的状态 SOFT_INPUT_STATE_VISIBLE 当用户进入窗口时，显示软键盘 SOFT_INPUT_STATE_HIDDEN 当用户进入该窗口时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_HIDDEN 当窗口获取焦点时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_VISIBLE 当窗口获取焦点时，显示软键盘 SOFT_INPUT_MASK_ADJUST window 会调整大小以适应软键盘窗口 SOFT_INPUT_ADJUST_UNSPECIFIED 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置 SOFT_INPUT_ADJUST_RESIZE 1. 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方 2. 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用 3. 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏 SOFT_INPUT_ADJUST_PAN 1. 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的 2. 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方 3. 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用 SOFT_INPUT_ADJUST_NOTHING 将不会调整大小，直接覆盖在window上 Kotlin 小技巧利用 plus (+) 和 plus (-) 对 Map 集合做运算，如下所示： fun main() { val numbersMap = mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3) // plus (+) println(numbersMap + Pair(&quot;four&quot;, 4)) // {one=1, two=2, three=3, four=4} println(numbersMap + Pair(&quot;one&quot;, 10)) // {one=10, two=2, three=3} println(numbersMap + Pair(&quot;five&quot;, 5) + Pair(&quot;one&quot;, 11)) // {one=11, two=2, three=3, five=5} // plus (-) println(numbersMap - &quot;one&quot;) // {two=2, three=3} println(numbersMap - listOf(&quot;two&quot;, &quot;four&quot;)) // {one=1, three=3}} 总结到这里就结束了，这篇文章主要介绍了 Window 的类型大概可以分为三类： 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window）。 分别介绍了 Window 的类型、Window 视图层级顺序、Window 的 flag、和 window 软键盘模式为后面的内容做铺垫 Window 都有那些常用的参数? 参数 备注 x window 左上角的 x 坐标 y window 左上角的 y 坐标 type Window 的类型 flag Window 的 flag 用于控制 Window 的显示 softInputMode window 软键盘输入区域的显示模式 alpha Window 的透明度，取值为0-1 gravity Window 在屏幕中的位置 alpha Window 的透明度，取值为0-1 format Window 的像素点格式，值定义在 PixelFormat 中 Window 都有那些类型？ 应用程序 Window（Application Window）、子 Window（Sub Windwow）、系统 Window（System Window），子 Window 依附于父 Window 上，并且他们的坐标空间相对于父 Window 的，每个大类型又包含多个小类型，每个类型在上文的表格中已经列出来了， Window 那些过时的 API 以及处理方案？ TYPE_PHONE、TYPE_SYSTEM_ALERT、TYPE_TOAST、TYPE_SYSTEM_OVERLAY、TYPE_PRIORITY_PHONE、TYPE_SYSTEM_ERROR 这些 type 在 API 26 中均已经过时，使用 TYPE_APPLICATION_OVERLAY 代替，需要申请 Manifest.permission.SYSTEM_ALERT_WINDOW 权限 TYPE_KEYGUARD 已经被从系统中移除，可以使用 TYPE_KEYGUARD_DIALOG 来代替 Window 视图层级顺序是如何确定的？ Window 的参数 x、y，分别表示 Window 左上角的 x 坐标，Window 左上角的 y 坐标，Window 视图层级顺序 用 Z-order 来表示，Z-order 对应着 WindowManager.LayoutParams 的 type 值，Z-order 可以理解为 Android 视图的层级概念，值越大越靠前，就越靠近用户。而 mBaseLayer 和 mSubLayer 决定 z-order 的两个因素 Window 都那些 flag？ Window 的 flag 用于控制 Window 的显示，flag 的参数如下所示： flag 备注 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON 当 Window 可见时允许锁屏 FLAG_DIM_BEHIND Window 后面的内容都变暗 FLAG_BLUR_BEHIND API 已经过时，Window 后面的内容都变模糊 FLAG_NOT_FOCUSABLE Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的，Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL FLAG_NOT_TOUCH_MODAL 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件，Window 之外的 view 也是可以响应 touch 事件 FLAG_NOT_TOUCHABLE 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口 FLAG_KEEP_SCREEN_ON 只要 Window 可见时屏幕就会一直亮着 FLAG_LAYOUT_IN_SCREEN 允许 Window 占满整个屏幕 FLAG_LAYOUT_NO_LIMITS 允许 Window 超过屏幕之外 FLAG_FULLSCREEN 全屏显示，隐藏所有的 Window 装饰，比如在游戏、播放器中的全屏显示 FLAG_FORCE_NOT_FULLSCREEN 表示比FLAG_FULLSCREEN低一级，会显示状态栏 FLAG_IGNORE_CHEEK_PRESSES 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件 FLAG_WATCH_OUTSIDE_TOUCH 则当按键动作发生在 Window 之外时，将接收到一个MotionEvent.ACTION_OUTSIDE事件 FLAG_SHOW_WHEN_LOCKED 已经过时，窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 表示负责绘制系统栏背景。如果设置，系统栏将以透明背景绘制， 此 Window 中的相应区域将填充 Window＃getStatusBarColor（）和 Window＃getNavigationBarColor（）中指定的颜色 FLAG_SHOW_WALLPAPER 表示要求系统壁纸显示在该 Window 后面，Window 表面必须是半透明的，才能真正看到它背后的壁纸 Window 软键盘模式？ Window 的软键盘模式表示 Window 软键盘输入区域的显示模式 model 备注 SOFT_INPUT_STATE_UNCHANGED 不会改变软键盘的状态 SOFT_INPUT_STATE_VISIBLE 当用户进入窗口时，显示软键盘 SOFT_INPUT_STATE_HIDDEN 当用户进入该窗口时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_HIDDEN 当窗口获取焦点时，隐藏软键盘 SOFT_INPUT_STATE_ALWAYS_VISIBLE 当窗口获取焦点时，显示软键盘 SOFT_INPUT_MASK_ADJUST window 会调整大小以适应软键盘窗口 SOFT_INPUT_ADJUST_UNSPECIFIED 没有指定状态,系统会选择一个合适的状态或依赖于主题的设置 SOFT_INPUT_ADJUST_RESIZE 1. 当软键盘弹出时，窗口会调整大小,例如点击一个EditView，整个layout都将平移可见且处于软件盘的上方 2. 同样的该模式不能与SOFT_INPUT_ADJUST_PAN结合使用 3. 如果窗口的布局参数标志包含FLAG_FULLSCREEN，则将忽略这个值，窗口不会调整大小，但会保持全屏 SOFT_INPUT_ADJUST_PAN 1. 当软键盘弹出时，窗口不需要调整大小, 要确保输入焦点是可见的 2. 例如有两个EditView的输入框，一个为Ev1，一个为Ev2，当你点击Ev1想要输入数据时，当前的Ev1的输入框会移到软键盘上方 3. 该模式不能与SOFT_INPUT_ADJUST_RESIZE结合使用 SOFT_INPUT_ADJUST_NOTHING 将不会调整大小，直接覆盖在window上 参考文献 https://developer.android.google.cn/…/WindowManager.LayoutParams https://www.jianshu.com/p/3528255475a2 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你同我一样喜欢研究 Android 源码，可以关注我，如果你喜欢这篇文章欢迎 star，一起来学习，期待与你一起成长 算法由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长 Android 10 源码系列正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 Android10-Source-Analysis，文章都会同步到这个仓库","link":"/2020/06/07/android10/window-manager/07-WindowManagerService/"},{"title":"0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构","text":"0xA06 Android 10 源码分析：WindowManager 视图绑定以及体系结构 引言 这是 Android 10 源码分析系列的第 6 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 Acivity 和 Dialog 视图解析绑定过程？ Activity 的视图如何与 Window 关联的？ Window 如何与 WindowManager 关联？ Dialog 的视图如何与 Window 关联？ 本文主要分析 Activity、Window、PhoneWindow、WindowManager 之间的关系，为我们后面的文章 「如何在 Andorid 系统里添加自定义View」 等等文章奠定基础，先来了解一下它们的基本概念 Activity：应用视图的容器。 WindowManager：它是一个接口类，继承自接口 ViewManager，对 Window 进行管理 Window：它是一个抽象类，它作为一个顶级视图添加到 WindowManager 中，对 View 进行管理 PhoneWindow：Window唯一实现类，Window是一个抽象概念，添加到WindowManager的根容器 DecorView: 它是 PhoneWindow 内部的一个成员变量，继承自 FrameLayout，FrameLayout 继承自 ViewGroup 在分析他们之前的关系之前，我们先来回顾一下 Acivity 和 Dialog 视图解析绑定的过程 Acivity 和 Dialog 视图解析绑定的过程Acivity 和 Dialog 相关的文章： 0xA03 Android 10 源码分析：APK 加载流程之资源加载 0xA04 Android 10 源码分析：APK 加载流程之资源加载（二） 0xA05 Android 10 源码分析：Dialog 加载绘制流程以及在 Kotlin、DataBinding 中的使用 在之前的文章 分别介绍了 Acivity 和 自定义 Dialog 视图的解析和绑定，总的来说分为三步 调用 LayoutInflater 的 inflate 方法，深度优先遍历解析 View 调用 ViewGroup 的 addView 方法将子 View 添加到根布局中 调用 WindowManager 的 addView 方法添加根布局 LayoutInflater 的 inflate 方法有多个重载的方法，常用的是下面三个参数的方法frameworks/base/core/java/android/view/LayoutInflater.java public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null);} resource：要解析的 xml 布局文件 Id root：表示根布局 attachToRoot：是否要添加到父布局 root 中 resource 其实很好理解就是资源 Id，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 当 View 解析完成之后，最后会调用 WindowManager 的 addView 方法，WindowManager 是一个接口类，继承自接口 ViewManager，用来管理 Window，它的实现类为 WindowManagerImpl，所以调用 WindowManager 的 addView 方法，实际上调用的是 WindowManagerImpl 的 addView 方法frameworks/base/core/java/android/view/WindowManagerImpl.java public final class WindowManagerImpl implements WindowManager { @UnsupportedAppUsage // 单例的设计模式 private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; private final Window mParentWindow; ...... public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); // mGlobal 是 WindowManagerGlobal 的实例 mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); } ...... } mGlobal 是 WindowManagerGlobal 的实例，使用的单例设计模式，参数 mParentWindow 是 Window 的实例，实际上是委托给 WindowManagerGlobal 去实现的 到这里我们关于 Acivity 和 Dialog 视图的解析和添加过程大概介绍完了，关于 Dialog 的视图如何与 Window 绑定在 0xA05 Android 10 源码分析：Dialog 加载绘制流程以及在 Kotlin、DataBinding 中的使用 文章中介绍了，接下来分析一下 Activity、Window、WindowManager 的关系 Activity、Window、WindowManager 的关系在 Activity 内部维护着一个 Window 的实例变量 mWindowframeworks/base/core/java/android/app/Activity.java public class Activity extends ContextThemeWrappe{ private Window mWindow;}``` Window 是一个抽象类，它的具体实现类为 PhoneWindow，在 Activity 的 attach 方法中给 Window 的实例变量 mWindow 赋值**frameworks/base/core/java/android/app/Activity.java** final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { …… mWindow = new PhoneWindow(this, window, activityConfigCallback); ...... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); ......} * 创建了 PhoneWindow 并赋值给 mWindow* 调用 PhoneWindow 的 setWindowManager 方法，这个方法的具体实现发生在 Window 中，最终调用的是 Window 的 setWindowManager 方法**frameworks/base/core/java/android/view/Window.java** public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { …… // mWindowManager 是 WindowManagerImpl的实例变量 mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);} 将 WindowManager 转换为 WindowManagerImpl，之后调用 createLocalWindowManager 方法，并传递当前的 Window 对象，构建 WindowManagerImpl 对象，之后赋值给 mWindowManager**frameworks/base/core/java/android/view/WindowManagerImpl.java** public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mContext, parentWindow);} 其实在 createLocalWindowManager 方法中，就做了一件事，将 Window 作为参数构建了一个 WindowManagerImpl 对象返还给调用处&lt;br/&gt;总的来说，其实就是在 Activity 的 attach 方法中，通过调用 Window 的 setWindowManager 方法将 Window 和 WindowManager 关联在了一起&lt;br/&gt;PhoneWindow 是 Window 的实现类，它是一个窗口，本身并不具备 View 相关的能力，实际上在 PhoneWindow 内部维护这一个变量 mDecor**frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java** public class PhoneWindow extends Window{ // This is the top-level view of the window, containing the window decor. private DecorView mDecor; private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { // 完成DecorView的实例化 mDecor = generateDecor(-1); …… } if (mContentParent == null) { // 调用 generateLayout 方法 要负责了DecorView的初始设置，诸如主题相关的feature、DecorView的背景 mContentParent = generateLayout(mDecor); } ...... } // 完成DecorView的实例化 protected DecorView generateDecor(int featureId) { ...... return new DecorView(context, featureId, this, getAttributes()); } // 调用 generateLayout 方法 要负责了DecorView的初始设置， // 诸如主题相关的feature、DecorView的背景，同时也初始化 contentParent protected ViewGroup generateLayout(DecorView decor) { ...... ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ...... }} * mDecor 是 window 的顶级视图，它继承自 FrameLayout，它的创建过程由 installDecor 完成，然后在 installDecor 方法中通过 generateDecor 方法来完成DecorView的实例化* 调用 generateLayout 方法 要负责了DecorView的初始设置，诸如主题相关的feature、DecorView的背景，同时也初始化 contentParent* mDecor 它实际上是一个 ViewGroup，当在 Activity 中调用 setContentView 方法，通过调用 inflater 方法把布局资源转换为一个 View，然后添加到 DecorView 的 mContenParnent 中当 View 初始化完成之后，最后会进入 ActivityThread 的 handlerResumeActivity 方法，执行了r.activity.makeVisible()方法**frameworks/base/core/java/android/app/ActivityThread.java** public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { …… if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } ...... }最终调用 Activity 的 makeVisible 方法，把 decorView 添加到 WindowManage 中**frameworks/base/core/java/android/app/Activity.java** void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE);} 到这里他们之间的关系明确了：* 一个 Activity 持有一个 PhoneWindow 的对象，而一个 PhoneWindow 对象持有一个 DecorView 的实例* PhoneWindow 继承自 Window，一个 Window 对象内部持有 mWindowManager 的实例，通过调用 setWindowManager 方法与 WindowManager 关联在一起* WindowManager 继承自 ViewManager，WindowManagerImpl 是 WindowManager 接口的实现类，但是具体的功能都会委托给 WindowManagerGlobal 来实现* 调用 WindowManager 的 addView 方法，实际上调用的是 WindowManagerImpl 的 addView 方法## 总结#### Acivity 和 Dialog 视图解析绑定过程？* 1. 调用 LayoutInflater 的 inflate 方法，深度优先遍历解析 View* 2. 调用 ViewGroup 的 addView 方法将子 View 添加到根布局中* 3. 调用 WindowManager 的 addView 方法添加根布局#### Activity 的视图如何与 Window 关联的？* 在 Activity 内部维护着一个 Window 的实例变量 mWindow**frameworks/base/core/java/android/app/Activity.java** public class Activity extends ContextThemeWrappe{ private Window mWindow;} * 最后调用 Activity 的 makeVisible 方法，把 decorView 添加到 WindowManage 中**frameworks/base/core/java/android/app/Activity.java** void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE);} #### Window 如何与 WindowManager 关联？在 Activity 的 attach 方法中，调用 PhoneWindow 的 setWindowManager 方法，这个方法的具体实现发生在 Window 中，最终调用的是 Window 的 setWindowManager 方法，将 Window 和 WindowManager 关联在了一起**frameworks/base/core/java/android/view/Window.java** public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { …… // mWindowManager 是 WindowManagerImpl的实例变量 mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);} #### Dialog 的视图如何与 Window 关联？* 在 Dialog 的构造方法中初始化了 Window 对象 **frameworks/base/core/java/android/app/Dialog.java** Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { … // 获取WindowManager对象 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 构建PhoneWindow final Window w = new PhoneWindow(mContext); // mWindow 是PhoneWindow实例 mWindow = w; …} * 调用 Dialog 的 show 方法，完成 view 的绘制和 Dialog 的显示**frameworks/base/core/java/android/app/Dialog.java** public void show() { // 获取DecorView mDecor = mWindow.getDecorView(); // 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); // 将DecorView和布局参数添加到WindowManager中 mWindowManager.addView(mDecor, l);} ## 参考文献 * [http://liuwangshu.cn/framework/wm/1-windowmanager.html](http://liuwangshu.cn/framework/wm/1-windowmanager.html) * [https://gudong.site/2017/05/08/activity-windown-decorview.html](https://gudong.site/2017/05/08/activity-windown-decorview.html) ## 结语 致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你同我一样喜欢研究 Android 源码，可以关注我，如果你喜欢这篇文章欢迎 star，一起来学习，期待与你一起成长 ### 算法 由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 * 数据结构： 数组、栈、队列、字符串、链表、树…… * 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：[Leetcode-Solutions-with-Java-And-Kotlin](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin)，一起来学习，期待与你一起成长 ### Android 10 源码系列 正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 [Android10-Source-Analysis](https://github.com/hi-dhl/Android10-Source-Analysis)，文章都会同步到这个仓库","link":"/2020/06/07/android10/window-manager/06-Window-WindowManager/"},{"title":"0xA05 Android 10 源码分析：Dialog加载绘制流程以及在Kotlin、DataBinding中的使用","text":"引言 这是 Android 10 源码分析系列的第 5 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 通过这篇文章你将学习到以下内容，将在文末总结部分会给出相应的答案 Dialog的的创建流程？ Dialog的视图怎么与Window做关联了？ 自定义CustomDialog的view的是如何绑定的? 如何使用Kotlin具名可选参数构造类，实现构建者模式？ 相比于Java的构建者模式，通过具名可选参数构造类具有以下优点? 如何在Dialog中使用DataBinding？ 阅读本文之前，如果之前没有看过 Apk加载流程之资源加载一 和 Apk加载流程之资源加载二 点击下方链接前去查看，这几篇文章都是互相关联的 0xA03 Android 10 源码分析：Apk加载流程之资源加载（一） 0xA04 Android 10 源码分析：Apk加载流程之资源加载（二） 本文主要来主要围绕以下几个方面来分析: Dialog加载绘制流程 如何使用Kotlin具名可选参数构造类，实现构建者模式 如何在Dialog中使用DataBinding 源码分析在开始分析Dialog的源码之前，需要了解一下Dialog加载绘制流程，涉及到的数据结构与职能 在包 android.app 下： Dialog：Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑 AlertDialog：继承自Dialog，是具体的Dialog的操作实现类 AlertDialog.Builder：是AlertDialog的内部类，主要用于构造AlertDialog AlertController：是AlertDialog的控制类 AlertController.AlertParams：是AlertController的内部类，负责AlertDialog的初始化参数 了解完相关的数据结构与职能，接下来回顾一下Dialog的创建流程 AlertDialog.Builder builder = new AlertDialog.Builder(this);builder.setIcon(R.mipmap.ic_launcher);builder.setMessage(&quot;Message部分&quot;);builder.setTitle(&quot;Title部分&quot;);builder.setView(R.layout.activity_main);builder.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); }});builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); }});alertDialog = builder.create();alertDialog.show(); 上面代码都不会很陌生，主要使用了设计模式当中-构建者模式， 构建AlertDialog.Builder对象 builder.setXXX 系列方法完成Dialog的初始化 调用builder.create()方法创建AlertDialog 调用AlertDialog的show()完成View的绘制并显示AlertDialog 主要通过上面四步完成Dialog的创建和显示，接下来根据源码来分析每个方法的具体实现，以及Dialog的视图怎么与Window做关联 1 构建AlertDialog.Builder对象AlertDialog.Builder builder = new AlertDialog.Builder(this); AlertDialog.Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法frameworks/base/core/java/android/app/AlertDialog.java // AlertController.AlertParams类型的成员变量private final AlertController.AlertParams P;public Builder(Context context) { this(context, resolveDialogTheme(context, Resources.ID_NULL));}public Builder(Context context, int themeResId) { // 构造ContextThemeWrapper，ContextThemeWrapper 是 Context的子类，主要用来处理和主题相关的 // 初始化成为变量 P P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId)));} ContextThemeWrapper 继承自ContextWrapper，Application、Service继承自ContextWrapper，Activity继承自ContextThemeWrapper P是AlertDialog.Builder中的AlertController.AlertParams类型的成员变量 AlertParams中包含了与AlertDialog视图中对应的成员变量，调用builder.setXXX系列方法之后，我们传递的参数就保存在P中了 1.1 AlertParams封装了初始化参数AlertController.AlertParams 是AlertController的内部类，负责AlertDialog的初始化参数frameworks/base/core/java/com/android/internal/app/AlertController.java public AlertParams(Context context) {mContext = context;// mCancelable 用来控制点击外部是否可取消，默认可以取消mCancelable = true;// LayoutInflater 主要来解析layout.xml文件mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);} 主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量，LayoutInflater 主要来解析layout.xml文件，关于LayoutInflater可以参考之前的文章0xA04 Android 10 源码分析：Apk加载流程之资源加载（二） 初始化完成AlertParams之后，就完成了AlertDialog.Builder的构建 2 调用AlertDialog.Builder的setXXX系列方法AlertDialog.Builder初始化完成之后，调用它的builder.setXXX 系列方法完成Dialog的初始化frameworks/base/core/java/android/app/AlertDialog.java // ... 省略了很多builder.setXXX方法public Builder setTitle(@StringRes int titleId) { P.mTitle = P.mContext.getText(titleId); return this;}public Builder setMessage(@StringRes int messageId) { P.mMessage = P.mContext.getText(messageId); return this;}public Builder setPositiveButton(@StringRes int textId, final OnClickListener listener) { P.mPositiveButtonText = P.mContext.getText(textId); P.mPositiveButtonListener = listener; return this;}public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this;}// ... 省略了很多builder.setXXX方法 上面所有setXXX方法都是给Builder的成员变量P赋值，并且他们的返回值都是Builder类型，因此可以通过消息琏的方式调用 builder.setTitle().setMessage().setPositiveButton()... PS: 在Kotlin应该尽量避免使用构建者模式，使用Kotlin中的具名可选参数，实现构建者模式，代码更加简洁，为了不影响阅读的流畅性，将这部分内容放到了文末扩展阅读部分 3 builder.create方法builder.setXXX 系列方法之后调用builder.create方法完成AlertDialog构建，接下来看一下create方法frameworks/base/core/java/android/app/AlertDialog.java public AlertDialog create() { // P.mContext 是ContextWrappedTheme 的实例 final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); // Dialog的参数其实保存在P这个类里面 // mAler是AlertController的实例，通过这个方法把P中的变量传给AlertController.AlertParams P.apply(dialog.mAlert); // 用来控制点击外部是否可取消,mCancelable 默认为true dialog.setCancelable(P.mCancelable); // 如果可以取消设置回调监听 if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } // 设置一系列监听 dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } // 返回 AlertDialog 对象 return dialog;} 根据P.mContex 构建了一个AlertDialog mAler是AlertController的实例，调用apply方法把P中的变量传给AlertController.AlertParams 设置是否可以点击外部取消，默认可以取消，同时设置回调监听 最后返回AlertDialog对象 3.1 如何构建AlertDialog我们来分析一下AlertDialog是如何构建的，来看一下它的造方法具体实现frameworks/base/core/java/android/app/AlertDialog.java AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); // getContext() 返回的是ContextWrapperTheme // getWindow() 返回的是 PhoneWindow // mAlert 是AlertController的实例 mAlert = AlertController.create(getContext(), this, getWindow());} PhoneWindows是什么时候创建的？AlertDialog继承自Dialog，首先调用了super的构造方法，来看一下Dialog的构造方法frameworks/base/core/java/android/app/Dialog.java Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { ... // 获取WindowManager对象 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 构建PhoneWindow final Window w = new PhoneWindow(mContext); // mWindow 是PhoneWindow实例 mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setOnWindowSwipeDismissedCallback(() -&gt; { if (mCancelable) { cancel(); } }); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); // 继承 Handler mListenersHandler = new ListenersHandler(this);} 获取WindowManager对象，构建了PhoneWindow，到这里我们知道了PhoneWindow是在Dialog构造方法创建的 初始化了Dialog的成员变量mWindow，mWindow 是PhoneWindow的实例 初始化了Dialog的成员变量mListenersHandler，mListenersHandler继承Handler 我们回到AlertDialog构造方法，在AlertDialog构造方法内，调用了 AlertController.create方法，来看一下这个方法 public static final AlertController create(Context context, DialogInterface di, Window window) { final TypedArray a = context.obtainStyledAttributes( null, R.styleable.AlertDialog, R.attr.alertDialogStyle, R.style.Theme_DeviceDefault_Settings); int controllerType = a.getInt(R.styleable.AlertDialog_controllerType, 0); a.recycle(); // 根据controllerType 使用不同的AlertController switch (controllerType) { case MICRO: // MicroAlertController 是matrix风格 继承自AlertController return new MicroAlertController(context, di, window); default: return new AlertController(context, di, window); }} 根据controllerType 返回不同的AlertController，到这里分析完了AlertDialog是如何构建的 4 调用Dialog的show方法显示Dialog调用AlertDialog.Builder的create方法之后返回了AlertDialog的实例，最后调用了AlertDialog的show方法显示dialog，但是AlertDialog是继承自Dialog的，实际上调用的是Dialog的show方法frameworks/base/core/java/android/app/Dialog.java public void show() { // mShowing变量用于表示当前dialog是否正在显示 if (mShowing) { if (mDecor != null) { if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); } mDecor.setVisibility(View.VISIBLE); } return; } mCanceled = false; // mCreated这个变量控制dispatchOnCreate方法只被执行一次 if (!mCreated) { dispatchOnCreate(null); } else { // Fill the DecorView in on any configuration changes that // may have occured while it was removed from the WindowManager. final Configuration config = mContext.getResources().getConfiguration(); mWindow.getDecorView().dispatchConfigurationChanged(config); } // 用于设置ActionBar onStart(); // 获取DecorView mDecor = mWindow.getDecorView(); if (mActionBar == null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { final ApplicationInfo info = mContext.getApplicationInfo(); mWindow.setDefaultIcon(info.icon); mWindow.setDefaultLogo(info.logo); mActionBar = new WindowDecorActionBar(this); } // 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); boolean restoreSoftInputMode = false; if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) { l.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; restoreSoftInputMode = true; } // 将DecorView和布局参数添加到WindowManager中，完成view的绘制 mWindowManager.addView(mDecor, l); if (restoreSoftInputMode) { l.softInputMode &amp;= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; } mShowing = true; // 向Handler发送一个Dialog的消息，从而显示AlertDialog sendShowMessage();} 判断dialog是否已经显示，如果显示了直接返回 判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法 获取布局参数添加到WindowManager，调用addView方法完成view的绘制 向Handler发送一个Dialog的消息，从而显示AlertDialog 4.1 dispatchOnCreate在上面代码中，根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法frameworks/base/core/java/android/app/Dialog.java void dispatchOnCreate(Bundle savedInstanceState) { if (!mCreated) { // 调用 onCreate 方法 onCreate(savedInstanceState); mCreated = true; }} 在dispatchOnCreate方法中主要调用Dialog的onCreate方法, Dialog的onCreate方法是个空方法，由于我们创建的是AlertDialog对象，AlertDialog继承于Dialog，所以调用的是AlertDialog的onCreate方法frameworks/base/core/java/android/app/AlertDialog.java protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mAlert.installContent();} 在这方法里面调用了AlertController的installContent方法，来看一下具体的实现逻辑frameworks/base/core/java/com/android/internal/app/AlertController.java public void installContent() { // 获取相应的Dialog布局文件 int contentView = selectContentView(); // 调用setContentView方法解析布局文件 mWindow.setContentView(contentView); // 初始化布局文件中的组件 setupView();} 调用selectContentView方法获取布局文件，来看一下具体的实现 frameworks/base/core/java/com/android/internal/app/AlertController.java* private int selectContentView() { if (mButtonPanelSideLayout == 0) { return mAlertDialogLayout; } if (mButtonPanelLayoutHint == AlertDialog.LAYOUT_HINT_SIDE) { return mButtonPanelSideLayout; } return mAlertDialogLayout;} 返回的布局是mAlertDialogLayout，布局文件是在AlertController的构造方法初始化的frameworks/base/core/java/com/android/internal/app/AlertController.java mAlertDialogLayout = a.getResourceId( R.styleable.AlertDialog_layout, R.layout.alert_dialog); 调用Window.setContentView方法解析布局文件，Activity的setContentView最后也是调用了Window.setContentView这个方法，具体的解析流程，可以参考之前的文章Activity布局加载流程 0xA03 Android 10 源码分析：Apk加载流程之资源加载 调用setupView方法初始化布局文件中的组件, 到这里dispatchOnCreate方法分析结束 4.2 调用mWindowManager.addView完成View的绘制回到我们的Dialog的show方法，在执行了dispatchOnCreate方法之后，又调用了onStart方法，这个方法主要用于设置ActionBar，然后初始化WindowManager.LayoutParams对象，最后调用mWindowManager.addView()方法完成界面的绘制，绘制完成之后调用sendShowMessage方法frameworks/base/core/java/android/app/Dialog.java private void sendShowMessage() { if (mShowMessage != null) { // Obtain a new message so this dialog can be re-used Message.obtain(mShowMessage).sendToTarget(); }} 向Handler发送一个Dialog的消息，从而显示AlertDialog，该消息最终会在ListenersHandler中的handleMessage方法中被执行，ListenersHandler是Dialog的内部类，继承Handlerframeworks/base/core/java/android/app/Dialog.java public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; }} 如果msg.what = SHOW，会执行OnShowListener.onShow方法，msg.what的值和OnShowListener调用setOnShowListener方法赋值的frameworks/base/core/java/android/app/Dialog.java public void setOnShowListener(@Nullable OnShowListener listener) { if (listener != null) { mShowMessage = mListenersHandler.obtainMessage(SHOW, listener); } else { mShowMessage = null; }} mListenersHandler构造了Message对象，当我们在Dialog中发送showMessage的时候，被mListenersHandler所接收 4.3 自定义Dialog的view的是如何绑定的在上文分析中根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法，在dispatchOnCreate方法中主要调用Dialog的onCreate方法，由于创建的是AlertDialog对象，AlertDialog继承于Dialog，所以实际调用的是AlertDialog的onCreate方法，来完成布局文件的解析，和布局文件中控件的初始化 同理我们自定义CustomDialog继承自Dialog，所以调用的是自定义CustomDialog的onCreate方法，代码如下 public class CustomDialog extends Dialog { Context mContext; // ... 省略构造方法 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); LayoutInflater inflater = (LayoutInflater) mContext .getSystemService(Context.LAYOUT_INFLATER_SERVICE); View view = inflater.inflate(R.layout.custom_dialog, null); setContentView(view); }} 在onCreate方法中调用了 Dialog的setContentView 方法, 来分析setContentView方法frameworks/base/core/java/android/app/Dialog.java public void setContentView(@NonNull View view) { mWindow.setContentView(view);} mWindow是PhoneWindow的实例，最后调用的是PhoneWindow的setContentView解析布局文件，Activity的setContentView最后也是调用了PhoneWindow的setContentView方法，具体的解析流程，可以参考之前的文章Activity布局加载流程 0xA03 Android 10 源码分析：Apk加载流程之资源加载 总结Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑 Dialog的的创建流程？ 构建AlertDialog.Builder对象 builder.setXXX 系列方法完成Dialog的初始化 调用builder.create()方法创建AlertDialog 调用AlertDialog的show()初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，最终将Dialog显示出来 Dialog的视图怎么与Window做关联了？ 在Dialog的构造方法中初始化了Window对象 Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { ... // 获取WindowManager对象 mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 构建PhoneWindow final Window w = new PhoneWindow(mContext); // mWindow 是PhoneWindow实例 mWindow = w; ...} 调用Dialog的show方法，完成view的绘制和Dialog的显示 public void show() { // 获取DecorView mDecor = mWindow.getDecorView(); // 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); // 将DecorView和布局参数添加到WindowManager中 mWindowManager.addView(mDecor, l);} 最终会通过WindowManager将DecorView添加到Window之中，用WIndow对象实现界面的加载与显示逻辑 自定义CustomDialog的view的是如何绑定的? 调用Dialog的show方法，在该方法内部会根据mCreated变量，判断dispatchOnCreate方法是否已经调用，如果没有则调用dispatchOnCreate方法，在dispatchOnCreate方法中主要调用Dialog的onCreate方法 自定义CustomDialog继承自Dialog，所以调用的是自定义CustomDialog的onCreate方法，在CustomDialog的onCreate方法中调用setContentView方法，最后调用的是PhoneWindow的setContentView解析布局文件，解析流程参考0xA03 Android 10 源码分析：Apk加载流程之资源加载 如何使用Kotlin具名可选参数构造类，实现构建者模式？ 这部分内容参考扩展阅读部分 相比于Java的构建者模式，通过具名可选参数构造类具有以下优点? 代码非常的简洁 每个参数名都可以显示的，声明对象时无须按照顺序书写，非常的灵活 构造函数中每个参数都是val声明的，在多线程并发业务场景中更加的安全 Kotlin的require方法，让我们在参数约束上更加的友好 如何在Dialog中使用DataBinding？ 这部分内容参考扩展阅读部分 扩展阅读1. Kotlin实现构建者模式刚才在上文中提到了，在Kotlin中应该尽量避免使用构建者模式，使用Kotlin的具名可选参数构造类，实现构建者模式，代码更加简洁 在 “Effective Java” 书中介绍构建者模式时，是这样子描述它的：本质上builder模式模拟了具名的可算参数，就像Ada和Python中的一样 关于Java用构建者模式实现自定义dialog，可以参考这边文章 Builder Pattern in Java，代码显得很长……..幸运的是，Kotlin是一门拥有具名可选参数的变成语言，Kotlin中的函数和构造器都支持这一特性，接下里我们使用具名可选参数构造类，实现构建者模式，点击JDataBinding前往查看，核心代码如下： class AppDialog( context: Context, val title: String? = null, val message: String? = null, val yes: AppDialog.() -&gt; Unit) : DataBindingDialog(context, R.style.AppDialog) { init { requireNotNull(message) { &quot;message must be not null&quot; } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) requestWindowFeature(Window.FEATURE_NO_TITLE) setContentView(root) display.text = message btnNo.setOnClickListener { dismiss() } btnYes.setOnClickListener { yes() } }} 调用方式也更加的简单 AppDialog( context = this@MainActivity, message = msg, yes = { // do something }).show() 相比于Java的构建者模式，通过具名可选参数构造类具有以下优点: 代码非常的简洁 每个参数名都可以显示的，声明对象时无须按照顺序书写，非常的灵活 构造函数中每个参数都是val声明的，在多线程并发业务场景中更加的安全 Kotlin的require方法，让我们在参数约束上更加的友好 2. 如何在Dialog中使用DataBindingDataBinding是什么？查看Google官网，会有更详细的介绍 DataBinding 是 Google 在 Jetpack 中推出的一款数据绑定的支持库，利用该库可以实现在页面组件中直接绑定应用程序的数据源 在使用Kotlin的具名可选参数构造类实现Dailog构建者模式的基础上，用DataBinding进行二次封装，加上DataBinding数据绑定的特性，使Dialog变得更加简洁、易用 Step1: 定义一个基类DataBindingDialog abstract class DataBindingDialog(@NonNull context: Context, @StyleRes themeResId: Int) : Dialog(context, themeResId) { protected inline fun &lt;reified T : ViewDataBinding&gt; binding(@LayoutRes resId: Int): Lazy&lt;T&gt; = lazy { requireNotNull( DataBindingUtil.bind&lt;T&gt;(LayoutInflater.from(context).inflate(resId, null)) ) { &quot;cannot find the matched view to layout.&quot; } }} Step2: 改造AppDialog class AppDialog( context: Context, val title: String? = null, val message: String? = null, val yes: AppDialog.() -&gt; Unit) : DataBindingDialog(context, R.style.AppDialog) { private val mBinding: DialogAppBinding by binding(R.layout.dialog_app) init { requireNotNull(message) { &quot;message must be not null&quot; } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) requestWindowFeature(Window.FEATURE_NO_TITLE) mBinding.apply { setContentView(root) display.text = message btnNo.setOnClickListener { dismiss() } btnYes.setOnClickListener { yes() } } }} 同理DataBinding在Activity、Fragment、Adapter中的使用也是一样的，利用Kotlin的inline、reified、DSL等等语法，可以设计出更加简洁并利于维护的代码 关于基于DataBinding封装的DataBindingActivity、DataBindingFragment、DataBindingDialog基础库相关代码，后续也会陆续完善基础库，点击JDataBinding前往查看，欢迎start 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你同我一样喜欢研究 Android 源码，可以关注我，如果你喜欢这篇文章欢迎 star，一起来学习，期待与你一起成长 算法由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长 Android 10 源码系列正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 Android10-Source-Analysis，文章都会同步到这个仓库","link":"/2020/06/07/android10/window-manager/05-Dialog/"},{"title":"0xA04 Android 10 源码分析：Apk加载流程之资源加载（二）","text":"引言 这是 Android 10 源码分析系列的第 4 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 通过这篇文章你将学习到以下内容，将在文末会给出相应的答案 View 中的 INVISIBLE、VISIBLE、GONE 都有什么作用？ 为什么 ViewStub 是大小为0的视图 ViewStub 有什么作用？ ViewStub 是如何创建的？ 为什么 ViewStub 能做到延迟加载？ ViewStub 指定的 Layout 布局文件是什么时候被加载的？ LayoutInflater 是一个抽象类它如何被创建的？ 系统服务存储在哪里？如何获取和添加系统服务？ 在上一篇文章 0xA02 Android 10 源码分析：APK 加载流程之资源加载 中通过 LayoutInflater.inflate 方法解析 XML 文件，了解到了系统如何对 merge、include 标签是如何处理的，本文主要围绕以下两方面内容 系统对 ViewStub 如何处理？ LayoutInflater 是如何被创建的？ 系统对 merge、include 是如何处理的 使用 merge 标签必须有父布局，且依赖于父布局加载 merge 并不是一个 ViewGroup，也不是一个 View，它相当于声明了一些视图，等待被添加，解析过程中遇到 merge 标签会将 merge 标签下面的所有子 view 添加到根布局中 merge 标签在 XML 中必须是根元素 相反的 include 不能作为根元素，需要放在一个 ViewGroup 中 使用 include 标签必须指定有效的 layout 属性 使用 include 标签不写宽高是没有关系的，会去解析被 include 的 layout merge 标签为什么可以起到优化布局的效果？ 解析过程中遇到 merge 标签，会调用 rInflate 方法，部分代码如下 // 根据元素名解析，生成对应的viewfinal View view = createViewFromTag(parent, name, context, attrs);final ViewGroup viewGroup = (ViewGroup) parent;final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子viewrInflateChildren(parser, view, attrs, true);// 添加解析的viewviewGroup.addView(view, params); 解析 merge 标签下面的所有子 view，然后添加到根布局中更多信息查看0xA02 Android 10 源码分析：APK 加载流程之资源加载，接下来看一下系统对 ViewStub 如何处理 1. ViewStub是什么关于 ViewStub 的介绍，可以点击下方官网链接查看官网链接https://developer.android.google.cn/reference/android…ViewStub ViewStub 的继承结构 简单来说主要以下几点： ViewStub 控件是一个不可见， 大小为 0 的视图 当 ViewStub 控件设置可见，或者调用 inflate() 方法，ViewStub 所指定的 layout 资源就会被加载 ViewStub 也会从其父控件中移除，ViewStub 会被新加载的 layout 文件代替 为什么 ViewStub 是大小为 0 的视图frameworks/base/core/java/android/view/ViewStub.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // 设置视图大小为0 setMeasuredDimension(0, 0);} ViewStub 的作用 主要用来延迟布局的加载，例如：在 Android 中非常常见的布局，用 ListView 来展示列表信息，当没有数据或者网络加载失败时, 加载空的 ListView 会占用一些资源，如果用 ViewStub 包裹 ListView，当有数据时，才会调用 inflate() 方法显示 ListView，起到延迟加载了布局效果 1.1 ViewStub 是如何被创建的在上篇文章 0xA02 Android 10 源码分析：APK 加载流程之资源加载 中，介绍了 View 的创建是通过调用了 LayoutInflater.createView 方法根据完整的类的路径名利用反射机制构建 View 对象，因为 ViewStub 是继承 View，所以 ViewStub 的创建和 View 的创建是相同的，来看一下 LayoutInflater.createView 方法frameworks/base/core/java/android/view/LayoutInflater.java ...try { // 利用构造函数，创建View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // 如果是ViewStub，则设置LayoutInflater final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view;} finally { mConstructorArgs[0] = lastContext;}... 根据完整的类的路径名利用反射机制构建 View 对象，如果遇到 ViewStub 将当前 LayoutInflater 设置给 ViewStub，当 ViewStub 控件设置可见，或者调用 inflate()，会调用 LayoutInflater 的 inflate 方法完成布局加载，接下来分析 ViewStub 的构造方法 1.2 ViewStub 的构造方法在上面提到了根据完整的类的路径名利用反射机制构建 View 对象，当 View 对象被创建的时候，会调用它的构造函数，来看一下 ViewStub 的构造方法 public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); saveAttributeDataForStyleable(context, R.styleable.ViewStub, attrs, a, defStyleAttr, defStyleRes); // 解析xml中设置的 android:inflatedId 的属性 mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); // 解析xml中设置的 android:layout 属性 mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); // 解析xml中设置的 android:id 属性 mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); // view不可见 setVisibility(GONE); // 不会调用 onDraw 方法绘制内容 setWillNotDraw(true);} 获取 android:inflatedId、android:layout、android:id 的值 调用 setVisibility 方法，设置 View 不可见 调用 setWillNotDraw 方法，不会调用 onDraw 方法绘制内容 在上面提到了如果想要加载 ViewStub 所指定的 layout 资源，需要设置 ViewStub 控件设置可见，或者调用 inflate() 方法，来看一下 ViewStub 的 setVisibility 方法 1.3 ViewStub 的 setVisibility 方法setVisibility(int visibility) 方法，参数 visibility 对应三个值分别是 INVISIBLE、VISIBLE、GONE VISIBLE：视图可见 INVISIBLE：视图不可见的，它仍然占用布局的空间 GONE：视图不可见，它不占用布局的空间 接下里查看一下 ViewStub 的 setVisibility 方法frameworks/base/core/java/android/view/ViewStub.java @Overridepublic void setVisibility(int visibility) { if (mInflatedViewRef != null) { // mInflatedViewRef 是 WeakReference的实例，调用inflate方法时候初始化 View view = mInflatedViewRef.get(); if (view != null) { // 设置View可见 view.setVisibility(visibility); } else { throw new IllegalStateException(&quot;setVisibility called on un-referenced view&quot;); } } else { super.setVisibility(visibility); // 当View为空且设置视图可见(VISIBLE、INVISIBLE)，调用inflate方法 if (visibility == VISIBLE || visibility == INVISIBLE) { inflate(); } }} mInflatedViewRef 是 WeakReference 的实例，调用 inflate 方法时候初始化 从 mInflatedViewRef 缓存中获取 View，并且设置 View 可见 当 View 为空且设置视图可见(VISIBLE、INVISIBLE)，会调用 inflate方法 1.4 ViewStub.inflate 方法调用了 ViewStub 的 setVisibility 方法，最后都会调用 ViewStub.inflate 方法，来查看一下frameworks/base/core/java/android/view/ViewStub.java public View inflate() { final ViewParent viewParent = getParent(); if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) { if (mLayoutResource != 0) { final ViewGroup parent = (ViewGroup) viewParent; // 解析布局视图 // 返回的view是android:layout指定的布局文件最顶层的view final View view = inflateViewNoAdd(parent); // 移除ViewStub // 添加view到被移除的ViewStub的位置 replaceSelfWithView(view, parent); // 添加view到 mInflatedViewRef 中 mInflatedViewRef = new WeakReference&lt;&gt;(view); if (mInflateListener != null) { // 加载完成之后，回调onInflate 方法 mInflateListener.onInflate(this, view); } return view; } else { // 需要在xml中设置android:layout，不是layout，否则会抛出异常 throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); } } else { // ViewStub不能作为根布局，它需要放在ViewGroup中, 否则会抛出异常 throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); }} 调用 inflateViewNoAdd 方法返回 android:layout 指定的布局文件最顶层的 View 调用 replaceSelfWithView 方法, 移除 ViewStub, 添加 View 到被移除的 ViewStub 的位置 添加 View 到 mInflatedViewRef 中 加载完成之后，回调 onInflate 方法 需要注意以下两点： 使用 ViewStub 需要在 XML 中设置 android:layout，不是 layout，否则会抛出异常 ViewStub 不能作为根布局，它需要放在 ViewGroup 中, 否则会抛出异常 来查看一下 inflateViewNoAdd 方法和 replaceSelfWithView 方法 1.5 ViewStub.inflateViewNoAdd 方法调用 inflateViewNoAdd 方法返回 android:layout 指定的布局文件最顶层的 Viewframeworks/base/core/java/android/view/ViewStub.java private View inflateViewNoAdd(ViewGroup parent) { final LayoutInflater factory; // mInflater 是View被创建的时候，如果是ViewStub, 将LayoutInflater赋值给mInflater if (mInflater != null) { factory = mInflater; } else { // 如果mInflater为空，则创建LayoutInflater factory = LayoutInflater.from(mContext); } // 从指定的 mLayoutResource 资源中解析布局视图 // mLayoutResource 是在xml设置的 Android:layout 指定的布局文件 final View view = factory.inflate(mLayoutResource, parent, false); // mInflatedId 是在xml设置的 inflateId if (mInflatedId != NO_ID) { // 将id复制给view view.setId(mInflatedId); //注意：如果指定了mInflatedId , 被inflate的layoutView的id就是mInflatedId } return view;} mInflater 是 View 被创建的时候，如果是 ViewStub, 将 LayoutInflater 赋值给 mInflater 如果 mInflater 为空则通过 LayoutInflater.from(mContext) 构建 LayoutInflater 调用 LayoutInflater 的 inflate 方法解析布局视图 将 mInflatedId 设置 View 1.6 ViewStub.replaceSelfWithView 方法调用 replaceSelfWithView 方法, 移除 ViewStub, 添加 View 到被移除的 ViewStub 的位置frameworks/base/core/java/android/view/ViewStub.java private void replaceSelfWithView(View view, ViewGroup parent) { // 获取ViewStub在视图中的位置 final int index = parent.indexOfChild(this); // 移除ViewStub // 注意：调用removeViewInLayout方法之后，调用findViewById()是找不到该ViewStub对象 parent.removeViewInLayout(this); final ViewGroup.LayoutParams layoutParams = getLayoutParams(); // 将xml中指定的 android:layout 布局文件中最顶层的View，添加到被移除的 ViewStub的位置 if (layoutParams != null) { parent.addView(view, index, layoutParams); } else { parent.addView(view, index); }} 获取 ViewStub 在视图中的位置，然后移除 ViewStub 添加 android:layout 布局文件中最顶层的 View 到被移除的 ViewStub 的位置 1.7 ViewStub 的注意事项 使用 ViewStub 需要在 XML 中设置 android:layout，不是 layout，否则会抛出异常 throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); ViewStub 不能作为根布局，它需要放在 ViewGroup 中, 否则会抛出异常 throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); 一旦调用 setVisibility(View.VISIBLE) 或者 inflate() 方法之后，该 ViewStub 将会从试图中被移除（此时调用 findViewById() 是找不到该 ViewStub 对象). // 获取ViewStub在视图中的位置final int index = parent.indexOfChild(this);// 移除ViewStub// 注意：调用removeViewInLayout方法之后，调用findViewById()是找不到该ViewStub对象parent.removeViewInLayout(this); 如果指定了 mInflatedId , 被 inflate 的 layoutView 的 id 就是 mInflatedId // mInflatedId 是在xml设置的 inflateIdif (mInflatedId != NO_ID) { // 将id复制给view view.setId(mInflatedId); //注意：如果指定了mInflatedId , 被inflate的layoutView的id就是mInflatedId} 被 inflate 的 layoutView 的 layoutParams 与 ViewStub 的 layoutParams 相同. final ViewGroup.LayoutParams layoutParams = getLayoutParams();// 将xml中指定的 android:layout 布局文件中最顶层的View 也就是根view，// 添加到被移除的 ViewStub的位置if (layoutParams != null) { parent.addView(view, index, layoutParams);} else { parent.addView(view, index);} 到这里关于 ViewStub 的构建、布局的加载以及注意事项分析完了，接下来分析一下 LayoutInflater 是如何被创建的 2 关于LayoutInflater在 0xA02 Android 10 源码分析：APK 加载流程之资源加载 文章中，介绍了 Activity 启动的时候通过调用 LayoutInflater 的 inflater 的方法加载 layout 文件，那么 LayoutInflater 是如何被创建的呢，先来看一段代码，相信下面的代码都不会很陌生 public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) { return new AllVh(LayoutInflater .from(viewGroup.getContext()) .inflate(R.layout.list_item, viewGroup, false));} LayoutInflater的inflate方法的三个参数都代表什么意思？ resource：要解析的 XML 布局文件 Id root：表示根布局 attachToRoot：是否要添加到父布局 root中 resource 其实很好理解就是资源 Id，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该View中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 2.1 LayoutInflater 是如何被创建的LayoutInflater 是一个抽象类，通过调用了 from() 的静态函数，经由系统服务 LAYOUT_INFLATER_SERVICE，最终创建了一个 LayoutInflater 的子类对象 PhoneLayoutInflater，继承结构如下： LayoutInflater.from(ctx) 就是根据传递过来的 Context 对象，调用 getSystemService() 来获取对应的系统服务, 来看一下这个方法frameworks/base/core/java/android/view/LayoutInflater.java public static LayoutInflater from(Context context) { // 获取系统服务 LAYOUT_INFLATER_SERVICE ，并赋值给 LayoutInflater // Context 是一个抽象类，真正的实现类是ContextImpl LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) { throw new AssertionError(&quot;LayoutInflater not found.&quot;); } return LayoutInflater;} 而 Context 本身是一个抽象类，它真正的实例化对象是 ContextImplframeworks/base/core/java/android/app/ContextImpl.java public Object getSystemService(String name) { // SystemServiceRegistry 是管理系统服务的 // 调用getSystemService方法，通过服务名字查找对应的服务 return SystemServiceRegistry.getSystemService(this, name);} 2.2 SystemServiceRegistrySystemServiceRegistry 管理所有的系统服务，调用 getSystemService 方法，通过服务名字查找对应的服务frameworks/base/core/java/android/app/SystemServiceRegistry.java public static Object getSystemService(ContextImpl ctx, String name) { // SYSTEM_SERVICE_FETCHERS 是一个map集合 // 从 map 集合中取出系统服务 ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;} ServiceFetcher 为 SystemServiceRegistry 类的静态内部接口，定义了 getService 方法 ServiceFetcher 的实现类 CachedServiceFetcher 实现了 getService方法 所有的系统服务都存储在一个 map 集合 SYSTEM_SERVICE_FETCHERS当 中，调用 get 方法来获取对应的服务 如果有 getSystemService 方法来获取服务，那么相应的也会有添加服务的方法frameworks/base/core/java/android/app/SystemServiceRegistry.java private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass, ServiceFetcher&lt;T&gt; serviceFetcher) { SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);} 通过调用 SYSTEM_SERVICE_NAMES 的 put 方法，往 map 集合中添加数据，那么 registerService 是什么时候调用的，在 SystemServiceRegistry 类中搜索 registerService 方法，知道了在类加载的时候通过静态代码块中添加的，来看一下 static { // 初始化加载所有的系统服务 ... // 省略了很多系统服务 registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() { @Override public LayoutInflater createService(ContextImpl ctx) { return new PhoneLayoutInflater(ctx.getOuterContext()); }}); ... // 省略了很多系统服务} 最终是创建了一个 PhoneLayoutInflater 并返回的，到这里 LayoutInflater 的创建流程就分析完了 总结View 中的 INVISIBLE、VISIBLE、GONE 都有什么作用？ 如果想隐藏或者显示 View，可以通过调用 setVisibility(int visibility) 方法来实现，参数 visibility 对应三个值分别是INVISIBLE、VISIBLE、GONE VISIBLE：视图可见 INVISIBLE：视图不可见的，它仍然占用布局的空间 GONE：视图不可见，它不占用布局的空间 为什么 ViewStub 是大小为0的视图？frameworks/base/core/java/android/view/ViewStub.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // 设置视图大小为0 setMeasuredDimension(0, 0);} ViewStub 有什么作用？ ViewStub 的作用主要用来延迟布局的加载 ViewStub 是如何创建的？ 因为 ViewStub 是继承 View, 所以 ViewStub 的创建和 View 的创建是相同的，通过调用了 LayoutInflater.createView 方法根据完整的类的路径名利用反射机制构建 View 对象frameworks/base/core/java/android/view/LayoutInflater.java ...try { // 利用构造函数，创建View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // 如果是ViewStub，则设置LayoutInflater final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view;} finally { mConstructorArgs[0] = lastContext;}... 为什么 ViewStub 能做到延迟加载？ 因为在解析 layout 文件过程中遇到 ViewStub，只是构建 ViewStub 的对象和初始化 ViewStub 的属性，没有真正开始解析 View，所以可以做到延迟初始化 ViewStub 指定的 Layout 布局文件是什么时候被加载的？ 当ViewStub 控件设置可见，或者调用 inflate() 方法，ViewStub 所指定的 layout 资源就会被加载 LayoutInflater 是一个抽象类它如何被创建的？ LayoutInflater 是一个抽象类，通过调用了 from() 的静态函数，经由系统服务 LAYOUT_INFLATER_SERVICE，最终创建了一个 LayoutInflater的子类对象 PhoneLayoutInflater，继承结构如下： LayoutInflater.from(ctx) 就是根据传递过来的 Context 对象，调用 getSystemService() 来获取对应的系统服务 系统服务存储在哪里？如何获取和添加系统服务？ SystemServiceRegistry 管理所有的系统服务，所有的系统服务都存储在一 个map集合SYSTEM_SERVICE_FETCHERS 当中，调用 getSystemService 方法获取系统服务，调用 registerService 方法添加系统服务 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你同我一样喜欢研究 Android 源码，可以关注我，如果你喜欢这篇文章欢迎 star，一起来学习，期待与你一起成长 算法由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长 Android 10 源码系列正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 Android10-Source-Analysis，文章都会同步到这个仓库","link":"/2020/06/07/android10/resource-manager/04-APK-resource2/"},{"title":"0xA03 Android 10 源码分析：APK 加载流程之资源加载","text":"引言 这是 Android 10 源码分析系列的第 3 篇 分支：android-10.0.0_r14 全文阅读大概 15 分钟 通过这篇文章你将学习到以下内容，文末会给出相应的答案 LayoutInflater的inflate 方法的三个参数都代表什么意思？ 系统对 merge、include 是如何处理的 merge 标签为什么可以起到优化布局的效果？ XML 中的 View 是如何被实例化的？ 为什么复杂布局会产生卡顿？在 Android 10 上做了那些优化？ BlinkLayout 是什么？ 前面两篇文章 0xA01 Android 10 源码分析：APK 是如何生成的 和 0xA02 Android 10 源码分析：APK 的安装流程 分析了 APK 大概可以分为代码和资源两部分，那么 APK 的加载也是分为代码和资源两部分，代码的加载涉及了进程的创建、启动、调度，本文主要来分析一下资源的加载，如果没有看过 APK 是如何生成的 和 APK 的安装流程 可以点击下方连接前往： 0xA01 Android 10 源码分析：APK 是如何生成的 0xA02 Android 10 源码分析：APK 的安装流程 1. Android 资源Android 资源大概分为两个部分：assets 和 res assets 资源 assets 资源放在 assets 目录下，它里面保存一些原始的文件，可以以任何方式来进行组织，这些文件最终会原封不动的被打包进 APK 文件中，通过AssetManager 来获取 asset 资源，代码如下 AssetManager assetManager = context.getAssets();InputStream is = assetManager.open(&quot;fileName&quot;); res资源 res 资源放在主工程的 res 目录下，这类资源一般都会在编译阶段生成一个资源 ID 供我们使用，res 目录包括 animator、anim、 color、drawable、layout、menu、raw、values、XML等，通过 getResource() 去获取 Resources 对象 Resources res = getContext().getResources(); APK 的生成过程中，会生成资源索引表 resources.arsc 文件和 R.java 文件，前者资源索引表 resources.arsc 记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息，后者定义了各个资源 ID 常量，运行时通过 Resources 和 AssetManger 共同完成资源的加载，如果资源是个文件，Resouces 先根据资源 ID 查找出文件名，AssetManger 再根据文件名查找出具体的资源，关于 resources.arsc，可以查看 0xA01 ASOP应用框架：APK 是如何生成的 2. 资源的加载和解析到 View 的生成下面代码一定不会很陌生，在 Activity 常见的几行代码 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.main_activity)} 一起来分析一下调用 setContentView 方法之后做了什么事情，接下来查看一下 Activity 中的 setContentView 方法frameworks/base/core/java/android/app/Activity.java public void setContentView(@LayoutRes int layoutResID) { // 实际上调用的是PhoneWindow.setContentView方法 getWindow().setContentView(layoutResID); initWindowDecorActionBar();} 调用 getWindow 方法返回的是 mWindow，mWindow 是 Windowd 对象，实际上是调用它的唯一实现类 PhoneWindow.setContentView 方法 2.1 Activity -&gt; PhoneWindowPhoneWindow 是 Window 的唯一实现类，它的结构如下： 当调用 Activity.setContentView 方法实际上调用的是 PhoneWindow.setContentView 方法frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java public void setContentView(int layoutResID) { // mContentParent是ID为ID_ANDROID_CONTENT的FrameLayout // 调用setContentView方法，就是给ID为ID_ANDROID_CONTENT的View添加子View if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { // FEATURE_CONTENT_TRANSITIONS，则是标记当前内容加载有没有使用过度动画 // 如果内容已经加载过，并且不需要动画，则会调用removeAllViews mContentParent.removeAllViews(); } // 检查是否设置了FEATURE_CONTENT_TRANSITIONS if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { // 解析指定的XML资源文件 mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } mContentParentExplicitlySet = true;} 先判断 mContentParent 是否为空，如果为空则调用 installDecor 方法，生成 mDecor，并将它赋值给 mContentParent 根据 FEATURE_CONTENT_TRANSITIONS 标记来判断是否加载过转场动画 如果设置了 FEATURE_CONTENT_TRANSITIONS 则添加 Scene 来过度启动，否则调用 mLayoutInflater.inflate(layoutResID, mContentParent)，解析资源文件，创建 View, 并添加到 mContentParent 视图中 2.2 PhoneWindow -&gt; LayoutInflater当调用 PhoneWindow.setContentView 方法，之后调用 LayoutInflater.inflate 方法，来解析 XML 资源文件frameworks/base/core/java/android/view/LayoutInflater.java public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null);} inflate 它有多个重载方法，最后调用的是 inflate(resource, root, root != null) 方法frameworks/base/core/java/android/view/LayoutInflater.java public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); // 根据XML预编译生成compiled_view.dex, 然后通过反射来生成对应的View，从而减少XmlPullParser解析Xml的时间 // 需要注意的是在目前的release版本中不支持使用 View view = tryInflatePrecompiled(resource, res, root, attachToRoot); if (view != null) { return view; } // 获取资源解析器 XmlResourceParser XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); }} 这个方法主要做了三件事： 根据 XML 预编译生成 compiled_view.dex, 然后通过反射来生成对应的 View 获取 XmlResourceParser 解析 View 注意：在目前的 release 版本中不支持使用 tryInflatePrecompiled 方法源码如下： private void initPrecompiledViews() { // Precompiled layouts are not supported in this release. // enabled 是否启动预编译布局，这里始终为false boolean enabled = false; initPrecompiledViews(enabled);}private void initPrecompiledViews(boolean enablePrecompiledViews) { mUseCompiledView = enablePrecompiledViews; if (!mUseCompiledView) { mPrecompiledClassLoader = null; return; } ...}View tryInflatePrecompiled(@LayoutRes int resource, Resources res, @Nullable ViewGroup root, boolean attachToRoot) { // mUseCompiledView始终为false if (!mUseCompiledView) { return null; } // 获取需要解析的资源文件的 pkg 和 layout String pkg = res.getResourcePackageName(resource); String layout = res.getResourceEntryName(resource); try { // 根据mPrecompiledClassLoader通过反射获取预编译生成的view对象的Class类 Class clazz = Class.forName(&quot;&quot; + pkg + &quot;.CompiledView&quot;, false, mPrecompiledClassLoader); Method inflater = clazz.getMethod(layout, Context.class, int.class); View view = (View) inflater.invoke(null, mContext, resource); if (view != null &amp;&amp; root != null) { // 将生成的view 添加根布局中 XmlResourceParser parser = res.getLayout(resource); try { AttributeSet attrs = Xml.asAttributeSet(parser); advanceToRootNode(parser); ViewGroup.LayoutParams params = root.generateLayoutParams(attrs); // 如果 attachToRoot=true添加到根布局中 if (attachToRoot) { root.addView(view, params); } else { // 否者将获取到的根布局的LayoutParams，设置到生成的view中 view.setLayoutParams(params); } } finally { parser.close(); } } return view; } catch (Throwable e) { } finally { } return null;} tryInflatePrecompiled 方法是 Android 10 新增的方法，这是一个在编译器运行的一个优化，因为布局文件越复杂 XmlPullParser 解析 XML 越耗时, tryInflatePrecompiled 方法根据 XML 预编译生成compiled_view.dex, 然后通过反射来生成对应的 View，从而减少 XmlPullParser 解析 XML 的时间，然后根据 attachToRoot 参数来判断是添加到根布局中，还是设置 LayoutParams 参数返回给调用者 用一个全局变量 mUseCompiledView 来控制是否启用 tryInflatePrecompiled 方法，根据源码分析，mUseCompiledView 始终为 false 了解了 tryInflatePrecompiled 方法之后，在来查看一下 inflate 方法中的三个参数都什么意思 resource：要解析的 XML 布局文件 ID root：表示根布局 attachToRoot：是否要添加到父布局 root 中 resource 其实很好理解就是资源 ID，而 root 和 attachToRoot 分别代表什么意思： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 根据源码知道调用 tryInflatePrecompiled 方法返回的 view 为空，继续往下执行调用 Resources 的 getLayout 方法获取资源解析器 XmlResourceParser 2.3 LayoutInflater -&gt; Resources上面说到 XmlResourceParser 是通过调用 Resources 的 getLayout 方法获取的，getLayout 方法又去调用了 Resources 的loadXmlResourceParser 方法frameworks/base/core/java/android/content/res/Resources.java public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException { return loadXmlResourceParser(id, &quot;layout&quot;);}XmlResourceParser loadXmlResourceParser(@AnyRes int id, @NonNull String type) throws NotFoundException { // TypedValue 主要用来存储资源 final TypedValue value = obtainTempTypedValue(); try { final ResourcesImpl impl = mResourcesImpl; // 获取XML资源，保存到 TypedValue impl.getValue(id, value, true); if (value.type == TypedValue.TYPE_STRING) { // 为指定的XML资源，加载解析器 return impl.loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type); } throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id) + &quot; type #0x&quot; + Integer.toHexString(value.type) + &quot; is not valid&quot;); } finally { releaseTempTypedValue(value); }} TypedValue 是动态的数据容器，主要用来存储 Resource 的资源，获取 XML 资源保存到 TypedValue，之后调用 ResourcesImpl 的 loadXmlResourceParser 方法加载对应的解析器 2.4 Resources -&gt; ResourcesImplResourcesImpl 实现了 Resource 的访问，它包含了 AssetManager 和所有的缓存，通过 Resource 的 getValue 方法获取 XML 资源保存到 TypedValue，之后就会调用 ResourcesImpl 的 loadXmlResourceParser 方法对该布局资源进行解析frameworks/base/core/java/android/content/res/ResourcesImpl.java XmlResourceParser loadXmlResourceParser(@NonNull String file, @AnyRes int id, int assetCookie, @NonNull String type) throws NotFoundException { if (id != 0) { try { synchronized (mCachedXmlBlocks) { final int[] cachedXmlBlockCookies = mCachedXmlBlockCookies; final String[] cachedXmlBlockFiles = mCachedXmlBlockFiles; final XmlBlock[] cachedXmlBlocks = mCachedXmlBlocks; // 首先从缓存中查找XML资源 final int num = cachedXmlBlockFiles.length; for (int i = 0; i &lt; num; i++) { if (cachedXmlBlockCookies[i] == assetCookie &amp;&amp; cachedXmlBlockFiles[i] != null &amp;&amp; cachedXmlBlockFiles[i].equals(file)) { // 调用newParser方法去构建一个XmlResourceParser对象，返回给调用者 return cachedXmlBlocks[i].newParser(id); } } // 如果缓存中没有，则创建XmlBlock，并将它放到缓存中 // XmlBlock是已编译的XML文件的一个包装类 final XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file); if (block != null) { final int pos = (mLastCachedXmlBlockIndex + 1) % num; mLastCachedXmlBlockIndex = pos; final XmlBlock oldBlock = cachedXmlBlocks[pos]; if (oldBlock != null) { oldBlock.close(); } cachedXmlBlockCookies[pos] = assetCookie; cachedXmlBlockFiles[pos] = file; cachedXmlBlocks[pos] = block; // 调用newParser方法去构建一个XmlResourceParser对象，返回给调用者 return block.newParser(id); } } } catch (Exception e) { final NotFoundException rnf = new NotFoundException(&quot;File &quot; + file + &quot; from xml type &quot; + type + &quot; resource ID #0x&quot; + Integer.toHexString(id)); rnf.initCause(e); throw rnf; } } throw new NotFoundException(&quot;File &quot; + file + &quot; from xml type &quot; + type + &quot; resource ID #0x&quot; + Integer.toHexString(id));} 首先从缓存中查找 XML 资源之后调用 newParser 方法，如果缓存中没有，则调用 AssetManger 的 openXmlBlockAsset 方法创建一个 XmlBlock，并将它放到缓存中，XmlBlock 是已编译的 XML 文件的一个包装类frameworks/base/core/java/android/content/res/AssetManager.java XmlBlock openXmlBlockAsset(int cookie, @NonNull String fileName) throws IOException { Preconditions.checkNotNull(fileName, &quot;fileName&quot;); synchronized (this) { ensureOpenLocked(); // 调用native方法nativeOpenXmlAsset, 加载指定的XML资源文件，得到ResXMLTree // xmlBlock是ResXMLTree对象的地址 final long xmlBlock = nativeOpenXmlAsset(mObject, cookie, fileName); if (xmlBlock == 0) { throw new FileNotFoundException(&quot;Asset XML file: &quot; + fileName); } // 创建XmlBlock，封装xmlBlock，返回给调用者 final XmlBlock block = new XmlBlock(this, xmlBlock); incRefsLocked(block.hashCode()); return block; }} 最终调用 native 方法 nativeOpenXmlAsset 去打开指定的 XML 文件，加载对应的资源，来查看一下 navtive 方法 NativeOpenXmlAssetframeworks/base/core/jni/android_util_AssetManager.cpp // java方法对应的native方法{&quot;nativeOpenXmlAsset&quot;, &quot;(JILjava/lang/String;)J&quot;, (void*)NativeOpenXmlAsset} static jlong NativeOpenXmlAsset(JNIEnv* env, jobject /*clazz*/, jlong ptr, jint jcookie, jstring asset_path) { ApkAssetsCookie cookie = JavaCookieToApkAssetsCookie(jcookie); ... const DynamicRefTable* dynamic_ref_table = assetmanager-&gt;GetDynamicRefTableForCookie(cookie); std::unique_ptr&lt;ResXMLTree&gt; xml_tree = util::make_unique&lt;ResXMLTree&gt;(dynamic_ref_table); status_t err = xml_tree-&gt;setTo(asset-&gt;getBuffer(true), asset-&gt;getLength(), true); asset.reset(); ... return reinterpret_cast&lt;jlong&gt;(xml_tree.release());} C++ 层的 NativeOpenXmlAsset 方法会创建 ResXMLTree 对象，返回的是 ResXMLTree 在 C++ 层的地址 Java 层 nativeOpenXmlAsse t方法的返回值 xmlBlock 是 C++ 层的 ResXMLTree 对象的地址，然后将 xmlBlock 封装进 XmlBlock 中返回给调用者 当 xmlBlock 创建之后，会调用 newParser 方法，构建一个 XmlResourceParser 对象，返回给调用者 2.5 ResourcesImpl -&gt; XmlBlockXmlBlock 是已编译的 XML 文件的一个包装类，XmlResourceParser 负责对 XML 的标签进行遍历解析的，它的真正的实现是 XmlBlock 的内部类 XmlBlock.Parser，而真正完成 XML 的遍历操作的函数都是由 XmlBlock 来实现的，为了提升效率都是通过 JNI 调用 native 的函数来做的，接下来查看一下 newParser 方法frameworks/base/core/java/android/content/res/XmlBlock.java public XmlResourceParser newParser(@AnyRes int resId) { synchronized (this) { // mNative是C++层的ResXMLTree对象的地址 if (mNative != 0) { // nativeCreateParseState方法根据 mNative 查找到ResXMLTree， // 在C++层构建一个ResXMLParser对象， // 构建Parser，封装ResXMLParser，返回给调用者 return new Parser(nativeCreateParseState(mNative, resId), this); } return null; }} 这个方法做两件事 mNative 是 C++ 层的 ResXMLTree 对象的地址，调用 native 方法 nativeCreateParseState，在 C++ 层构建一个 ResXMLParser 对象，返回 ResXMLParser 对象在 C++ 层的地址 Java 层拿到 ResXMLParser 在 C++ 层地址，构建 Parser，封装 ResXMLParser，返回给调用者 接下来查看一下 native 方法 nativeCreateParseStateframeworks/base/core/jni/android_util_XmlBlock.cpp // java方法对应的native方法{ &quot;nativeCreateParseState&quot;, &quot;(JI)J&quot;, (void*) android_content_XmlBlock_nativeCreateParseState } static jlong android_content_XmlBlock_nativeCreateParseState(JNIEnv* env, jobject clazz, jlong token, jint res_id){ ResXMLTree* osb = reinterpret_cast&lt;ResXMLTree*&gt;(token); if (osb == NULL) { jniThrowNullPointerException(env, NULL); return 0; } ResXMLParser* st = new ResXMLParser(*osb); if (st == NULL) { jniThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, NULL); return 0; } st-&gt;setSourceResourceId(res_id); st-&gt;restart(); return reinterpret_cast&lt;jlong&gt;(st);} token 对应 Java 层 mNative，是 C++ 层的 ResXMLTree 对象的地址 调用 C++ 层 android_content_XmlBlock_nativeCreateParseState 方法，根据 token找到 ResXMLTree 对象 在 C++ 层构建一个 ResXMLParser 对象，返给 Java 层对应 ResXMLParser 对象在 C++ 层的地址 Java 层拿到 ResXMLParser 在 C++ 层地址，封装到 Parser 中 2.6 再次回到 LayoutInflater经过一系列的跳转，最后调用 XmlBlock.newParser 方法获取资源解析器 XmlResourceParser，之后回到 LayoutInflater 调用处 inflate 方法，然后调用 rInflate 方法解析 Viewframeworks/base/core/java/android/view/LayoutInflater.java public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { // 获取context final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; // 存储根布局 View result = root; try { // 处理 START_TA G和 END_TAG advanceToRootNode(parser); final String name = parser.getName(); // 解析merge标签，rInflate方法会将merge标签下面的所有子view添加到根布局中 // 这也是为什么merge标签可以简化布局的效果 if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); } // 解析merge标签下的所有的View，添加到根布局中 rInflate(parser, root, inflaterContext, attrs, false); } else { // 如果不是merge标签，调用createViewFromTag方法解析布局视图，这里的temp其实是我们xml里的top view final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; // 如果根布局不为空的话，且attachToRoot为false，为View设置布局参数 if (root != null) { // 获取根布局的LayoutParams params = root.generateLayoutParams(attrs); // attachToRoot为false，为View设置LayoutParams if (!attachToRoot) { temp.setLayoutParams(params); } } // 解析当前View下面的所有子View rInflateChildren(parser, temp, attrs, true); // 如果 root 不为空且 attachToRoot 为false，将解析出来的View 添加到根布局 if (root != null &amp;&amp; attachToRoot) { root.addView(temp, params); } // 如果根布局为空 或者 attachToRoot 为false，返回当前的View if (root == null || !attachToRoot) { result = temp; } } } catch (XmlPullParserException e) { final InflateException ie = new InflateException(e.getMessage(), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; } catch (Exception e) { throw ie; } finally { } return result; }} 解析 merge 标签，使用 merge 标签必须有父布局，且依赖于父布局加载 rInflate 方法会将 merge 标签下面的所有 View 添加到根布局中 如果不是 merge 标签，调用 createViewFromTag 解析布局视图，返回 temp, 这里的 temp 其实是我们 XML 里的 Top View 调用 rInflateChildren 方法，传递参数 temp，在 rInflateChildren方 法里内部，会调用 rInflate 方法, 解析当前 View 下面的所有子 View 通过分析源码知道了attachToRoot 和 root的参数代表什么意思，这里总结一下： 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的View生成 LayoutParams并设置到该 View 中去 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回 无论是不是 merge 标签，最后都会调用 rInflate 方法进行 View 树的解析，他们的区别在于，如果是 merge 标签传递的参数 finishInflate 是 false，如果不是 merge 标签传递的参数 finishInflate 是 trueframeworks/base/core/java/android/view/LayoutInflater.java void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException { // 获取数的深度 final int depth = parser.getDepth(); int type; boolean pendingRequestFocus = false; // 逐个 View 解析 while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) { if (type != XmlPullParser.START_TAG) { continue; } final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) { // 解析android:focusable=&quot;true&quot;, 获取View的焦点 pendingRequestFocus = true; consumeChildElements(parser); } else if (TAG_TAG.equals(name)) { // 解析android:tag标签 parseViewTag(parser, parent, attrs); } else if (TAG_INCLUDE.equals(name)) { // 解析include标签，include标签不能作为根布局 if (parser.getDepth() == 0) { throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); } parseInclude(parser, context, parent, attrs); } else if (TAG_MERGE.equals(name)) { // merge标签必须作为根布局 throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); } else { // 根据元素名解析，生成View final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); // rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子View rInflateChildren(parser, view, attrs, true); // 添加解析的View viewGroup.addView(view, params); } } if (pendingRequestFocus) { parent.restoreDefaultFocus(); } // 如果finishInflate为true，则调用onFinishInflate方法 if (finishInflate) { parent.onFinishInflate(); }} 整个 View 树的解析过程如下： 获取 View 树的深度 逐个 View 解析 解析 android:focusable=”true”, 获取 View 的焦点 解析 android:tag 标签 解析 include 标签，并且 include 标签不能作为根布局 解析 merge 标签，并且 merge 标签必须作为根布局 根据元素名解析，生成对应的 View rInflateChildren 方法内部调用的 rInflate 方法，深度优先遍历解析所有的子 View 添加解析的 View 注意：通过分析源码, 以下几点需要特别注意 include 标签不能作为根元素，需要放在 ViewGroup中 merge 标签必须为根元素，使用 merge 标签必须有父布局，且依赖于父布局加载 当 XmlResourseParser 对 XML 的遍历，随着布局越复杂，层级嵌套越多，所花费的时间也越长，所以对布局的优化，可以使用 meger 标签减少层级的嵌套 在解析过程中调用 createViewFromTag 方法，根据元素名解析，生成对应的 View，接下来查看一下 createViewFromTag 方法frameworks/base/core/java/android/view/LayoutInflater.java private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) { return createViewFromTag(parent, name, context, attrs, false);}View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) { if (name.equals(&quot;view&quot;)) { name = attrs.getAttributeValue(null, &quot;class&quot;); } // 如果设置了theme, 构建一个ContextThemeWrapper if (!ignoreThemeAttr) { final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) { context = new ContextThemeWrapper(context, themeResId); } ta.recycle(); } try {\b\b // 如果name是blink，则创建BlinkLayout // 如果设置factory，根据factory进行解析, 这是系统留给我们的Hook入口 View view = tryCreateView(parent, name, context, attrs); // 如果 tryCreateView方法返回的View为空，则判断是内置View还是自定义View // 如果是内置的View则调用onCreateView方法，如果是自定义View 则调用createView方法 if (view == null) { final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try { // 如果使用自定义View，需要在XML指定全路径的， // 例如：com.hi.dhl.CustomView，那么这里就有个.了 // 可以利用这一点判定是内置的View，还是自定义View if (-1 == name.indexOf('.')) { // 解析内置View view = onCreateView(context, parent, name, attrs); } else { // 解析自定义View view = createView(context, name, null, attrs); } /** * onCreateView方法与createView方法的区别 * onCreateView方法：会给内置的View前面加一个前缀，例如：android.widget，最终会调用createView方法 * createView方法: 据完整的类的路径名利用反射机制构建View对象 */ } finally { mConstructorArgs[0] = lastContext; } } return view; } catch (InflateException e) { throw e; } catch (ClassNotFoundException e) { throw ie; } catch (Exception e) { throw ie; }} 解析 View 标签，如果设置了 theme, 构建一个 ContextThemeWrapper 调用 tryCreateView 方法，如果 name 是 blink，则创建 BlinkLayout，如果设置 factory，根据 factory 进行解析，这是系统留给我们的 Hook 入口，我们可以人为的干涉系统创建 View，添加更多的功能 如果 tryCreateView 方法返回的 View 为空，则分别调用 onCreateView 方法和 createView 方法，onCreateView 方法解析内置 View，createView 方法解析自定义 View 在解析过程中，会先调用 tryCreateView 方法，来看一下 tryCreateView 方法内部做了什么frameworks/base/core/java/android/view/LayoutInflater.java public final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) { // BlinkLayout它是FrameLayout的子类，是LayoutInflater中的一个内部类, // 如果当前标签为TAG_1995，则创建一个隔500毫秒闪烁一次的BlinkLayout来承载它的布局内容 if (name.equals(TAG_1995)) { // Let's party like it's 1995! // 源码注释也很有意思，写了Let's party like it's 1995!, 据说是为了庆祝1995年的复活节 return new BlinkLayout(context, attrs); } // 如果设置factory，根据factory进行解析, 这是系统留给我们的Hook入口，我们可以人为的干涉系统创建View，添加更多的功能 if (mFactory2 != null) { view = mFactory2.onCreateView(parent, name, context, attrs); } else if (mFactory != null) { view = mFactory.onCreateView(name, context, attrs); } else { view = null; } if (view == null &amp;&amp; mPrivateFactory != null) { view = mPrivateFactory.onCreateView(parent, name, context, attrs); } return view;} 如果 name 是 blink，则创建 BlinkLayout，返给调用者 如果设置 factory，根据 factory 进行解析, 这是系统留给我们的 Hook 入口，我们可以人为的干涉系统创建 View，添加更多的功能，例如夜间模式，将 View 返给调用者 根据刚才的分析，会先调用 tryCreateView 方法，如果这个方法返回的 View 为空，然后会调用 onCreateView 方法对内置 View 进行解析，createView 方法对自定义 View 进行解析 onCreateView 方法与 createView 方法的有什么区别 onCreateView 方法：会给内置的 View 前面加一个前缀，例如： android.widget，最终会调用 createView 方法 createView 方法: 根据完整的类的路径名利用反射机制构建 View 对象 来看一下这两个方法的实现，LayoutInflater 是一个抽象类，我们实际使用的是 PhoneLayoutInflater，它的结构如下 PhoneLayoutInflater 重写了 LayoutInflater 的 onCreatView 方法，这个方法就是给内置的 View 前面加一个前缀frameworks/base/core/java/com/android/internal/policy/PhoneLayoutInflater.java private static final String[] sClassPrefixList = { &quot;android.widget.&quot;, &quot;android.webkit.&quot;, &quot;android.app.&quot;}; protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException { for (String prefix : sClassPrefixList) { try { View view = createView(name, prefix, attrs); if (view != null) { return view; } } catch (ClassNotFoundException e) { } } return super.onCreateView(name, attrs);} onCreateView 方法会给内置的 View 前面加一个前缀，之后调用 createView 方法，真正的 View 构建还是在 LayoutInflater 的 createView 方法里完成的，createView 方法根据完整的类的路径名利用反射机制构建 View 对象frameworks/base/core/java/android/view/LayoutInflater.java public final View createView(@NonNull Context viewContext, @NonNull String name, @Nullable String prefix, @Nullable AttributeSet attrs) throws ClassNotFoundException, InflateException { ... try { if (constructor == null) { // 如果在缓存中没有找到构造函数，则根据完整的类的路径名利用反射机制构建View对象 clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); if (mFilter != null &amp;&amp; clazz != null) { boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) { failNotAllowed(name, prefix, viewContext, attrs); } } // 利用反射机制构建clazz, 将它的构造函数存入sConstructorMap中，下次可以直接从缓存中查找 constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); } else { // 如果从缓存中找到了缓存的构造函数 if (mFilter != null) { Boolean allowedState = mFilterMap.get(name); if (allowedState == null) { // 根据完整的类的路径名利用反射机制构建View对象 clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); ... } else if (allowedState.equals(Boolean.FALSE)) { failNotAllowed(name, prefix, viewContext, attrs); } } } ... try { // 利用构造函数，创建View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // 如果是ViewStub，则设置LayoutInflater final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view; } finally { mConstructorArgs[0] = lastContext; } } catch (NoSuchMethodException e) { throw ie; } catch (ClassCastException e) { throw ie; } catch (ClassNotFoundException e) { throw e; } catch (Exception e) { throw ie; } finally { }}``` * 先从缓存中寻找构造函数，如果存在直接使用* 如果没有找到根据完整的类的路径名利用反射机制构建 View 对象到了这里关于 APK 的布局 XML 资源文件的查找和解析 -&gt; View 的生成流程到这里就结束了## 总结那我们就来依次来回答上面提出的几个问题**LayoutInflater 的 inflate 的三个参数都代表什么意思？*** resource：要解析的 XML 布局文件 ID* root：表示根布局* attachToRoot：是否要添加到父布局 root 中resource 其实很好理解就是资源 ID，而 root 和 attachToRoot 分别代表什么意思：* 当 attachToRoot == true 且 root ！= null 时，新解析出来的 View 会被 add 到 root 中去，然后将 root 作为结果返回* 当 attachToRoot == false 且 root ！= null 时，新解析的 View 会直接作为结果返回，而且 root 会为新解析的 View 生成 LayoutParams 并设置到该 View 中去* 当 attachToRoot == false 且 root == null 时，新解析的 View 会直接作为结果返回**系统对 merge、include 是如何处理的*** 使用 merge 标签必须有父布局，且依赖于父布局加载* merge 并不是一个 ViewGroup，也不是一个 View，它相当于声明了一些视图，等待被添加，解析过程中遇到 merge 标签会将 merge 标签下面的所有子 view 添加到根布局中* merge 标签在 XML 中必须是根元素* 相反的 include 不能作为根元素，需要放在一个 ViewGroup 中* 使用 include 标签必须指定有效的 layout 属性* 使用 include 标签不写宽高是没有关系的，会去解析被 include 的 layout**merge 标签为什么可以起到优化布局的效果？**解析过程中遇到 merge 标签，会调用 rInflate 方法，部分代码如下 // 根据元素名解析，生成对应的Viewfinal View view = createViewFromTag(parent, name, context, attrs);final ViewGroup viewGroup = (ViewGroup) parent;final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子ViewrInflateChildren(parser, view, attrs, true);// 添加解析的ViewviewGroup.addView(view, params); 解析 merge 标签下面的所有子 View，然后添加到根布局中**View 是如何被实例化的？**View 分为系统 View 和自定义 View, 通过调用 onCreateView 与createView 方法进行不同的处理* onCreateView 方法：会给内置的 View 前面加一个前缀，例如：android.widget，最终会调用 createView 方法* createView 方法：根据完整的类的路径名利用反射机制构建 View 对象**为什么复杂布局会产生卡顿？在 Android 10 上做了那些优化？*** XmlResourseParser 对 XML 的遍历，随着布局越复杂，层级嵌套越多，所花费的时间也越长* 调用 onCreateView 与 createView 方法是通过反射创建 View 对象导致的耗时* 在 Android 10上，新增 tryInflatePrecompiled 方法是为了减少 XmlPullParser 解析 XML 的时间，但是用一个全局变量 mUseCompiledView 来控制是否启用 tryInflatePrecompiled 方法，根据源码分析，mUseCompiledView 始终为 false，所以 tryInflatePrecompiled 方法目前在 release 版本中不可使用**BlinkLayout 是什么？**BlinkLayout 继承 FrameLayout，是一种会闪烁的布局，被包裹的内容会一直闪烁，根据源码注释 Let's party like it's 1995!，BlinkLayout 是为了庆祝 1995 年的复活节, 有兴趣可以看看 [reddit](https://www.reddit.com/r/androiddev/comments/3sekn8/lets_party_like_its_1995_from_the_layoutinflater/) 上的讨论，来查看一下它的源码是如何实现的&lt;br/&gt; private static class BlinkLayout extends FrameLayout { private static final int MESSAGE_BLINK = 0x42; private static final int BLINK_DELAY = 500; private boolean mBlink; private boolean mBlinkState; private final Handler mHandler; public BlinkLayout(Context context, AttributeSet attrs) { super(context, attrs); mHandler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { if (msg.what == MESSAGE_BLINK) { if (mBlink) { mBlinkState = !mBlinkState; // 每隔500ms循环调用 makeBlink(); } // 触发dispatchDraw invalidate(); return true; } return false; } }); } private void makeBlink() { // 发送延迟消息 Message message = mHandler.obtainMessage(MESSAGE_BLINK); mHandler.sendMessageDelayed(message, BLINK_DELAY); } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); mBlink = true; mBlinkState = true; makeBlink(); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); mBlink = false; mBlinkState = true; // 移除消息，避免内存泄露 mHandler.removeMessages(MESSAGE_BLINK); } @Override protected void dispatchDraw(Canvas canvas) { if (mBlinkState) { super.dispatchDraw(canvas); } }} 通过源码分析可以看出，BlinkLayout 通过 Handler 每隔 500ms 发送消息，在 handleMessage 中循环调用 invalidate 方法，通过调用 invalidate 方法，来触发 dispatchDraw 方法，做到一闪一闪的效果 ## 参考 * [https://www.reddit.com/r/androiddev/comments/3sekn8/lets_party_like_its_1995_from_the_layoutinflater/](https://www.reddit.com/r/androiddev/comments/3sekn8/lets_party_like_its_1995_from_the_layoutinflater/) * [https://github.com/RTFSC-Android/RTFSC/blob/master/LayoutInflater.md](https://github.com/RTFSC-Android/RTFSC/blob/master/LayoutInflater.md) * [https://www.yuque.com/beesx/beesandroid/gd7w9o](https://www.yuque.com/beesx/beesandroid/gd7w9o) ## 结语 致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你同我一样喜欢研究 Android 源码，可以关注我，如果你喜欢这篇文章欢迎 star，一起来学习，期待与你一起成长 ### 算法 由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 * 数据结构： 数组、栈、队列、字符串、链表、树…… * 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：[Leetcode-Solutions-with-Java-And-Kotlin](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin)，一起来学习，期待与你一起成长 ### Android 10 源码系列 正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 [Android10-Source-Analysis](https://github.com/hi-dhl/Android10-Source-Analysis)，文章都会同步到这个仓库","link":"/2020/06/07/android10/resource-manager/03-APK-resource/"},{"title":"0xA02 Android 10 源码分析：APK 的安装流程","text":"前言 这是 Android 10 源码分析系列的第 2 篇 分支：android-10.0.0_r14 全文阅读大概 10 分钟 上一篇文章介绍了 0xA01 Android 10 源码分析：APK 是如何生成的，这篇文章接着介绍如何安装 APK，需要说一下 Android 10 及更高版本中, 安装器 PackageInstaller 源码位置有所变动 PackageInstaller 源码所在位置PackageInstaller 是系统内置的应用程序，用于安装和卸载应用 在 Android 9 及更低版本中，软件包安装和权限控制功能包含在 PackageInstaller 软件包 (//packages/apps/PackageInstaller) 中。在 Android 10 及更高版本中，权限控制功能位于单独的软件包 PermissionController (//packages/apps/PermissionController)，这两个软件包在 Android 10 中的位置如下图所示，更多信息点击这里前往 Android 权限 Android 9 及更低版本中 ： 软件包安装和权限控制功能源码路径：packages/apps/PackageInstaller Android 10 及更高版本： 权限控制功能 PermissionController 源码路径：packages/apps/PermissionController/ 安装器 PackageInstaller 源码路径：frameworks/base/packages/PackageInstaller/ 在 Android 系统不同的目录存放不同类型的应用 /system/framwork：保存的是资源型的应用程序，它们用来打包资源文件 /system/app：保存系统自带的应用程序 /data/app：保存用户安装的应用程序 /data/data：应用数据目录 /data/app-private：保存受DRM保护的私有应用程序 /vendor/app：保存设备厂商提供的应用程序 查看 PackageInstaller 源码方式 AOSP-PackageInstaller: 包含了安装器 PackageInstaller(7.1.2、8.1.0、9.0.0、10.0.0) 的源码，可以切换分之查看，跟随 Android 版本更新，你永远可以看到最新的源代码 aospxref：这是一个在线查看 Android 源码网站，服务器在阿里云访问速度很快，文末有关这个网站的介绍 googlesource-PackageInstaller：这是安装器 PackageInstaller 在 googlesource 上的地址 1. APK 的安装方式安装 APK 主要分为以下三种场景 安装系统应用：系统启动后调用 PackageManagerService.main() 初始化注册解析安装工作 public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { // Self-check for initial settings. PackageManagerServiceCompilerMapping.checkProperties(); PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); m.enableSystemUserPackages(); ServiceManager.addService(&quot;package&quot;, m); final PackageManagerNative pmn = m.new PackageManagerNative(); ServiceManager.addService(&quot;package_native&quot;, pmn); return m;} 通过 adb 安装：通过 pm 参数，调用 PM 的 runInstall 方法，进入 PackageManagerService 安装安装工作 通过系统安装器 PackageInstaller 进行安装：先调用 InstallStart 进行权限检查之后启动 PackageInstallActivity，调用 PackageInstallActivity 的 startInstall 方法，点击 OK 按钮后进入 PackageManagerService 完成拷贝解析安装工作 所有安装方式大致相同，最终就是回到 PackageManagerService 中，安装一个 APK 的大致流程如下： 拷贝到 APK 文件到指定目录 解压缩 APK，拷贝文件，创建应用的数据目录 解析 APK 的 AndroidManifest.xml 文件 向 Launcher 应用申请添加创建快捷方式 本文主要来分析通过安装器 PackageInstaller 安装 APK，这是用户最常用的一种方式 2. PackageInstaller 的入口下面代码一定不会很陌生，这就是我们常用的安装 APK 的代码（PS: 关于静默安装我会后续分享在逆向开发相关的文章） Intent intent = new Intent(Intent.ACTION_VIEW);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);/** 自Android N开始，是通过FileProvider共享相关文件，但是Android Q对公* 有目录 File API进行了限制，只能通过Uri来操作*/if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q){ // filePath是通过ContentResolver得到的 intent.setDataAndType(Uri.parse(filePath) ,&quot;application/vnd.android.package-archive&quot;); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);}else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(mContext, &quot;com.dhl.file.fileProvider&quot;, file); intent.setDataAndType(contentUri, &quot;application/vnd.android.package-archive&quot;);} else { intent.setDataAndType(Uri.fromFile(file), &quot;application/vnd.android.package-archive&quot;);}startActivity(intent);// 需要在AndroidManifest添加权限&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt; 通过 intent.setDataAndType 方法指定 Intent 的数据类型为 application/vnd.android.package-archive，隐式匹配的 Activity 为 InstallStart：frameworks/base/packages/PackageInstaller/AndroidManifest.xml &lt;activity android:name=&quot;.InstallStart&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot; android:exported=&quot;true&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;content&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;data android:scheme=&quot;content&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_INSTALL&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 本文分析的是 10.0 的源码，在 8.0、9.0、10.0 等等版本中隐式匹配的 Activity 是 InstallStart，7.0 隐式匹配的 Activity 是 PackageInstallerActivity 安装器 PackageInstaller 的入口 Activity 是 InstallStart，定义了两个 scheme：content 和 package 3. APK 的安装流程通过上面方式找到了入口 Activity，下面我们来查看一下 APK 是如何安装的 3.1 InstallStart主要工作： 判断是否勾选“未知来源”选项，若未勾选跳转到设置安装未知来源界面 对于大于等于 Android 8.0 版本，会先检查是否申请安装权限，若没有则中断安装 判断 Uri 的 Scheme 协议，若是 content 则调用 InstallStaging, 若是 package 则调用 PackageInstallerActivity 当我们调用上面安装代码来安装 APK 时。会跳转到 InstallStart, 并调用它的 onCreate 方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallStart.java @Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ... final boolean isSessionInstall = PackageInstaller.ACTION_CONFIRM_INSTALL.equals(intent.getAction()); ... final ApplicationInfo sourceInfo = getSourceInfo(callingPackage); final int originatingUid = getOriginatingUid(sourceInfo); boolean isTrustedSource = false; // 判断是否勾选“未知来源”选项 if (sourceInfo != null &amp;&amp; (sourceInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) { isTrustedSource = intent.getBooleanExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, false); } if (!isTrustedSource &amp;&amp; originatingUid != PackageInstaller.SessionParams.UID_UNKNOWN) { final int targetSdkVersion = getMaxTargetSdkVersionForUid(this, originatingUid); // 如果targetSdkVerison小于0中止安装 if (targetSdkVersion &lt; 0) { Log.w(LOG_TAG, &quot;Cannot get target sdk version for uid &quot; + originatingUid); mAbortInstall = true; // 如果targetSdkVersion大于等于26（8.0）, 且获取不到REQUEST_INSTALL_PACKAGES权限中止安装 } else if (targetSdkVersion &gt;= Build.VERSION_CODES.O &amp;&amp; !declaresAppOpPermission( originatingUid, Manifest.permission.REQUEST_INSTALL_PACKAGES)) { Log.e(LOG_TAG, &quot;Requesting uid &quot; + originatingUid + &quot; needs to declare permission &quot; + Manifest.permission.REQUEST_INSTALL_PACKAGES); mAbortInstall = true; } } ... // 如果设置了ACTION_CONFIRM_PERMISSIONS，则调用PackageInstallerActivity。 if (isSessionInstall) { nextActivity.setClass(this, PackageInstallerActivity.class); } else { Uri packageUri = intent.getData(); // 判断Uri的Scheme协议是否是content if (packageUri != null &amp;&amp; packageUri.getScheme().equals( ContentResolver.SCHEME_CONTENT)) { // [IMPORTANT] This path is deprecated, but should still work. // 这个路径已经被起用了，但是仍然可以工作 // 调用InstallStaging来拷贝file/content，防止被修改 nextActivity.setClass(this, InstallStaging.class); } else if (packageUri != null &amp;&amp; packageUri.getScheme().equals( PackageInstallerActivity.SCHEME_PACKAGE)) { // 如果Uri中包含package，则调用PackageInstallerActivity nextActivity.setClass(this, PackageInstallerActivity.class); } else { // Uri不合法 Intent result = new Intent(); result.putExtra(Intent.EXTRA_INSTALL_RESULT, PackageManager.INSTALL_FAILED_INVALID_URI); setResult(RESULT_FIRST_USER, result); nextActivity = null; } } if (nextActivity != null) { startActivity(nextActivity); } finish();} 根据 Uri 的 Scheme 协议，若是 content 则调用 InstallStaging，查看 InstallStaging 的 onResume方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallStaging.java @Overrideprotected void onResume() { super.onResume(); if (mStagingTask == null) { if (mStagedFile == null) { // 创建临时文件 mStagedFile 用来存储数据 try { mStagedFile = TemporaryFileManager.getStagedFile(this); } catch (IOException e) { showError(); return; } } // 启动 StagingAsyncTask，并传入了content协议的Uri mStagingTask = new StagingAsyncTask(); mStagingTask.execute(getIntent().getData()); }} 创建临时文件 mStagedFile 用来存储数据 启动 StagingAsyncTask，并传入了 content 协议的 Uri private final class StagingAsyncTask extends AsyncTask&lt;Uri, Void, Boolean&gt; { @Override protected Boolean doInBackground(Uri... params) { ... Uri packageUri = params[0]; try (InputStream in = getContentResolver().openInputStream(packageUri)) { ... // 将packageUri（content协议的Uri）的内容写入到mStagedFile中 try (OutputStream out = new FileOutputStream(mStagedFile)) { byte[] buffer = new byte[1024 * 1024]; int bytesRead; while ((bytesRead = in.read(buffer)) &gt;= 0) { // Be nice and respond to a cancellation if (isCancelled()) { return false; } out.write(buffer, 0, bytesRead); } } } catch (IOException | SecurityException | IllegalStateException e) { Log.w(LOG_TAG, &quot;Error staging apk from content URI&quot;, e); return false; } return true; } @Override protected void onPostExecute(Boolean success) { if (success) { // 如果写入成功，调用DeleteStagedFileOnResult Intent installIntent = new Intent(getIntent()); installIntent.setClass(InstallStaging.this, DeleteStagedFileOnResult.class); installIntent.setData(Uri.fromFile(mStagedFile)); ... startActivity(installIntent); InstallStaging.this.finish(); } else { showError(); } }} doInBackground 方法中将 packageUri（content 协议的 Uri）的内容写入到 mStagedFile 中 如果写入成功，调用 DeleteStagedFileOnResult 的 OnCreate 方法： frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/DeleteStagedFileOnResult.java protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (savedInstanceState == null) { // 启动PackageInstallerActivity Intent installIntent = new Intent(getIntent()); installIntent.setClass(this, PackageInstallerActivity.class); installIntent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION); startActivityForResult(installIntent, 0); }} 经过分析 InstallStaging 主要起了中转作用，将 content 协议的 Uri 转换为 File 协议，最后跳转到 PackageInstallerActivity 3.2 PackageInstallerActivity主要工作： 显示安装界面 初始化安装需要用的各种对象，比如 PackageManager、IPackageManager、AppOpsManager、UserManager、PackageInstaller 等等 根据传递过来的 Scheme 协议做不同的处理 检查是否允许、初始化安装 在准备安装的之前，检查应用列表判断该应用是否已安装，若已安装则提示该应用已安装，由用户决定是否替换 在安装界面，提取出 APK 中权限信息并展示出来 点击 OK 按钮确认安装后，会调用 startInstall 开始安装工作 PackageInstallerActivity 才是应用安装器 PackageInstaller 真正的入口 Activity，查看它的 onCreate 方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java protected void onCreate(Bundle icicle) { getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS); super.onCreate(null); // 初始化安装需要用到的对象 mPm = getPackageManager(); mIpm = AppGlobals.getPackageManager(); mAppOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); // 根据Uri的Scheme做不同的处理 boolean wasSetUp = processPackageUri(packageUri); if (!wasSetUp) { return; } // 显示安装界面 bindUi(); // 检查是否允许安装包，如果允许则启动安装。如果不允许显示适当的对话框 checkIfAllowedAndInitiateInstall();} 主要做了对象的初始化，解析 Uri 的 Scheme，初始化界面，安装包检查等等工作，接着查看一下 processPackageUri 方法 private boolean processPackageUri(final Uri packageUri) { mPackageURI = packageUri; final String scheme = packageUri.getScheme(); // 根据这个Scheme协议分别对package协议和file协议进行处理 switch (scheme) { case SCHEME_PACKAGE: { try { // 通过PackageManager对象获取指定包名的包信息 mPkgInfo = mPm.getPackageInfo(packageUri.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.MATCH_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + packageUri.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); return false; } mAppSnippet = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } break; case ContentResolver.SCHEME_FILE: { // 根据packageUri创建一个新的File File sourceFile = new File(packageUri.getPath()); // 解析APK得到APK的信息，PackageParser.Package存储了APK的所有信息 PackageParser.Package parsed = PackageUtil.getPackageInfo(this, sourceFile); if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); return false; } // 根据PackageParser.Package得到的APK信息，生成PackageInfo mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mAppSnippet = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } break; default: { throw new IllegalArgumentException(&quot;Unexpected URI scheme &quot; + packageUri); } } return true;} 主要对 Scheme 协议分别对 package 协议和 file 协议进行处理 SCHEME_PACKAGE： 在 package 协议中调用了 PackageManager.getPackageInfo 方法生成 PackageInfo，PackageInfo 是跨进程传递的包数据（activities、receivers、services、providers、permissions等等）包含 APK 的所有信息 SCHEME_FILE： 在 file 协议的处理中调用了 PackageUtil.getPackageInfo 方法，方法内部调用了 PackageParser.parsePackage() 把 APK 文件的 manifest 和签名信息都解析完成并保存在了 Package，Package 包含了该 APK 的所有信息 调用 PackageParser.generatePackageInfo 生成 PackageInfo 接着往下走，都解析完成之后，回到 onCreate 方法，继续调用 checkIfAllowedAndInitiateInstall 方法 private void checkIfAllowedAndInitiateInstall() { // 首先检查安装应用程序的用户限制，如果有限制并弹出弹出提示Dialog或者跳转到设置界面 final int installAppsRestrictionSource = mUserManager.getUserRestrictionSource( UserManager.DISALLOW_INSTALL_APPS, Process.myUserHandle()); if ((installAppsRestrictionSource &amp; UserManager.RESTRICTION_SOURCE_SYSTEM) != 0) { showDialogInner(DLG_INSTALL_APPS_RESTRICTED_FOR_USER); return; } else if (installAppsRestrictionSource != UserManager.RESTRICTION_NOT_SET) { startActivity(new Intent(Settings.ACTION_SHOW_ADMIN_SUPPORT_DETAILS)); finish(); return; } // 判断如果允许安装未知来源或者根据Intent判断得出该APK不是未知来源 if (mAllowUnknownSources || !isInstallRequestFromUnknownSource(getIntent())) { initiateInstall(); } else { // 检查未知安装源限制,如果有限制弹出Dialog,显示相应的信息 final int unknownSourcesRestrictionSource = mUserManager.getUserRestrictionSource( UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, Process.myUserHandle()); final int unknownSourcesGlobalRestrictionSource = mUserManager.getUserRestrictionSource( UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, Process.myUserHandle()); final int systemRestriction = UserManager.RESTRICTION_SOURCE_SYSTEM &amp; (unknownSourcesRestrictionSource | unknownSourcesGlobalRestrictionSource); if (systemRestriction != 0) { showDialogInner(DLG_UNKNOWN_SOURCES_RESTRICTED_FOR_USER); } else if (unknownSourcesRestrictionSource != UserManager.RESTRICTION_NOT_SET) { startAdminSupportDetailsActivity(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES); } else if (unknownSourcesGlobalRestrictionSource != UserManager.RESTRICTION_NOT_SET) { startAdminSupportDetailsActivity( UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY); } else { // 处理未知来源的APK handleUnknownSources(); } }} 主要检查安装应用程序的用户限制，当 APK 文件不对或者安装有限制则调用 showDialogInner 方法，弹出 dialog 提示用户，显示相应的错误信息，来看一下都有那些错误信息 // Dialog identifiers used in showDialogprivate static final int DLG_BASE = 0;// package信息错误private static final int DLG_PACKAGE_ERROR = DLG_BASE + 2;// 存储空间不够private static final int DLG_OUT_OF_SPACE = DLG_BASE + 3;// 安装错误private static final int DLG_INSTALL_ERROR = DLG_BASE + 4;// 用户限制的未知来源private static final int DLG_UNKNOWN_SOURCES_RESTRICTED_FOR_USER = DLG_BASE + 5;private static final int DLG_ANONYMOUS_SOURCE = DLG_BASE + 6;// 在wear上不支持private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7;private static final int DLG_EXTERNAL_SOURCE_BLOCKED = DLG_BASE + 8;// 安装限制用户使用的应用程序private static final int DLG_INSTALL_APPS_RESTRICTED_FOR_USER = DLG_BASE + 9; 如果用户允许安装未知来源，会调用 initiateInstall 方法 private void initiateInstall() { String pkgName = mPkgInfo.packageName; // 检查设备上是否存在相同包名的APK String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] { pkgName }); if (oldName != null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] != null) { pkgName = oldName[0]; mPkgInfo.packageName = pkgName; mPkgInfo.applicationInfo.packageName = pkgName; } // 检查package是否已安装, 如果已经安装则显示对话框提示用户是否替换。 try { mAppInfo = mPm.getApplicationInfo(pkgName, PackageManager.MATCH_UNINSTALLED_PACKAGES); if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) == 0) { mAppInfo = null; } } catch (NameNotFoundException e) { mAppInfo = null; } // 初始化确认安装界面 startInstallConfirm();} 根据包名获取应用程序的信息，调用 startInstallConfirm 方法初始化安装确认界面后，当用户点击确认按钮之后发生了什么，接着查看确认按钮点击事件 private void bindUi() { ... // 点击确认按钮，安装APK mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install), (ignored, ignored2) -&gt; { if (mOk.isEnabled()) { if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, true); finish(); } else { // 启动Activity来完成应用的安装 startInstall(); } } }, null); // 点击取消按钮，取消此次安装 mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel), (ignored, ignored2) -&gt; { // Cancel and finish setResult(RESULT_CANCELED); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, false); } finish(); }, null); setupAlert(); mOk = mAlert.getButton(DialogInterface.BUTTON_POSITIVE); mOk.setEnabled(false);} 当用户点击确认按钮调用了 startInstall 方法，启动子 Activity 完成 APK 的安装 private void startInstall() { // 启动子Activity来完成应用的安 Intent newIntent = new Intent(); newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mPkgInfo.applicationInfo); newIntent.setData(mPackageURI); newIntent.setClass(this, InstallInstalling.class); ... if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI); startActivity(newIntent); finish();} startInstall 方法用来跳转到 InstallInstalling，并关闭掉当前的 PackageInstallerActivity 3.3 InstallInstalling主要工作： 向包管理器发送包的信息，然后等待包管理器处理结果 注册一个观察者 InstallEventReceiver，并接受安装成功和失败的回调 在方法 onResume 中创建同步栈，打开安装 session，设置安装进度条 InstallInstalling 首先向包管理器发送包的信息，然后等待包管理器处理结果，并在方法 InstallSuccess 和方法 InstallFailed 进行成功和失败的处理，查看 InstallInstalling 的 onCreate 方法：frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/InstallInstalling.java protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ... // 判断安装的应用是否已经存在 if (&quot;package&quot;.equals(mPackageURI.getScheme())) { try { getPackageManager().installExistingPackage(appInfo.packageName); launchSuccess(); } catch (PackageManager.NameNotFoundException e) { launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); } } else { final File sourceFile = new File(mPackageURI.getPath()); PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, appInfo, sourceFile); ... if (savedInstanceState != null) { // 如果savedInstanceState 不为空，获取已经存在mSessionId 和mInstallId 重新注册 mSessionId = savedInstanceState.getInt(SESSION_ID); mInstallId = savedInstanceState.getInt(INSTALL_ID); try { // 根据mInstallId向InstallEventReceiver注册一个观察者，launchFinishBasedOnResult会接收到安装事件的回调 InstallEventReceiver.addObserver(this, mInstallId, this::launchFinishBasedOnResult); } catch (EventResultPersister.OutOfIdsException e) { } } else { // 如果为空创建SessionParams，代表安装会话的参数 // 解析APK, 并将解析的参数赋值给SessionParams PackageInstaller.SessionParams params = new PackageInstaller.SessionParams( PackageInstaller.SessionParams.MODE_FULL_INSTALL); ... try { // 注册InstallEventReceiver，并在launchFinishBasedOnResult会接收到安装事件的回调 mInstallId = InstallEventReceiver .addObserver(this, EventResultPersister.GENERATE_NEW_ID, this::launchFinishBasedOnResult); } catch (EventResultPersister.OutOfIdsException e) { launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); } try { // createSession 内部通过IPackageInstaller与PackageInstallerService进行进程间通信， // 最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId mSessionId = getPackageManager().getPackageInstaller().createSession(params); } catch (IOException e) { launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); } } ... }} 最终都会注册一个观察者 InstallEventReceiver，并在 launchFinishBasedOnResult 会接收到安装事件的回调，其中 InstallEventReceiver 继承自 BroadcastReceiver，用于接收安装事件并回调给 EventResultPersister createSession 内部通过 IPackageInstaller 与 PackageInstallerService 进行进程间通信，最终调用的是 PackageInstallerService的createSession 方法来创建并返回 mSessionId 接下来在 onResume 方法创建 InstallingAsyncTask 用来执行 APK 的安装，接着查看 onResume 方法 protected void onResume() { super.onResume(); if (mInstallingTask == null) { PackageInstaller installer = getPackageManager().getPackageInstaller(); // 根据mSessionId 获取SessionInfo, 代表安装会话的详细信息 PackageInstaller.SessionInfo sessionInfo = installer.getSessionInfo(mSessionId); if (sessionInfo != null &amp;&amp; !sessionInfo.isActive()) { mInstallingTask = new InstallingAsyncTask(); mInstallingTask.execute(); } else { // 安装完成后会收到广播 mCancelButton.setEnabled(false); setFinishOnTouchOutside(false); } }} 得到 SessionInfo 创建并创建 InstallingAsyncTask，InstallingAsyncTask 的 doInBackground 方法设置安装进度条，并将 APK 信息写入 PackageInstaller.Session，写入完成之后，在 InstallingAsyncTask 的 onPostExecute 进行成功与失败的处理，接着查看 onPostExecute 方法 protected void onPostExecute(PackageInstaller.Session session) { if (session != null) { Intent broadcastIntent = new Intent(BROADCAST_ACTION); broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND); broadcastIntent.setPackage(getPackageName()); broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId); PendingIntent pendingIntent = PendingIntent.getBroadcast( InstallInstalling.this, mInstallId, broadcastIntent, PendingIntent.FLAG_UPDATE_CURRENT); session.commit(pendingIntent.getIntentSender()); mCancelButton.setEnabled(false); setFinishOnTouchOutside(false); } else { getPackageManager().getPackageInstaller().abandonSession(mSessionId); if (!isCancelled()) { launchFailure(PackageManager.INSTALL_FAILED_INVALID_APK, null); } }} 创建了 broadcastIntent，并通过 PackageInstaller.Session 的 commit 方法发送出去，通过 broadcastIntent 构造方法指定的 Intent 的 Action 为 BROADCAST_ACTION，而 BROADCAST_ACTION 是一个常量值 private static final String BROADCAST_ACTION = &quot;com.android.packageinstaller.ACTION_INSTALL_COMMIT&quot;; 回到 InstallInstalling.OnCreate 方法，在 OnCreate 方法注册 InstallEventReceiver，而 InstallEventReceiver 继承自 BroadcastReceiver，而使用 BroadcastReceiver 需要在 AndroidManifest.xml注册，接着查看 AndroidManifest.xml：/frameworks/base/packages/PackageInstaller/AndroidManifest.xml &lt;receiver android:name=&quot;.InstallEventReceiver&quot; android:permission=&quot;android.permission.INSTALL_PACKAGES&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;com.android.packageinstaller.ACTION_INSTALL_COMMIT&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 安装结束之后，会在观察者 InstallEventReceiver 注册的回调方法 launchFinishBasedOnResult 处理安装事件的结果，接着查看 launchFinishBasedOnResult private void launchFinishBasedOnResult(int statusCode, int legacyStatus, String statusMessage) { if (statusCode == PackageInstaller.STATUS_SUCCESS) { launchSuccess(); } else { launchFailure(legacyStatus, statusMessage); }}private void launchSuccess() { Intent successIntent = new Intent(getIntent()); successIntent.setClass(this, InstallSuccess.class); successIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); startActivity(successIntent); finish();} private void launchFailure(int legacyStatus, String statusMessage) { Intent failureIntent = new Intent(getIntent()); failureIntent.setClass(this, InstallFailed.class); failureIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); failureIntent.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, legacyStatus); failureIntent.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, statusMessage); startActivity(failureIntent); finish();} 安装成功和失败，都会启动一个新的 Activity（InstallSuccess、InstallFailed）将结果展示给用户，然后 finish 掉 InstallInstalling 4. 总结总结一下 PackageInstaller 安装APK的过程： 根据根据 Uri 的 Scheme 找到入口 InstallStart InstallStart 根据 Uri 的 Scheme 协议不同做不同的处理 都会调用 PackageInstallerActivity, 然后分别对package协议和 file 协议的 Uri 进行处理 PackageInstallerActivity 检查未知安装源限制,如果安装源限制弹出提示 Dialog 点击 OK 按钮确认安装后，会调用 startInstall 开始安装工作 如果用户允许安装，然后跳转到 InstallInstalling，进行 APK 的安装工作 在 InstallInstalling 中，向包管理器发送包的信息，然后注册一个观察者 InstallEventReceiver，并接受安装成功和失败的回调 5. 关于 packages.xml在 Andorid 系统目录 “/data/system” 下保存很多系统文件，主要介绍 packages.xml 文件 packages.xml：记录了系统中所有安装的应用信息，包括基本信息、签名和权限、APK 文件的路径、native 库的存储路径 系统启动的时候会通过 PackageManagerServcie 读取这个文件加载系统中所有安装的应用，这个文件在开发中也是非常有帮助的，不同厂商会对 Android 源码有不同的修改，如果我们需要分析系统 App 的源码，就通过这个 packages.xml 找到目标 APK，dump 出来分析源码 以下是 packages.xml 文件部分内容 &lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;packages&gt; &lt;version sdkVersion=&quot;27&quot; databaseVersion=&quot;3&quot; fingerprint=&quot;Meizu/meizu_M1822_CN/M1822:8.1.0/OPM1.171019.026/1539943691:user/release-keys&quot; /&gt; &lt;version volumeUuid=&quot;primary_physical&quot; sdkVersion=&quot;27&quot; databaseVersion=&quot;27&quot; fingerprint=&quot;Meizu/meizu_M1822_CN/M1822:8.1.0/OPM1.171019.026/1539943691:user/release-keys&quot; /&gt; &lt;meizu_version meizu_fingerprint=&quot;8.1.0-1541573178_stable&quot; /&gt; &lt;permission-trees /&gt; &lt;permissions&gt; &lt;item name=&quot;com.meizu.voiceassistant.push.permission.MESSAGE&quot; package=&quot;com.meizu.voiceassistant&quot; protection=&quot;2&quot; /&gt; &lt;item name=&quot;com.meizu.safe.alphame.permission.DATA&quot; package=&quot;com.meizu.safe&quot; protection=&quot;18&quot; /&gt; &lt;item name=&quot;android.permission.REAL_GET_TASKS&quot; package=&quot;android&quot; protection=&quot;18&quot; /&gt; ...... &lt;item name=&quot;android.permission.MODIFY_PHONE_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.WAKE_LOCK&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;1&quot; /&gt; &lt;/package&gt; &lt;package name=&quot;com.android.providers.telephony&quot; codePath=&quot;/system/priv-app/TelephonyProvider&quot; nativeLibraryPath=&quot;/system/priv-app/TelephonyProvider/lib&quot; primaryCpuAbi=&quot;arm64-v8a&quot; publicFlags=&quot;1007402501&quot; privateFlags=&quot;8&quot; ft=&quot;11e8dc5d800&quot; it=&quot;11e8dc5d800&quot; ut=&quot;11e8dc5d800&quot; version=&quot;27&quot; sharedUserId=&quot;1001&quot; isOrphaned=&quot;true&quot; forceFull=&quot;true&quot;&gt; &lt;sigs count=&quot;1&quot;&gt; &lt;cert index=&quot;0&quot; /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=&quot;android.permission.SEND_RECEIVE_STK_INTENT&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.BIND_INCALL_SERVICE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; ...... &lt;item name=&quot;android.permission.UPDATE_APP_OPS_STATS&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;1&quot; /&gt; &lt;/package&gt; 5.1. package 表示包信息 name 表示应用的包名 codePath 表示的是 APK 文件的路径 nativeLibraryPath 表示应用的 native 库的存储路径 it 表示应用安装的时间 ut 表示应用最后一次修改的时间 version 表示应用的版本号 userId 表示所属于的 id 5.2. sign 表示应用的签名 count 表示标签中包含有多少个证书 cert 表示具体的证书的值 5.3. perms 表示应用声明使用的权限，每一个子标签代表一项权限6. 安利一个在线查看 Android 源码网站aospxref 是 weishu 大神搭建一个在线查看在线查看 Android源码网站, 访问速度非常快 在这之前我常用的在线查看 Android 源码的网站 androidxref，访问速度不仅慢，而且更新也不及时，现在 Android 10 发布了，这个网站到现在提供的最新的代码还是 Andorid 9 aospxref 提供了与 androidxref 完全一样的源码浏览和交叉索引功能；除此之外，它还有一些别的优点： 跟随 Android 版本更新，你永远可以看到最新的源代码。 服务器在阿里云，国内访问速度贼快。 opengrok 版本较高，查阅代码时会有自动提示。 对页面做过部分优化，使用更便捷；比如可以在任意界面跳转到首页。 参考 Android包管理总结 安利一个看 Android 源代码的网站 Android 权限 Android包管理机制（一）PackageInstaller的初始化 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你同我一样喜欢研究 Android 源码，可以关注我，如果你喜欢这篇文章欢迎 star，一起来学习，期待与你一起成长 算法由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长 Android 10 源码系列正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 Android10-Source-Analysis，文章都会同步到这个仓库","link":"/2020/06/07/android10/package-manager/02-APK-install/"},{"title":"0xA01 Android 10 源码分析：APK 是如何生成的","text":"前言 这是 Android 10 源码分析系列的第 1 篇 分支：android-10.0.0_r14 全文阅读大概 5 分钟 在 Android Studio 中直接点击 Run ‘app’ 就可以在 build/outputs/apk 生成可以在 android 设备中安装的 APK 文件，那么 APK 生成的过程是怎么样的呢？ APK 文件大概可以分为两个部分：代码和资源，所以打包的也分为代码和资源两个部分，我们可以根据 Google提供的流程图 来具体了解一个 APK 的构建过程 新版构建流程图 APK 打包的内容主要有：应用模块也就是自己开发的用到的源代码、资源文件、aidl 接口文件，还有就是依赖模块即源代码用到的第三方依赖库如：aar、jar、so 文件 为了能够清楚的了解 APK 是如何生成的, 来看一下老版构建流程图 老版构建流程图 在了解 APK 生成的过程之前，我们需要了解一下图中各个工具的作用 工具 名字 功能 AAPT/APT2 Android 资源打包工具 AIDL 将所有的 AIDL 接口转化为 Java 接口 Javac(Java Compiler) 将所有的 Java 代码编译成 Class文件 Dex 将 Class 文件编译成 Dex 文件 Apkbuilder 将处理后的资源和代码打包生成 APK 文件 Jarsigner/Apksigner 对未签名的 APK 文件进行签名 Zipalign 优化签名后的 APK，减少运行时所占用的内存 构建过程1. 使用 AAPT 工具生成 R.java 文件AAPT（Android Asset Packaging Tool）android 资源打包工具，将资源文件（包括AndroidManifest.xml、布局文件、各种 xml 资源等）打包生成 R.java 文件，将 AndroidManifest.xml 生成二进制的 AndroidManifest.java 文件 aapt p -M AndroidManifest.xml -S output/res/ -I android.jar -J ./ -F input/out.apkp：打包-M：AndroidManifest.xml 文件路径-S：res 目录路径-A：assets 目录路径-I：android.jar 路径，会用到的一些系统库-J 指定生成的 R.java 的输出目录-F 具体指定 APK 文件的输出 但是从 Android Studio 3.0 开始，google 默认开启了 AAPT2 作为资源编译的编译器，AAPT2 的出现为资源的增量编译提供了支持，aapt2 主要分两步，compile 和 link compile aapt2 compile -o res.apk --dir output/res/-o：指定已编译资源的输出路径--dir：指定包含多个资源文件的资源目录 link aapt2 link -o input/out.apk -I tools/android.jar --manifest output/AndroidManifest.xml -A res.apk --java ./-o：指定链接的资源 APK 的输出路径-I：指定 android.jar 路径--manifest：指定 AndroidManifest.xml 路径--java ：指定要在其中生成 R.java 的目录 2. 所有的 AIDL 接口转化为 Java 接口使用 AIDL（Android Interface Denifition Language），位于 sdk\\build-tools 目录下的 aidl 工具，将源码文件、aidl 文件、framework.aidl 等所有的 AIDL 文件，生成相应的 Java 文件，命令如下： aidl -Iaidl -pAndroid/Sdk/platforms/android-29/framework.aidl -obuild aidl/com/android/vending/billing/IInAppBillingService.aidl-I 指定 import 语句的搜索路径，注意 -I 与目录之间一定不要有空格-p 指定系统类的 import 语句路径，如果是要用到 android.os.Bundle 系统的类，一定要设置 sdk 的 framework.aidl 路径-o 生成 java 文件的目录，注意 -o 与目录之间一定不要有空格，而且这设置项一定要在 aidl 文件路径之前设置 3. 将 Java 代码编译成 Class 文件使用 Javac（Java Compiler）把项目中所有的 Java 代码编译成 class 文件, 包括 Java 源文件、AAPT 生成的 R.java 文件 以及 aidl 生成的 Java 接口文件，命令如下： javac -target 1.8 -bootclasspath platforms/android-28/android.jar -d ./java/com/testjni/*.java 4. 将 Class 文件编译成 Dex 文件使用 DX 工具将所有的 Class 文件（包括第三方库中的 class 文件）转换成 Dex 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），该过程主要完成 Java 字节码转换成 Dalvik 字节码, 命令如下： java -jar dx.jar --dex --ouput=classes.dex ./java/com/testjni/*.class--dex：将 class 文件转成dex文件--output：指定生成 dex 文件到具体位置 5. 打包生成 APK 文件使用 Apkbuilder（主要用到的是 sdk/tools/lib/sdklib.jar 文件中的 ApkBuilderMain 类）将所有的 Dex 文件、Resource.arsc、Res 文件夹、Assets 文件夹、AndroidManifest.xml 打包生成 APK 文件（未签名） 6. 对 APK 文件签名使用 Apksigner（Android官方针对 APK 签名及验证工具）或 Jarsigner（JDK提供针对 jar 包签名工具）对未签名的 APK 文件进行签名 ps：如果使用 Apksigner 签名需要（7. 优化 APK 文件）放到（6. 对 APK 文件签名）签名前面，为什么？请查看关于 Apksigner 和 Jarsigner 的区别，请移步到文末 7. 优化 APK 文件使用 zipalign 对签名后的 APK 文件进行对齐处理，对齐的主要过程是将 APK 包中所有的资源文件距离文件起始偏移为 4 字节整数倍，这样通过内存映射访问 APK 文件时的速度会更快，减少其在设备上运行时所占用的内存 总结上述打包过程都是 AndroidStudio 编译时，调用各种编译命令自动完成的, 总结一下上述打包过程： 除了 assets 和 res/raw 资源被原装不动地打包进 APK 之外，其它的资源都会被编译或者处理 除了 assets 资源之外，其它的资源都会被赋予一个资源 ID 打包工具负责编译和打包资源，编译完成之后，会生成一个 resources.arsc 文件和一个 R.java，前者保存的是一个资源索引表，后者定义了各个资源 ID 常量 应用程序配置文件 AndroidManifest.xml 同样会被编译成二进制的 xml 文件，然后再打包到 APK 里面去 应用程序在运行时通过 AssetManager 来访问资源，或通过资源 ID 来访问，或通过文件名来访问 APK 文件大概可以分为两个部分：代码和资源, 代码部分通过 Javac 将 Java 代码编译成 Class 文件, 然后通过 DX 工具将 Class 文件编译成 Dex 文件，接下来我们主要来分析一下资源的编译和打包 资源的编译和打包在分析资源的编译和打包之前，我们需要了解一下 Android 都有哪些资源，其实 Android 资源大概分为两个部分：assets 和 res 1. assets 资源assets 资源放在 assets 目录下，它里面保存一些原始的文件，可以以任何方式来进行组织，这些文件最终会原封不动的被打包进 APK 文件中，通过 AssetManager 来获取 asset 资源，代码如下 AssetManager assetManager = context.getAssets();InputStream is = assetManager.open(&quot;fileName&quot;); 2. res 资源res 资源放在主工程的 res 目录下，这类资源一般都会在编译阶段生成一个资源ID供我们使用，res 目录包括 animator、anim、 color、drawable、layout、menu、raw、values、xml 等 上述资源文件除了 raw 类型资源，以及 drawable 文件夹下的 Bitmap 资源之外，其它的资源文件均会被编译成二进制格式的 XML 文件，生成的二进制格式的 XML 文件分别有一个字符串资源池，用来保存文件中引用到的每一个字符串 这样原来在文本格式的 XML 文件中的每一个放置字符串的地方在二进制格式的XML文件中都被替换成一个索引到字符串资源池的整数值，将整数值保存在 R.java 类中，R.java 会和其他源文件一起编译到 APK 中去 将资源编译成二进制文件，都是由 AAPT 工具来完成的，资源打包主要有以下几个流程： 解析 AndroidManifest.xml，获得应用程序的包名称，创建资源表 添加被引用资源包，被添加的资源会以一种资源 ID 的方式定义在 R.java 中 资源打包工具创建一个 AaptAssets 对象，收集当前需要编译的资源文件，收集到的资源保存在 AaptAssets 对象对象中 将上一步 AaptAssets 对象保存的资源，添加到资源表 ResourceTable 中去，用于最终生成资源描述文件 resources.arsc 编译 values 类资源，这类资源包括数组、颜色、尺寸、字符串等值 给 style、array 这类资源分配资源 ID 编译 XML 资源文件，编译的流程分为：① 解析 XML 文件 ② 赋予属性名称资源 ID ③ 解析属性值 ④ 将 XML 文件从文本格式转换为二进制格式 生成资源索引表 resources.arsc 2.1 资源 IDAAP 工具会所有的资源都会生成一个 R.java 文件，并且每个资源都对应 R.java 中的十六进制整数变量，其实这些十六进制的整数是由三部分组成：PackageId + TypeId + ItemValue，代码所示： public final class R { public static final class anim { public static final int abc_fade_in=0x7f010000; public static final int abc_fade_in=0x7f010001; //*** } public static final class string { public static final int a11y_no_data=0x7f100000; public static final int a11y_no_permission=0x7f100001; //*** }} 最高字节是 Package ID 表示命名空间，标明资源的来源，Android 系统自己定义了两个 Package ID，系统资源命名空间：0x01 和 应用资源命名空间：0x7f 正因为应用资源命名空间：0x7f，我们在做插件化的时候就会出现一个问题，宿主和插件包，合并资源后资源 ID 冲突。通过上面分析要解决这个问题，就要为不同的插件设置不同的 PackageId，而宿主可以保留原来 0x7f 不变，这样就永远不会有冲突发生了 如何解决资源冲突 制定一个不用冲突的命名规范 library Module 的 build.gradle 中设置资源前缀(推荐) android { resourcePrefix &quot;&lt;前缀&gt;&quot; }2.2 资源索引(resources.arsc)最终生成的是资源索引表 resources.arsc ，resources.arsc 是一个编译后的二进制文件, 在 AndroidStudio 打开 resources.arsc 文件，如下所示 Android 正是利用这个索引表根据资源 ID 进行资源的查找，为不同语言、不同地区、不同设备提供相对应的最佳资源。查找和通过 Resources 和 AssetManger 来完成的 在文中提到了两个工具 Apksigner 和 Jarsigner，下面一起来了解一下 Apksigner 和 Jarsigner 的区别 Apksigner 和 Jarsigner 的区别在 Android Studio 中点击菜单 Build-&gt;Generate signed apk… 打包签名过程中,可以看到两种签名选项 V1(Jar Signature) 和 V2(Full APK Signature) Jarsigner 是 JDK 提供的针对 JAR 包签名的通用工具 Apksigner 是 Google 官方提供的针对 Android APK 签名及验证的专用工具 从Android 7.0 开始, 谷歌增加新签名方案 V2 Scheme (APK Signature)，但Android 7.0 以下版本, 只能用旧签名方案 V1 scheme (JAR signing) V1(Jar Signature)签名: 来自 JDK(Jarsigner)，对 ZIP 压缩包的每个文件进行验证, 签名后还能对压缩包修改(移动/重新压缩文件)，对 V1 签名的 APK/JAR 解压,在 META-INF 存放签名文件(MANIFEST.MF, CERT.SF, CERT.RSA), 其中 MANIFEST.MF 文件保存所有文件的 SHA1 指纹(除了 META-INF 文件), 由此可知: V1 签名是对压缩包中单个文件签名验证 V2(Full APK Signature)签名: 来自 Google(apksigner), 对 ZIP 压缩包的整个文件验证, 签名后不能修改压缩包(包括 zipalign), 对 V2 签名的 APK 解压, 没有发现签名文件, 重新压缩后 V2 签名就失效, 由此可知: V2 签名是对整个 APK 签名验证 创建发布密钥库，请参阅在 Android Studio 中为应用签名 总结 V1 签名是对压缩包中单个文件签名验证 V2 签名是对整个 APK 签名验证 zipalign 可以在 V1 签名后执行 zipalign 不能在 V2 签名后执行,只能在 V2 签名之前执行 V2 签名更安全(不能修改压缩包) V2 签名验证时间更短(不需要解压验证), 因而安装速度加快 注意: apksigner 工具默认同时使用 V1 和 V2 签名,以兼容 Android 7.0 以下版本 参考文献 Google的 Apk 构建流程 Android Studio 中为应用签名 AAPT2 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你同我一样喜欢研究 Android 源码，可以关注我，如果你喜欢这篇文章欢迎 star，一起来学习，期待与你一起成长 算法由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长 Android 10 源码系列正在写一系列的 Android 10 源码分析的文章，了解系统源码，不仅有助于分析问题，在面试过程中，对我们也是非常有帮助的，如果你同我一样喜欢研究 Android 源码，可以关注我 GitHub 上的 Android10-Source-Analysis，文章都会同步到这个仓库","link":"/2020/06/07/android10/package-manager/01-APK-generate/"},{"title":"LeetCode 剑指 offer：替换空格","text":"题目来源于 LeetCode 剑指 offer 第 05 号问题：替换空格。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/ 题目描述请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例: 输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制： 0 &lt;= s 的长度 &lt;= 10000 思路声明一个 StringBuffer，遍历字符串，如果遇见空格，添加 %20 到 buffer 中, 否则添加当前字符 复杂度分析： 时间复杂度：O(n)，当一个字符串的长度为 n 时，遍历字符串一遍，时间复杂度为 O(n) 空间复杂度：0(n)，需要创建 StringBuffer 有额外的开销，每次遇见空格，就替换为 %20，最坏的情况下，长度是原来的 3 倍 Kotlin 实现class Solution { fun replaceSpace(s: String): String { val buffer = StringBuffer() var i = 0 val len = s.length while (i &lt; len) { if (s[i] == ' ') { buffer.append(&quot;%20&quot;) } else { buffer.append(s[i]) } i++ } return buffer.toString() }} Java 实现class Solution { public String replaceSpace(String s) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == ' ') { buffer.append(&quot;%20&quot;); } else { buffer.append(s.charAt(i)); } } return buffer.toString(); }} 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译相关的文章，请持续关注 由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长","link":"/2020/05/31/LeetCode/offer/03-space/"},{"title":"LeetCode 剑指 offer：二维数组中的查找","text":"题目来源于 LeetCode 剑指 offer 第 04 号问题：二维数组中的查找。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/ 题目描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000 思路：线性查找由题意得知，每个二维数组都有以下特点： 每一行都按照从左到右递增的顺序排序 每一列都按照从上到下递增的顺序排序 因为都是有序的，所以可以选择将左上角 或者 右上角作为起点，寻找一个和目标数字相等的数，在这里我选择右上角作为起点即 matrix[0][maxColumn] 其中 maxColumn = matrix[0].size - 1 即每一行的最大列数，算法步骤如下 初始化 raw = 0，column = maxColumn 如果 matrix[raw][column] == target，说明存在和目标数字相等的数返回 true 如果 matrix[raw][column] &gt; target, 说明当前元素大于目标值，所以当前元素所在的下面所有元素都大于目标值，因此 column - 1，往左边寻找 如果 matrix[raw][column] &lt; target，说明当前元素小于目标值，所以当前元素所在的左边所有元素都小于目标值，因此 raw + 1，往下面寻找 遍历结束之后，如果没有找到即返回 false 复杂度分析： 时间复杂度：O(n+m)，如果二维数组的有 n 行 m 列，那么在循环过程中行数不会超过 n 行，列数不会超过 m 列，因此在循环结束之后总的次数不会超过 n+m 次 空间复杂度：0(1)，因为没有额外的开销，在内存中一直都是恒定的 Kotlin 实现class Solution { fun findNumberIn2DArray(matrix: Array&lt;IntArray&gt;, target: Int): Boolean { if (matrix == null || matrix.size &lt;= 0 || matrix[0].size &lt;= 0) { return false; } var raw = 0 var column = matrix[0].size - 1; val maxRaw = matrix.size - 1; while (raw &lt;= maxRaw &amp;&amp; column &gt;= 0) { when { matrix[raw][column] == target -&gt; return true matrix[raw][column] &gt; target -&gt; column-- else -&gt; raw++ } } return false }} Java 实现class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length &lt;= 0 || matrix[0].length &lt;= 0) { return false; } int row = 0; int column = matrix[0].length - 1; int maxRow = matrix.length - 1; while (row &lt;= maxRow &amp;&amp; column &gt;= 0) { if (matrix[row][column] == target) { return true; } else if (matrix[row][column] &gt; target) { column--; } else { row++; } } return false; }} 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译相关的文章，请持续关注 由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长","link":"/2020/05/31/LeetCode/offer/02-arrays/"},{"title":"基于 Smali 文件 Android Studio 动态调试 APP","text":"最近在研究动态调试技术，网上关于基于 Smali 动态调试App的教程很多，很多细节都没有贴出来，走了很多弯路，将调研结果分享一下，如果有写的不好地方，欢迎指正 Github：https://github.com/hi-dhl/DebugApkSmali 准备工作 一部 Root 过的 Android 手机，打开开发者模式 Xposed 的运行的环境 安装 smalidea 插件，点击这里下载 安装 BDOpener.apk 或者 XDebug.apk 反编译 Apk(apktool)点击 这里下载 最新的 apktool , 并配置好环境（不同环境配置的方式不同，参考 官网） 下载你需要反编译的 Apk 文件，执行 apktool d 反编译Apk名字.apk 如果反编译出来多个smali文件夹，可以用ant写个脚本，多个文件夹合并成一个 smalideaAndroidStudio 如果要调试smali代码，需要安装第三方插件: smalidea AS中【Android Studio–&gt;Preferences–&gt;Plugins–&gt;Install plugin from desk…】，安装插件 Android Studio 导入 smali 新疆一个 Android 工程项目（ps: 一定要新建Android项目，否则可能会找不到 “Attach debuger to Android Process”）删掉自动创建的资源和代码文件 复制反编译好的 smali 文件, 到新建 Android 项目 java 文件夹下 PS: 也可以使用我配置好的项目 “ApkSampleSmali” , 需要安装提供的 Sample.apk进行测试 Android Studio 动态调试配置新建调试配置，【Run–&gt;Edit Configurations–&gt; + –&gt;Remote】，name 随意，端口 8700 动态调试 在 smali 代码中打入断点，如下图标记1 然后点击 “Attach debuger to Android Process” ，如下图标记2 选择你要调试的进程，手动进入对应功能, 即进入断点动态调试（ps: 如果你想要的进程没有展示出来，请重新勾选 xposed module(BDOpener), 重启手机） 运行环境信息 Xposed Version90-beta3 BDOpener 1.0 AndoridStudio 3.3.2 smalidea 0.0.5 apktool 2.4.0 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你喜欢这篇文章欢迎 Star 一起来学习，期待与你一起成长","link":"/2020/05/30/AndroidStudio/02-smalidea/"},{"title":"解决在 Android Studio 3.2 找不到 Android Device Monitor 工具","text":"升级到 AndroidStudio 最新版本( &gt;3.2 )朋友们都会遇到一个问题，找不到 DDMS [Android Device Monitor], 只能从 SDK 目录下找到 monitor 启动 DDMS [Android Device Monitor]，所以写了一个插件快速启动 Android Device Monitor 源码及使用方式开发工具：IntelliJ IDEA Github地址：https://github.com/hi-dhl/DeviceMonitorPlugin 插件下载地址：https://github.com/hi-dhl/DeviceMonitorPlugin/releases/download/1.0/DeviceMonitorPlugin.jar 安装方式： 打开 AndroidStudio 选择 Preference -&gt; Plugins-&gt; install plugin from disk 选择下载好的插件 [DeviceMonitorPlugin.jar] -&gt; 重启 AndroidStudio 如何启动： 打开 AndroidStudio 菜单栏 tools -&gt; 单击 DeviceMonitor PS: Google 虽然删除了 AdnroidStudio 启动入口，但是本地 SDK 中还是存在，插件通过动态获取本地 SDK 路径启动 AndroidDeviceMonitor, 由于电脑性能不同，启动速度会有不同 Google 为什么弃用 Android Device MonitorAndroid Developers官网上的原文链接 Android Device Monitor 是一个 Android 应用调试和分析工具提供了一个 UI 工具，但是大部分组件在 Android Studio 3.1 已经弃用了, 并且会在 Android Studio 3.2 中移除，将会用新的工具帮助开发人员调试和分析 Android 应用 详情戳这里 插件核心代码public class Monitor extends AnAction { @Override public void actionPerformed(AnActionEvent anActionEvent) { try { Project project = anActionEvent.getData(PlatformDataKeys.PROJECT); String os = AndroidUtils.getPlatformName(); String sdkPath = AndroidUtils.getApkLocalProperties(project); if (os.toLowerCase().startsWith(&quot;win&quot;)) { sdkPath += File.separator + &quot;tools&quot; + File.separator + &quot;monitor.bat&quot;; } else { sdkPath += File.separator + &quot;tools&quot; + File.separator + &quot;monitor&quot;; } Runtime.getRuntime().exec(sdkPath); } catch (Exception e) { } }} /** * 动态获取本地Android SDK的路径 * * @param project * @return */public static String getApkLocalProperties(Project project) { String sdkPath = &quot;&quot;; try { String path = project.getBasePath() + File.separator + &quot;local.properties&quot;; Properties properties = new Properties(); InputStream inputStream = new FileInputStream(path); properties.load(inputStream); sdkPath = properties.getProperty(&quot;sdk.dir&quot;); } catch (Exception e) { } return sdkPath;} Github地址：https://github.com/hi-dhl/DeviceMonitorPlugin 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你喜欢这篇文章欢迎 Star 一起来学习，期待与你一起成长","link":"/2020/05/30/AndroidStudio/01-monitor/"},{"title":"LeetCode剑指offer：数组中重复的数字","text":"题目来源于 LeetCode 剑指 offer 第 03 号问题：数组中重复的数字。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/ 题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1: 输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 思路一：原地置换法题目指出 在一个长度为 n 的数组 nums 里的所有数字都在 [0,n-1] 的范围内，可遍历数组并通过交换操作使元素的 索引 与 值，通过索引找到对应的值，算法流程如下： 当 nums[i] == i 时，即 值 和 索引，一一对应无需交换 当 nums[nums[i]] == nums[i]，即索引 nums[i] 对应的值 和 nums[i] 相等，找到相同的值，返回此值 nums[i] 上面条件都不满足，即交换索引为 i 和 nums[i] 的元素值，将数字交换到对应索引位置 没有找到返回 -1，即代表数组中无相同值 例如数组 [2,0,1] 交换逻辑如下, 当 i = 0 时： temp = num[i], 即 temp = 2 num[i] = num[temp]，即 num[i] = 1 num[temp] = temp, 即 num[temp] = 2 将 即 值 和 索引 一一对应 Java实现public class Solution { public int findRepeatNumber(int[] nums) { int len = nums.length; for (int i = 0; i &lt; len; i++) { if (nums[i] == i) continue; if (nums[nums[i]] == nums[i]) { return nums[i]; } int temp = nums[i]; nums[nums[i]] = nums[temp]; nums[temp] = temp; } return -1; }} Koltin实现class Solution { fun findRepeatNumber(nums: IntArray): Int { for ((index, value) in nums.withIndex()) { if (value == index) continue if (nums[value] == nums[index]) { return nums[index] } val temp = value nums[value] = nums[temp] nums[temp] = temp } return -1 }} 思路二：哈希算法利用 Haset API 的特性，如果添加重复的元素会返回 false Java 实现public class Solution { public int findRepeatNumber2(int[] nums) { int len = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; len; i++) { if (!set.add(nums[i])) { return nums[i]; } } return -1; }} Koltin 实现class Solution { fun findRepeatNumber(nums: IntArray): Int { val set = HashSet&lt;Int&gt;() for ((index, value) in nums.withIndex()) { if (!set.add(value)) { return value; } } return -1 }} 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译相关的文章，请持续关注 由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长","link":"/2020/05/24/LeetCode/offer/01-number/"},{"title":"LeetCode二分查找：寻找比目标字母大的最小字母","text":"题目来源于 LeetCode 上第 744 号（Find Smallest Letter Greater Than Target）问题：寻找比目标字母大的最小字母。题目难度为 Easy。 英文地址：https://leetcode.com/problems/find-smallest-letter-greater-than-target/ 中文地址：https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/ 题目描述Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target. Letters also wrap around. For example, if the target is target = ‘z’ and letters = [‘a’, ‘b’], the answer is ‘a’. Examples: Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;a&quot; Output: &quot;c&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;c&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;d&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;g&quot; Output: &quot;j&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;j&quot; Output: &quot;c&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;k&quot; Output: &quot;c&quot;Note: 1. letters has a length in range [2, 10000]. 2. letters consists of lowercase letters, and contains at least 2 unique letters. 3. target is a lowercase letter. 二分查找从题意分析从有序列表中找比目标字母大的最小字母得知，这题应该使用二分查找，因为二分查找的时间复杂度 O(logn) 但是这题目有个坑，就是题意给的不准确，笔者也提交几次才通过，总结规律如下： 当 target &lt; letters[0] 时，即 letters[0] 是比目标字母大的最小字母，返回 letters[0] 当 target &gt;= letters[height -1], 即返回 letters[0] Java 实现class Solution { public char nextGreatestLetter(char[] letters, char target) { int low = 0; int height = letters.length - 1; if (target &lt; letters[0] || target &gt;= letters[height]) return letters[0]; while (low &lt;= height) { int mind = (low + height) &gt;&gt;&gt; 1; if (letters[mind] &lt;= target) { low = mind + 1; } else { height = mind - 1; } } return letters[low]; }} Koltin 实现class Solution { fun nextGreatestLetter(letters: CharArray, target: Char): Char { var low = 0 var height = letters.size - 1 if (target &lt; letters[0] || target &gt;= letters[height]) { return letters[0] } while (low &lt;= height) { val mid = (low + height) ushr 1 when { letters[mid] &lt;= target -&gt; low = mid + 1 else -&gt; height = mid - 1 } } return letters[low] }} 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译相关的文章，请持续关注 由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长","link":"/2020/05/24/LeetCode/binary-search/03-find-letter/"},{"title":"LeetCode二分查找：X的平方根","text":"题目来源于 LeetCode 上第 69号（Sqrt(x)）问题：X的平方根。题目难度为 Easy。 英文地址：https://leetcode.com/problems/sqrtx/ 中文地址：https://leetcode-cn.com/problems/sqrtx/ 题目描述Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4Output: 2 Example 2: Input: 8Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 思路：二分查找二分法的解题思路大致以下几个步骤： 寻找平方根 x 的区间范围：[low, height] 用二分法在区间 [low, height] 内寻找平方根 当 low &lt;= height 时：令 mind = (low + height) / 2，square = mind * mind 比较 square 与 x： 如果 square &gt; x，则 height = mind -1。 如果 square &lt; x，则 low = mind + 1。 如果 square == x，即平方根为 mind，返回 mind。 如果在区间内没有找到，则返回 height。 如何确定 x 的区间范围：[low, height]？ 当 x &gt;= 2 时：它的整数平方根一定小于 x / 2 且大于 0，即 0 &lt; a &lt; x / 2，例如 9 的的平方根是 3，16 的平方根是 4，8 的平方根是 2.82842… 取整数部分即是 2，以此类类推可以将区间范围在次缩小 即 0 &lt; a &lt; x / 4 当 x =1 时：即 1 / 4 的值为0了，所以为了兼顾 1 的特殊情况，需要将边界设为 x / 4 +1 综合以上两种情况 x 的区间范围：[0, x / 4 + 1]，为了提高效率所以使用了位运算符，即 x/4 等价于 x &gt;&gt;&gt; 2 Java实现class Solution { public int mySqrt(int x) { long low = 0; long height = (x &gt;&gt;&gt; 2) + 1; long lx = (long) x; while (low &lt;= height) { long mind = (low + height) &gt;&gt;&gt; 1; long square = mind * mind; if (square == lx) { return (int) mind; } else if (square &lt; lx) { low = mind + 1; } else { height = mind - 1; } } return (int)height; }} Kotlin 实现class Solution { fun mySqrt(x: Int): Int { var low = 0L var height = (x ushr 2).toLong() + 1 val target = x.toLong() while (low &lt;= height) { val mind = (low + height) ushr 1 val square: Long = mind * mind when { square == target -&gt; return mind.toInt() square &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return height.toInt() }} 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译相关的文章，请持续关注 由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长","link":"/2020/05/24/LeetCode/binary-search/02-x-square/"},{"title":"LeetCode二分查找：有效的完全平方数","text":"题目来源于 LeetCode 上第 367 号（Valid Perfect Square）问题：有效的完全平方数。题目难度为 Easy。 英文地址：https://leetcode.com/problems/valid-perfect-square/ 中文地址：https://leetcode-cn.com/problems/valid-perfect-square/ 题目描述Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: Input: 16Output: true Example 2: Input: 14Output: false 思路：二分查找什么是完全平方数？维基百科 数学上，平方数，或称完全平方数，是指可以写成某个整数的平方的数，即其平方根为整数的数。例如，9 = 3 × 3，它是一个平方数。 二分法的解题思路大致以下几个步骤： 寻找完全平方数 x 的区间范围：[low, height] 用二分法在区间 [low, height] 内寻找完全平方数 当 low &lt;= height 时：令 mind = (low + height) / 2，square = mind * mind 比较 square 与 x： 如果 square &gt; x，则 height = mind -1。 如果 square &lt; x，则 low = mind + 1。 如果 square == x，即完全平方数为 mind，返回 true。 如果在区间内没有找到，则返回 false。 如何确定 x 的区间范围：[low, height]？ 根据上面的概念 完全平方数 是某个整数的平方的数，也就是说 完全平方数 = n *n，例如，9 = 3 × 3 当 x &gt;= 2 时：它的整数平方根一定小于 x / 2 且大于 0，即 0 &lt; a &lt; x / 2 当 x =1 时：即 1 / 2 的值为0了，所以为了兼顾 1 的特殊情况，需要将边界设为 x / 2 +1 综合以上两种情况 x 的区间范围：[0, x / 2 + 1]，为了提高效率所以使用了位运算符，即 x/2 等价于 x &gt;&gt;&gt; 1 Java实现public class Solution { public boolean isPerfectSquare(int num) { long low = 0; long height = (num &gt;&gt;&gt; 1) + 1; while (low &lt;= height) { long mind = (low + height) &gt;&gt;&gt; 1; long square = mind * mind; if (square == num) { return true; } else if (square &lt; num) { low = mind + 1; } else { height = mind - 1; } } return false; }} Koltin实现class Solution { fun isPerfectSquare(num: Int): Boolean { var low = 0L var height = (num ushr 1).toLong() + 1 var target = num.toLong() while (low &lt;= height) { val mind: Long = (low + height) ushr 1 val square = mind * mind when { square == target -&gt; return true square &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return false }} 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译相关的文章，请持续关注 由于 LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我按照经典类型题目去分类、和题目的难易程度去排序 数据结构： 数组、栈、队列、字符串、链表、树…… 算法： 查找算法、搜索算法、位运算、排序、数学、…… 每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：Leetcode-Solutions-with-Java-And-Kotlin，一起来学习，期待与你一起成长","link":"/2020/05/23/LeetCode/binary-search/01-square/"},{"title":"10分钟入门Shell脚本编程","text":"前言写下这篇文章，是对自己在学习和使用过程中的总结，文笔不是很好，如果有什么问题欢迎沟通交流 Github地址：https://github.com/hi-dhl/fast_guides Shell是什么Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务, Shell脚本（shell script），是一种为Shell编写的脚本程序。我们经常说的shell通常都是指shell脚本。 环境和工具Shell跟java、php、Python编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Mac OS，Linux 自带了shell解释器，Windows比较麻烦，因为Win7专业版和旗舰版默认安装PowerShell，标准版和家庭版中就没有安装的，为了方便建议安装cygwin PHP、Python 也可以作为Shell编程PHP、Python是属于高级编程语言，但是也可以做Shell编程，因为只要有解释器，也可以用作脚本编程 如下是一个Python Shell Script示例（假设文件名叫op_python_base.py）： #!/usr/bin/env python3 //告诉Python从系统环境中找python# -*- coding: utf-8 -*- //设置为UTF-8编码for index in range(10): print(index); 源码：op_python_base 如下是一个PHP Shell Script示例（假设文件名叫op_php_base.php）： #!/usr/bin/php&lt;?phpfor($i=0 ;$i&lt;10; $i++){ echo $i;}?&gt; 源码：op_php_base 为什么要学习Shell既然PHP、Python都可以用来写脚本编程，那为什么还要学习陌生、晦涩难懂的Shell，主要有一下几个原因 环境兼容性，Win7专业版和旗舰版默认安装PowerShell，标准版和家庭版中就没有安装的，其他主流的操作系统都预制了Shell解释器，所以使用sh、bash编写，提供给其他人使用是非常方便的，但是PHP、Python 等等需要安装相应的环境 如果你想做一些定时任务比如说检测进程是否存在，自动备份，或者说自动部署环境、服务器之间的数据同步等等sh、bash会是你最好的选择 sh与bashsh: Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh bash: Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash 第一个shell脚本我们先来看一个例子我相信写过代码的童鞋，应该对下面的代码很熟悉并不陌生，（假设文件名叫op_base.sh）： #!/usr/bin/env bashmkdir codecd codefor ((i=0; i&lt;3; i++)); do touch test_${i}.txt echo &quot;shell很简单&quot; &gt;&gt; test_${i}.txtdone 第一行：从系统path中寻找指定脚本的解释程序第二行：创建 名叫code文件夹第三行：进入创建的文件夹第四行：for循环3次第四行：创建文件第五行：往创建的文件中写入信息第六行：结束循环 mkdir, touch，cd，touch，echo都是系统命令，在命令行下可以直接执行for, do, done 是shell脚本语言 for循环的语法 源码：op_base.sh 编写Shell新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php，扩展名为php，如果你用Python，扩展名为python 第一行一般是这样： #!/usr/bin/php#!/usr/bin/env python3#!/usr/bin/env bash #!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行 /env 是系统的PATH目录中查找 运行 Shell 脚本有两种方法：作为可执行程序chmod +x op_base.sh./op_base.sh 第一行设置 op_base.sh可执行权限第二行执行op_base.sh 作为参数/bin/sh op_base.sh 变量定义变量时，变量名前不需要加符号和Python一样但是在PHP语言中变量需要加$，如： my_name=&quot;jack&quot;my_name='jack'; ps: 变量名和等号之间不能有空格,变量后面不能有; Shell中的引号和PHP类似，字符串可以用单引号，也可以用双引号 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行 双引号： 双引号里可以有变量 双引号里可以出现转义字符 但是在Python中单引号和双引号是没有区别，但是Python 还有三个引号，在三个引号内字符都不会被转义 使用变量对于已经定义过的变量，使用的适合在前面添加$ echo $my_nameecho ${my_name} 变量名外面的花括号是可选的，加不加都行,建议使用第二种形式 注释以“#”开头的行就是注释，会被解释器忽略。 多行注释sh里没有多行注释，只能每一行加一个#号。就像这样： #--------------------------------------------# Author: jack ## Notes: 10分钟入门Shell脚本编程## Project home page:# https://github.com/hi-dhl/fast_guides#-------------------------------------------- 字符串字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似 Shell不像其他语言有php、python 有很多数据类型，在Shell中常用的数据类型字符串数字和字符串（ps: 除了数字和字符串，也没啥其它类型好用了，哈哈） 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行 双引号： 双引号里可以有变量 双引号里可以出现转义字符 字符串操作拼接字符串my_name=&quot;jack&quot;;my_age=&quot;20岁&quot;echo $my_name $my_ageecho $my_name$my_age 获取字符串长度echo ${#my_name} 截取字符串echo ${my_name:0:2} 源码：op_str.sh Shell 数组定义数组在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： name=(name1 name2 name3) 还可以单独定义数组的各个分量： ary[0]=name1ary[1]=name2ary[3]=name3 ps: 可以不使用连续的下标，而且下标的范围没有限制 读取数组读取数组元素值的一般格式是： ${数组名[下标]} 例如： echo ${name[0]} 使用@符号可以获取数组中的所有元素，例如： echo ${name[@]} 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同，例如： # 取得数组元素的个数length=${#name[@]}echo $length# 或者length=${#name[*]}echo $length# 取得数组单个元素的长度lengthn=${#name[n]}echo $length 源码：op_arry.sh Shell 流程控制和Java、PHP、Python等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)： &lt;?phpif (isset($_GET[&quot;q&quot;])) { search(q);}else { // 不做任何事情} 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else ifif condition1then command1elif condition2 then command2else commandNfi 例子： #!/usr/bin/env basha=1b=2if [ $a == $b ] then echo &quot;a 等于 b&quot; elif [ $a -gt $b ] then echo &quot;a 大于 b&quot; elif [ $a -lt $b ] then echo &quot;a 小于 b&quot; else echo &quot;没有符合的条件&quot; fi 源码：op_if.sh for 循环Shell的for循环和Python 有点类似 Python的for循环for index in 1,2,3,4,5: print(index); Shell的for循环，第一种写法for index in 1 2 3 4 5; do echo &quot;index=&quot;$indexdone Shell的for循环，第二种写法for ((i=0; i&lt;5; i++)); do echo &quot;i=&quot;$idone 源码：op_for.sh while 语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。 int=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 源码：op_while.sh Shell结合系统命令sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。 例如定时检测nginx、mysql是否被关闭path=/var/loglog=${path}/httpd-mysql.logname=(apache mysql)exs_init[0]=&quot;service httpd start&quot;exs_init[1]=&quot;/etc/init.d/mysqld restart&quot;for ((i=0; i&lt;2; i++)); do echo &quot;检查${name[i]}进程是否存在&quot; ps -ef|grep ${name[i]} |grep -v grep if [ $? -eq 0 ]; then pid=$(pgrep -f ${name[i]}) echo &quot;`date +&quot;%Y-%m-%d %H:%M:%S&quot;` ${name[$i]} is running with pid $pid&quot; &gt;&gt; ${log} else $(${exs_init[i]}) echo &quot;`date +&quot;%Y-%m-%d %H:%M:%S&quot;` ${name[$i]} start success&quot; &gt;&gt; ${log} fidone 解释：检测 nginx、mysql进程是否存在，如果不存在了会自动重新启动。脚本每次运行会写日志的，没事可以去看看该日志文件，如果进程是不是真的经常性不存在，恐怕就要排查一下深层原因了。 源码：check_nginx.sh 编辑 /etc/crontab 文件crontab -e 在文件最后添加一行： */5 * * * * /xxx/check_nginx.sh &gt; /dev/null 2&gt;&amp;1 上表示每 5 分钟，执行一下脚本 /xxx/check_nginx.sh，其中xxx代表路径 /dev/null 2&gt;&amp;1 的意思是该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。 # For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * command to be executed 添加完配置，需要重启才能生效service crond restart","link":"/2020/05/21/Linux/01-shell/"}],"tags":[{"name":"DeviceMonitor","slug":"DeviceMonitor","link":"/tags/DeviceMonitor/"},{"name":"AndroidStudio","slug":"AndroidStudio","link":"/tags/AndroidStudio/"},{"name":"smalidea","slug":"smalidea","link":"/tags/smalidea/"},{"name":"smali-android-studio","slug":"smali-android-studio","link":"/tags/smali-android-studio/"},{"name":"apktool","slug":"apktool","link":"/tags/apktool/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"译文","slug":"译文","link":"/tags/%E8%AF%91%E6%96%87/"},{"name":"Fragment","slug":"Fragment","link":"/tags/Fragment/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"剑指offer","slug":"剑指offer","link":"/tags/%E5%89%91%E6%8C%87offer/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"Android源码","slug":"Android源码","link":"/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Android10-包管理系统","slug":"Android10-包管理系统","link":"/tags/Android10-%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Android10-资源管理系统","slug":"Android10-资源管理系统","link":"/tags/Android10-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"Android10-窗口管理系统","slug":"Android10-窗口管理系统","link":"/tags/Android10-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"AndroidStudio","slug":"AndroidStudio","link":"/categories/AndroidStudio/"},{"name":"逆向","slug":"逆向","link":"/categories/%E9%80%86%E5%90%91/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"精选译文","slug":"精选译文","link":"/categories/%E7%B2%BE%E9%80%89%E8%AF%91%E6%96%87/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Android10","slug":"Android10","link":"/categories/Android10/"}]}