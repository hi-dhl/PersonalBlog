{"pages":[],"posts":[{"title":"基于 Smali 文件 Android Studio 动态调试 APP","text":"最近在研究动态调试技术，网上关于基于 Smali 动态调试App的教程很多，很多细节都没有贴出来，走了很多弯路，将调研结果分享一下，如果有写的不好地方，欢迎指正 Github：https://github.com/hi-dhl/DebugApkSmali 准备工作 一部 Root 过的 Android 手机，打开开发者模式 Xposed 的运行的环境 安装 smalidea 插件，点击这里下载 安装 BDOpener.apk 或者 XDebug.apk 反编译 Apk(apktool)点击 这里下载 最新的 apktool , 并配置好环境（不同环境配置的方式不同，参考 官网） 下载你需要反编译的 Apk 文件，执行 apktool d 反编译Apk名字.apk 如果反编译出来多个smali文件夹，可以用ant写个脚本，多个文件夹合并成一个 smalideaAndroidStudio 如果要调试smali代码，需要安装第三方插件: smalidea AS中【Android Studio–&gt;Preferences–&gt;Plugins–&gt;Install plugin from desk…】，安装插件 Android Studio 导入 smali 新疆一个 Android 工程项目（ps: 一定要新建Android项目，否则可能会找不到 “Attach debuger to Android Process”）删掉自动创建的资源和代码文件 复制反编译好的 smali 文件, 到新建 Android 项目 java 文件夹下 PS: 也可以使用我配置好的项目 “ApkSampleSmali” , 需要安装提供的 Sample.apk进行测试 Android Studio 动态调试配置新建调试配置，【Run–&gt;Edit Configurations–&gt; + –&gt;Remote】，name 随意，端口 8700 动态调试 在 smali 代码中打入断点，如下图标记1 然后点击 “Attach debuger to Android Process” ，如下图标记2 选择你要调试的进程，手动进入对应功能, 即进入断点动态调试（ps: 如果你想要的进程没有展示出来，请重新勾选 xposed module(BDOpener), 重启手机） 运行环境信息 Xposed Version90-beta3 BDOpener 1.0 AndoridStudio 3.3.2 smalidea 0.0.5 apktool 2.4.0 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你喜欢这篇文章欢迎 Star 一起来学习，期待与你一起成长","link":"/2020/05/30/AndroidStudio/%E5%9F%BA%E4%BA%8ESmali%E6%96%87%E4%BB%B6AndroidStudio%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95APP/"},{"title":"解决在 Android Studio 3.2 找不到 Android Device Monitor 工具","text":"升级到 AndroidStudio 最新版本( &gt;3.2 )朋友们都会遇到一个问题，找不到 DDMS [Android Device Monitor], 只能从 SDK 目录下找到 monitor 启动 DDMS [Android Device Monitor]，所以写了一个插件快速启动 Android Device Monitor 源码及使用方式开发工具：IntelliJ IDEA Github地址：https://github.com/hi-dhl/DeviceMonitorPlugin 插件下载地址：https://github.com/hi-dhl/DeviceMonitorPlugin/releases/download/1.0/DeviceMonitorPlugin.jar 安装方式： 打开 AndroidStudio 选择 Preference -&gt; Plugins-&gt; install plugin from disk 选择下载好的插件 [DeviceMonitorPlugin.jar] -&gt; 重启 AndroidStudio 如何启动： 打开 AndroidStudio 菜单栏 tools -&gt; 单击 DeviceMonitor PS: Google 虽然删除了 AdnroidStudio 启动入口，但是本地 SDK 中还是存在，插件通过动态获取本地 SDK 路径启动 AndroidDeviceMonitor, 由于电脑性能不同，启动速度会有不同 Google 为什么弃用 Android Device MonitorAndroid Developers官网上的原文链接 Android Device Monitor 是一个 Android 应用调试和分析工具提供了一个 UI 工具，但是大部分组件在 Android Studio 3.1 已经弃用了, 并且会在 Android Studio 3.2 中移除，将会用新的工具帮助开发人员调试和分析 Android 应用 详情戳这里 插件核心代码public class Monitor extends AnAction { @Override public void actionPerformed(AnActionEvent anActionEvent) { try { Project project = anActionEvent.getData(PlatformDataKeys.PROJECT); String os = AndroidUtils.getPlatformName(); String sdkPath = AndroidUtils.getApkLocalProperties(project); if (os.toLowerCase().startsWith(&quot;win&quot;)) { sdkPath += File.separator + &quot;tools&quot; + File.separator + &quot;monitor.bat&quot;; } else { sdkPath += File.separator + &quot;tools&quot; + File.separator + &quot;monitor&quot;; } Runtime.getRuntime().exec(sdkPath); } catch (Exception e) { } }} /** * 动态获取本地Android SDK的路径 * * @param project * @return */public static String getApkLocalProperties(Project project) { String sdkPath = &quot;&quot;; try { String path = project.getBasePath() + File.separator + &quot;local.properties&quot;; Properties properties = new Properties(); InputStream inputStream = new FileInputStream(path); properties.load(inputStream); sdkPath = properties.getProperty(&quot;sdk.dir&quot;); } catch (Exception e) { } return sdkPath;} Github地址：https://github.com/hi-dhl/DeviceMonitorPlugin 结语致力于分享一系列 Android 系统源码、逆向分析、算法、翻译、Jetpack 源码相关的文章，如果你喜欢这篇文章欢迎 Star 一起来学习，期待与你一起成长","link":"/2020/05/30/AndroidStudio/%E8%A7%A3%E5%86%B3%E5%9C%A8Android%20Studio%203.2%E6%89%BE%E4%B8%8D%E5%88%B0Android%20Device%20Monitor%E5%B7%A5%E5%85%B7/"},{"title":"LeetCode剑指offer：数组中重复的数字","text":"题目来源于 LeetCode 剑指 offer 第 03 号问题：数组中重复的数字。题目难度为 Easy。 中文地址：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/ 题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1: 输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 思路一：原地置换法题目指出 在一个长度为 n 的数组 nums 里的所有数字都在 [0,n-1] 的范围内，可遍历数组并通过交换操作使元素的 索引 与 值，通过索引找到对应的值，算法流程如下： 当 nums[i] == i 时，即 值 和 索引，一一对应无需交换 当 nums[nums[i]] == nums[i]，即索引 nums[i] 对应的值 和 nums[i] 相等，找到相同的值，返回此值 nums[i] 上面条件都不满足，即交换索引为 i 和 nums[i] 的元素值，将数字交换到对应索引位置 没有找到返回 -1，即代表数组中无相同值 例如数组 [2,0,1] 交换逻辑如下, 当 i = 0 时： temp = num[i], 即 temp = 2 num[i] = num[temp]，即 num[i] = 1 num[temp] = temp, 即 num[temp] = 2 将 即 值 和 索引 一一对应 Java实现public class Solution { public int findRepeatNumber(int[] nums) { int len = nums.length; for (int i = 0; i &lt; len; i++) { if (nums[i] == i) continue; if (nums[nums[i]] == nums[i]) { return nums[i]; } int temp = nums[i]; nums[nums[i]] = nums[temp]; nums[temp] = temp; } return -1; }} Koltin实现class Solution { fun findRepeatNumber(nums: IntArray): Int { for ((index, value) in nums.withIndex()) { if (value == index) continue if (nums[value] == nums[index]) { return nums[index] } val temp = value nums[value] = nums[temp] nums[temp] = temp } return -1 }} 思路二：哈希算法利用 Haset API 的特性，如果添加重复的元素会返回 false Java 实现public class Solution { public int findRepeatNumber2(int[] nums) { int len = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; len; i++) { if (!set.add(nums[i])) { return nums[i]; } } return -1; }} Koltin 实现class Solution { fun findRepeatNumber(nums: IntArray): Int { val set = HashSet&lt;Int&gt;() for ((index, value) in nums.withIndex()) { if (!set.add(value)) { return value; } } return -1 }} 结语致力于分享一系列的Android系统源码、逆向分析、算法相关的文章，如果你同我一样喜欢算法、LeetCode，可以关注我，一起来学习，期待与你一起成长","link":"/2020/05/24/LeetCode/%E5%89%91%E6%8C%87offer/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"LeetCode二分查找：寻找比目标字母大的最小字母","text":"题目来源于 LeetCode 上第 744 号（Find Smallest Letter Greater Than Target）问题：寻找比目标字母大的最小字母。题目难度为 Easy。 英文地址：https://leetcode.com/problems/find-smallest-letter-greater-than-target/ 中文地址：https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/ 题目描述Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target. Letters also wrap around. For example, if the target is target = ‘z’ and letters = [‘a’, ‘b’], the answer is ‘a’. Examples: Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;a&quot; Output: &quot;c&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;c&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;d&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;g&quot; Output: &quot;j&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;j&quot; Output: &quot;c&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;k&quot; Output: &quot;c&quot;Note: 1. letters has a length in range [2, 10000]. 2. letters consists of lowercase letters, and contains at least 2 unique letters. 3. target is a lowercase letter. 二分查找从题意分析从有序列表中找比目标字母大的最小字母得知，这题应该使用二分查找，因为二分查找的时间复杂度 O(logn) 但是这题目有个坑，就是题意给的不准确，笔者也提交几次才通过，总结规律如下： 当 target &lt; letters[0] 时，即 letters[0] 是比目标字母大的最小字母，返回 letters[0] 当 target &gt;= letters[height -1], 即返回 letters[0] Java 实现class Solution { public char nextGreatestLetter(char[] letters, char target) { int low = 0; int height = letters.length - 1; if (target &lt; letters[0] || target &gt;= letters[height]) return letters[0]; while (low &lt;= height) { int mind = (low + height) &gt;&gt;&gt; 1; if (letters[mind] &lt;= target) { low = mind + 1; } else { height = mind - 1; } } return letters[low]; }} Koltin 实现class Solution { fun nextGreatestLetter(letters: CharArray, target: Char): Char { var low = 0 var height = letters.size - 1 if (target &lt; letters[0] || target &gt;= letters[height]) { return letters[0] } while (low &lt;= height) { val mid = (low + height) ushr 1 when { letters[mid] &lt;= target -&gt; low = mid + 1 else -&gt; height = mid - 1 } } return letters[low] }} 结语致力于分享一系列的Android系统源码、逆向分析、算法相关的文章，如果你同我一样喜欢算法、LeetCode，可以关注我，一起来学习，期待与你一起成长","link":"/2020/05/24/LeetCode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97/"},{"title":"LeetCode二分查找：X的平方根","text":"题目来源于 LeetCode 上第 69号（Sqrt(x)）问题：X的平方根。题目难度为 Easy。 英文地址：https://leetcode.com/problems/sqrtx/ 中文地址：https://leetcode-cn.com/problems/sqrtx/ 题目描述Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4Output: 2 Example 2: Input: 8Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 思路：二分查找二分法的解题思路大致以下几个步骤： 寻找平方根 x 的区间范围：[low, height] 用二分法在区间 [low, height] 内寻找平方根 当 low &lt;= height 时：令 mind = (low + height) / 2，square = mind * mind 比较 square 与 x： 如果 square &gt; x，则 height = mind -1。 如果 square &lt; x，则 low = mind + 1。 如果 square == x，即平方根为 mind，返回 mind。 如果在区间内没有找到，则返回 height。 如何确定 x 的区间范围：[low, height]？ 当 x &gt;= 2 时：它的整数平方根一定小于 x / 2 且大于 0，即 0 &lt; a &lt; x / 2，例如 9 的的平方根是 3，16 的平方根是 4，8 的平方根是 2.82842… 取整数部分即是 2，以此类类推可以将区间范围在次缩小 即 0 &lt; a &lt; x / 4 当 x =1 时：即 1 / 4 的值为0了，所以为了兼顾 1 的特殊情况，需要将边界设为 x / 4 +1 综合以上两种情况 x 的区间范围：[0, x / 4 + 1]，为了提高效率所以使用了位运算符，即 x/4 等价于 x &gt;&gt;&gt; 2 Java实现class Solution { public int mySqrt(int x) { long low = 0; long height = (x &gt;&gt;&gt; 2) + 1; long lx = (long) x; while (low &lt;= height) { long mind = (low + height) &gt;&gt;&gt; 1; long square = mind * mind; if (square == lx) { return (int) mind; } else if (square &lt; lx) { low = mind + 1; } else { height = mind - 1; } } return (int)height; }} Kotlin 实现class Solution { fun mySqrt(x: Int): Int { var low = 0L var height = (x ushr 2).toLong() + 1 val target = x.toLong() while (low &lt;= height) { val mind = (low + height) ushr 1 val square: Long = mind * mind when { square == target -&gt; return mind.toInt() square &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return height.toInt() }} 结语致力于分享一系列的Android系统源码、逆向分析、算法相关的文章，如果你同我一样喜欢算法、LeetCode，可以关注我，一起来学习，期待与你一起成长","link":"/2020/05/24/LeetCode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/X%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"},{"title":"LeetCode二分查找：有效的完全平方数","text":"题目来源于 LeetCode 上第 367 号（Valid Perfect Square）问题：有效的完全平方数。题目难度为 Easy。 英文地址：https://leetcode.com/problems/valid-perfect-square/ 中文地址：https://leetcode-cn.com/problems/valid-perfect-square/ 题目描述Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: Input: 16Output: true Example 2: Input: 14Output: false 思路：二分查找什么是完全平方数？维基百科 数学上，平方数，或称完全平方数，是指可以写成某个整数的平方的数，即其平方根为整数的数。例如，9 = 3 × 3，它是一个平方数。 二分法的解题思路大致以下几个步骤： 寻找完全平方数 x 的区间范围：[low, height] 用二分法在区间 [low, height] 内寻找完全平方数 当 low &lt;= height 时：令 mind = (low + height) / 2，square = mind * mind 比较 square 与 x： 如果 square &gt; x，则 height = mind -1。 如果 square &lt; x，则 low = mind + 1。 如果 square == x，即完全平方数为 mind，返回 true。 如果在区间内没有找到，则返回 false。 如何确定 x 的区间范围：[low, height]？ 根据上面的概念 完全平方数 是某个整数的平方的数，也就是说 完全平方数 = n *n，例如，9 = 3 × 3 当 x &gt;= 2 时：它的整数平方根一定小于 x / 2 且大于 0，即 0 &lt; a &lt; x / 2 当 x =1 时：即 1 / 2 的值为0了，所以为了兼顾 1 的特殊情况，需要将边界设为 x / 2 +1 综合以上两种情况 x 的区间范围：[0, x / 2 + 1]，为了提高效率所以使用了位运算符，即 x/2 等价于 x &gt;&gt;&gt; 1 Java实现public class Solution { public boolean isPerfectSquare(int num) { long low = 0; long height = (num &gt;&gt;&gt; 1) + 1; while (low &lt;= height) { long mind = (low + height) &gt;&gt;&gt; 1; long square = mind * mind; if (square == num) { return true; } else if (square &lt; num) { low = mind + 1; } else { height = mind - 1; } } return false; }} Koltin实现class Solution { fun isPerfectSquare(num: Int): Boolean { var low = 0L var height = (num ushr 1).toLong() + 1 var target = num.toLong() while (low &lt;= height) { val mind: Long = (low + height) ushr 1 val square = mind * mind when { square == target -&gt; return true square &lt; target -&gt; low = mind + 1 else -&gt; height = mind - 1 } } return false }} 结语致力于分享一系列的Android系统源码、逆向分析、算法相关的文章，如果你同我一样喜欢算法、LeetCode，可以关注我，一起来学习，期待与你一起成长","link":"/2020/05/23/LeetCode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"title":"10分钟入门Shell脚本编程","text":"前言写下这篇文章，是对自己在学习和使用过程中的总结，文笔不是很好，如果有什么问题欢迎沟通交流 Github地址：https://github.com/hi-dhl/fast_guides Shell是什么Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务, Shell脚本（shell script），是一种为Shell编写的脚本程序。我们经常说的shell通常都是指shell脚本。 环境和工具Shell跟java、php、Python编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Mac OS，Linux 自带了shell解释器，Windows比较麻烦，因为Win7专业版和旗舰版默认安装PowerShell，标准版和家庭版中就没有安装的，为了方便建议安装cygwin PHP、Python 也可以作为Shell编程PHP、Python是属于高级编程语言，但是也可以做Shell编程，因为只要有解释器，也可以用作脚本编程 如下是一个Python Shell Script示例（假设文件名叫op_python_base.py）： #!/usr/bin/env python3 //告诉Python从系统环境中找python# -*- coding: utf-8 -*- //设置为UTF-8编码for index in range(10): print(index); 源码：op_python_base 如下是一个PHP Shell Script示例（假设文件名叫op_php_base.php）： #!/usr/bin/php&lt;?phpfor($i=0 ;$i&lt;10; $i++){ echo $i;}?&gt; 源码：op_php_base 为什么要学习Shell既然PHP、Python都可以用来写脚本编程，那为什么还要学习陌生、晦涩难懂的Shell，主要有一下几个原因 环境兼容性，Win7专业版和旗舰版默认安装PowerShell，标准版和家庭版中就没有安装的，其他主流的操作系统都预制了Shell解释器，所以使用sh、bash编写，提供给其他人使用是非常方便的，但是PHP、Python 等等需要安装相应的环境 如果你想做一些定时任务比如说检测进程是否存在，自动备份，或者说自动部署环境、服务器之间的数据同步等等sh、bash会是你最好的选择 sh与bashsh: Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh bash: Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash 第一个shell脚本我们先来看一个例子我相信写过代码的童鞋，应该对下面的代码很熟悉并不陌生，（假设文件名叫op_base.sh）： #!/usr/bin/env bashmkdir codecd codefor ((i=0; i&lt;3; i++)); do touch test_${i}.txt echo &quot;shell很简单&quot; &gt;&gt; test_${i}.txtdone 第一行：从系统path中寻找指定脚本的解释程序第二行：创建 名叫code文件夹第三行：进入创建的文件夹第四行：for循环3次第四行：创建文件第五行：往创建的文件中写入信息第六行：结束循环 mkdir, touch，cd，touch，echo都是系统命令，在命令行下可以直接执行for, do, done 是shell脚本语言 for循环的语法 源码：op_base.sh 编写Shell新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php，扩展名为php，如果你用Python，扩展名为python 第一行一般是这样： #!/usr/bin/php#!/usr/bin/env python3#!/usr/bin/env bash #!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行 /env 是系统的PATH目录中查找 运行 Shell 脚本有两种方法：作为可执行程序chmod +x op_base.sh./op_base.sh 第一行设置 op_base.sh可执行权限第二行执行op_base.sh 作为参数/bin/sh op_base.sh 变量定义变量时，变量名前不需要加符号和Python一样但是在PHP语言中变量需要加$，如： my_name=&quot;jack&quot;my_name='jack'; ps: 变量名和等号之间不能有空格,变量后面不能有; Shell中的引号和PHP类似，字符串可以用单引号，也可以用双引号 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行 双引号： 双引号里可以有变量 双引号里可以出现转义字符 但是在Python中单引号和双引号是没有区别，但是Python 还有三个引号，在三个引号内字符都不会被转义 使用变量对于已经定义过的变量，使用的适合在前面添加$ echo $my_nameecho ${my_name} 变量名外面的花括号是可选的，加不加都行,建议使用第二种形式 注释以“#”开头的行就是注释，会被解释器忽略。 多行注释sh里没有多行注释，只能每一行加一个#号。就像这样： #--------------------------------------------# Author: jack ## Notes: 10分钟入门Shell脚本编程## Project home page:# https://github.com/hi-dhl/fast_guides#-------------------------------------------- 字符串字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似 Shell不像其他语言有php、python 有很多数据类型，在Shell中常用的数据类型字符串数字和字符串（ps: 除了数字和字符串，也没啥其它类型好用了，哈哈） 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单引号（对单引号使用转义符后也不行 双引号： 双引号里可以有变量 双引号里可以出现转义字符 字符串操作拼接字符串my_name=&quot;jack&quot;;my_age=&quot;20岁&quot;echo $my_name $my_ageecho $my_name$my_age 获取字符串长度echo ${#my_name} 截取字符串echo ${my_name:0:2} 源码：op_str.sh Shell 数组定义数组在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： name=(name1 name2 name3) 还可以单独定义数组的各个分量： ary[0]=name1ary[1]=name2ary[3]=name3 ps: 可以不使用连续的下标，而且下标的范围没有限制 读取数组读取数组元素值的一般格式是： ${数组名[下标]} 例如： echo ${name[0]} 使用@符号可以获取数组中的所有元素，例如： echo ${name[@]} 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同，例如： # 取得数组元素的个数length=${#name[@]}echo $length# 或者length=${#name[*]}echo $length# 取得数组单个元素的长度lengthn=${#name[n]}echo $length 源码：op_arry.sh Shell 流程控制和Java、PHP、Python等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)： &lt;?phpif (isset($_GET[&quot;q&quot;])) { search(q);}else { // 不做任何事情} 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else ifif condition1then command1elif condition2 then command2else commandNfi 例子： #!/usr/bin/env basha=1b=2if [ $a == $b ] then echo &quot;a 等于 b&quot; elif [ $a -gt $b ] then echo &quot;a 大于 b&quot; elif [ $a -lt $b ] then echo &quot;a 小于 b&quot; else echo &quot;没有符合的条件&quot; fi 源码：op_if.sh for 循环Shell的for循环和Python 有点类似 Python的for循环for index in 1,2,3,4,5: print(index); Shell的for循环，第一种写法for index in 1 2 3 4 5; do echo &quot;index=&quot;$indexdone Shell的for循环，第二种写法for ((i=0; i&lt;5; i++)); do echo &quot;i=&quot;$idone 源码：op_for.sh while 语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。 int=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 源码：op_while.sh Shell结合系统命令sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。 例如定时检测nginx、mysql是否被关闭path=/var/loglog=${path}/httpd-mysql.logname=(apache mysql)exs_init[0]=&quot;service httpd start&quot;exs_init[1]=&quot;/etc/init.d/mysqld restart&quot;for ((i=0; i&lt;2; i++)); do echo &quot;检查${name[i]}进程是否存在&quot; ps -ef|grep ${name[i]} |grep -v grep if [ $? -eq 0 ]; then pid=$(pgrep -f ${name[i]}) echo &quot;`date +&quot;%Y-%m-%d %H:%M:%S&quot;` ${name[$i]} is running with pid $pid&quot; &gt;&gt; ${log} else $(${exs_init[i]}) echo &quot;`date +&quot;%Y-%m-%d %H:%M:%S&quot;` ${name[$i]} start success&quot; &gt;&gt; ${log} fidone 解释：检测 nginx、mysql进程是否存在，如果不存在了会自动重新启动。脚本每次运行会写日志的，没事可以去看看该日志文件，如果进程是不是真的经常性不存在，恐怕就要排查一下深层原因了。 源码：check_nginx.sh 编辑 /etc/crontab 文件crontab -e 在文件最后添加一行： */5 * * * * /xxx/check_nginx.sh &gt; /dev/null 2&gt;&amp;1 上表示每 5 分钟，执行一下脚本 /xxx/check_nginx.sh，其中xxx代表路径 /dev/null 2&gt;&amp;1 的意思是该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。 # For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * command to be executed 添加完配置，需要重启才能生效service crond restart","link":"/2020/05/21/Linux/10%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"DeviceMonitor","slug":"DeviceMonitor","link":"/tags/DeviceMonitor/"},{"name":"AndroidStudio","slug":"AndroidStudio","link":"/tags/AndroidStudio/"},{"name":"smalidea","slug":"smalidea","link":"/tags/smalidea/"},{"name":"smali-android-studio","slug":"smali-android-studio","link":"/tags/smali-android-studio/"},{"name":"apktool","slug":"apktool","link":"/tags/apktool/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"剑指offer","slug":"剑指offer","link":"/tags/%E5%89%91%E6%8C%87offer/"}],"categories":[{"name":"AndroidStudio","slug":"AndroidStudio","link":"/categories/AndroidStudio/"},{"name":"逆向","slug":"逆向","link":"/categories/%E9%80%86%E5%90%91/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}